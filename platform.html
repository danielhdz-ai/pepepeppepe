<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trading Survivor - Trading Journal Profesional V2</title>
    <!-- VERSION: 2025-12-24-FIX-DEPLOYED -->
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.2/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
    <!-- Chart.js Date Adapter -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <!-- Incluir Dexie.js -->
    <script src="https://unpkg.com/dexie@3/dist/dexie.js"></script>
    <!-- Incluir CryptoJS para firmas HMAC -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <!-- Incluir Lightweight Charts v4.1.1 -->
    <script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>
    <!-- Lightweight Charts ya incluido arriba -->
    
    <!-- Supabase usando ES Module CDN -->
    <script type="importmap">
    {
      "imports": {
        "@supabase/supabase-js": "https://esm.sh/@supabase/supabase-js@2"
      }
    }
    </script>
    
    <!-- TradingView Widget API -->
    <script type="text/javascript" src="https://s3.tradingview.com/tv.js"></script>
    <!-- html2canvas y jsPDF para screenshots -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    
    <!-- Group Invitations CSS -->
    <link rel="stylesheet" href="frontend/group-invitations.css">
    
    <!-- Script para detectar vista pública y invitaciones -->
    <script>
        // Detectar si es vista pública (tiene parámetro ?audicion= con un ID válido)
        try {
            const urlParams = new URLSearchParams(window.location.search);
            const audicionParam = urlParams.get('audicion');
            const inviteToken = urlParams.get('invite');
            
            // Vista pública de audición
            const isPublicView = audicionParam && audicionParam.length > 5;
            
            // Variable global para saltar autenticación
            window.IS_PUBLIC_AUDICION_VIEW = isPublicView || false;
            window.PUBLIC_AUDICION_ID = audicionParam || null;
            
            // Variable global para invitación de grupo
            window.GROUP_INVITE_TOKEN = inviteToken || null;
            
            if (window.IS_PUBLIC_AUDICION_VIEW) {
                // Agregar clase para ocultar todo excepto la sección de Audición
                document.documentElement.classList.add('public-audicion-view');
                console.log('📊 Modo Vista Pública de Audición activado - ID:', audicionParam);
            } else if (window.GROUP_INVITE_TOKEN) {
                console.log('🎟️ Token de invitación detectado:', inviteToken);
            } else {
                console.log('🔓 Modo normal - No es vista pública');
            }
        } catch (error) {
            console.error('Error al detectar vista pública:', error);
            window.IS_PUBLIC_AUDICION_VIEW = false;
            window.PUBLIC_AUDICION_ID = null;
            window.GROUP_INVITE_TOKEN = null;
        }
    </script>
    <style>
        /* ===== PALETA DE COLORES TRADING SURVIVOR ===== */
        :root {
            --primary: #39ff14;       /* Verde Fluorescente */
            --secondary: #28e000;     /* Verde Fluorescente más oscuro para hover */
            --background: #000000;    /* Negro Puro */
            --surface: #020202;       /* Negro casi puro para tarjetas (más oscuro) */
            --surface-light: #0a0a0a; /* Gris muy oscuro para bordes e inactivos (más oscuro) */
            --text: #ffffff;          /* Blanco Puro */
            --text-secondary: #a0a0a0; /* Gris claro para texto secundario */
            --red: #ff4136;           /* Rojo brillante para pérdidas */
            --green: #39ff14;         /* Verde Fluorescente para ganancias */
            --yellow: #f59e0b;        /* Amarillo para métricas neutrales */
            --success: #10b981;       /* Verde para métricas positivas */
            --danger: #ef4444;        /* Rojo para métricas negativas */
            --warning: #eab308;       /* Amarillo para métricas de alerta */
            --accent: #10b981;        /* Verde para métricas especiales */
            --border: #0d0d0d;        /* Color de bordes (más oscuro) */
            --sidebar-width: 260px;   /* Ancho del sidebar expandido */
            --sidebar-collapsed: 70px; /* Ancho del sidebar colapsado */
        }

        /* ===== RESET Y BASE ===== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', 'Segoe UI', 'Roboto', system-ui, -apple-system, sans-serif;
            background-color: var(--background);
            color: var(--text);
            overflow-x: hidden;
        }

        /* ===== SIDEBAR LATERAL ===== */
        .sidebar {
            position: fixed;
            left: 0;
            top: 0;
            height: 100vh;
            width: var(--sidebar-width);
            background: linear-gradient(180deg, #0a0a0a 0%, #000000 100%);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            z-index: 1000;
            transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
        }

        .sidebar.collapsed {
            width: var(--sidebar-collapsed);
        }

        /* Logo Container */
        .sidebar-logo {
            padding: 1.5rem 1rem;
            display: flex;
            align-items: center;
            gap: 0.1rem;
            border-bottom: 1px solid var(--border);
            min-height: 70px;
            transition: justify-content 0.3s ease;
        }

        .sidebar.collapsed .sidebar-logo {
            justify-content: center;
        }

        .logo-icon {
            font-size: 2rem;
            color: var(--primary);
            filter: drop-shadow(0 0 12px rgba(57, 255, 20, 0.5));
            transition: transform 0.3s ease;
            flex-shrink: 0;
            min-width: 38px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .logo-icon:hover {
            transform: scale(1.1) rotate(5deg);
            filter: drop-shadow(0 0 20px rgba(57, 255, 20, 0.8));
        }

        .logo-text {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--text);
            white-space: nowrap;
            opacity: 1;
            transition: opacity 0.3s ease;
            margin-left: -15px;
        }

        .sidebar.collapsed .logo-text {
            opacity: 0;
            width: 0;
        }

        /* Toggle Button */
        .sidebar-toggle {
            position: relative;
            width: 100%;
            padding: 0.75rem 1.5rem;
            background: transparent;
            border: none;
            border-top: 1px solid var(--border);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            color: var(--text-secondary);
            font-size: 0.85rem;
            margin: 0.5rem 0;
        }

        .sidebar-toggle:hover {
            background: rgba(57, 255, 20, 0.05);
            color: var(--primary);
        }

        .sidebar-toggle i {
            color: var(--text-secondary);
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .sidebar-toggle:hover i {
            color: var(--primary);
        }

        .sidebar.collapsed .sidebar-toggle span {
            display: none;
        }

        /* Navigation Menu */
        .sidebar-nav {
            flex: 1;
            padding: 1rem 0;
            overflow-y: auto;
            overflow-x: hidden;
        }

        .sidebar-nav::-webkit-scrollbar {
            width: 4px;
        }

        .sidebar-nav::-webkit-scrollbar-track {
            background: var(--surface);
        }

        .sidebar-nav::-webkit-scrollbar-thumb {
            background: var(--primary);
            border-radius: 2px;
        }

        /* Scrollbars globales en negro */
        *::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        *::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        *::-webkit-scrollbar-thumb {
            background: #000000;
            border-radius: 5px;
            border: 2px solid #1a1a1a;
        }

        *::-webkit-scrollbar-thumb:hover {
            background: #333333;
        }

        .nav-section {
            padding: 0.5rem 0;
        }

        .nav-section-title {
            font-size: 0.65rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-secondary);
            padding: 0.75rem 1.25rem 0.5rem;
            white-space: nowrap;
            transition: opacity 0.3s ease;
        }

        .sidebar.collapsed .nav-section-title {
            opacity: 0;
            height: 0;
            padding: 0;
        }

        .nav-item {
            position: relative;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem 1.25rem;
            margin: 0.125rem 0.5rem;
            color: var(--text-secondary);
            text-decoration: none;
            border-radius: 8px;
            transition: all 0.2s ease;
            cursor: pointer;
            font-size: 0.9rem;
            white-space: nowrap;
        }

        .nav-item:hover {
            background: rgba(57, 255, 20, 0.1);
            color: var(--primary);
        }

        .nav-item.active {
            background: linear-gradient(90deg, rgba(57, 255, 20, 0.15) 0%, rgba(57, 255, 20, 0.05) 100%);
            color: var(--primary);
            border-left: 3px solid var(--primary);
        }

        .nav-item i {
            font-size: 1.1rem;
            min-width: 20px;
            text-align: center;
            flex-shrink: 0;
        }

        .nav-item-text {
            flex: 1;
            transition: opacity 0.3s ease;
        }

        .sidebar.collapsed .nav-item-text {
            opacity: 0;
            width: 0;
        }

        .sidebar.collapsed .nav-item {
            justify-content: center;
            padding: 0.75rem;
        }

        /* Submenu para Informes */
        /* Sidebar Footer */
        .sidebar-footer {
            border-top: 1px solid var(--border);
            padding: 1rem;
        }

        .footer-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem 0.75rem;
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s ease;
            margin-bottom: 0.25rem;
            white-space: nowrap;
        }

        .footer-item:hover {
            background: rgba(57, 255, 20, 0.1);
            color: var(--primary);
        }

        .footer-item i {
            font-size: 1rem;
            min-width: 20px;
            text-align: center;
        }

        .sidebar.collapsed .footer-item {
            justify-content: center;
            padding: 0.75rem;
        }

        .sidebar.collapsed .footer-item span {
            display: none;
        }

        /* ===== MAIN CONTENT AREA ===== */
        .main-content {
            margin-left: var(--sidebar-width);
            min-height: 100vh;
            width: calc(100% - var(--sidebar-width));
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            background: var(--background);
        }

        .sidebar.collapsed ~ .main-content {
            margin-left: var(--sidebar-collapsed);
            width: calc(100% - var(--sidebar-collapsed));
        }

        /* Top Bar */
        .top-bar {
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            padding: 1rem 2rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: sticky;
            top: 0;
            z-index: 100;
            backdrop-filter: blur(10px);
        }

        .top-bar-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--text);
        }

        .top-bar-actions {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .user-menu {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem 1rem;
            background: var(--surface-light);
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .user-menu:hover {
            background: rgba(57, 255, 20, 0.1);
            border: 1px solid var(--primary);
        }

        .user-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 0.9rem;
            color: var(--background);
        }

        .user-email {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        /* ===== HEADER SUPERIOR ===== */
        .main-header {
            position: fixed;
            top: 0;
            left: 280px;
            right: 0;
            height: 64px;
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding: 0 1.5rem;
            z-index: 999;
            transition: left 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .sidebar.collapsed ~ .main-header {
            left: 70px;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .user-menu-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            border-radius: 8px;
            background: transparent;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .user-menu-toggle:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .user-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--primary);
            display: flex;
            align-items: center;
            justify-content: center;
            color: #000;
            font-weight: 700;
            font-size: 0.9rem;
        }

        .user-dropdown {
            position: absolute;
            top: calc(100% + 0.5rem);
            right: 0;
            min-width: 200px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .user-dropdown a {
            display: flex;
            align-items: center;
            padding: 0.75rem 1rem;
            color: var(--text);
            text-decoration: none;
            font-size: 0.9rem;
            transition: all 0.2s ease;
        }

        .user-dropdown a:hover {
            background: rgba(57, 255, 20, 0.1);
            color: var(--primary);
        }

        .user-dropdown a i {
            margin-right: 0.5rem;
            width: 20px;
        }

        .user-dropdown .logout-link {
            border-top: 1px solid var(--border);
            color: var(--red);
        }

        .user-dropdown .logout-link:hover {
            background: rgba(239, 68, 68, 0.1);
        }

        /* Content Container */
        .content-container {
            margin-top: 64px;
            padding: 2rem;
            width: 100%;
            max-width: none;
        }

        /* ===== CONFIGURACIONES LAYOUT ===== */
        .config-layout {
            display: flex;
            gap: 0;
            height: calc(100vh - 120px);
            overflow: hidden;
        }

        .config-sidebar {
            width: 280px;
            background: var(--surface);
            border-right: 1px solid var(--border);
            overflow-y: auto;
            flex-shrink: 0;
        }

        .config-sidebar-title {
            font-size: 1.5rem;
            font-weight: 700;
            padding: 2rem 1.5rem 1rem;
            color: var(--text);
            border-bottom: 1px solid var(--border);
        }

        .config-nav {
            padding: 1rem 0;
        }

        .config-nav-item {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 1rem 1.5rem;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
            border-left: 3px solid transparent;
        }

        .config-nav-item:hover {
            background: rgba(57, 255, 20, 0.05);
            color: var(--primary);
        }

        .config-nav-item.active {
            background: rgba(57, 255, 20, 0.1);
            color: var(--primary);
            border-left-color: var(--primary);
            font-weight: 600;
        }

        .config-nav-item i {
            font-size: 1.1rem;
            width: 20px;
            text-align: center;
        }

        .config-content {
            flex: 1;
            overflow-y: auto;
            padding: 2rem;
            background: var(--background);
        }

        .config-section {
            display: none;
        }

        .config-section.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .config-section-title {
            font-size: 2rem;
            font-weight: 700;
            color: var(--text);
            margin-bottom: 0.5rem;
        }

        .config-section-subtitle {
            color: var(--text-secondary);
            margin-bottom: 2rem;
            font-size: 1rem;
        }

        .config-card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 0.75rem;
            margin-bottom: 1.5rem;
            overflow: hidden;
        }

        .config-card.border-danger {
            border-color: var(--danger);
        }

        .config-card-header {
            padding: 1.25rem 1.5rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .config-card-header h3 {
            font-size: 1.125rem;
            font-weight: 600;
            color: var(--text);
        }

        .config-card-body {
            padding: 1.5rem;
        }

        .config-actions {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border);
        }

        /* Form Elements */
        .form-group {
            margin-bottom: 1.5rem;
        }

        .form-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--text);
            font-size: 0.9rem;
        }

        .form-control {
            width: 100%;
            padding: 0.75rem 1rem;
            background: var(--background);
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            color: var(--text);
            font-size: 1rem;
            transition: all 0.2s ease;
        }

        .form-control:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(57, 255, 20, 0.1);
        }

        .form-control:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        /* Toggle Switch */
        .feature-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem 0;
            border-bottom: 1px solid var(--border);
        }

        .feature-toggle:last-child {
            border-bottom: none;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
            flex-shrink: 0;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--surface-light);
            transition: 0.3s;
            border-radius: 26px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: var(--primary);
        }

        input:checked + .toggle-slider:before {
            transform: translateX(24px);
        }

        input:disabled + .toggle-slider {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Buttons */
        .btn-primary, .btn-outline, .btn-danger, .btn-link {
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
            font-size: 0.95rem;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            text-decoration: none;
        }

        .btn-primary {
            background: var(--primary);
            color: var(--background);
        }

        .btn-primary:hover {
            background: var(--secondary);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(57, 255, 20, 0.3);
        }

        .btn-outline {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text);
        }

        .btn-outline:hover {
            border-color: var(--primary);
            color: var(--primary);
        }

        .btn-danger {
            background: var(--danger);
            color: white;
        }

        .btn-danger:hover {
            background: #cc0000;
        }

        .btn-link {
            background: transparent;
            color: var(--primary);
            padding: 0.25rem 0.5rem;
        }

        /* P&L Color Classes - Verde Fluorescente y Rojo */
        .text-positive {
            color: #00FF41 !important; /* Verde fluorescente */
        }

        .text-negative {
            color: #FF1744 !important; /* Rojo brillante */
        }

        .text-green {
            color: #00FF41 !important; /* Verde fluorescente */
        }

        .text-red {
            color: #FF1744 !important; /* Rojo brillante */
        }

        .btn-link:hover {
            text-decoration: underline;
        }

        /* Badges */
        .badge-success {
            padding: 0.35rem 0.75rem;
            background: rgba(57, 255, 20, 0.15);
            color: var(--primary);
            border-radius: 50px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        /* Alerts */
        .alert {
            padding: 1rem;
            border-radius: 0.5rem;
            display: flex;
            align-items: flex-start;
            gap: 1rem;
        }

        .alert i {
            font-size: 1.25rem;
            flex-shrink: 0;
            margin-top: 0.125rem;
        }

        .alert-warning {
            background: rgba(255, 193, 7, 0.1);
            border: 1px solid rgba(255, 193, 7, 0.3);
            color: #ffc107;
        }

        .alert-success {
            background: rgba(57, 255, 20, 0.1);
            border: 1px solid rgba(57, 255, 20, 0.3);
            color: var(--primary);
        }

        .alert-info {
            background: rgba(13, 110, 253, 0.1);
            border: 1px solid rgba(13, 110, 253, 0.3);
            color: #0d6efd;
        }

        .alert-danger {
            background: rgba(255, 65, 54, 0.1);
            border: 1px solid rgba(255, 65, 54, 0.3);
            color: var(--danger);
        }

        /* User Profile Display */
        .user-profile-display {
            display: flex;
            gap: 2rem;
            align-items: flex-start;
        }

        .user-avatar-large {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--background);
            flex-shrink: 0;
        }

        .user-profile-info {
            flex: 1;
        }

        /* Plan Display */
        .plan-display {
            display: flex;
            gap: 1.5rem;
            align-items: center;
            padding: 1.5rem;
            background: linear-gradient(135deg, rgba(57, 255, 20, 0.1) 0%, rgba(57, 255, 20, 0.05) 100%);
            border-radius: 0.75rem;
            margin-bottom: 1.5rem;
        }

        .plan-icon {
            width: 80px;
            height: 80px;
            background: var(--primary);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            color: var(--background);
        }

        .plan-info h4 {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text);
            margin-bottom: 0.5rem;
        }

        .plan-price {
            font-size: 2rem;
            font-weight: 700;
            color: var(--primary);
        }

        .plan-price span {
            font-size: 1rem;
            color: var(--text-secondary);
            font-weight: 400;
        }

        .plan-features {
            margin-top: 1.5rem;
        }

        .feature-list {
            list-style: none;
            padding: 0;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 0.75rem;
        }

        .feature-list li {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            color: var(--text-secondary);
        }

        .feature-list i {
            color: var(--primary);
            font-size: 0.9rem;
        }

        .plan-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1.5rem;
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border);
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            display: block;
            font-size: 2rem;
            font-weight: 700;
            color: var(--primary);
        }

        .stat-label {
            display: block;
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-top: 0.5rem;
        }

        /* Billing History */
        .billing-history {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .billing-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            background: var(--background);
            border-radius: 0.5rem;
        }

        /* Mentor Card */
        .mentor-card {
            background: linear-gradient(135deg, rgba(57, 255, 20, 0.05) 0%, rgba(0, 0, 0, 0) 100%);
        }

        .mentor-profile {
            display: flex;
            gap: 2rem;
            margin-bottom: 2rem;
        }

        .mentor-avatar {
            position: relative;
            flex-shrink: 0;
        }

        .mentor-avatar img {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            border: 3px solid var(--primary);
        }

        .mentor-badge {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 32px;
            height: 32px;
            background: var(--primary);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--background);
            border: 3px solid var(--surface);
        }

        .mentor-info h3 {
            font-size: 1.75rem;
            font-weight: 700;
            color: var(--text);
            margin-bottom: 0.25rem;
        }

        .mentor-title {
            color: var(--primary);
            font-weight: 600;
            margin-bottom: 1rem;
        }

        .mentor-stats {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .mentor-stat {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            color: var(--text-secondary);
        }

        .mentor-stat i {
            color: var(--primary);
            width: 20px;
        }

        .mentor-description {
            margin-bottom: 2rem;
        }

        .services-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin-top: 1rem;
        }

        .service-item {
            padding: 1.5rem;
            background: var(--background);
            border-radius: 0.75rem;
            border: 1px solid var(--border);
            text-align: center;
            transition: all 0.3s ease;
        }

        .service-item:hover {
            border-color: var(--primary);
            transform: translateY(-2px);
        }

        .service-item i {
            font-size: 2rem;
            color: var(--primary);
            margin-bottom: 1rem;
        }

        .service-item h5 {
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--text);
        }

        .service-item p {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .mentorship-contact {
            margin-top: 2rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border);
        }

        .contact-methods {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .testimonials {
            margin-top: 2rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border);
        }

        .testimonial-item {
            background: var(--background);
            padding: 1.5rem;
            border-radius: 0.75rem;
            border: 1px solid var(--border);
        }

        .testimonial-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .testimonial-avatar {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: var(--primary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            color: var(--background);
        }

        .rating {
            display: flex;
            gap: 0.25rem;
            color: #ffc107;
            font-size: 0.875rem;
        }

        .testimonial-text {
            color: var(--text-secondary);
            font-style: italic;
        }

        /* Import/Export */
        .import-zone {
            margin-bottom: 1.5rem;
        }

        .upload-area {
            border: 2px dashed var(--border);
            border-radius: 0.75rem;
            padding: 3rem 2rem;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .upload-area:hover {
            border-color: var(--primary);
            background: rgba(57, 255, 20, 0.03);
        }

        .upload-area i {
            font-size: 3rem;
            color: var(--primary);
            margin-bottom: 1rem;
        }

        .csv-format-info {
            background: var(--background);
            padding: 1rem;
            border-radius: 0.5rem;
            border: 1px solid var(--border);
        }

        .code-block {
            display: block;
            background: rgba(57, 255, 20, 0.05);
            padding: 0.75rem;
            border-radius: 0.375rem;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            color: var(--primary);
            margin-top: 0.5rem;
            overflow-x: auto;
        }

        .export-options {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .export-option {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            background: var(--background);
            border-radius: 0.5rem;
            border: 1px solid var(--border);
        }

        /* ===== UTILIDADES Y COMPONENTES ===== */
        .card {
            background-color: var(--surface);
            border-radius: 0.5rem;
            border: 1px solid var(--surface-light);
            padding: 1.5rem;
        }

        /* Pestañas de navegación */
        .nav-tabs {
            display: flex !important;
            flex-direction: row;
            border-bottom: 1px solid var(--surface-light);
        }
        .nav-tab {
            padding: 0.75rem 1.5rem;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            color: var(--text-secondary);
            border-bottom: 3px solid transparent;
            margin-bottom: -1px;
            white-space: nowrap;
            flex-shrink: 0;
        }
        .nav-tab.active {
            color: var(--text);
            border-bottom-color: var(--primary);
            font-weight: 600;
        }
        .nav-tab:hover:not(.active) {
            color: var(--text);
            border-bottom-color: var(--surface-light);
        }

        /* Contenedor de sección */
        .section-container {
            display: none;
            padding: 1.5rem 0;
            margin-bottom: 2rem;
        }
        .section-container { display: none; }
        .section-container.active { display: block !important; }

        /* Tarjetas de métricas */
        .metric-card {
            background-color: var(--surface);
            border-radius: 0.5rem;
            padding: 1.5rem;
            border: 1px solid var(--surface-light);
            transition: all 0.2s ease-in-out;
        }
        .metric-card:hover {
            border-color: var(--primary);
            box-shadow: 0 0 20px rgba(57, 255, 20, 0.05);
        }
        .metric-card canvas {
            max-height: 300px;
        }
        
        /* TradingView Widgets - Forzar Dark Mode */
        .tradingview-widget-container {
            background-color: #000000 !important;
            border-radius: 0.5rem;
            overflow: hidden;
        }
        .tradingview-widget-container__widget {
            background-color: #000000 !important;
        }
        .tradingview-widget-container iframe {
            background-color: #000000 !important;
        }
        
        /* Ticker Tape - Forzar fondo negro */
        .ticker-tape-wrapper {
            background-color: #000000 !important;
        }
        tv-ticker-tape {
            display: block !important;
            background-color: #000000 !important;
            background: #000000 !important;
        }
        tv-ticker-tape::part(*) {
            background-color: #000000 !important;
            background: #000000 !important;
        }
        tv-ticker-tape * {
            background-color: #000000 !important;
        }
        tv-ticker-tape iframe {
            background-color: #000000 !important;
        }
        tv-ticker-tape::shadow * {
            background-color: #000000 !important;
        }

        /* Tarjetas de Cuentas */
        .account-card {
            background-color: var(--surface);
            border-radius: 1rem;
            padding: 1.5rem;
            border: 1px solid var(--surface-light);
            transition: all 0.2s ease-in-out;
        }
        .account-card:hover {
            border-color: var(--primary);
            box-shadow: 0 0 20px rgba(57, 255, 20, 0.1);
            transform: translateY(-2px);
        }
        .account-card.selected {
            border-color: var(--primary);
            box-shadow: 0 0 25px rgba(57, 255, 20, 0.15);
        }

        /* Calendario */
        .calendar-day {
            width: 100%; aspect-ratio: 1.3 / 1; display: flex; flex-direction: column; align-items: center; justify-content: center;
            border-radius: 0.25rem; cursor: pointer; transition: all 0.2s ease; position: relative;
            background-color: var(--surface); border: 1px solid var(--surface-light);
            padding: 0.2rem;
        }
        .calendar-day.empty { background-color: transparent; border-color: var(--background); cursor: default; }
        .calendar-day.empty:hover { transform: none; }
        .calendar-day.profit { background-color: rgba(57, 255, 20, 0.05); border-color: var(--green); }
        .calendar-day.loss { background-color: rgba(255, 65, 54, 0.05); border-color: var(--red); }
        .calendar-day.border-primary { border-color: #39ff14 !important; border-width: 2px !important; box-shadow: 0 0 10px rgba(57, 255, 20, 0.3); }
        .calendar-day:not(.empty):hover { transform: scale(1.05); z-index: 10; border-color: var(--primary); }
        .day-number { font-size: 0.85rem; font-weight: 600; }
        .day-profit { font-size: 0.7rem; line-height: 1.1; }
        .day-profit.positive { color: var(--green); }
        .day-profit.negative { color: var(--red); }
        .day-trades { font-size: 0.6rem; color: var(--text-secondary); }

        /* Columna de totales semanales */
        .calendar-week-total {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: var(--surface-light);
            border: 1px solid var(--border);
            border-radius: 0.25rem;
            padding: 0.3rem 0.2rem;
            aspect-ratio: 1.3 / 1;
        }
        .week-label {
            font-size: 0.6rem;
            color: var(--text-secondary);
            font-weight: 600;
            margin-bottom: 0.1rem;
            line-height: 1;
        }
        .week-total {
            font-size: 0.75rem;
            font-weight: 700;
            line-height: 1.1;
        }
        .week-total.positive {
            color: var(--green);
        }
        .week-total.negative {
            color: var(--red);
        }
        .week-trades-count {
            font-size: 0.55rem;
            color: var(--text-secondary);
            margin-top: 0.05rem;
            line-height: 1;
        }

        /* Barras Horizontales de Métricas (estilo gráfico) */
        .metric-bar-container {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem 0;
        }
        .metric-bar-label {
            min-width: 80px;
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text);
            text-align: right;
        }
        .metric-bar-wrapper {
            flex: 1;
            position: relative;
            height: 28px;
            background-color: var(--background);
            border-radius: 4px;
            overflow: hidden;
        }
        .metric-bar-fill {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            transition: width 0.6s ease;
            border-radius: 4px;
        }
        .metric-bar-fill.positive {
            background: linear-gradient(90deg, rgba(57, 255, 20, 0.8) 0%, rgba(57, 255, 20, 1) 100%);
            box-shadow: 0 0 10px rgba(57, 255, 20, 0.3);
        }
        .metric-bar-fill.negative {
            background: linear-gradient(90deg, rgba(255, 65, 54, 0.8) 0%, rgba(255, 65, 54, 1) 100%);
            box-shadow: 0 0 10px rgba(255, 65, 54, 0.3);
        }
        .metric-bar-fill.warning {
            background: linear-gradient(90deg, rgba(255, 193, 7, 0.8) 0%, rgba(255, 193, 7, 1) 100%);
            box-shadow: 0 0 10px rgba(255, 193, 7, 0.3);
        }
        .metric-bar-fill.info {
            background: linear-gradient(90deg, rgba(156, 163, 175, 0.8) 0%, rgba(156, 163, 175, 1) 100%);
            box-shadow: 0 0 10px rgba(156, 163, 175, 0.3);
        }
        .metric-bar-value {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.7rem;
            font-weight: 700;
            color: #ffffff;
            text-shadow: 0 0 4px rgba(0, 0, 0, 0.5);
            z-index: 2;
        }
        .metric-bar-value.outside {
            left: calc(100% + 8px);
            right: auto;
            color: #ffffff;
            text-shadow: none;
        }

        /* Selección manual de días y semanas */
        .calendar-day.selected {
            border: 2px solid var(--primary) !important;
            background-color: rgba(16, 185, 129, 0.1) !important;
            box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.2);
        }
        .calendar-day.selected::after {
            content: '✓';
            position: absolute;
            top: 2px;
            right: 2px;
            color: var(--primary);
            font-size: 12px;
            font-weight: bold;
        }
        .week-summary.selected {
            border: 2px solid var(--primary) !important;
            background-color: rgba(16, 185, 129, 0.1) !important;
            box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.2);
        }
        .calendar-selection-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-bottom: 16px;
        }
        .selection-mode-btn {
            padding: 6px 12px;
            background: var(--surface);
            border: 1px solid var(--surface-light);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            color: var(--text-secondary);
            font-size: 12px;
        }
        .selection-mode-btn.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }
        .selection-mode-btn:hover:not(.active) {
            background: var(--surface-light);
        }

        /* Botones */
        button {
            background-color: var(--surface-light); color: var(--text); border: 1px solid var(--surface-light);
            border-radius: 0.25rem; padding: 0.6rem 1.2rem; cursor: pointer; transition: all 0.2s ease; font-weight: 500;
        }
        button:hover { background-color: var(--primary); border-color: var(--primary); color: var(--background); font-weight: bold; }
        button.primary { background-color: var(--primary); border-color: var(--primary); color: var(--background); font-weight: bold; }
        button.primary:hover { background-color: var(--secondary); border-color: var(--secondary); }
        button.secondary { background-color: var(--surface); border-color: var(--surface-light); color: var(--text); font-weight: 500; }
        button.secondary:hover { background-color: var(--surface-light); border-color: var(--primary); color: var(--primary); }
        button.warning { background-color: #f59e0b; border-color: #f59e0b; color: white; font-weight: 500; }
        button.warning:hover { background-color: #d97706; border-color: #d97706; }
        button.success { background-color: var(--green); border-color: var(--green); color: var(--background); font-weight: bold; }
        button.danger { background-color: var(--red); border-color: var(--red); }
        #operations-table td button, #accounts-container button, #finances-table-body td button {
            padding: 0.3rem 0.6rem; font-size: 0.875rem; background-color: transparent; border: none;
        }
        #operations-table td button:hover, #accounts-container button:hover, #finances-table-body td button:hover {
            opacity: 0.8; color: var(--primary);
        }

        /* Botón de Setup en operaciones */
        .setup-op-btn {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.4rem 0.6rem;
            font-size: 0.75rem;
            background-color: transparent;
            border: 1px solid var(--primary);
            border-radius: 0.375rem;
            transition: all 0.2s ease;
            white-space: nowrap;
        }
        .setup-op-btn:hover {
            background-color: var(--primary);
            color: var(--background);
        }
        .setup-op-btn i {
            font-size: 0.875rem;
        }

        /* Modal de asignar setup */
        .setup-option {
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .setup-option:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(57, 255, 20, 0.2);
        }

        /* Botones de filtro de Funded */
        .funded-filter-btn {
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            background-color: var(--surface);
            border: 1px solid var(--surface-light);
            color: var(--text-secondary);
            border-radius: 0.375rem;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 500;
        }
        .funded-filter-btn:hover {
            background-color: var(--surface-light);
            color: var(--primary);
            border-color: var(--primary);
        }
        .funded-filter-btn.active {
            background-color: var(--primary);
            color: var(--background);
            border-color: var(--primary);
            font-weight: 600;
        }
        .funded-filter-btn i {
            opacity: 0.8;
        }
        .funded-filter-btn.active i {
            opacity: 1;
        }

        /* Pestañas de Finanzas */
        /* Funded Tabs - IGUALADO CON FINANCES-TAB */
        .funded-view {
            display: none !important;
        }
        .funded-view.active {
            display: block !important;
        }

        /* Funded Calendar Styles */
        #funded-calendar-days {
            min-height: 500px;
        }
        .funded-calendar-day {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            padding: 1rem;
            min-height: 100px;
            display: flex;
            flex-direction: column;
            transition: all 0.2s ease;
            cursor: pointer;
        }
        .funded-calendar-day:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        .funded-calendar-day.empty {
            background: transparent;
            border-color: transparent;
            cursor: default;
        }
        .funded-calendar-day.empty:hover {
            transform: none;
            box-shadow: none;
        }
        .funded-calendar-day.has-events {
            border: 2px solid var(--primary);
            background: rgba(57, 255, 20, 0.05);
        }
        .funded-day-number {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--text);
            margin-bottom: 0.5rem;
        }
        .funded-calendar-day.empty .funded-day-number {
            color: var(--text-secondary);
            opacity: 0.3;
        }
        .funded-day-amount {
            font-size: 1rem;
            font-weight: 600;
            margin-top: auto;
        }
        .funded-day-amount.positive {
            color: var(--green);
        }
        .funded-day-amount.negative {
            color: var(--red);
        }
        .funded-day-events {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-top: 0.25rem;
        }
        .funded-week-card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            padding: 1rem;
            transition: all 0.2s ease;
        }
        .funded-week-card:hover {
            border-color: var(--primary);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(57, 255, 20, 0.15);
        }
        .funded-week-title {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }
        .funded-week-amount {
            font-size: 1.5rem;
            font-weight: 700;
        }
        .funded-week-amount.positive {
            color: var(--green);
        }
        .funded-week-amount.negative {
            color: var(--red);
        }
        .funded-week-total {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-top: 0.25rem;
        }

        /* Badges */
        .badge {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            font-size: 0.75rem;
            font-weight: 600;
            border-radius: 9999px;
            text-transform: uppercase;
            letter-spacing: 0.025em;
        }
        .badge-success {
            background-color: rgba(57, 255, 20, 0.15);
            color: var(--green);
        }
        .badge-danger {
            background-color: rgba(255, 0, 0, 0.15);
            color: var(--red);
        }
        .badge-warning {
            background-color: rgba(245, 158, 11, 0.15);
            color: #f59e0b;
        }
        .badge-primary {
            background-color: rgba(57, 255, 20, 0.15);
            color: var(--primary);
        }

        /* Formularios */
        input, select, textarea {
            background-color: var(--surface); color: var(--text); border: 1px solid var(--surface-light);
            border-radius: 0.25rem; padding: 0.6rem; width: 100%; transition: border-color 0.2s ease;
        }
        input:focus, select:focus, textarea:focus { outline: none; border-color: var(--primary); }
        
        /* Multi-Select Dropdown */
        .multi-select-container {
            position: relative;
            display: inline-block;
        }
        .multi-select-trigger {
            background-color: var(--surface);
            color: var(--text);
            border: 1px solid var(--surface-light);
            border-radius: 0.25rem;
            padding: 0.6rem 2.5rem 0.6rem 0.6rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            min-width: 12rem;
            transition: border-color 0.2s ease;
            position: relative;
        }
        .multi-select-trigger:hover {
            border-color: var(--primary);
        }
        .multi-select-trigger .chevron {
            position: absolute;
            right: 0.6rem;
            font-size: 0.75rem;
            transition: transform 0.2s ease;
        }
        .multi-select-trigger.open .chevron {
            transform: rotate(180deg);
        }
        .multi-select-count {
            background-color: var(--primary);
            color: var(--background);
            border-radius: 9999px;
            padding: 0.1rem 0.5rem;
            font-size: 0.75rem;
            font-weight: 600;
        }
        .multi-select-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            margin-top: 0.25rem;
            background-color: var(--surface);
            border: 1px solid var(--surface-light);
            border-radius: 0.25rem;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            min-width: 100%;
            max-height: 300px;
            overflow-y: auto;
            display: none;
        }
        .multi-select-dropdown.open {
            display: block;
        }
        .multi-select-option {
            padding: 0.6rem 0.8rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: background-color 0.2s ease;
        }
        .multi-select-option:hover {
            background-color: rgba(57, 255, 20, 0.05);
        }
        .multi-select-option input[type="checkbox"] {
            width: auto;
            cursor: pointer;
        }
        .multi-select-option.all {
            border-bottom: 1px solid var(--surface-light);
            font-weight: 600;
        }
        input[type="file"]::file-selector-button {
            background-color: var(--primary); color: var(--background); border: none; padding: 0.5rem 1rem;
            border-radius: 0.25rem; cursor: pointer; transition: background-color 0.3s ease; margin-right: 0.8rem; font-weight: bold;
        }
        input[type="file"]::file-selector-button:hover { background-color: var(--secondary); }

        /* Tablas */
        table { width: 100%; border-collapse: separate; border-spacing: 0; }
        th {
            text-align: left; padding: 0.8rem 1rem; background-color: transparent;
            font-weight: 600; color: var(--text-secondary); text-transform: uppercase; font-size: 0.75rem;
            letter-spacing: 0.05em; border-bottom: 1px solid var(--surface-light);
        }
        td {
            padding: 0.8rem 1rem; border-bottom: 1px solid var(--surface);
            overflow: hidden; text-overflow: ellipsis; white-space: nowrap; vertical-align: middle;
        }
        tr:hover td { background-color: rgba(57, 255, 20, 0.03); }
        #operations-table tr.cursor-pointer:hover td { background-color: rgba(57, 255, 20, 0.08); }
        #best-trades tr.cursor-pointer:hover td, #worst-trades tr.cursor-pointer:hover td, #day-modal-table-body tr.cursor-pointer:hover td {
             background-color: rgba(57, 255, 20, 0.08);
        }
        /* Tablas clicables en Analytics */
        #analytics-monthly-performance tr, 
        #analytics-daily-performance tr,
        #analytics-weekly-performance tr,
        #analytics-quarterly-performance tr {
            cursor: pointer;
        }
        #analytics-monthly-performance tr:hover td, 
        #analytics-daily-performance tr:hover td,
        #analytics-weekly-performance tr:hover td,
        #analytics-quarterly-performance tr:hover td {
            background-color: rgba(57, 255, 20, 0.08);
        }

        /* --- NUEVO: Estilo para cabeceras de tabla ordenables --- */
        #operations-table-render th[data-sort] {
            cursor: pointer;
            position: relative;
        }
        #operations-table-render th[data-sort]:hover {
            color: var(--text);
        }
        #operations-table-render th[data-sort].sorted::after {
            content: '';
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            border: 4px solid transparent;
        }
        #operations-table-render th[data-sort].sorted.asc::after {
            border-bottom-color: var(--primary);
            margin-top: -2px;
        }
        #operations-table-render th[data-sort].sorted.desc::after {
            border-top-color: var(--primary);
            margin-top: 2px;
        }

        /* --- Optimización de tabla de operaciones --- */
        #operations-table-render {
            font-size: 0.875rem; /* Reducir tamaño de fuente ligeramente */
            table-layout: fixed; /* Layout fijo para mejor control de anchos */
            width: 100%;
        }
        #operations-table-render th,
        #operations-table-render td {
            padding: 0.5rem 0.25rem; /* Reducir padding para más espacio */
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        /* Anchos específicos para cada columna */
        #operations-table-render th:nth-child(1) { width: 8%; } /* Fecha */
        #operations-table-render th:nth-child(2) { width: 6%; } /* Entrada */
        #operations-table-render th:nth-child(3) { width: 6%; } /* Salida */
        #operations-table-render th:nth-child(4) { width: 10%; } /* Cuenta */
        #operations-table-render th:nth-child(5) { width: 12%; } /* Instrumento */
        #operations-table-render th:nth-child(6) { width: 6%; } /* Tipo */
        #operations-table-render th:nth-child(7) { width: 8%; } /* Entrada */
        #operations-table-render th:nth-child(8) { width: 8%; } /* Salida */
        #operations-table-render th:nth-child(9) { width: 6%; } /* Volumen */
        #operations-table-render th:nth-child(10) { width: 7%; } /* Resultado */
        #operations-table-render th:nth-child(11) { width: 8%; } /* P&L */
        #operations-table-render th:nth-child(12) { width: 6%; } /* Fees */
        #operations-table-render th:nth-child(13) { width: 5%; } /* Divisa */
        #operations-table-render th:nth-child(14) { width: 6%; } /* Sesión */
        #operations-table-render th:nth-child(15) { width: 8%; } /* Setup */
        #operations-table-render th:nth-child(16) { width: 8%; } /* Acciones */

        /* --- ESTILOS PARA PLATAFORMAS --- */
        .platform-card {
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .platform-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }
        .platform-card .metric-card {
            border: 2px solid transparent;
            border-radius: 1rem;
            transition: border-color 0.2s ease;
        }
        .platform-card:hover .metric-card {
            border-color: var(--primary);
        }
        .platform-card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .platform-card.disabled:hover {
            transform: none;
            box-shadow: none;
        }

        /* Platform Detail View */
        .platform-detail-container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .platform-detail-header {
            display: flex;
            align-items: center;
            gap: 1.5rem;
            margin-bottom: 2rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--border);
        }

        .platform-detail-back {
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .platform-detail-back:hover {
            background: var(--surface-light);
            border-color: var(--primary);
            transform: translateX(-4px);
        }

        .platform-detail-title h2 {
            font-size: 2rem;
            font-weight: 700;
            color: var(--text);
            margin-bottom: 0.25rem;
        }

        .platform-detail-title p {
            font-size: 1rem;
            color: var(--text-secondary);
        }

        .platform-logo {
            width: 48px;
            height: 48px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            overflow: hidden;
        }

        .platform-logo img {
            width: 48px;
            height: 48px;
            object-fit: cover;
        }

        /* Platform Tabs */
        .platform-tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 2rem;
            border-bottom: 2px solid var(--border);
            padding-bottom: 0;
        }

        .platform-tab {
            padding: 1rem 2rem;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            border-bottom: 3px solid transparent;
            margin-bottom: -2px;
        }

        .platform-tab:hover {
            color: var(--text);
            background: rgba(57, 255, 20, 0.05);
        }

        .platform-tab.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
        }

        .platform-tab-content {
            display: none !important;
        }

        .platform-tab-content.active {
            display: block !important;
            animation: fadeIn 0.3s ease;
        }

        /* Status Cards */
        .status-card {
            padding: 1.25rem;
            border-radius: 8px;
            display: flex;
            align-items: flex-start;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .status-card-success {
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid rgba(16, 185, 129, 0.3);
        }

        .status-card-warning {
            background: rgba(245, 158, 11, 0.1);
            border: 1px solid rgba(245, 158, 11, 0.3);
        }

        .status-card-info {
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid rgba(16, 185, 129, 0.3);
        }

        .status-card-icon {
            font-size: 1.5rem;
            flex-shrink: 0;
        }

        .status-card-success .status-card-icon {
            color: var(--success);
        }

        .status-card-warning .status-card-icon {
            color: var(--warning);
        }

        .status-card-info .status-card-icon {
            color: #10b981;
        }

        /* Quick Sync Button */
        #bingx-quick-sync {
            font-size: 0.75rem;
            font-weight: 500;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }
        #bingx-quick-sync:hover {
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);
            transform: translateY(-1px);
        }
        #bingx-quick-sync:active {
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }
        #bingx-quick-sync i {
            transition: transform 0.3s ease;
        }
        #bingx-quick-sync:hover i {
            transform: rotate(180deg);
        }

        /* MEXC Quick Sync Button Animation */
        #mexc-quick-sync {
            font-size: 0.75rem;
            font-weight: 500;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }
        #mexc-quick-sync:hover {
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);
            transform: translateY(-1px);
        }
        #mexc-quick-sync:active {
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }
        #mexc-quick-sync i {
            transition: transform 0.3s ease;
        }
        #mexc-quick-sync:hover i {
            transform: rotate(180deg);
        }

        /* Currency Switch */
        /* Selector de moneda tipo dropdown */
        .currency-selector { padding: 0.5rem 1rem; background-color: var(--surface); border: 1px solid var(--surface-light); border-radius: 0.25rem; color: var(--text); font-size: 0.875rem; cursor: pointer; transition: all 0.2s; min-width: 80px; }
        .currency-selector:hover { border-color: var(--primary); }
        .currency-selector:focus { outline: none; border-color: var(--primary); box-shadow: 0 0 0 2px rgba(57, 255, 20, 0.1); }

        /* Toolbar profesional con selectores y botones */
        .section-toolbar { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem; margin-bottom: 1.5rem; }
        .toolbar-left { display: flex; align-items: center; gap: 1rem; flex-wrap: wrap; }
        .toolbar-right { display: flex; align-items: center; gap: 0.75rem; }
        .filter-group { display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem 1rem; background-color: var(--surface); border: 1px solid var(--surface-light); border-radius: 0.375rem; }
        .action-btn { display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem 1rem; background-color: var(--surface); border: 1px solid var(--surface-light); border-radius: 0.375rem; color: var(--text); font-size: 0.875rem; cursor: pointer; transition: all 0.2s; }
        .action-btn:hover { background-color: var(--surface-light); border-color: var(--primary); }
        .action-btn i { font-size: 0.875rem; }

        /* Panel Lateral de Filtros (estilo Tradervue) */
        .filters-sidebar { position: fixed; top: 0; right: -400px; width: 400px; height: 100vh; background-color: var(--surface); border-left: 1px solid var(--surface-light); z-index: 1001; transition: right 0.3s ease-out; overflow-y: auto; display: flex; flex-direction: column; }
        .filters-sidebar.active { right: 0; }
        .filters-sidebar-header { padding: 1.5rem; border-bottom: 1px solid var(--surface-light); display: flex; justify-content: space-between; align-items: center; }
        .filters-sidebar-header h3 { font-size: 1.25rem; font-weight: 600; color: var(--text); margin: 0; }
        .close-filters-btn { background: none; border: none; color: var(--text-secondary); font-size: 1.5rem; cursor: pointer; padding: 0.5rem; transition: color 0.2s; }
        .close-filters-btn:hover { color: var(--primary); }
        
        .filters-sidebar-content { flex: 1; padding: 1.5rem; overflow-y: auto; }
        .filter-section { margin-bottom: 1.5rem; }
        .filter-section.expandable { border: 1px solid var(--surface-light); border-radius: 0.5rem; overflow: hidden; }
        .filter-section-header { padding: 1rem; background-color: var(--bg); cursor: pointer; display: flex; justify-content: space-between; align-items: center; transition: background-color 0.2s; }
        .filter-section-header:hover { background-color: var(--surface); }
        .filter-section-header i { transition: transform 0.3s; color: var(--text-secondary); }
        .filter-section.expanded .filter-section-header i { transform: rotate(180deg); }
        .filter-section-content { max-height: 0; overflow: hidden; transition: max-height 0.3s ease-out; padding: 0 1rem; }
        .filter-section.expanded .filter-section-content { max-height: 500px; padding: 1rem; }
        
        .filter-label { display: block; font-size: 0.875rem; font-weight: 600; color: var(--text); margin-bottom: 0.5rem; }
        .filter-sublabel { display: block; font-size: 0.8rem; font-weight: 500; color: var(--text-secondary); margin-bottom: 0.4rem; }
        .filter-sublabel.mt-3 { margin-top: 1rem; }
        
        .filter-sidebar-input, .filter-sidebar-select { width: 100%; padding: 0.75rem; background-color: var(--bg); border: 1px solid var(--surface-light); border-radius: 0.375rem; color: var(--text); font-size: 0.875rem; transition: all 0.2s; }
        .filter-sidebar-input:focus, .filter-sidebar-select:focus { outline: none; border-color: var(--primary); background-color: var(--surface); }
        .filter-sidebar-input::placeholder { color: var(--text-secondary); }
        
        .filter-checkbox-group { display: flex; flex-direction: column; gap: 0.75rem; }
        .filter-checkbox { display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.875rem; color: var(--text); }
        .filter-checkbox input[type="checkbox"] { width: 18px; height: 18px; cursor: pointer; accent-color: var(--primary); }
        
        .filters-sidebar-footer { padding: 1.5rem; border-top: 1px solid var(--surface-light); display: flex; gap: 0.75rem; }
        .sidebar-apply-btn { flex: 1; display: flex; align-items: center; justify-content: center; gap: 0.5rem; padding: 0.875rem; background-color: var(--primary); color: var(--bg); border: none; border-radius: 0.375rem; font-weight: 600; font-size: 0.95rem; cursor: pointer; transition: all 0.2s; }
        .sidebar-apply-btn:hover { background-color: #2ecc11; transform: translateY(-1px); box-shadow: 0 4px 12px rgba(57, 255, 20, 0.3); }
        .sidebar-clear-btn { padding: 0.875rem 1.25rem; background-color: transparent; color: var(--text); border: 1px solid var(--surface-light); border-radius: 0.375rem; font-weight: 500; cursor: pointer; transition: all 0.2s; }
        .sidebar-clear-btn:hover { background-color: var(--surface-light); border-color: var(--primary); color: var(--primary); }
        
        .filters-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); z-index: 1000; opacity: 0; pointer-events: none; transition: opacity 0.3s ease-out; }
        .filters-overlay.active { opacity: 1; pointer-events: all; }

        /* Panel de Filtros Equity Graph */
        .filters-panel { background-color: var(--surface); border: 1px solid var(--surface-light); border-radius: 0.5rem; padding: 1.5rem; margin-bottom: 1.5rem; }
        .filters-section { margin-bottom: 1rem; }
        .filters-section:last-child { margin-bottom: 0; }
        .filters-section-title { font-size: 0.95rem; font-weight: 600; color: var(--text); margin-bottom: 1rem; display: flex; align-items: center; }
        .filter-item { display: flex; flex-direction: column; }
        .filter-label { font-size: 0.8rem; font-weight: 500; color: var(--text-secondary); margin-bottom: 0.4rem; display: flex; align-items: center; }
        .filter-label i { font-size: 0.75rem; }
        .filter-select { width: 100%; padding: 0.6rem 0.75rem; background-color: var(--bg); border: 1px solid var(--surface-light); border-radius: 0.375rem; color: var(--text); font-size: 0.875rem; transition: all 0.2s; }
        .filter-select:focus { outline: none; border-color: var(--primary); background-color: var(--surface); }
        .filter-input { width: 100%; padding: 0.6rem 0.75rem; background-color: var(--bg); border: 1px solid var(--surface-light); border-radius: 0.375rem; color: var(--text); font-size: 0.875rem; transition: all 0.2s; }
        .filter-input:focus { outline: none; border-color: var(--primary); background-color: var(--surface); }

        /* Gráficos */
        .chart-container { position: relative; height: 320px; margin-bottom: 1rem; }

        /* Loading Spinner */
        .loading { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(10, 10, 10, 0.9); display: flex; align-items: center; justify-content: center; z-index: 1000; }
        .spinner { border: 4px solid var(--surface-light); border-radius: 50%; border-top: 4px solid var(--primary); width: 50px; height: 50px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Animaciones para notificaciones */
        @keyframes slideInRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        @keyframes slideOutRight {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
        }

        /* Rich Text Editor - Editor de Texto Enriquecido */
        .rich-text-editor {
            background-color: var(--surface);
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            overflow: hidden;
        }
        
        .rte-toolbar {
            background-color: var(--bg);
            border-bottom: 1px solid var(--border);
            padding: 0.5rem;
            display: flex;
            flex-wrap: wrap;
            gap: 0.25rem;
            align-items: center;
        }
        
        .rte-toolbar-group {
            display: flex;
            gap: 0.25rem;
            padding: 0 0.5rem;
            border-right: 1px solid var(--border);
        }
        
        .rte-toolbar-group:last-child {
            border-right: none;
        }
        
        .rte-btn {
            background-color: transparent;
            border: 1px solid transparent;
            border-radius: 0.25rem;
            padding: 0.4rem 0.6rem;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 0.875rem;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 32px;
            height: 32px;
        }
        
        .rte-btn:hover {
            background-color: var(--surface);
            color: var(--primary);
            border-color: var(--primary);
        }
        
        .rte-btn.active {
            background-color: var(--primary);
            color: var(--bg);
            border-color: var(--primary);
        }
        
        .rte-btn i {
            font-size: 0.875rem;
        }
        
        .rte-select {
            background-color: var(--surface);
            border: 1px solid var(--border);
            border-radius: 0.25rem;
            padding: 0.4rem 0.6rem;
            color: var(--text);
            font-size: 0.875rem;
            cursor: pointer;
            min-width: 100px;
        }
        
        .rte-select:focus {
            outline: none;
            border-color: var(--primary);
        }
        
        .rte-content {
            padding: 1rem;
            min-height: 150px;
            max-height: 400px;
            overflow-y: auto;
            color: var(--text);
            line-height: 1.6;
            font-size: 0.9375rem;
        }
        
        .rte-content:focus {
            outline: none;
        }
        
        .rte-content[contenteditable="true"]:empty:before {
            content: attr(data-placeholder);
            color: var(--text-secondary);
            opacity: 0.5;
        }
        
        .rte-footer {
            background-color: var(--bg);
            border-top: 1px solid var(--border);
            padding: 0.5rem 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        
        .rte-actions {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        
        .rte-voice-btn {
            background-color: var(--surface);
            border: 1px solid var(--border);
            border-radius: 0.375rem;
            padding: 0.5rem 1rem;
            color: var(--text);
            cursor: pointer;
            font-size: 0.875rem;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .rte-voice-btn:hover {
            background-color: var(--surface-light);
            border-color: var(--primary);
            color: var(--primary);
        }
        
        .rte-voice-btn.recording {
            background-color: #ff4136;
            border-color: #ff4136;
            color: white;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .rte-download-btn {
            background-color: var(--primary);
            border: 1px solid var(--primary);
            border-radius: 0.375rem;
            padding: 0.5rem 1rem;
            color: var(--bg);
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 600;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .rte-download-btn:hover {
            background-color: #2ecc11;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(57, 255, 20, 0.3);
        }
        
        .rte-char-count {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }
        
        .rte-voice-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }
        
        .rte-voice-wave {
            width: 4px;
            height: 16px;
            background-color: var(--primary);
            margin: 0 2px;
            animation: wave 1s infinite ease-in-out;
        }
        
        .rte-voice-wave:nth-child(1) { animation-delay: 0s; }
        .rte-voice-wave:nth-child(2) { animation-delay: 0.1s; }
        .rte-voice-wave:nth-child(3) { animation-delay: 0.2s; }
        .rte-voice-wave:nth-child(4) { animation-delay: 0.3s; }
        
        @keyframes wave {
            0%, 100% { height: 8px; }
            50% { height: 20px; }
        }

        /* Daily Journal Styles */
        .daily-journal-day-card {
            background-color: var(--surface);
            border: 1px solid var(--border);
            border-radius: 0.75rem;
            padding: 1.5rem;
            transition: all 0.3s ease;
        }
        
        .daily-journal-day-card:hover {
            border-color: var(--primary);
            box-shadow: 0 4px 12px rgba(57, 255, 20, 0.1);
        }
        
        .daily-journal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            cursor: pointer;
        }
        
        .daily-journal-date {
            font-size: 1.125rem;
            font-weight: 600;
            color: var(--text);
        }
        
        .daily-journal-pl {
            font-size: 1.25rem;
            font-weight: 700;
        }
        
        .daily-journal-pl.positive {
            color: var(--success);
        }
        
        .daily-journal-pl.negative {
            color: var(--danger);
        }
        
        .daily-journal-chart-container {
            height: 120px;
            margin: 1rem 0;
            position: relative;
        }
        
        .daily-journal-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }
        
        .daily-journal-metric {
            text-align: center;
        }
        
        .daily-journal-metric-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 0.25rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .daily-journal-metric-value {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text);
        }
        
        .daily-journal-note-btn {
            padding: 0.5rem 1rem;
            background-color: var(--primary);
            color: var(--bg);
            border: none;
            border-radius: 0.5rem;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .daily-journal-note-btn:hover {
            background-color: #2ecc11;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(57, 255, 20, 0.3);
        }
        
        .daily-journal-note-btn.has-note {
            background-color: var(--surface-light);
            color: var(--primary);
            border: 1px solid var(--primary);
        }
        
        /* Mini Calendar para Daily Journal */
        .daily-journal-mini-calendar {
            user-select: none;
        }
        
        .daily-journal-calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        
        .daily-journal-calendar-month {
            font-weight: 600;
            font-size: 0.95rem;
            color: var(--text);
        }
        
        .daily-journal-calendar-nav {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            transition: color 0.2s;
        }
        
        .daily-journal-calendar-nav:hover {
            color: var(--primary);
        }
        
        .daily-journal-calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 0.25rem;
        }
        
        .daily-journal-calendar-day-header {
            text-align: center;
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--text-secondary);
            padding: 0.25rem;
            text-transform: uppercase;
        }
        
        .daily-journal-calendar-day {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            border-radius: 0.25rem;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        
        .daily-journal-calendar-day:hover {
            background-color: var(--surface-light);
        }
        
        .daily-journal-calendar-day.empty {
            cursor: default;
            color: var(--text-secondary);
            opacity: 0.3;
        }
        
        .daily-journal-calendar-day.today {
            border: 2px solid var(--primary);
            font-weight: 700;
        }
        
        .daily-journal-calendar-day.has-data {
            font-weight: 600;
        }
        
        .daily-journal-calendar-day.has-data.positive {
            background-color: rgba(57, 255, 20, 0.2);
            color: var(--success);
        }
        
        .daily-journal-calendar-day.has-data.negative {
            background-color: rgba(255, 65, 54, 0.2);
            color: var(--danger);
        }
        
        .daily-journal-calendar-day.selected {
            background-color: var(--primary);
            color: var(--bg);
        }

        /* Mini Calendar MÁS PEQUEÑO para Funded Day Panel */
        #funded-day-mini-calendar {
            max-width: 280px;
        }
        
        #funded-day-mini-calendar .daily-journal-calendar-header {
            margin-bottom: 0.4rem;
        }
        
        #funded-day-mini-calendar .daily-journal-calendar-month {
            font-size: 0.7rem;
            font-weight: 500;
        }
        
        #funded-day-mini-calendar .daily-journal-calendar-nav {
            padding: 0.1rem 0.3rem;
            font-size: 0.65rem;
        }
        
        #funded-day-mini-calendar .daily-journal-calendar-grid {
            gap: 0.1rem;
        }
        
        #funded-day-mini-calendar .daily-journal-calendar-day-header {
            font-size: 0.5rem;
            padding: 0.1rem;
        }
        
        #funded-day-mini-calendar .daily-journal-calendar-day {
            font-size: 0.6rem;
            min-height: 28px;
            padding: 0.15rem;
            flex-direction: column;
            gap: 0.1rem;
        }
        
        #funded-day-mini-calendar .daily-journal-calendar-day.today {
            border-width: 1.5px;
        }
        
        #funded-day-mini-calendar .mini-day-number {
            font-size: 0.6rem;
            line-height: 1;
        }
        
        #funded-day-mini-calendar .mini-day-amount {
            font-size: 0.5rem;
            line-height: 1;
            font-weight: 600;
        }

        /* --- Yearly Calendar View --- */
        #yearly-calendar-view {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
        }
        .mini-calendar {
            background-color: var(--surface);
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            padding: 1rem;
        }
        .mini-calendar-header {
            text-align: center;
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: var(--primary);
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .mini-calendar-open-btn {
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            padding: 0.25rem 0.5rem;
            font-size: 0.7rem;
            background-color: transparent;
            color: var(--primary);
            border: 1px solid var(--primary);
            border-radius: 0.25rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .mini-calendar-open-btn:hover {
            background-color: var(--primary);
            color: var(--bg);
        }
        .mini-calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 4px;
            text-align: center;
        }
        .mini-calendar-weekday {
            font-size: 0.75rem;
            color: var(--text-secondary);
            font-weight: 500;
        }
        .mini-calendar-day {
            font-size: 0.8rem;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            position: relative;
        }
        .mini-calendar-day.operated {
            cursor: pointer;
            font-weight: bold;
        }
        .mini-calendar-day.profit {
            background-color: rgba(57, 255, 20, 0.2);
            color: var(--text);
        }
        .mini-calendar-day.profit:hover {
            background-color: rgba(57, 255, 20, 0.4);
        }
        .mini-calendar-day.loss {
            background-color: rgba(255, 65, 54, 0.2);
            color: var(--text);
        }
        .mini-calendar-day.loss:hover {
            background-color: rgba(255, 65, 54, 0.4);
        }

        /* Modals */
        .image-modal { 
            display: none; 
            position: fixed; 
            z-index: 1001; 
            left: 0; 
            top: 0; 
            width: 100%; 
            height: 100%; 
            background-color: rgba(0,0,0,0.98); 
            align-items: center; 
            justify-content: center; 
        }
        
        .image-modal-content {
            max-width: 95vw;
            max-height: 95vh;
            border-radius: 8px;
            object-fit: contain;
            cursor: zoom-in;
            transition: all 0.3s ease;
        }

        .image-modal-content.fullscreen {
            max-width: 100vw !important;
            max-height: 100vh !important;
            width: 100vw;
            height: 100vh;
            border-radius: 0;
            cursor: zoom-out;
            object-fit: contain;
        }

        /* Para asegurar que la imagen se ve a pantalla completa cuando el modal está en fullscreen API */
        .image-modal:fullscreen .image-modal-content,
        .image-modal:-webkit-full-screen .image-modal-content,
        .image-modal:-moz-full-screen .image-modal-content,
        .image-modal:-ms-fullscreen .image-modal-content {
            max-width: 100vw !important;
            max-height: 100vh !important;
            width: 100vw;
            height: 100vh;
        }
        
        .image-modal-close { 
            position: absolute; 
            top: 20px; 
            right: 40px; 
            color: #fff; 
            font-size: 50px; 
            font-weight: bold; 
            cursor: pointer; 
            z-index: 1002;
            transition: all 0.3s;
            background: rgba(0,0,0,0.5);
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }
        
        .image-modal-close:hover {
            background: rgba(255,0,0,0.7);
            transform: rotate(90deg);
        }
        
        .image-modal-nav {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            color: #fff;
            font-size: 60px;
            font-weight: bold;
            cursor: pointer;
            z-index: 1002;
            padding: 20px 25px;
            background: rgba(0,0,0,0.5);
            border-radius: 8px;
            transition: all 0.3s;
            user-select: none;
        }
        
        .image-modal-nav:hover {
            background: rgba(0,0,0,0.8);
            transform: translateY(-50%) scale(1.1);
        }
        
        #image-modal-prev {
            left: 30px;
        }
        
        #image-modal-next {
            right: 30px;
        }
        
        .image-modal-counter {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 18px;
            background: rgba(0,0,0,0.7);
            padding: 10px 25px;
            border-radius: 25px;
            z-index: 1002;
        }
        
        .image-modal-fullscreen-btn {
            position: absolute;
            top: 20px;
            left: 40px;
            color: #fff;
            font-size: 30px;
            cursor: pointer;
            z-index: 1002;
            background: rgba(0,0,0,0.5);
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }
        
        .image-modal-fullscreen-btn:hover {
            background: rgba(0,150,255,0.7);
            transform: scale(1.1);
        }

        #day-detail-modal { background-color: rgba(0,0,0,0.8); }
        #day-detail-modal > div { background-color: var(--surface); border: 1px solid var(--surface-light); }

        /* New Calendar Modal Styles */
        .calendar-day-cell {
            width: 38px;
            height: 38px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
            border: 1px solid transparent;
        }
        .calendar-day-cell:hover {
            background-color: var(--surface-light);
        }
        .calendar-day-cell.today {
            border-color: var(--primary);
        }
        .calendar-day-cell.selected {
            background-color: var(--primary);
            color: var(--background);
            font-weight: bold;
        }
        .calendar-day-cell.in-range {
            background-color: rgba(57, 255, 20, 0.15);
            border-radius: 0;
        }
        .calendar-day-cell.range-start {
            background-color: var(--primary);
            color: var(--background);
            border-top-left-radius: 50%;
            border-bottom-left-radius: 50%;
        }
        .calendar-day-cell.range-end {
            background-color: var(--primary);
            color: var(--background);
            border-top-right-radius: 50%;
            border-bottom-right-radius: 50%;
        }
        .calendar-day-cell.disabled {
            color: var(--text-secondary);
            cursor: not-allowed;
            opacity: 0.5;
        }
        .date-range-preset.active {
            background-color: var(--primary);
            color: var(--background);
            font-weight: bold;
        }

        /* --- NUEVO: Estilo para el modal de detalles de Analytics --- */
        #analytics-detail-modal {
            display: none; /* Oculto por defecto */
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0,0,0,0.9);
            z-index: 1002;
            padding: 2rem;
            overflow-y: auto;
        }
        .analytics-detail-container {
            background-color: var(--background);
            border: 1px solid var(--surface-light);
            border-radius: 0.5rem;
            max-width: 95%;
            margin: 2rem auto;
            padding: 2rem;
        }


        /* --- AUTHENTICATION MODAL STYLES --- */
        .auth-overlay {
            display: flex; /* CAMBIADO: siempre flex, se oculta con clase */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            z-index: 9999;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        
        .auth-overlay.active {
            opacity: 1;
            pointer-events: all;
        }

        .auth-modal {
            background-color: var(--surface);
            border: 1px solid var(--surface-light);
            border-radius: 0.75rem;
            padding: 2rem;
            width: 100%;
            max-width: 400px;
            margin: 1rem;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            transform: scale(0.9);
            transition: transform 0.3s ease;
        }
        
        .auth-overlay.active .auth-modal {
            transform: scale(1);
        }

        .auth-tabs {
            display: flex;
            margin-bottom: 2rem;
            border-bottom: 1px solid var(--surface-light);
        }

        .auth-tab {
            flex: 1;
            padding: 0.75rem 1rem;
            text-align: center;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            color: var(--text-secondary);
            transition: all 0.2s ease;
            font-weight: 500;
        }

        .auth-tab.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
        }

        .auth-tab:hover:not(.active) {
            color: var(--text);
        }

        .auth-form {
            display: none;
        }

        .auth-form.active {
            display: block;
        }

        .auth-input {
            width: 100%;
            padding: 0.75rem 1rem;
            background-color: var(--background);
            border: 1px solid var(--surface-light);
            border-radius: 0.5rem;
            color: var(--text);
            font-size: 1rem;
            transition: all 0.2s ease;
            margin-bottom: 1rem;
        }

        .auth-input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(57, 255, 20, 0.1);
        }

        .auth-input::placeholder {
            color: var(--text-secondary);
        }

        .auth-button {
            width: 100%;
            padding: 0.75rem 1rem;
            background-color: var(--primary);
            color: var(--background);
            border: none;
            border-radius: 0.5rem;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-bottom: 1rem;
        }

        .auth-button:hover {
            background-color: var(--secondary);
        }

        .auth-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .auth-error {
            background-color: rgba(255, 65, 54, 0.1);
            border: 1px solid var(--red);
            color: var(--red);
            padding: 0.75rem;
            border-radius: 0.5rem;
            margin-bottom: 1rem;
            font-size: 0.875rem;
        }

        .auth-success {
            background-color: rgba(57, 255, 20, 0.1);
            border: 1px solid var(--primary);
            color: var(--primary);
            padding: 0.75rem;
            border-radius: 0.5rem;
            margin-bottom: 1rem;
            font-size: 0.875rem;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            color: var(--text);
            font-size: 0.875rem;
        }

        .user-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background-color: var(--primary);
            color: var(--background);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 0.875rem;
        }

        .logout-button {
            padding: 0.5rem 1rem;
            background-color: var(--surface);
            border: 1px solid var(--surface-light);
            color: var(--text);
            border-radius: 0.375rem;
            cursor: pointer;
            font-size: 0.875rem;
            transition: all 0.2s ease;
        }

        .logout-button:hover {
            background-color: var(--surface-light);
            border-color: var(--primary);
        }

        .app-hidden {
            display: none !important;
        }

        /* --- STREAMER MODE STYLES (Scoped to accounts) --- */
        #accounts.streamer-mode-active .hide-amount,
        #finances.streamer-mode-active .hide-amount {
            filter: blur(6px);
            transition: filter 0.3s ease;
        }
        .hide-amount {
            transition: filter 0.3s ease;
        }

        /* Ocultar cartel molesto de sincronización de BingX */
        #bingx-connection-status {
            display: none !important;
        }
        /* --- END: AUTHENTICATION STYLES --- */

        /* --- AUDICION PUBLICA STYLES --- */
        .public-link-card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .public-link-input-group {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            margin-bottom: 1rem;
        }

        .public-link-input {
            flex: 1;
            padding: 0.75rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 0.375rem;
            color: var(--text);
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }

        .copy-link-btn {
            padding: 0.75rem 1.5rem;
            background: var(--primary);
            color: var(--bg);
            border: none;
            border-radius: 0.375rem;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }

        .copy-link-btn:hover {
            background: var(--secondary);
            transform: translateY(-1px);
        }

        .audicion-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .audicion-option-card {
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 0.375rem;
            padding: 1rem;
        }

        .audicion-option-card label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            color: var(--text);
            cursor: pointer;
        }

        .audicion-option-card input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .public-view-badge {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            background: var(--primary);
            color: var(--bg);
            border-radius: 50px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-left: 0.5rem;
        }

        /* === PRIVACY SWITCH - DISEÑO PROFESIONAL === */
        #audicion-privacy-settings-btn {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        #audicion-privacy-settings-btn:hover {
            background: rgba(148, 163, 184, 0.15) !important;
            border-color: rgba(148, 163, 184, 0.6) !important;
            color: #fff !important;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        #audicion-privacy-settings-btn:active {
            transform: translateY(0);
        }
        
        .privacy-switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 24px;
            flex-shrink: 0;
        }

        .privacy-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .privacy-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(100, 100, 100, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 24px;
        }

        .privacy-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 2px;
            background-color: white;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .privacy-switch input:checked + .privacy-slider {
            background: linear-gradient(135deg, #39ff14, #28e000);
            border-color: #39ff14;
            box-shadow: 0 0 8px rgba(57, 255, 20, 0.3);
        }

        .privacy-switch input:checked + .privacy-slider:before {
            transform: translateX(20px);
        }

        .privacy-switch input:focus + .privacy-slider {
            box-shadow: 0 0 0 3px rgba(57, 255, 20, 0.1);
        }

        /* === ANIMACIONES PROFESIONALES === */
        @keyframes fadeInScale {
            from {
                opacity: 0;
                transform: scale(0.95);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.8;
            }
        }

        /* Animación de hover en tarjetas */
        .metric-card {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .metric-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
        }

        /* Números animados */
        .animate-number {
            animation: slideUp 0.5s ease-out;
        }

        /* Vista pública - Ocultar controles de edición */
        .public-audicion-view .edit-trade-btn,
        .public-audicion-view .delete-trade-btn,
        .public-audicion-view .add-operation-btn,
        .public-audicion-view .sidebar,
        .public-audicion-view .top-bar,
        .public-audicion-view #auth-modal,
        .public-audicion-view [data-target]:not([data-target="audicion"]) {
            display: none !important;
        }

        .public-audicion-view .main-content {
            margin-left: 0 !important;
            width: 100% !important;
        }

        .public-audicion-view #audicion-section {
            display: block !important;
        }
        
        .public-audicion-view #audicion {
            display: block !important;
        }

        /* Modal para generar enlace público */
        .public-link-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .public-link-modal.active {
            display: flex;
        }

        .public-link-modal-content {
            background: var(--surface);
            border-radius: 0.5rem;
            padding: 2rem;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }

        .public-link-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .public-link-modal-header h3 {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--text);
        }

        .close-modal-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            transition: color 0.2s;
        }

        .close-modal-btn:hover {
            color: var(--primary);
        }

        /* --- END: AUDICION PUBLICA STYLES --- */

        /* --- OPERATIONS METRICS STYLES --- */
        .circular-chart {
            display: block;
            max-width: 100%;
            max-height: 100%;
        }

        .circular-chart .circle {
            transition: stroke-dasharray 0.5s ease;
            transform: rotate(-90deg);
            transform-origin: center;
        }

        .circular-chart .percentage {
            font-weight: bold;
            font-family: 'Segoe UI', sans-serif;
        }

        /* Metric card icon/badge styling */
        .metric-card .metric-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            border-radius: 8px;
            font-size: 16px;
        }

        .metric-card .metric-legend {
            font-size: 12px;
            color: var(--text-secondary);
        }
        /* --- END: OPERATIONS METRICS STYLES --- */

        /* --- OPERATION DETAIL TABS STYLES --- */
        .notes-tab-btn, .images-tab-btn, .analytics-detail-tab-btn {
            transition: all 0.2s ease;
        }
        
        .notes-tab-btn.active, .images-tab-btn.active, .analytics-detail-tab-btn.active {
            background-color: var(--primary);
            color: #000;
        }
        
        .notes-tab-content, .analytics-detail-tab-content {
            display: block;
        }
        
        .notes-tab-content.hidden, .images-tab-content.hidden {
            display: none;
        }
        
        .images-tab-content.active, .notes-tab-content.active {
            display: block;
        }
        
        #drop-zone {
            transition: all 0.2s ease;
        }
        
        #drop-zone:hover {
            border-color: var(--primary);
            background-color: rgba(16, 185, 129, 0.05);
        }
        
        #drop-zone.drag-over {
            border-color: var(--primary);
            background-color: rgba(16, 185, 129, 0.1);
        }
        /* --- END: OPERATION DETAIL TABS STYLES --- */

        .informe-sub-section-container {
            display: none;
        }
        .informe-sub-section-container.active {
            display: block;
        }

        /* TradingView Chart Styles */
        #tradingview-chart-container {
            background: #1e1e1e;
            border: 1px solid #333;
        }

        #tradingview-widget-detail {
            background: #1e1e1e;
        }

        #tradingview-loading-detail {
            background: rgba(30, 30, 30, 0.9);
        }

        .trade-marker {
            position: absolute;
            z-index: 1000;
            font-size: 18px;
            pointer-events: none;
        }

        .entry-marker {
            color: #00ff88;
        }

        .exit-marker {
            color: #ff4444;
        }

        /* Toast Notifications Animations */
        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }

        .toast-notification {
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: var(--surface);
            border-radius: 8px;
            padding: 2rem;
            max-width: 800px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
        }

        /* PDF Report Option Cards */
        .pdf-report-option {
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .pdf-report-option:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(57, 255, 20, 0.2);
        }
        
        .pdf-report-option.active {
            border-color: var(--primary) !important;
            background: rgba(57, 255, 20, 0.05) !important;
        }

        /* Rating Stars */
        #setup-rating-selector .star {
            cursor: pointer;
            font-size: 2rem;
            transition: all 0.2s ease;
            opacity: 0.3;
            display: inline-block;
        }

        #setup-rating-selector .star:hover {
            opacity: 1;
        }

        /* Chartbook & Playbook specific */
        .line-clamp-3 {
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        /* ===== EDITOR DE NOTAS AVANZADAS ===== */
        #funded-day-notes-editor,
        #finance-notes-editor {
            min-height: 400px;
            line-height: 1.6;
        }

        #funded-day-notes-editor:empty:before,
        #finance-notes-editor:empty:before {
            content: attr(placeholder);
            color: var(--text-secondary);
            font-style: italic;
        }

        #funded-day-notes-editor:focus,
        #finance-notes-editor:focus {
            outline: none;
        }

        /* Estilos para el contenido del editor */
        #funded-day-notes-editor h1,
        #finance-notes-editor h1 {
            font-size: 2rem;
            font-weight: bold;
            margin: 1rem 0;
        }

        #funded-day-notes-editor h2,
        #finance-notes-editor h2 {
            font-size: 1.5rem;
            font-weight: bold;
            margin: 0.875rem 0;
        }

        #funded-day-notes-editor h3,
        #finance-notes-editor h3 {
            font-size: 1.25rem;
            font-weight: bold;
            margin: 0.75rem 0;
        }

        #funded-day-notes-editor p,
        #finance-notes-editor p {
            margin: 0.5rem 0;
        }

        #funded-day-notes-editor ul,
        #funded-day-notes-editor ol,
        #finance-notes-editor ul,
        #finance-notes-editor ol {
            margin: 0.5rem 0;
            padding-left: 2rem;
        }

        #funded-day-notes-editor a,
        #finance-notes-editor a {
            color: var(--primary);
            text-decoration: underline;
        }

        #funded-day-notes-editor a:hover,
        #finance-notes-editor a:hover {
            color: var(--secondary);
        }

        /* Vista de solo lectura de notas */
        #notes-display {
            line-height: 1.6;
        }

        #notes-display h1 {
            font-size: 2rem;
            font-weight: bold;
            margin: 1rem 0;
        }

        #notes-display h2 {
            font-size: 1.5rem;
            font-weight: bold;
            margin: 0.875rem 0;
        }

        #notes-display h3 {
            font-size: 1.25rem;
            font-weight: bold;
            margin: 0.75rem 0;
        }

        #notes-display p {
            margin: 0.5rem 0;
        }

        #notes-display ul,
        #notes-display ol {
            margin: 0.5rem 0;
            padding-left: 2rem;
        }

        #notes-display a {
            color: var(--primary);
            text-decoration: underline;
        }

        #notes-display a:hover {
            color: var(--secondary);
        }

        /* Scrollbar personalizado para el editor */
        #funded-day-notes-editor::-webkit-scrollbar {
            width: 8px;
        }

        #funded-day-notes-editor::-webkit-scrollbar-track {
            background: var(--surface);
        }

        #funded-day-notes-editor::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }

        #funded-day-notes-editor::-webkit-scrollbar-thumb:hover {
            background: var(--primary);
        }
        
        /* ===== ESTILOS PARA VISTA PÚBLICA DE AUDICIÓN ===== */
        .public-audicion-view .sidebar,
        .public-audicion-view aside {
            display: none !important;
        }
        
        .public-audicion-view .top-bar,
        .public-audicion-view .main-header,
        .public-audicion-view #main-header {
            display: none !important;
        }
        
        .public-audicion-view .section-container:not(#audicion) {
            display: none !important;
        }
        
        .public-audicion-view #audicion {
            display: block !important;
            padding: 0 !important;
            margin: 0 !important;
        }
        
        .public-audicion-view .main-content {
            margin-left: 0 !important;
            width: 100% !important;
            padding-top: 0 !important;
            padding: 0 !important;
        }
        
        .public-audicion-view .section-container {
            padding: 0 !important;
            margin: 0 !important;
        }
        
        /* Header público de audición */
        .public-audicion-header {
            display: none;
            background: var(--background);
            border-bottom: 1px solid var(--border);
            padding: 1.5rem 2rem;
            position: sticky;
            top: 0;
            z-index: 100;
        }
        
        .public-audicion-view .public-audicion-header {
            display: flex !important;
            align-items: center;
            gap: 0.1rem;
        }
        
        .public-audicion-header .logo-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        
        .public-audicion-header .logo-text {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--text);
            white-space: nowrap;
            margin-left: -15px;
        }
        
        /* Ocultar botón compartir en vista pública */
        .public-audicion-view #audicion-public-link-section,
        .public-audicion-view #share-audicion-btn,
        .public-audicion-view #copy-audicion-link {
            display: none !important;
        }
        
        /* Ocultar filtros y selectores en vista pública */
        .public-audicion-view #audicion-filter-dates-btn,
        .public-audicion-view #audicion-filter-dates-btn-header,
        .public-audicion-view #audicion-account-select {
            display: none !important;
        }
        
        /* Header público con logo y botón de registro */
        #public-header {
            display: none;
            background: linear-gradient(180deg, #0a0a0a 0%, #000000 100%);
            border-bottom: 1px solid var(--border);
            padding: 1rem 2rem;
            position: sticky;
            top: 0;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .public-audicion-view #public-header {
            display: flex !important;
            justify-content: space-between;
            align-items: center;
        }

        #public-header .logo-container {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        #public-header .logo-icon {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            box-shadow: 0 0 20px rgba(57, 255, 20, 0.3);
        }

        #public-header .logo-text {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--text);
            letter-spacing: -0.5px;
        }

        #public-header .register-btn {
            background: var(--primary);
            color: var(--background);
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-weight: 600;
            text-decoration: none;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(57, 255, 20, 0.3);
        }

        #public-header .register-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(57, 255, 20, 0.4);
            background: var(--secondary);
        }
        
        /* Ocultar modal de autenticación en vista pública */
        .public-audicion-view #auth-modal {
            display: none !important;
        }
        
        /* Header público */
        #public-header {
            display: none;
            background: linear-gradient(135deg, #0a0a0a 0%, #000000 100%);
            border-bottom: 2px solid var(--primary);
            padding: 1.5rem 2rem;
            position: sticky;
            top: 0;
            z-index: 1000;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(57, 255, 20, 0.1);
        }
        
        .public-audicion-view #public-header {
            display: flex !important;
            justify-content: space-between;
            align-items: center;
        }
        
        #public-header .logo-section {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        #public-header .logo-icon {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #39ff14 0%, #00ff88 100%);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            box-shadow: 0 4px 15px rgba(57, 255, 20, 0.3);
        }
        
        #public-header .logo-text {
            font-size: 1.25rem;
            font-weight: 700;
            background: linear-gradient(135deg, #39ff14 0%, #00ff88 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        #public-header .register-btn {
            background: linear-gradient(135deg, #39ff14 0%, #00ff88 100%);
            color: #000;
            padding: 0.75rem 2rem;
            border-radius: 10px;
            font-weight: 700;
            text-decoration: none;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            box-shadow: 0 4px 15px rgba(57, 255, 20, 0.4);
            border: none;
            cursor: pointer;
        }
        
        #public-header .register-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(57, 255, 20, 0.5);
        }
        
        #public-header .home-btn {
            background: transparent;
            color: var(--text);
            padding: 0.75rem 1.5rem;
            border-radius: 10px;
            font-weight: 600;
            text-decoration: none;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            border: 2px solid var(--border);
        }
        
        #public-header .home-btn:hover {
            background: var(--surface-light);
            border-color: var(--primary);
            color: var(--primary);
        }
        
        #public-header .public-header-actions {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
            border-radius: 10px;
            font-weight: 700;
            font-size: 0.95rem;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(57, 255, 20, 0.3);
            border: none;
            cursor: pointer;
        }
        
        #public-header .register-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(57, 255, 20, 0.4);
        }

        /* ===== SWITCH / TOGGLE STYLES ===== */
        .switch {
            position: relative;
            display: inline-block;
            width: 48px;
            height: 24px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--border);
            transition: .4s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: var(--primary);
        }

        input:checked + .slider:before {
            transform: translateX(24px);
        }

        /* ===== SOCIAL MEDIA STYLES ===== */
        #social-media-leaderboard tbody tr:hover {
            background-color: var(--surface-light);
            cursor: pointer;
        }

        .trader-rank {
            font-weight: 700;
            font-size: 1.25rem;
            color: var(--text-secondary);
        }

        .trader-info {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .trader-avatar {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary), var(--accent));
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 700;
            font-size: 1.25rem;
            flex-shrink: 0;
            overflow: hidden;
        }

        .trader-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .trader-details {
            display: flex;
            flex-direction: column;
        }

        .trader-name {
            font-weight: 600;
            font-size: 0.9375rem;
        }

        .trader-location {
            font-size: 0.8125rem;
            color: var(--text-secondary);
        }

        .trader-stars {
            color: #fbbf24;
            font-size: 0.875rem;
        }

        .metric-positive {
            color: #10b981;
            font-weight: 600;
        }

        .metric-negative {
            color: #ef4444;
            font-weight: 600;
        }

        .metric-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* ===== SOCIAL MEDIA STYLES ===== */
        .social-tab-content {
            display: none;
        }
        
        .social-tab-content.active {
            display: block;
        }

        /* Trader Card en Following List */
        .trader-following-card {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem;
            background: var(--surface-light);
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            transition: all 0.2s;
            cursor: pointer;
        }

        .trader-following-card:hover {
            border-color: var(--primary);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .trader-following-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary), var(--accent));
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 700;
            font-size: 1rem;
            flex-shrink: 0;
            overflow: hidden;
        }

        .trader-following-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* Activity Feed Item */
        .activity-item {
            padding: 1rem;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            transition: all 0.2s;
        }

        .activity-item:hover {
            border-color: var(--primary);
            box-shadow: 0 2px 8px rgba(57, 255, 20, 0.1);
        }

        .activity-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.75rem;
        }

        .activity-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary), var(--accent));
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 700;
            font-size: 0.875rem;
            flex-shrink: 0;
        }

        .activity-time {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .activity-trade-card {
            padding: 0.75rem;
            background: var(--background);
            border: 1px solid var(--border);
            border-radius: 0.375rem;
            margin-top: 0.5rem;
        }

        /* Group Card */
        .group-card {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem;
            background: var(--surface-light);
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            transition: all 0.2s;
            cursor: pointer;
        }

        .group-card:hover {
            border-color: var(--primary);
            transform: translateX(4px);
        }

        .group-card.active {
            background: rgba(57, 255, 20, 0.1);
            border-color: var(--primary);
        }

        .group-avatar {
            width: 40px;
            height: 40px;
            background: var(--surface);
            border-radius: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            flex-shrink: 0;
        }

        .group-unread-badge {
            min-width: 20px;
            height: 20px;
            background: var(--red);
            color: white;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            font-weight: 700;
            padding: 0 0.35rem;
        }

        /* Chat Messages */
        .chat-message {
            display: flex;
            gap: 0.75rem;
            margin-bottom: 1rem;
            animation: messageSlideIn 0.2s ease;
        }

        @keyframes messageSlideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .chat-message.own {
            flex-direction: row-reverse;
        }

        .chat-message-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary), var(--accent));
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 700;
            font-size: 0.75rem;
            flex-shrink: 0;
        }

        .chat-message-content {
            max-width: 70%;
        }

        .chat-message-bubble {
            padding: 0.75rem 1rem;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 1rem;
            word-wrap: break-word;
        }

        .chat-message.own .chat-message-bubble {
            background: var(--primary);
            color: var(--background);
            border-color: var(--primary);
        }

        .chat-message-image {
            max-width: 100%;
            border-radius: 0.5rem;
            margin-top: 0.5rem;
            cursor: pointer;
            transition: transform 0.2s;
            border: none;
        }

        .chat-message-image:hover {
            transform: scale(1.02);
        }

        .chat-message-meta {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.25rem;
            font-size: 0.7rem;
            color: var(--text-secondary);
        }

        .chat-message.own .chat-message-meta {
            justify-content: flex-end;
        }

        /* Member Card */
        .member-card {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem;
            background: var(--surface-light);
            border: 1px solid var(--border);
            border-radius: 0.5rem;
        }

        .member-info {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .member-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary), var(--accent));
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 700;
            font-size: 0.875rem;
            flex-shrink: 0;
        }

        .member-role-badge {
            padding: 0.2rem 0.5rem;
            background: var(--primary);
            color: var(--background);
            border-radius: 0.25rem;
            font-size: 0.65rem;
            font-weight: 700;
            text-transform: uppercase;
        }

        /* Trader Item para invitar */
        .trader-invite-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem;
            background: var(--surface-light);
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .invite-btn {
            padding: 0.4rem 0.8rem;
            background: var(--primary);
            color: var(--background);
            border: none;
            border-radius: 0.375rem;
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .invite-btn:hover {
            background: var(--secondary);
            transform: scale(1.05);
        }

        .invite-btn:disabled {
            background: var(--surface-light);
            color: var(--text-secondary);
            cursor: not-allowed;
            transform: none;
        }

        /* Public Group Card */
        .public-group-card {
            padding: 0.75rem;
            background: var(--surface-light);
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            margin-bottom: 0.5rem;
            transition: all 0.2s;
        }

        .public-group-card:hover {
            border-color: var(--primary);
            transform: translateX(4px);
        }

        .join-group-btn {
            width: 100%;
            padding: 0.5rem;
            background: var(--primary);
            color: var(--background);
            border: none;
            border-radius: 0.375rem;
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 0.5rem;
        }

        .join-group-btn:hover {
            background: var(--secondary);
        }

        /* Scrollbar para chat */
        #group-messages-container::-webkit-scrollbar {
            width: 6px;
        }

        #group-messages-container::-webkit-scrollbar-track {
            background: var(--background);
        }

        #group-messages-container::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 3px;
        }

        #group-messages-container::-webkit-scrollbar-thumb:hover {
            background: var(--primary);
        }

        /* Follow Button */
        .follow-btn {
            padding: 0.4rem 1rem;
            background: transparent;
            color: var(--primary);
            border: 1px solid var(--primary);
            border-radius: 0.375rem;
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .follow-btn:hover {
            background: var(--primary);
            color: var(--background);
        }

        .follow-btn.following {
            background: var(--primary);
            color: var(--background);
        }

        .follow-btn.following:hover {
            background: var(--red);
            border-color: var(--red);
        }

        /* ===== OPERATIONS VIEW STYLES ===== */
        .operations-view-content {
            animation: fadeIn 0.3s ease-in-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Heatmap Styles */
        .heatmap-table td {
            padding: 16px;
            text-align: center;
            border: 1px solid var(--border);
            transition: all 0.2s ease;
            cursor: pointer;
            min-width: 90px;
            font-size: 0.875rem;
            font-weight: 500;
        }

        .heatmap-table td:first-child {
            text-align: left;
            font-weight: 600;
            background: var(--surface);
        }

        .heatmap-table td:hover:not(:first-child) {
            transform: scale(1.05);
            z-index: 10;
            box-shadow: 0 0 20px rgba(57, 255, 20, 0.3);
        }

        .heatmap-cell-data {
            display: flex;
            flex-direction: column;
            gap: 4px;
            align-items: center;
        }

        .heatmap-value {
            font-size: 1rem;
            font-weight: 700;
        }

        .heatmap-count {
            font-size: 0.7rem;
            opacity: 0.7;
        }

        /* Instrument & Setup Group Styles */
        .group-item {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .group-item:hover {
            border-color: var(--primary);
            box-shadow: 0 0 20px rgba(57, 255, 20, 0.1);
        }

        .group-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1.25rem 1.5rem;
            cursor: pointer;
            user-select: none;
            background: linear-gradient(135deg, var(--surface) 0%, var(--surface-light) 100%);
        }

        .group-header:hover {
            background: linear-gradient(135deg, var(--surface-light) 0%, var(--surface) 100%);
        }

        .group-header-left {
            display: flex;
            align-items: center;
            gap: 1rem;
        }



        .group-info h4 {
            font-size: 1.125rem;
            font-weight: 700;
            margin-bottom: 0.25rem;
        }

        .group-info .group-subtitle {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .group-stats {
            display: flex;
            gap: 2rem;
            align-items: center;
        }

        .group-stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.25rem;
        }

        .group-stat-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .group-stat-value {
            font-size: 1.25rem;
            font-weight: 700;
        }

        .group-expand-icon {
            font-size: 0.875rem;
            transition: transform 0.3s ease;
            color: var(--text-secondary);
            display: inline-block;
        }

        .group-item.expanded .group-expand-icon {
            transform: rotate(180deg);
        }

        .group-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease;
        }

        .group-item.expanded .group-content {
            max-height: 2000px;
            border-top: 1px solid var(--border);
        }

        .group-details {
            padding: 1.5rem;
        }

        .group-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .group-metric-card {
            background: var(--background);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 1rem;
            text-align: center;
        }

        .group-metric-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        .group-metric-value {
            font-size: 1.5rem;
            font-weight: 700;
        }

        .group-trades-list {
            margin-top: 1rem;
        }

        .group-trades-header {
            font-size: 0.875rem;
            font-weight: 600;
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
        }

        .mini-trade-row {
            display: grid;
            grid-template-columns: 120px 100px 1fr 100px 100px;
            gap: 1rem;
            padding: 0.75rem;
            border-bottom: 1px solid var(--border);
            font-size: 0.875rem;
            transition: background 0.2s ease;
        }

        .mini-trade-row:hover {
            background: rgba(57, 255, 20, 0.05);
        }

        .mini-trade-row:last-child {
            border-bottom: none;
        }

        /* ===== PROFESSIONAL COMPONENTS ===== */
        /* Key Metrics Panel */
        .key-metrics-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: linear-gradient(135deg, var(--surface) 0%, var(--background) 100%);
            border: 1px solid var(--border);
            border-radius: 8px;
        }

        .key-metric {
            text-align: center;
            padding: 1rem;
            background: var(--background);
            border-radius: 6px;
            border: 1px solid var(--border);
        }

        .key-metric-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
        }

        .key-metric-value {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 0.25rem;
        }

        .key-metric-trend {
            font-size: 0.875rem;
            font-weight: 600;
        }

        /* Professional Badges */
        .badge {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .badge-success {
            background: rgba(57, 255, 20, 0.1);
            color: var(--green);
            border: 1px solid var(--green);
        }

        .badge-danger {
            background: rgba(255, 65, 54, 0.1);
            color: var(--red);
            border: 1px solid var(--red);
        }

        .badge-warning {
            background: rgba(245, 158, 11, 0.1);
            color: var(--yellow);
            border: 1px solid var(--yellow);
        }

        .badge-neutral {
            background: rgba(160, 160, 160, 0.1);
            color: var(--text-secondary);
            border: 1px solid var(--border);
        }

        /* Progress Bars */
        .progress-bar-container {
            width: 100%;
            height: 8px;
            background: var(--surface-light);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 0.5rem;
        }

        .progress-bar-fill {
            height: 100%;
            transition: width 0.6s ease;
            border-radius: 4px;
        }

        .progress-bar-success {
            background: linear-gradient(90deg, var(--green) 0%, #28e000 100%);
        }

        .progress-bar-danger {
            background: linear-gradient(90deg, var(--red) 0%, #cc3429 100%);
        }

        .progress-bar-warning {
            background: linear-gradient(90deg, var(--yellow) 0%, #d97706 100%);
        }

        /* Insight Cards */
        .insight-card {
            background: var(--surface);
            border-left: 4px solid var(--primary);
            padding: 1rem 1.25rem;
            border-radius: 6px;
            margin-bottom: 1rem;
        }

        .insight-card.success {
            border-left-color: var(--green);
            background: linear-gradient(90deg, rgba(57, 255, 20, 0.05) 0%, var(--surface) 100%);
        }

        .insight-card.danger {
            border-left-color: var(--red);
            background: linear-gradient(90deg, rgba(255, 65, 54, 0.05) 0%, var(--surface) 100%);
        }

        .insight-card.warning {
            border-left-color: var(--yellow);
            background: linear-gradient(90deg, rgba(245, 158, 11, 0.05) 0%, var(--surface) 100%);
        }

        .insight-title {
            font-size: 0.875rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
        }

        .insight-content {
            font-size: 0.95rem;
            line-height: 1.5;
            color: var(--text);
        }

        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }

        .stat-box {
            background: var(--background);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 1rem;
            text-align: center;
            transition: all 0.2s ease;
        }

        .stat-box:hover {
            border-color: var(--primary);
            transform: translateY(-2px);
        }

        .stat-label {
            font-size: 0.7rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
        }

        .stat-subvalue {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-top: 0.25rem;
        }

        /* Hot/Cold Zone Indicators */
        .zone-indicator {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: var(--surface);
            border-radius: 6px;
            border: 1px solid var(--border);
        }

        .zone-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .zone-dot.hot {
            background: var(--green);
            box-shadow: 0 0 8px var(--green);
        }

        .zone-dot.cold {
            background: var(--red);
            box-shadow: 0 0 8px var(--red);
        }

        /* Score Circle */
        .score-circle {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: 700;
            border: 3px solid;
            margin: 0 auto;
        }

        .score-circle.excellent {
            border-color: var(--green);
            background: rgba(57, 255, 20, 0.1);
            color: var(--green);
        }

        .score-circle.good {
            border-color: #28e000;
            background: rgba(40, 224, 0, 0.1);
            color: #28e000;
        }

        .score-circle.average {
            border-color: var(--yellow);
            background: rgba(245, 158, 11, 0.1);
            color: var(--yellow);
        }

        .score-circle.poor {
            border-color: var(--red);
            background: rgba(255, 65, 54, 0.1);
            color: var(--red);
        }

        /* Comparison Indicator */
        .comparison-indicator {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.875rem;
            font-weight: 600;
        }

        .comparison-indicator.up {
            color: var(--green);
        }

        .comparison-indicator.down {
            color: var(--red);
        }

        .comparison-indicator.neutral {
            color: var(--text-secondary);
        }

        .arrow-up::before {
            content: '↗';
            margin-right: 0.25rem;
        }

        .arrow-down::before {
            content: '↘';
            margin-right: 0.25rem;
        }

        .arrow-neutral::before {
            content: '→';
            margin-right: 0.25rem;
        }
    </style>
```
</head>
<body>
    <!-- ===== HEADER SUPERIOR ===== -->
    <header class="main-header">
        <div class="header-right">
            <!-- Selector de Cuenta Principal (Multi-Select) -->
            <div class="flex items-center gap-3">
                <div id="main-account-logo" class="w-14 h-14 rounded-xl flex items-center justify-center" style="display: none;">
                    <img id="main-account-logo-img" src="" alt="" class="w-14 h-14 rounded-xl object-contain">
                </div>
                <div class="multi-select-container">
                    <div class="multi-select-trigger" id="main-account-trigger">
                        <span id="main-account-display">Seleccionar cuenta</span>
                        <i class="fas fa-chevron-down chevron"></i>
                    </div>
                    <div class="multi-select-dropdown" id="main-account-dropdown">
                        <!-- Opciones se cargarán dinámicamente -->
                    </div>
                </div>
                <!-- Mantener el select oculto para compatibilidad -->
                <select id="main-account-select" class="w-48" style="display: none;">
                    <option value="">Seleccionar cuenta</option>
                </select>
            </div>
            
            <!-- Usuario Menu -->
            <div style="position: relative; margin-left: 1rem;">
                <button id="user-menu-toggle" class="user-menu-toggle">
                    <div id="header-user-avatar" class="user-avatar">D</div>
                    <span id="header-user-email" style="font-size: 0.875rem; color: var(--text-secondary);"></span>
                    <i class="fas fa-chevron-down" style="font-size: 0.75rem; color: var(--text-secondary);"></i>
                </button>
                
                <!-- Dropdown Menu -->
                <div id="user-dropdown-menu" class="user-dropdown" style="display: none;">
                    <a href="#" id="header-config-btn">
                        <i class="fas fa-cog"></i>Configuración
                    </a>
                    <a href="#" id="header-logout-btn" class="logout-link">
                        <i class="fas fa-sign-out-alt"></i>Cerrar Sesión
                    </a>
                </div>
            </div>
        </div>
    </header>

    <!-- ===== SIDEBAR LATERAL ===== -->
    <aside class="sidebar" id="sidebar">
        <!-- Logo -->
        <div class="sidebar-logo">
            <div class="logo-icon" style="margin-right: 0px;">
                <img src="logos/traders-survivor-logo.png" alt="Trading Survivor" style="width: 80px; height: 80px; object-fit: contain; filter: drop-shadow(0 0 1px rgba(57, 255, 20, 0.4));">
            </div>
            <span class="logo-text">Trading Survivor</span>
        </div>

        <!-- Toggle Button -->
        <div class="sidebar-toggle" id="sidebarToggle">
            <i class="fas fa-bars"></i>
            <span>Contraer</span>
        </div>

        <!-- Navigation Menu -->
        <nav class="sidebar-nav">
            <!-- Main Sections -->
            <div class="nav-section">
                <div class="nav-section-title">Principal</div>
                <div class="nav-item active" data-target="dashboard">
                    <i class="fas fa-chart-line"></i>
                    <span class="nav-item-text">Dashboard</span>
                </div>
                <div class="nav-item" data-target="analytics">
                    <i class="fas fa-chart-pie"></i>
                    <span class="nav-item-text">Analytics</span>
                </div>
                <div class="nav-item" data-target="informe">
                    <i class="fas fa-file-alt"></i>
                    <span class="nav-item-text">Informe</span>
                </div>
                <div class="nav-item" data-target="daily-journal">
                    <i class="fas fa-book"></i>
                    <span class="nav-item-text">Daily Journal</span>
                </div>
                <div class="nav-item" data-target="calendar">
                    <i class="fas fa-calendar"></i>
                    <span class="nav-item-text">Calendario</span>
                </div>
                <div class="nav-item" data-target="equity-graph">
                    <i class="fas fa-chart-area"></i>
                    <span class="nav-item-text">Equity Graph</span>
                </div>
            </div>

            <!-- Trading Section -->
            <div class="nav-section">
                <div class="nav-section-title">Trading</div>
                <div class="nav-item" data-target="operations">
                    <i class="fas fa-exchange-alt"></i>
                    <span class="nav-item-text">Operaciones</span>
                </div>
                <div class="nav-item" data-target="chartbook">
                    <i class="fas fa-chart-area"></i>
                    <span class="nav-item-text">Chartbook</span>
                </div>
                <div class="nav-item" data-target="playbook">
                    <i class="fas fa-book-open"></i>
                    <span class="nav-item-text">Playbook</span>
                </div>
                <div class="nav-item" data-target="notebook">
                    <i class="fas fa-sticky-note"></i>
                    <span class="nav-item-text">Notebook</span>
                </div>
            </div>

            <!-- Funded Section -->
            <div class="nav-section">
                <div class="nav-section-title">Funded</div>
                <div class="nav-item" data-target="funded">
                    <i class="fas fa-trophy"></i>
                    <span class="nav-item-text">Funded</span>
                </div>
                <div class="nav-item" data-target="finances">
                    <i class="fas fa-dollar-sign"></i>
                    <span class="nav-item-text">Finanzas</span>
                </div>
            </div>

            <!-- Audición Section -->
            <div class="nav-section">
                <div class="nav-section-title">Audición</div>
                <div class="nav-item" data-target="audicion">
                    <i class="fas fa-star"></i>
                    <span class="nav-item-text">Audición</span>
                </div>
                <div class="nav-item" data-target="social-media">
                    <i class="fas fa-users"></i>
                    <span class="nav-item-text">Social Media</span>
                </div>
            </div>

            <!-- Cuentas Section -->
            <div class="nav-section">
                <div class="nav-section-title">Cuentas</div>
                <div class="nav-item" data-target="accounts">
                    <i class="fas fa-university"></i>
                    <span class="nav-item-text">Cuentas</span>
                </div>
                <div class="nav-item" data-target="platforms">
                    <i class="fas fa-plug"></i>
                    <span class="nav-item-text">Plataformas</span>
                </div>
            </div>

            <!-- Tools Section -->
            <div class="nav-section">
                <div class="nav-section-title">Herramientas</div>
                <div class="nav-item" data-target="news">
                    <i class="fas fa-newspaper"></i>
                    <span class="nav-item-text">Noticias</span>
                </div>
                <div class="nav-item" data-target="market-scanner">
                    <i class="fas fa-chart-area"></i>
                    <span class="nav-item-text">Market Scanner</span>
                </div>
            </div>
        </nav>

        <!-- Sidebar Footer -->
        <div class="sidebar-footer">
            <div class="footer-item" data-target="config">
                <i class="fas fa-cog"></i>
                <span>Configuración</span>
            </div>
            <div class="footer-item" id="darkModeToggle">
                <i class="fas fa-moon"></i>
                <span>Modo Oscuro</span>
            </div>
            <div class="footer-item" id="supportBtn">
                <i class="fas fa-life-ring"></i>
                <span>Soporte</span>
            </div>
        </div>
    </aside>

    <!-- ===== MAIN CONTENT ===== -->
    <div class="main-content">

        <!-- Authentication Modal (FUERA de mainApp) -->
        <div id="authModal" class="auth-overlay">
            <div class="auth-modal">
                <div class="text-center mb-6">
                    <h2 class="text-2xl font-bold text-white flex items-center justify-center">
                        <span class="logo-container" style="margin-right: 6px;">
                            <img src="logos/traders-survivor-logo.png" alt="Trading Survivor" style="width: 80px; height: 80px; object-fit: contain; filter: drop-shadow(0 0 1.5px rgba(57, 255, 20, 0.45));">
                        </span>
                        Trading Survivor
                    </h2>
                    <p class="text-text-secondary mt-2">Accede a tu trading journal profesional</p>
                </div>

                <div class="auth-tabs">
                    <div class="auth-tab active" data-tab="login">
                        <i class="fas fa-sign-in-alt mr-2"></i>
                        Iniciar Sesión
                    </div>
                    <div class="auth-tab" data-tab="register">
                        <i class="fas fa-user-plus mr-2"></i>
                        Registrarse
                    </div>
                </div>

                <!-- Login Form -->
                <form id="loginForm" class="auth-form active">
                    <div id="authMessage" class="auth-error" style="display: none;"></div>

                    <input
                        type="email"
                        id="loginEmail"
                        class="auth-input"
                        placeholder="Email"
                        required
                    />

                    <input
                        type="password"
                        id="loginPassword"
                        class="auth-input"
                        placeholder="Contraseña"
                        required
                    />

                    <button type="submit" class="auth-button">
                        <i class="fas fa-sign-in-alt mr-2"></i>
                        Iniciar Sesión
                    </button>
                </form>

                <!-- Register Form -->
                <form id="registerForm" class="auth-form">
                    <input
                        type="email"
                        id="registerEmail"
                        class="auth-input"
                        placeholder="Email"
                        required
                    />

                    <input
                        type="password"
                        id="registerPassword"
                        class="auth-input"
                        placeholder="Contraseña (mínimo 6 caracteres)"
                        minlength="6"
                        required
                    />

                    <input
                        type="password"
                        id="confirmPassword"
                        class="auth-input"
                        placeholder="Confirmar Contraseña"
                        minlength="6"
                        required
                    />

                    <button type="submit" class="auth-button">
                        <i class="fas fa-user-plus mr-2"></i>
                        Crear Cuenta
                    </button>
                </form>
            </div>
        </div>

        <!-- Content Container -->
        <div class="content-container" id="mainApp">

        <!-- NUEVO DASHBOARD PRINCIPAL -->
        <section id="dashboard" class="section-container active">
            <div class="section-toolbar">
                <div class="toolbar-left">
                    <div class="flex items-center gap-3">
                        <div id="new-dashboard-account-logo" class="w-14 h-14 rounded-xl flex items-center justify-center" style="display: none;">
                            <img id="new-dashboard-account-logo-img" src="" alt="" class="w-14 h-14 rounded-xl object-contain">
                        </div>
                        <select id="new-dashboard-account-select" class="w-48">
                            <option value="all">Todas las cuentas</option>
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <button id="new-dashboard-date-filter-btn" class="date-filter-trigger p-1" title="Filtrar por fecha">
                            <i class="fas fa-calendar-alt"></i>
                        </button>
                        <div id="new-dashboard-date-filter-display" class="text-sm text-text-secondary">Sin filtro de fecha</div>
                    </div>
                    
                    <div class="filter-group">
                        <select id="new-dashboard-currency-select" class="currency-selector">
                            <option value="USD">USD</option>
                            <option value="EUR">EUR</option>
                            <option value="%">%</option>
                        </select>
                    </div>
                </div>
                
                <div class="toolbar-right">
                    <button class="action-btn" id="new-dashboard-filters-btn">
                        <i class="fas fa-filter"></i>
                        <span>Filtros</span>
                    </button>
                    <button class="action-btn" id="new-dashboard-download-btn">
                        <i class="fas fa-download"></i>
                        <span>Descargar</span>
                    </button>
                </div>
            </div>

            <!-- Fila superior: Métricas principales (6 gauges - tamaño Analytics) -->
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-6 gap-4 mb-6">
                <!-- Net P&L -->
                <div class="metric-card bg-surface border border-border rounded-lg p-5">
                    <div class="flex items-center justify-between mb-2">
                        <h3 class="text-xs text-text-secondary font-medium">Net P&L</h3>
                        <i class="fas fa-info-circle text-xs text-text-secondary"></i>
                    </div>
                    <p id="new-dash-net-pl" class="text-2xl font-bold text-green mb-2 hide-amount">$0.00</p>
                    <!-- Radial Gauge -->
                    <div class="relative" style="height: 100px; margin-bottom: 8px;">
                        <canvas id="new-dash-net-pl-gauge"></canvas>
                    </div>
                    <div class="flex items-center justify-center text-xs text-text-secondary">
                        <i class="far fa-chart-bar mr-1"></i>
                        <span id="new-dash-total-trades">0 trades</span>
                    </div>
                </div>

                <!-- Comisiones -->
                <div class="metric-card bg-surface border border-border rounded-lg p-5">
                    <div class="flex items-center justify-between mb-2">
                        <h3 class="text-xs text-text-secondary font-medium">Comisiones</h3>
                        <i class="fas fa-info-circle text-xs text-text-secondary"></i>
                    </div>
                    <p id="new-dash-comisiones" class="text-2xl font-bold text-red mb-2 hide-amount">$0.00</p>
                    <!-- Radial Gauge -->
                    <div class="relative" style="height: 100px; margin-bottom: 8px;">
                        <canvas id="new-dash-comisiones-gauge"></canvas>
                    </div>
                    <div class="flex items-center justify-center text-xs text-text-secondary">
                        <i class="far fa-money-bill-wave mr-1"></i>
                        <span id="new-dash-comisiones-count">0 fees</span>
                    </div>
                </div>

                <!-- Trade Win % -->
                <div class="metric-card bg-surface border border-border rounded-lg p-5">
                    <div class="flex items-center justify-between mb-2">
                        <h3 class="text-xs text-text-secondary font-medium">Trade Win %</h3>
                        <i class="fas fa-info-circle text-xs text-text-secondary"></i>
                    </div>
                    <p id="new-dash-win-rate" class="text-2xl font-bold text-white mb-2">0%</p>
                    <!-- Gauge Chart -->
                    <div class="relative" style="height: 100px; margin-bottom: 8px;">
                        <canvas id="new-dash-win-rate-gauge"></canvas>
                    </div>
                    <div class="grid grid-cols-3 gap-2 text-center">
                        <div class="bg-green bg-opacity-20 rounded px-1 py-0.5">
                            <span class="text-xs font-bold text-green" id="new-dash-wins">0</span>
                        </div>
                        <div class="bg-surface-light rounded px-1 py-0.5">
                            <span class="text-xs font-bold text-text-secondary">0</span>
                        </div>
                        <div class="bg-red bg-opacity-20 rounded px-1 py-0.5">
                            <span class="text-xs font-bold text-red" id="new-dash-losses">0</span>
                        </div>
                    </div>
                </div>

                <!-- Day Win -->
                <div class="metric-card bg-surface border border-border rounded-lg p-5">
                    <div class="flex items-center justify-between mb-2">
                        <h3 class="text-xs text-text-secondary font-medium">Day Win</h3>
                        <i class="fas fa-info-circle text-xs text-text-secondary"></i>
                    </div>
                    <p id="new-dash-day-win-rate" class="text-2xl font-bold text-white mb-2">0%</p>
                    <!-- Gauge Chart -->
                    <div class="relative" style="height: 100px; margin-bottom: 8px;">
                        <canvas id="new-dash-day-win-gauge"></canvas>
                    </div>
                    <div class="grid grid-cols-2 gap-2 text-center">
                        <div class="bg-green bg-opacity-20 rounded px-1 py-0.5">
                            <span class="text-xs font-bold text-green" id="new-dash-day-wins">0</span>
                        </div>
                        <div class="bg-red bg-opacity-20 rounded px-1 py-0.5">
                            <span class="text-xs font-bold text-red" id="new-dash-day-losses">0</span>
                        </div>
                    </div>
                </div>

                <!-- Profit Factor -->
                <div class="metric-card bg-surface border border-border rounded-lg p-5">
                    <div class="flex items-center justify-between mb-2">
                        <h3 class="text-xs text-text-secondary font-medium">Profit Factor</h3>
                        <i class="fas fa-info-circle text-xs text-text-secondary"></i>
                    </div>
                    <p id="new-dash-profit-factor" class="text-2xl font-bold text-white mb-2">0.00</p>
                    <!-- Speedometer Chart -->
                    <div class="relative" style="height: 100px;">
                        <canvas id="new-dash-profit-factor-gauge"></canvas>
                    </div>
                </div>

                <!-- Avg Win/Loss Trade -->
                <div class="metric-card bg-surface border border-border rounded-lg p-5">
                    <div class="flex items-center justify-between mb-2">
                        <h3 class="text-xs text-text-secondary font-medium">Avg win/loss trade</h3>
                        <i class="fas fa-info-circle text-xs text-text-secondary"></i>
                    </div>
                    <p id="new-dash-avg-ratio" class="text-2xl font-bold text-white mb-3 hide-amount">0.00</p>
                    <!-- Dual progress bar -->
                    <div class="mb-2">
                        <div class="flex items-center gap-0 h-3 rounded-full overflow-hidden bg-surface-light">
                            <div id="new-dash-win-bar" class="h-full transition-all duration-500" style="width: 50%; background: linear-gradient(90deg, rgba(57, 255, 20, 0.8) 0%, rgba(57, 255, 20, 1) 100%);"></div>
                            <div id="new-dash-loss-bar" class="h-full transition-all duration-500" style="width: 50%; background: linear-gradient(90deg, rgba(255, 65, 54, 1) 0%, rgba(255, 65, 54, 0.8) 100%);"></div>
                        </div>
                    </div>
                    <div class="flex items-center justify-between text-xs">
                        <span class="text-green font-bold hide-amount" id="new-dash-avg-win">$0</span>
                        <span class="text-red font-bold hide-amount" id="new-dash-avg-loss">$0</span>
                    </div>
                </div>
            </div>

            <!-- Segunda fila: Operaciones recientes y Calendario -->
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-6">
                <!-- Operaciones Recientes (1 columna) -->
                <div class="metric-card bg-surface border border-border rounded-lg p-6">
                    <h3 class="text-base font-semibold text-white mb-4">Operaciones Recientes</h3>
                    <div class="overflow-y-auto" style="max-height: 350px;">
                        <table class="w-full text-sm">
                            <thead class="sticky top-0 bg-surface border-b border-border">
                                <tr>
                                    <th class="text-left py-2 text-xs font-semibold text-text-secondary">FECHA</th>
                                    <th class="text-left py-2 text-xs font-semibold text-text-secondary">SÍMBOLO</th>
                                    <th class="text-right py-2 text-xs font-semibold text-text-secondary">P&L</th>
                                </tr>
                            </thead>
                            <tbody id="new-dash-recent-ops">
                                <!-- Se llenará dinámicamente -->
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- Calendario Mensual (2 columnas) -->
                <div class="metric-card bg-surface border border-border rounded-lg p-6 lg:col-span-2">
                    <div class="flex items-center justify-between mb-4">
                        <h3 class="text-base font-semibold text-white">Calendario Mensual</h3>
                        <div class="flex items-center gap-2">
                            <button id="new-dash-cal-prev" class="text-text-secondary hover:text-primary transition-colors p-1">
                                <i class="fas fa-chevron-left"></i>
                            </button>
                            <span id="new-dash-cal-month" class="text-sm font-semibold text-white">Enero 2025</span>
                            <button id="new-dash-cal-next" class="text-text-secondary hover:text-primary transition-colors p-1">
                                <i class="fas fa-chevron-right"></i>
                            </button>
                        </div>
                    </div>
                    <!-- Header de días -->
                    <div class="grid grid-cols-8 gap-2 text-center font-bold p-2 mb-2 text-text-secondary text-xs">
                        <div>Dom</div>
                        <div>Lun</div>
                        <div>Mar</div>
                        <div>Mié</div>
                        <div>Jue</div>
                        <div>Vie</div>
                        <div>Sáb</div>
                        <div>Semana</div>
                    </div>
                    <!-- Grid del calendario -->
                    <div id="new-dash-calendar-grid" class="grid grid-cols-8 gap-2">
                        <!-- El calendario se generará dinámicamente aquí -->
                    </div>
                </div>
            </div>

            <!-- Tercera fila: Gráficas principales (tamaño Analytics) -->
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-6">
                <!-- Daily Net Cumulative P&L -->
                <div class="metric-card bg-surface border border-border rounded-lg p-6">
                    <h3 class="text-base font-semibold text-white mb-4">Daily Net Cumulative P&L</h3>
                    <div class="chart-container" style="position: relative; height: 300px; width: 100%;">
                        <canvas id="new-dash-cumulative-chart"></canvas>
                    </div>
                </div>

                <!-- Net Daily P&L -->
                <div class="metric-card bg-surface border border-border rounded-lg p-6">
                    <h3 class="text-base font-semibold text-white mb-4">Net Daily P&L</h3>
                    <div class="chart-container" style="position: relative; height: 300px; width: 100%;">
                        <canvas id="new-dash-daily-pl-chart"></canvas>
                    </div>
                </div>

                <!-- Puntuación de Rendimiento -->
                <div class="metric-card bg-surface border border-border rounded-lg p-6">
                    <h3 class="text-base font-semibold text-white mb-4">Puntuación de Rendimiento</h3>
                    <div class="chart-container" style="position: relative; height: 300px; width: 100%;">
                        <canvas id="new-dash-radar-chart"></canvas>
                    </div>
                </div>
            </div>

            <!-- Cuarta fila: Rendimiento por Instrumento y Día de la Semana -->
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                <!-- Rendimiento por Instrumento -->
                <div class="metric-card bg-surface border border-border rounded-lg p-6">
                    <h3 class="text-base font-semibold text-white mb-4">Rendimiento por Instrumento</h3>
                    <div class="chart-container" style="position: relative; height: 300px; width: 100%;">
                        <canvas id="new-dash-instrument-chart"></canvas>
                    </div>
                </div>

                <!-- Rendimiento por Día de la Semana -->
                <div class="metric-card bg-surface border border-border rounded-lg p-6">
                    <h3 class="text-base font-semibold text-white mb-4">Rendimiento por Día de la Semana</h3>
                    <div class="chart-container" style="position: relative; height: 300px; width: 100%;">
                        <canvas id="new-dash-day-chart"></canvas>
                    </div>
                </div>
            </div>

        </section>



        <section id="analytics" class="section-container">
            <h2 class="text-xl font-semibold mb-4">Análisis Detallado</h2>
            <div class="section-toolbar">
                <div class="toolbar-left">
                    <div class="flex items-center gap-3">
                        <div id="analytics-account-logo" class="w-14 h-14 rounded-xl flex items-center justify-center" style="display: none;">
                            <img id="analytics-account-logo-img" src="" alt="" class="w-14 h-14 rounded-xl object-contain">
                        </div>
                        <select id="analytics-account-select" class="w-48">
                            <option value="all">Todas las cuentas</option>
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <button id="analytics-date-filter-btn" class="date-filter-trigger p-1" title="Filtrar por fecha">
                            <i class="fas fa-calendar-alt"></i>
                        </button>
                        <div id="analytics-date-filter-display" class="text-sm text-text-secondary">Sin filtro de fecha</div>
                    </div>
                    
                    <div class="filter-group">
                        <select id="analytics-currency-select" class="currency-selector">
                            <option value="USD">USD</option>
                            <option value="EUR">EUR</option>
                            <option value="%">%</option>
                        </select>
                    </div>
                </div>
                
                <div class="toolbar-right">
                    <button class="action-btn" id="analytics-filters-btn">
                        <i class="fas fa-filter"></i>
                        <span>Filtros</span>
                    </button>
                    <button class="action-btn" id="analytics-download-btn">
                        <i class="fas fa-download"></i>
                        <span>Descargar</span>
                    </button>
                </div>
            </div>

            <!-- Fila superior: 6 módulos pequeños -->
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-6 gap-4 mb-6">
                <!-- P&L Bruto Total -->
                <div class="metric-card bg-surface border border-border rounded-lg p-5">
                    <div class="flex items-center justify-between mb-2">
                        <h3 class="text-xs text-text-secondary font-medium">P&L Bruto Total</h3>
                        <i class="fas fa-info-circle text-xs text-text-secondary"></i>
                    </div>
                    <p id="analytics-total-pl" class="text-2xl font-bold text-green mb-2">$0.00</p>
                    <!-- Radial Gauge -->
                    <div class="relative" style="height: 100px; margin-bottom: 8px;">
                        <canvas id="analytics-pl-bruto-gauge"></canvas>
                    </div>
                    <div class="flex items-center justify-center text-xs text-text-secondary">
                        <i class="far fa-chart-bar mr-1"></i>
                        <span id="analytics-pl-bruto-trades">0 trades</span>
                    </div>
                </div>
                
                <!-- P&L Neto Total -->
                <div class="metric-card bg-surface border border-border rounded-lg p-5">
                    <div class="flex items-center justify-between mb-2">
                        <h3 class="text-xs text-text-secondary font-medium">P&L Neto Total</h3>
                        <i class="fas fa-info-circle text-xs text-text-secondary"></i>
                    </div>
                    <p id="analytics-net-pl" class="text-2xl font-bold text-green mb-2">$5,118.86</p>
                    <!-- Radial Gauge -->
                    <div class="relative" style="height: 100px; margin-bottom: 8px;">
                        <canvas id="analytics-pl-neto-gauge"></canvas>
                    </div>
                    <div class="flex items-center justify-center text-xs text-text-secondary">
                        <i class="far fa-chart-bar mr-1"></i>
                        <span id="analytics-total-trades">0 trades</span>
                    </div>
                </div>

                <!-- Trade Win % -->
                <div class="metric-card bg-surface border border-border rounded-lg p-5">
                    <div class="flex items-center justify-between mb-2">
                        <h3 class="text-xs text-text-secondary font-medium">Trade Win %</h3>
                        <i class="fas fa-info-circle text-xs text-text-secondary"></i>
                    </div>
                    <p id="analytics-win-rate" class="text-2xl font-bold text-white mb-2">44.90%</p>
                    <!-- Gauge Chart -->
                    <div class="relative" style="height: 100px; margin-bottom: 8px;">
                        <canvas id="analytics-trade-win-gauge"></canvas>
                    </div>
                    <div class="grid grid-cols-3 gap-2 text-center">
                        <div class="bg-green bg-opacity-20 rounded px-1 py-0.5">
                            <span class="text-xs font-bold text-green" id="analytics-wins">22</span>
                        </div>
                        <div class="bg-surface-light rounded px-1 py-0.5">
                            <span class="text-xs font-bold text-text-secondary">0</span>
                        </div>
                        <div class="bg-red bg-opacity-20 rounded px-1 py-0.5">
                            <span class="text-xs font-bold text-red" id="analytics-losses">27</span>
                        </div>
                    </div>
                </div>

                <!-- Profit Factor -->
                <div class="metric-card bg-surface border border-border rounded-lg p-5">
                    <div class="flex items-center justify-between mb-2">
                        <h3 class="text-xs text-text-secondary font-medium">Profit Factor</h3>
                        <i class="fas fa-info-circle text-xs text-text-secondary"></i>
                    </div>
                    <p id="analytics-profit-factor" class="text-2xl font-bold text-white mb-2">1.30</p>
                    <!-- Speedometer Chart -->
                    <div class="relative" style="height: 100px;">
                        <canvas id="analytics-profit-factor-gauge"></canvas>
                    </div>
                </div>

                <!-- Day Win % -->
                <div class="metric-card bg-surface border border-border rounded-lg p-5">
                    <div class="flex items-center justify-between mb-2">
                        <h3 class="text-xs text-text-secondary font-medium">Day Win %</h3>
                        <i class="fas fa-info-circle text-xs text-text-secondary"></i>
                    </div>
                    <p id="analytics-day-win-rate" class="text-2xl font-bold text-white mb-2">46.67%</p>
                    <!-- Gauge Chart -->
                    <div class="relative" style="height: 100px; margin-bottom: 8px;">
                        <canvas id="analytics-day-win-gauge"></canvas>
                    </div>
                    <div class="grid grid-cols-3 gap-2 text-center">
                        <div class="bg-green bg-opacity-20 rounded px-1 py-0.5">
                            <span class="text-xs font-bold text-green" id="analytics-day-wins">14</span>
                        </div>
                        <div class="bg-surface-light rounded px-1 py-0.5">
                            <span class="text-xs font-bold text-text-secondary" id="analytics-day-neutral">9</span>
                        </div>
                        <div class="bg-red bg-opacity-20 rounded px-1 py-0.5">
                            <span class="text-xs font-bold text-red" id="analytics-day-losses">16</span>
                        </div>
                    </div>
                </div>

                <!-- Avg Win/Loss Trade -->
                <div class="metric-card bg-surface border border-border rounded-lg p-5">
                    <div class="flex items-center justify-between mb-2">
                        <h3 class="text-xs text-text-secondary font-medium">Avg win/loss trade</h3>
                        <i class="fas fa-info-circle text-xs text-text-secondary"></i>
                    </div>
                    <p id="analytics-avg-ratio" class="text-2xl font-bold text-white mb-3">1.59</p>
                    <!-- Dual progress bar (barra comparativa divergente) -->
                    <div class="mb-2">
                        <div class="flex items-center gap-0 h-3 rounded-full overflow-hidden bg-surface-light">
                            <div id="analytics-win-bar" class="h-full transition-all duration-500" style="width: 61%; background: linear-gradient(90deg, rgba(57, 255, 20, 0.8) 0%, rgba(57, 255, 20, 1) 100%);"></div>
                            <div id="analytics-loss-bar" class="h-full transition-all duration-500" style="width: 39%; background: linear-gradient(90deg, rgba(255, 65, 54, 1) 0%, rgba(255, 65, 54, 0.8) 100%);"></div>
                        </div>
                    </div>
                    <div class="flex items-center justify-between text-xs">
                        <span class="text-green font-bold" id="analytics-avg-win-trade">$1.01K</span>
                        <span class="text-red font-bold" id="analytics-avg-loss-trade">-$634</span>
                    </div>
                </div>
            </div>

            <!-- Fila con Rendimiento de Última Semana y las dos gráficas -->
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-6">
                <!-- Rendimiento de Última Semana -->
                <div class="metric-card bg-surface border border-border rounded-lg p-6">
                    <h3 class="text-base font-semibold text-white mb-4">Rendimiento de Última Semana</h3>
                    <div class="overflow-y-auto" style="max-height: 350px;">
                        <table class="w-full text-sm">
                            <thead class="sticky top-0 bg-surface">
                                <tr class="border-b border-border">
                                    <th class="text-left py-2 text-xs font-semibold text-text-secondary">DÍA</th>
                                    <th class="text-right py-2 text-xs font-semibold text-text-secondary">P/L</th>
                                    <th class="text-right py-2 text-xs font-semibold text-text-secondary">TRADES</th>
                                    <th class="text-right py-2 text-xs font-semibold text-text-secondary">WIN %</th>
                                </tr>
                            </thead>
                            <tbody id="analytics-lastweek-performance">
                                <!-- Se llenará dinámicamente -->
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- Daily Net Cumulative P&L -->
                <div class="metric-card bg-surface border border-border rounded-lg p-6">
                    <div class="flex items-center justify-between mb-4">
                        <h3 class="text-base font-semibold text-white">Daily Net Cumulative P&L</h3>
                        <div class="flex items-center gap-2">
                            <i class="fas fa-info-circle text-xs text-text-secondary"></i>
                            <span class="text-xs bg-yellow bg-opacity-20 text-yellow px-2 py-0.5 rounded">BETA</span>
                        </div>
                    </div>
                    <div class="chart-container" style="position: relative; height: 300px; width: 100%;">
                        <canvas id="analytics-cumulative-pl-chart"></canvas>
                    </div>
                </div>

                <!-- Net Daily P&L -->
                <div class="metric-card bg-surface border border-border rounded-lg p-6">
                    <div class="flex items-center justify-between mb-4">
                        <h3 class="text-base font-semibold text-white">Net Daily P&L</h3>
                        <i class="fas fa-info-circle text-xs text-text-secondary"></i>
                    </div>
                    <div class="chart-container" style="position: relative; height: 300px; width: 100%;">
                        <canvas id="analytics-net-daily-pl-chart"></canvas>
                    </div>
                </div>
            </div>
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-8">
                <div class="metric-card"><h3 class="text-base mb-1 text-text-secondary">Avg Comisión</h3><p id="analytics-avg-fee" class="text-2xl font-bold text-yellow hide-amount">$0.00</p></div>
                <div class="metric-card"><h3 class="text-base mb-1 text-text-secondary">Drawdown Máx.</h3><p id="analytics-max-drawdown-short" class="text-2xl font-bold text-red hide-amount">$0.00</p></div>
                <div class="metric-card"><h3 class="text-base mb-1 text-text-secondary">Comisiones Totales</h3><p id="analytics-total-fees" class="text-2xl font-bold text-red hide-amount">$0.00</p></div>
                <div class="metric-card"><h3 class="text-base mb-1 text-text-secondary">Avg PL / Trade</h3><p id="analytics-avg-pl-trade" class="text-2xl font-bold text-white hide-amount">$0.00</p></div>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
                <div class="metric-card"><h3 class="text-lg font-semibold mb-3">Métricas Clave</h3><dl class="space-y-2 text-sm">
                    <div class="flex justify-between"><dt>Ganancia Promedio:</dt><dd id="analytics-avg-win" class="font-semibold text-green">$0.00</dd></div>
                    <div class="flex justify-between"><dt>Pérdida Promedio:</dt><dd id="analytics-avg-loss" class="font-semibold text-red">$0.00</dd></div>
                    <div class="flex justify-between"><dt>Expectativa:</dt><dd id="analytics-expectancy" class="font-semibold text-white">$0.00</dd></div>
                    <div class="flex justify-between"><dt>Mayor Ganancia:</dt><dd id="analytics-largest-win" class="font-semibold text-green">$0.00</dd></div>
                    <div class="flex justify-between"><dt>Mayor Pérdida:</dt><dd id="analytics-largest-loss" class="font-semibold text-red">$0.00</dd></div></dl>
                </div>
                 <div class="metric-card"><h3 class="text-lg font-semibold mb-3">Rachas y Costos</h3><dl class="space-y-2 text-sm"><div class="flex justify-between"><dt>Racha Ganadora Máx.:</dt><dd id="analytics-longest-win-streak" class="font-semibold">0</dd></div><div class="flex justify-between"><dt>Racha Perdedora Máx.:</dt><dd id="analytics-longest-loss-streak" class="font-semibold">0</dd></div><div class="flex justify-between"><dt>Trades Ganadores:</dt><dd id="analytics-total-wins-count" class="font-semibold">0</dd></div><div class="flex justify-between"><dt>Trades Perdedores:</dt><dd id="analytics-total-losses-count" class="font-semibold">0</dd></div><div class="flex justify-between"><dt>Trades Breakeven:</dt><dd id="analytics-total-breakeven-count" class="font-semibold">0</dd></div><div class="flex justify-between border-t border-surface-light pt-2 mt-2"><dt class="font-bold">Comisiones Totales:</dt><dd id="analytics-fees-total" class="font-bold text-red">$0.00</dd></div><div class="flex justify-between"><dt>P/L Neto (después fees):</dt><dd id="analytics-net-pl-after-fees" class="font-bold text-green">$0.00</dd></div></dl></div>
                <div class="metric-card"><h3 class="text-lg font-semibold mb-3">Métricas de Riesgo y Consistencia</h3><dl class="space-y-2 text-sm">
                    <div class="flex justify-between"><dt>Drawdown Máximo:</dt><dd id="analytics-max-drawdown" class="font-semibold text-red">$0.00 (0%)</dd></div>
                    <div class="flex justify-between"><dt>Ratio Ganancia/Pérdida Prom:</dt><dd id="analytics-avg-wl-ratio" class="font-semibold">0.00</dd></div>
                    <div class="flex justify-between"><dt>Tiempo Prom. por Operación:</dt><dd id="analytics-avg-hold-time" class="font-semibold">N/A</dd></div>
                    <div class="flex justify-between"><dt>Desv. Estándar del P/L:</dt><dd id="analytics-std-dev-pl" class="font-semibold">$0.00</dd></div>
                </dl></div>
                <div class="metric-card"><h3 class="text-lg font-semibold mb-3">Análisis de Tiempo</h3><dl class="space-y-2 text-sm">
                    <div class="flex justify-between"><dt>Duración Win Prom:</dt><dd id="analytics-avg-win-duration" class="font-semibold text-green">N/A</dd></div>
                    <div class="flex justify-between"><dt>Duración Loss Prom:</dt><dd id="analytics-avg-loss-duration" class="font-semibold text-red">N/A</dd></div>
                    <div class="flex justify-between"><dt>Mejor Hora de Trading:</dt><dd id="analytics-best-hour" class="font-semibold text-green">N/A</dd></div>
                    <div class="flex justify-between"><dt>Peor Hora de Trading:</dt><dd id="analytics-worst-hour" class="font-semibold text-red">N/A</dd></div>
                    <div class="flex justify-between"><dt>Trade Ganador Más Largo:</dt><dd id="analytics-longest-win-duration" class="font-semibold">N/A</dd></div>
                    <div class="flex justify-between"><dt>Trade Perdedor Más Largo:</dt><dd id="analytics-longest-loss-duration" class="font-semibold">N/A</dd></div>
                    <div class="flex justify-between"><dt>Trade Ganador Más Rápido:</dt><dd id="analytics-fastest-win" class="font-semibold text-green">N/A</dd></div>
                </dl></div>
            </div>

             <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                <div class="metric-card"><h3 class="text-lg font-semibold mb-2">Rendimiento por Mes</h3><div class="overflow-y-auto max-h-72"><table class="w-full"><thead><tr><th>Mes</th><th>P/L</th><th>Trades</th><th>Win %</th></tr></thead><tbody id="analytics-monthly-performance"></tbody></table></div></div>
                <div class="metric-card"><h3 class="text-lg font-semibold mb-2">Rendimiento por Día de la Semana</h3><div class="overflow-y-auto max-h-72"><table class="w-full"><thead><tr><th>Día</th><th>P/L</th><th>Trades</th><th>Win %</th></tr></thead><tbody id="analytics-daily-performance"></tbody></table></div></div>
            </div>

             <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                <div class="metric-card"><h3 class="text-lg font-semibold mb-2">Rendimiento de la Semana</h3><div class="overflow-y-auto max-h-72"><table class="w-full"><thead><tr><th>Semana</th><th>P/L</th><th>Trades</th><th>Win %</th></tr></thead><tbody id="analytics-weekly-performance"></tbody></table></div></div>
                <div class="metric-card"><h3 class="text-lg font-semibold mb-2">Rendimiento por Trimestre</h3><div class="overflow-y-auto max-h-72"><table class="w-full"><thead><tr><th>Trimestre</th><th>P/L</th><th>Trades</th><th>Win %</th></tr></thead><tbody id="analytics-quarterly-performance"></tbody></table></div></div>
            </div>

             <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <div class="metric-card"><h3 class="text-lg font-semibold mb-2">Rendimiento por Instrumento (Top 10)</h3><div class="chart-container" style="height: 280px;"><canvas id="analytics-instrument-performance-chart"></canvas></div></div>
                <div class="metric-card"><h3 class="text-lg font-semibold mb-2">Rendimiento por Hora del Día (Entrada)</h3><div class="chart-container" style="height: 280px;"><canvas id="analytics-hourly-performance-chart"></canvas></div></div>
            </div>
        </section>

        <!-- EQUITY GRAPH SECTION -->
        <section id="equity-graph" class="section-container">
            <div class="section-toolbar">
                <div class="toolbar-left">
                    <h2 class="text-2xl font-bold">Análisis de Performance</h2>
                    <div class="flex items-center gap-3 ml-6">
                        <div id="equity-account-logo" class="w-14 h-14 rounded-xl flex items-center justify-center" style="display: none;">
                            <img id="equity-account-logo-img" src="" alt="" class="w-14 h-14 rounded-xl object-contain">
                        </div>
                        <!-- Multi-Select Container -->
                        <div class="multi-select-container">
                            <div class="multi-select-trigger" id="equity-account-trigger">
                                <span id="equity-account-display">Todas las cuentas</span>
                                <i class="fas fa-chevron-down chevron"></i>
                            </div>
                            <div class="multi-select-dropdown" id="equity-account-dropdown">
                                <!-- Opciones se cargarán dinámicamente -->
                            </div>
                        </div>
                    </div>
                </div>
                <div class="toolbar-right">
                    <button id="equity-toggle-filters-btn" class="action-btn">
                        <i class="fas fa-filter"></i>
                        <span>Filtros</span>
                    </button>
                </div>
            </div>

            <!-- Navegación de Subsecciones -->
            <div class="nav-tabs flex mb-6">
                <div class="nav-tab equity-view-tab active" data-view="performance">
                    Performance Analytics
                </div>
                <div class="nav-tab equity-view-tab" data-view="evaluator">
                    Evaluador de Cuentas
                </div>
                <div class="nav-tab equity-view-tab" data-view="edge-finder">
                    Edge Finder
                </div>
            </div>

            <!-- ========== SUBSECCIÓN 1: EVALUADOR DE CUENTAS ========== -->
            <div id="equity-view-evaluator" class="equity-view-content" style="display: none;">
                <!-- Panel de Control del Evaluador -->
                <div class="metric-card mb-6">
                    <div class="flex flex-wrap items-center justify-between gap-4 mb-4">
                        <h3 class="text-lg font-semibold">
                            Evaluador de Cuentas - Comparación Múltiple
                        </h3>
                        <div class="flex gap-3">
                            <select id="evaluator-display-mode" class="px-4 py-2 bg-surface border border-border rounded">
                                <option value="return">Return ($)</option>
                                <option value="balance">Balance de Cuenta ($)</option>
                                <option value="return-pct">Return (%)</option>
                                <option value="roi">ROI (%)</option>
                                <option value="r-multiple">R-Multiple</option>
                            </select>
                            <select id="evaluator-chart-type" class="px-4 py-2 bg-surface border border-border rounded">
                                <option value="area">Gráfico de Área</option>
                                <option value="line">Líneas</option>
                                <option value="stepped">Escalonado</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Gráfico Principal Comparativo -->
                <div style="width: 100%; height: 600px; background: var(--surface); border-radius: 12px; padding: 24px; margin-bottom: 24px;">
                    <canvas id="evaluator-main-chart"></canvas>
                </div>

                <!-- Tabla Comparativa de Métricas -->
                <div class="metric-card mb-6">
                    <h3 class="text-lg font-semibold mb-4">
                        Comparación de Métricas Clave
                    </h3>
                    <div class="overflow-x-auto">
                        <table class="w-full" id="evaluator-comparison-table">
                            <thead>
                                <tr style="background: var(--surface-light);">
                                    <th class="p-3 text-left" style="position: sticky; left: 0; background: var(--surface-light); z-index: 10;">Cuenta</th>
                                    <th class="p-3 text-right">Balance Inicial</th>
                                    <th class="p-3 text-right">Balance Final</th>
                                    <th class="p-3 text-right">P/L Neto</th>
                                    <th class="p-3 text-right">Return %</th>
                                    <th class="p-3 text-center">Trades</th>
                                    <th class="p-3 text-right">Win Rate</th>
                                    <th class="p-3 text-right">Profit Factor</th>
                                    <th class="p-3 text-right">Max DD</th>
                                    <th class="p-3 text-right">Sharpe Ratio</th>
                                    <th class="p-3 text-center">Ranking</th>
                                </tr>
                            </thead>
                            <tbody id="evaluator-comparison-tbody">
                                <!-- Se llenará dinámicamente -->
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- Gráficos Comparativos Adicionales -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                    <!-- Gráfico de Barras: Volumen por Cuenta -->
                    <div class="metric-card" style="height: 400px;">
                        <h4 class="text-base font-semibold mb-4">Volumen de Operaciones</h4>
                        <canvas id="evaluator-volume-chart"></canvas>
                    </div>

                    <!-- Gráfico de Barras: Win Rate Comparison -->
                    <div class="metric-card" style="height: 400px;">
                        <h4 class="text-base font-semibold mb-4">Comparación de Win Rate</h4>
                        <canvas id="evaluator-winrate-chart"></canvas>
                    </div>
                </div>

                <!-- Gráfico de Performance Mensual Comparativa -->
                <div class="metric-card" style="height: 450px;">
                    <h4 class="text-base font-semibold mb-4">Performance Mensual Comparativa</h4>
                    <canvas id="evaluator-monthly-chart"></canvas>
                </div>
            </div>

            <!-- ========== SUBSECCIÓN 2: EDGE FINDER ========== -->
            <div id="equity-view-edge-finder" class="equity-view-content" style="display: none;">
                <!-- Insight Cards AI-Powered -->
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                    <div class="metric-card bg-gradient-to-br from-green-900/20 to-surface border border-primary/30">
                        <div class="flex items-start justify-between mb-3">
                            <div>
                                <p class="text-sm text-primary mb-1">Mejor Setup</p>
                                <p id="edge-best-setup-name" class="text-2xl font-bold text-white mb-2">--</p>
                                <p class="text-sm text-text-secondary">
                                    <span id="edge-best-setup-winrate">--</span> | 
                                    <span id="edge-best-setup-profit" class="text-primary">$0</span>
                                </p>
                            </div>
                        </div>
                        <div class="pt-3 border-t border-primary/20">
                            <p class="text-xs text-primary font-semibold">Recomendación</p>
                            <p id="edge-best-setup-recommendation" class="text-xs text-text-secondary mt-1">--</p>
                        </div>
                    </div>

<div class="metric-card bg-gradient-to-br from-green-900/20 to-surface border border-primary/30">
                        <div class="flex items-start justify-between mb-3">
                            <div>
                                <p class="text-sm text-primary mb-1">Mejor Horario</p>
                                <p id="edge-best-time-hour" class="text-2xl font-bold text-white mb-2">--</p>
                                <p class="text-sm text-text-secondary">
                                    <span id="edge-best-time-trades">0 trades</span> | 
                                    <span id="edge-best-time-winrate">0% WR</span>
                                </p>
                            </div>
                        </div>
                        <div class="pt-3 border-t border-primary/20">
                            <p class="text-xs text-primary font-semibold">Insight</p>
                            <p id="edge-best-time-insight" class="text-xs text-text-secondary mt-1">--</p>
                        </div>
                    </div>

                    <div class="metric-card bg-gradient-to-br from-red-900/20 to-surface border border-red-500/30">
                        <div class="flex items-start justify-between mb-3">
                            <div>
                                <p class="text-sm text-red-400 mb-1">Oportunidad Perdida</p>
                                <p id="edge-opp-lost-amount" class="text-2xl font-bold text-white mb-2">$0</p>
                                <p id="edge-opp-lost-trades" class="text-sm text-text-secondary">0 trades mejorados</p>
                            </div>
                        </div>
                        <div class="pt-3 border-t border-red-500/20">
                            <p class="text-xs text-red-400 font-semibold">What-If Analysis</p>
                            <p id="edge-opportunity-whatif" class="text-xs text-text-secondary mt-1">--</p>
                        </div>
                    </div>
                </div>

                <!-- Análisis de Winning Patterns -->
                <div class="metric-card mb-6">
                    <h3 class="text-lg font-semibold mb-4">
                        Patrones Ganadores Identificados
                    </h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                        <div class="bg-surface-light p-4 rounded-lg border border-border hover:border-primary transition-colors">
                            <div class="flex items-center justify-between mb-3">
                                <h4 class="font-semibold">Por Setup</h4>
                            </div>
                            <div id="edge-pattern-setups" class="space-y-2 text-sm">
                                <!-- Se llenará dinámicamente -->
                            </div>
                        </div>

                        <div class="bg-surface-light p-4 rounded-lg border border-border hover:border-primary transition-colors">
                            <div class="flex items-center justify-between mb-3">
                                <h4 class="font-semibold">Por Instrumento</h4>
                            </div>
                            <div id="edge-pattern-instruments" class="space-y-2 text-sm">
                                <!-- Se llenará dinámicamente -->
                            </div>
                        </div>

                        <div class="bg-surface-light p-4 rounded-lg border border-border hover:border-primary transition-colors">
                            <div class="flex items-center justify-between mb-3">
                                <h4 class="font-semibold">Por Sesión</h4>
                            </div>
                            <div id="edge-pattern-sessions" class="space-y-2 text-sm">
                                <!-- Se llenará dinámicamente -->
                            </div>
                        </div>
                    </div>
                </div>

                <!-- What-If Analysis Detallado -->
                <div class="metric-card mb-6">
                    <h3 class="text-lg font-semibold mb-4">
                        Análisis What-If: Simulaciones de Optimización
                    </h3>
                    <div class="overflow-x-auto">
                        <table class="w-full">
                            <thead>
                                <tr style="background: var(--surface-light);">
                                    <th class="p-3 text-left">Escenario</th>
                                    <th class="p-3 text-center">Condición</th>
                                    <th class="p-3 text-right">P/L Actual</th>
                                    <th class="p-3 text-right">P/L Proyectado</th>
                                    <th class="p-3 text-right">Diferencia</th>
                                    <th class="p-3 text-center">Trades</th>
                                    <th class="p-3 text-right">Win Rate</th>
                                    <th class="p-3 text-center">Viabilidad</th>
                                </tr>
                            </thead>
                            <tbody id="edge-whatif-tbody">
                                <!-- Se llenará dinámicamente -->
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- Exit Optimization Analysis -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                    <div class="metric-card">
                        <h4 class="text-base font-semibold mb-4">
                            Análisis de Salidas: Winners Cut Too Early
                        </h4>
                        <div style="height: 300px;">
                            <canvas id="edge-winners-cut-chart"></canvas>
                        </div>
                        <div id="edge-exit-winners-stats" class="mt-4 text-sm text-text-secondary">
                            <!-- Estadísticas -->
                        </div>
                    </div>

                    <div class="metric-card">
                        <h4 class="text-base font-semibold mb-4">
                            Análisis de Salidas: Losers Held Too Long
                        </h4>
                        <div style="height: 300px;">
                            <canvas id="edge-losers-held-chart"></canvas>
                        </div>
                        <div id="edge-exit-losers-stats" class="mt-4 text-sm text-text-secondary">
                            <!-- Estadísticas -->
                        </div>
                    </div>
                </div>

                <!-- Risk-Adjusted Metrics -->
                <div class="metric-card">
                    <h3 class="text-lg font-semibold mb-4">
                        Métricas Ajustadas por Riesgo
                    </h3>
                    <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                        <div class="text-center p-4 bg-surface-light rounded-lg">
                            <p class="text-xs text-text-secondary mb-1">Sharpe Ratio</p>
                            <p id="edge-sharpe" class="text-2xl font-bold text-white">0.00</p>
                            <p class="text-xs text-text-secondary mt-1">Retorno/Riesgo</p>
                        </div>
                        <div class="text-center p-4 bg-surface-light rounded-lg">
                            <p class="text-xs text-text-secondary mb-1">Sortino Ratio</p>
                            <p id="edge-sortino" class="text-2xl font-bold text-white">0.00</p>
                            <p class="text-xs text-text-secondary mt-1">Downside Risk</p>
                        </div>
                        <div class="text-center p-4 bg-surface-light rounded-lg">
                            <p class="text-xs text-text-secondary mb-1">Calmar Ratio</p>
                            <p id="edge-calmar" class="text-2xl font-bold text-white">0.00</p>
                            <p class="text-xs text-text-secondary mt-1">Return/Max DD</p>
                        </div>
                        <div class="text-center p-4 bg-surface-light rounded-lg">
                            <p class="text-xs text-text-secondary mb-1">Expectancy</p>
                            <p id="edge-expectancy" class="text-2xl font-bold text-white">$0.00</p>
                            <p class="text-xs text-text-secondary mt-1">Por Trade</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- ========== SUBSECCIÓN 3: PERFORMANCE ANALYTICS ========== -->
            <div id="equity-view-performance" class="equity-view-content">
                <!-- Panel de Control y KPIs -->
                <div class="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-4 mb-6">
                    <div class="metric-card p-4 text-center">
                        <p class="text-xs text-text-secondary mb-1">Account Balance</p>
                        <p id="perf-account-balance" class="text-xl font-bold text-white">$0.00</p>
                    </div>
                    <div class="metric-card p-4 text-center">
                        <p class="text-xs text-text-secondary mb-1">Total Trades</p>
                        <p id="perf-total-trades" class="text-xl font-bold text-white">0</p>
                    </div>
                    <div class="metric-card p-4 text-center">
                        <p class="text-xs text-text-secondary mb-1">Win Rate</p>
                        <p id="perf-winrate" class="text-xl font-bold text-primary">0%</p>
                    </div>
                    <div class="metric-card p-4 text-center">
                        <p class="text-xs text-text-secondary mb-1">Profit Factor</p>
                        <p id="perf-profit-factor" class="text-xl font-bold text-white">0.00</p>
                    </div>
                    <div class="metric-card p-4 text-center">
                        <p class="text-xs text-text-secondary mb-1">Return %</p>
                        <p id="perf-return-percent" class="text-xl font-bold text-primary">0%</p>
                    </div>
                    <div class="metric-card p-4 text-center">
                        <p class="text-xs text-text-secondary mb-1">Max Drawdown</p>
                        <p id="perf-max-drawdown" class="text-xl font-bold text-red">$0.00</p>
                    </div>
                </div>

                <!-- Controles de Visualización -->
                <div class="metric-card mb-6">
                    <div class="flex flex-wrap items-center gap-4">
                        <div class="flex items-center gap-2">
                            <label class="text-sm text-text-secondary">Tipo de Gráfico:</label>
                            <select id="perf-chart-type" class="px-4 py-2 bg-surface border border-border rounded">
                                <option value="area">Área</option>
                                <option value="line">Línea</option>
                                <option value="bar">Barras</option>
                            </select>
                        </div>
                        <div class="flex items-center gap-2">
                            <label class="text-sm text-text-secondary">Métrica:</label>
                            <select id="perf-metric" class="px-4 py-2 bg-surface border border-border rounded">
                                <option value="return">Return ($)</option>
                                <option value="balance">Balance</option>
                                <option value="return-pct">Return (%)</option>
                                <option value="drawdown">Drawdown</option>
                            </select>
                        </div>
                        <div class="flex items-center gap-2">
                            <label class="text-sm text-text-secondary">Agrupar:</label>
                            <select id="perf-grouping" class="px-4 py-2 bg-surface border border-border rounded">
                                <option value="trades">Por Trade</option>
                                <option value="day">Por Día</option>
                                <option value="week">Por Semana</option>
                                <option value="month">Por Mes</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Gráfico Principal -->
                <div style="width: 100%; height: 600px; background: var(--surface); border-radius: 12px; padding: 24px; margin-bottom: 24px;">
                    <canvas id="performance-main-chart" style="width: 100% !important; height: 100% !important;"></canvas>
                </div>
                <p class="text-xs text-text-secondary text-center mb-6">Curva de rendimiento acumulado mostrando la evolución del capital a lo largo del tiempo</p>

                <!-- Distribution Charts -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                    <div class="metric-card" style="height: 450px; padding: 20px;">
                        <h4 class="text-base font-semibold mb-4">Distribución de P/L</h4>
                        <div style="width: 100%; height: calc(100% - 80px);">
                            <canvas id="perf-pl-distribution" style="width: 100% !important; height: 100% !important;"></canvas>
                        </div>
                        <p class="text-xs text-text-secondary text-center mt-3">Histograma de ganancias y pérdidas por operación</p>
                    </div>
                    <div class="metric-card" style="height: 450px; padding: 20px;">
                        <h4 class="text-base font-semibold mb-4">Duración de Trades</h4>
                        <div style="width: 100%; height: calc(100% - 80px);">
                            <canvas id="perf-duration-distribution" style="width: 100% !important; height: 100% !important;"></canvas>
                        </div>
                        <p class="text-xs text-text-secondary text-center mt-3">Distribución del tiempo de permanencia en cada operación</p>
                    </div>
                </div>

                <!-- Time Analysis -->
                <div class="metric-card mb-6" style="height: 500px; padding: 20px;">
                    <div class="flex justify-between items-center mb-4">
                        <h4 class="text-base font-semibold">Performance por Tiempo</h4>
                        <select id="perf-time-analysis-type" class="px-4 py-2 bg-surface border border-border rounded text-sm">
                            <option value="hour">Por Hora del Día</option>
                            <option value="day">Por Día de la Semana</option>
                            <option value="month">Por Mes</option>
                        </select>
                    </div>
                    <div style="width: 100%; height: calc(100% - 110px);">
                        <canvas id="perf-time-analysis" style="width: 100% !important; height: 100% !important;"></canvas>
                    </div>
                    <p class="text-xs text-text-secondary text-center mt-3">Análisis de rendimiento según franjas horarias, días de la semana o meses</p>
                </div>

                <!-- MAE/MFE Analysis -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                    <div class="metric-card" style="height: 450px; padding: 20px;">
                        <h4 class="text-base font-semibold mb-4">MAE Analysis (Maximum Adverse Excursion)</h4>
                        <div style="width: 100%; height: calc(100% - 80px);">
                            <canvas id="perf-mae-chart" style="width: 100% !important; height: 100% !important;"></canvas>
                        </div>
                        <p class="text-xs text-text-secondary text-center mt-3">Peor punto en contra que alcanzó cada trade antes de cerrarse</p>
                    </div>
                    <div class="metric-card" style="height: 450px; padding: 20px;">
                        <h4 class="text-base font-semibold mb-4">MFE Analysis (Maximum Favorable Excursion)</h4>
                        <div style="width: 100%; height: calc(100% - 80px);">
                            <canvas id="perf-mfe-chart" style="width: 100% !important; height: 100% !important;"></canvas>
                        </div>
                        <p class="text-xs text-text-secondary text-center mt-3">Mejor punto a favor que alcanzó cada trade antes de cerrarse</p>
                    </div>
                </div>

                <!-- Drawdown Timeline -->
                <div class="metric-card mb-6" style="height: 500px; padding: 20px;">
                    <h4 class="text-base font-semibold mb-4">Análisis de Drawdown Histórico</h4>
                    <div style="width: 100%; height: calc(100% - 90px);">
                        <canvas id="perf-drawdown-timeline" style="width: 100% !important; height: 100% !important;"></canvas>
                    </div>
                    <p class="text-xs text-text-secondary text-center mt-3">Evolución del drawdown mostrando las caídas desde picos históricos</p>
                </div>

                <!-- Rolling Statistics -->
                <div class="metric-card" style="height: 500px; padding: 20px;">
                    <div class="flex justify-between items-center mb-4">
                        <h4 class="text-base font-semibold">Estadísticas Móviles</h4>
                        <div class="flex gap-2">
                            <select id="perf-rolling-metric" class="px-3 py-2 bg-surface border border-border rounded text-sm">
                                <option value="winrate">Win Rate</option>
                                <option value="profitfactor">Profit Factor</option>
                                <option value="avgpl">Avg P/L</option>
                            </select>
                            <select id="perf-rolling-window" class="px-3 py-2 bg-surface border border-border rounded text-sm">
                                <option value="20">20 Trades</option>
                                <option value="50">50 Trades</option>
                                <option value="100">100 Trades</option>
                            </select>
                        </div>
                    </div>
                    <div style="width: 100%; height: calc(100% - 110px);">
                        <canvas id="perf-rolling-stats" style="width: 100% !important; height: 100% !important;"></canvas>
                    </div>
                    <p class="text-xs text-text-secondary text-center mt-3">Ventana móvil de 20 operaciones mostrando la evolución del win rate a lo largo del tiempo</p>
                </div>

                <!-- KPIs Avanzados -->
                <div class="metric-card">
                    <h3 class="text-lg font-semibold mb-4">KPIs Profesionales Adicionales</h3>
                    <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
                        <div class="bg-surface-light p-4 rounded-lg text-center">
                            <p class="text-xs text-text-secondary mb-1">Avg Winner</p>
                            <p id="perf-avg-winner" class="text-lg font-bold text-primary">$0.00</p>
                        </div>
                        <div class="bg-surface-light p-4 rounded-lg text-center">
                            <p class="text-xs text-text-secondary mb-1">Avg Loser</p>
                            <p id="perf-avg-loser" class="text-lg font-bold text-red">$0.00</p>
                        </div>
                        <div class="bg-surface-light p-4 rounded-lg text-center">
                            <p class="text-xs text-text-secondary mb-1">Win/Loss Ratio</p>
                            <p id="perf-win-loss-ratio" class="text-lg font-bold text-white">0.00</p>
                        </div>
                        <div class="bg-surface-light p-4 rounded-lg text-center">
                            <p class="text-xs text-text-secondary mb-1">Expectancy</p>
                            <p id="perf-expectancy" class="text-lg font-bold text-white">$0.00</p>
                        </div>
                        <div class="bg-surface-light p-4 rounded-lg text-center">
                            <p class="text-xs text-text-secondary mb-1">Largest Winner</p>
                            <p id="perf-largest-winner" class="text-lg font-bold text-primary">$0.00</p>
                        </div>
                        <div class="bg-surface-light p-4 rounded-lg text-center">
                            <p class="text-xs text-text-secondary mb-1">Largest Loser</p>
                            <p id="perf-largest-loser" class="text-lg font-bold text-red">$0.00</p>
                        </div>
                        <div class="bg-surface-light p-4 rounded-lg text-center">
                            <p class="text-xs text-text-secondary mb-1">Recovery Factor</p>
                            <p id="perf-recovery-factor" class="text-lg font-bold text-white">0.00</p>
                        </div>
                        <div class="bg-surface-light p-4 rounded-lg text-center">
                            <p class="text-xs text-text-secondary mb-1">Avg Trade Duration</p>
                            <p id="perf-avg-duration" class="text-lg font-bold text-white">0m</p>
                        </div>
                        <div class="bg-surface-light p-4 rounded-lg text-center">
                            <p class="text-xs text-text-secondary mb-1">Best Day</p>
                            <p id="perf-best-day" class="text-lg font-bold text-primary">$0.00</p>
                        </div>
                        <div class="bg-surface-light p-4 rounded-lg text-center">
                            <p class="text-xs text-text-secondary mb-1">Worst Day</p>
                            <p id="perf-worst-day" class="text-lg font-bold text-red">$0.00</p>
                        </div>
                        <div class="bg-surface-light p-4 rounded-lg text-center">
                            <p class="text-xs text-text-secondary mb-1">Consecutive Wins</p>
                            <p id="perf-consecutive-wins" class="text-lg font-bold text-primary">0</p>
                        </div>
                        <div class="bg-surface-light p-4 rounded-lg text-center">
                            <p class="text-xs text-text-secondary mb-1">Consecutive Losses</p>
                            <p id="perf-consecutive-losses" class="text-lg font-bold text-red">0</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section id="informe" class="section-container">
            <!-- Filters -->
            <div class="section-toolbar">
                <div class="toolbar-left">
                    <div class="flex items-center gap-3">
                        <div id="informe-account-logo" class="w-14 h-14 rounded-xl flex items-center justify-center" style="display: none;">
                            <img id="informe-account-logo-img" src="" alt="" class="w-14 h-14 rounded-xl object-contain">
                        </div>
                        <select id="informe-account-select" class="w-48">
                            <option value="all">Todas las cuentas</option>
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <button id="informe-date-filter-btn" class="date-filter-trigger p-1" title="Filtrar por fecha">
                            <i class="fas fa-calendar-alt"></i>
                        </button>
                        <div id="informe-date-filter-display" class="text-sm text-text-secondary">Sin filtro de fecha</div>
                    </div>
                    
                    <div class="filter-group">
                        <select id="informe-currency-select" class="currency-selector">
                            <option value="USD">USD</option>
                            <option value="EUR">EUR</option>
                            <option value="%">%</option>
                        </select>
                    </div>
                </div>
                
                <div class="toolbar-right">
                    <button class="action-btn" id="informe-filters-btn">
                        <i class="fas fa-filter"></i>
                        <span>Filtros</span>
                    </button>
                    <button class="action-btn" id="informe-download-btn">
                        <i class="fas fa-download"></i>
                        <span>Descargar</span>
                    </button>
                </div>
            </div>

            <!-- Filter Panel -->
            <div id="informe-filters-panel" class="hidden bg-surface p-4 rounded-lg mb-6">
                <div class="grid grid-cols-1 md:grid-cols-3 lg:grid-cols-5 gap-4">
                    <!-- Symbol Filter -->
                    <div>
                        <label for="informe-filter-symbol" class="block text-sm font-medium text-text-secondary mb-1">Símbolo</label>
                        <input type="text" id="informe-filter-symbol" placeholder="Ej: EURUSD, BTCUSDT" class="w-full">
                    </div>
                    <!-- Operation Type Filter -->
                    <div>
                        <label for="informe-filter-type" class="block text-sm font-medium text-text-secondary mb-1">Tipo Operación</label>
                        <select id="informe-filter-type" class="w-full">
                            <option value="all">Todos</option>
                            <option value="buy">Long (Compra)</option>
                            <option value="sell">Short (Venta)</option>
                        </select>
                    </div>
                    <!-- Result Filter -->
                    <div>
                        <label for="informe-filter-result" class="block text-sm font-medium text-text-secondary mb-1">Resultado</label>
                        <select id="informe-filter-result" class="w-full">
                            <option value="all">Todos</option>
                            <option value="win">Ganancia</option>
                            <option value="loss">Pérdida</option>
                            <option value="breakeven">Breakeven</option>
                        </select>
                    </div>
                    <!-- P/L Range Filter -->
                    <div class="md:col-span-2 lg:col-span-2 grid grid-cols-2 gap-2">
                        <div>
                            <label for="informe-filter-pl-min" class="block text-sm font-medium text-text-secondary mb-1">P/L Mínimo</label>
                            <input type="number" id="informe-filter-pl-min" placeholder="Ej: -100" class="w-full">
                        </div>
                        <div>
                            <label for="informe-filter-pl-max" class="block text-sm font-medium text-text-secondary mb-1">P/L Máximo</label>
                            <input type="number" id="informe-filter-pl-max" placeholder="Ej: 500" class="w-full">
                        </div>
                    </div>
                    <!-- Day of Week Filter -->
                    <div>
                        <label for="informe-filter-day" class="block text-sm font-medium text-text-secondary mb-1">Día de la Semana</label>
                        <select id="informe-filter-day" class="w-full">
                            <option value="all">Todos</option>
                            <option value="1">Lunes</option>
                            <option value="2">Martes</option>
                            <option value="3">Miércoles</option>
                            <option value="4">Jueves</option>
                            <option value="5">Viernes</option>
                            <option value="6">Sábado</option>
                            <option value="0">Domingo</option>
                        </select>
                    </div>
                </div>
                <!-- Action Buttons -->
                <div class="flex justify-end gap-2 mt-4">
                    <button id="informe-apply-filters-btn" class="primary">Aplicar Filtros</button>
                    <button id="informe-clear-filters-btn" class="secondary">Limpiar</button>
                </div>
            </div>

            <!-- Sub-tabs for Informe section -->
            <div class="nav-tabs flex mb-6">
                <div class="nav-tab informe-sub-tab active" data-target="informe-informes-content">Informes</div>
                <div class="nav-tab informe-sub-tab" data-target="informe-metricas-content">Métricas</div>
                <div class="nav-tab informe-sub-tab" data-target="informe-metricas-avanzadas-content">Métricas Avanzadas</div>
                <div class="nav-tab informe-sub-tab" data-target="informe-simbolos-content">Símbolos</div>
                <div class="nav-tab informe-sub-tab" data-target="informe-tiempo-content">Tiempo</div>
                <div class="nav-tab informe-sub-tab" data-target="informe-graficos-content">Gráficos</div>
                <div class="nav-tab informe-sub-tab" data-target="informe-comisiones-content">Comisiones</div>
            </div>

            <!-- Tab Content -->
            <div id="informe-informes-content" class="informe-sub-section-container active">
                <!-- PnL Metrics Grid -->
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-8">
                    <!-- P&L Bruto Total -->
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">P&L Bruto Total</p>
                        <p class="text-xs text-text-secondary mb-2">Sin comisiones</p>
                        <p id="informe-total-pl" class="text-2xl font-bold text-positive">$0.00</p>
                    </div>
                    <!-- P&L Neto Total -->
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">P&L Neto Total</p>
                        <p class="text-xs text-text-secondary mb-2">Después de comisiones</p>
                        <p id="informe-realized-pl" class="text-2xl font-bold text-positive">$0.00</p>
                    </div>
                    <!-- PnL no realizado -->
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">PnL no realizado</p>
                        <p class="text-xs text-text-secondary mb-2">PnL</p>
                        <p id="informe-unrealized-pl" class="text-2xl font-bold text-neutral">$0.00</p>
                    </div>
                    <!-- Solo beneficio PnL -->
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">Solo beneficio PnL</p>
                        <p class="text-xs text-text-secondary mb-2">Solo pérdida PnL</p>
                        <p id="informe-only-win-pl" class="text-xl font-bold text-positive">$0.00</p>
                        <p id="informe-only-loss-pl" class="text-xl font-bold text-negative">$0.00</p>
                    </div>
                    <!-- Valor total de la cuenta -->
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">Valor total de la cuenta</p>
                        <p class="text-xs text-text-secondary mb-2">Balance inicial + PnL de operaciones</p>
                        <p id="informe-total-account-value" class="text-2xl font-bold text-positive">$0.00</p>
                    </div>
                    <!-- Transacciones monetarias totales -->
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">Transacciones monetarias totales</p>
                        <p class="text-xs text-text-secondary mb-2">Depósitos - retiros</p>
                        <p id="informe-total-monetary-transactions" class="text-2xl font-bold text-neutral">$0.00</p>
                    </div>
                    <!-- Depósitos totales -->
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">Depósitos totales</p>
                        <p class="text-xs text-text-secondary mb-2">Devolución de depósitos</p>
                        <p id="informe-total-deposits" class="text-2xl font-bold text-neutral">$0.00</p>
                    </div>
                    <!-- Retiros totales -->
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">Retiros totales</p>
                        <p class="text-xs text-text-secondary mb-2">&nbsp;</p>
                        <p id="informe-total-withdrawals" class="text-2xl font-bold text-neutral">$0.00</p>
                    </div>
                    <!-- PnL promedio por operación -->
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">PnL promedio por operación</p>
                        <p id="informe-avg-pl-trade" class="text-xl font-bold text-positive">$0.00</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">Promedio %</p>
                        <p id="informe-avg-pl-percentage" class="text-xl font-bold text-positive">0.00%</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">PnL PROMEDIO (Por día)</p>
                        <p id="informe-avg-pl-day" class="text-xl font-bold text-positive">$0.00</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">PnL PROMEDIO (Por mes)</p>
                        <p id="informe-avg-pl-month" class="text-xl font-bold text-positive">$0.00</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">PnL PROMEDIO (Por año)</p>
                        <p id="informe-avg-pl-year" class="text-xl font-bold text-positive">$0.00</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">PROMEDIO GANADOR PnL (Por operación)</p>
                        <p id="informe-avg-win-pl-trade" class="text-xl font-bold text-positive">$0.00</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">PROMEDIO GANADOR PnL (Por día)</p>
                        <p id="informe-avg-win-pl-day" class="text-xl font-bold text-positive">$0.00</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">PROMEDIO GANADOR PnL (Por mes)</p>
                        <p id="informe-avg-win-pl-month" class="text-xl font-bold text-positive">$0.00</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">PROMEDIO GANADOR PnL (Por año)</p>
                        <p id="informe-avg-win-pl-year" class="text-xl font-bold text-positive">$0.00</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">PÉRDIDA PROMEDIO PnL (Por operación)</p>
                        <p id="informe-avg-loss-pl-trade" class="text-xl font-bold text-negative">$0.00</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">PÉRDIDA PROMEDIO PnL (Por día)</p>
                        <p id="informe-avg-loss-pl-day" class="text-xl font-bold text-negative">$0.00</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">PÉRDIDA PROMEDIO PnL (Por mes)</p>
                        <p id="informe-avg-loss-pl-month" class="text-xl font-bold text-negative">$0.00</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">PÉRDIDA PROMEDIO PnL (Por año)</p>
                        <p id="informe-avg-loss-pl-year" class="text-xl font-bold text-neutral">$0.00</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">PROMEDIO GANADOR PnL % (Por operación)</p>
                        <p id="informe-avg-win-pl-percentage" class="text-xl font-bold text-positive">0.00%</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">PnL GANADOR TOTAL % (Por operación)</p>
                        <p id="informe-total-win-pl-percentage" class="text-xl font-bold text-positive">0.00%</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">PÉRDIDA PROMEDIO PnL % (Por operación)</p>
                        <p id="informe-avg-loss-pl-percentage" class="text-xl font-bold text-negative">0.00%</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">PÉRDIDA TOTAL PnL % (Por operación)</p>
                        <p id="informe-total-loss-pl-percentage" class="text-xl font-bold text-negative">0.00%</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">MEJOR GANADOR PnL (Por operación)</p>
                        <p id="informe-best-win-pl-trade" class="text-xl font-bold text-positive">$0.00</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">LA PEOR PÉRDIDA DE PnL (Por operación)</p>
                        <p id="informe-worst-loss-pl-trade" class="text-xl font-bold text-negative">$0.00</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">MEJOR GANADOR PnL (Por día)</p>
                        <p id="informe-best-win-pl-day" class="text-xl font-bold text-positive">$0.00</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">LA PEOR PÉRDIDA DE PnL (Por día)</p>
                        <p id="informe-worst-loss-pl-day" class="text-xl font-bold text-negative">$0.00</p>
                    </div>
                </div>

                <!-- Advanced Professional Metrics -->
                <!-- Detailed Metrics Grid -->
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-8">
                    <!-- Beneficio del último día -->
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">Beneficio del último día</p>
                        <p id="informe-last-day-pl" class="text-xl font-bold text-negative">$0.00</p>
                    </div>
                    <!-- Ganancias de la semana pasada -->
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">Ganancias de la semana pasada</p>
                        <p id="informe-last-week-pl" class="text-xl font-bold text-negative">$0.00</p>
                    </div>
                    <!-- Beneficio del mes pasado -->
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">Beneficio del mes pasado</p>
                        <p id="informe-last-month-pl" class="text-xl font-bold text-positive">$0.00</p>
                    </div>
                    <!-- Beneficio del año pasado -->
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">Beneficio del año pasado</p>
                        <p id="informe-last-year-pl" class="text-xl font-bold text-positive">$0.00</p>
                    </div>
                </div>

                <!-- Charts Section -->
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mt-8">
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-1">P&L Agregado por Símbolo (Mejores)</h3>
                        <p class="text-xs text-text-secondary mb-3">Top 10 instrumentos con mayor ganancia acumulada</p>
                        <div class="chart-container" style="height: 300px;">
                            <canvas id="informe-chart-pnl-desc"></canvas>
                        </div>
                    </div>
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-1">P&L Agregado por Símbolo (Peores)</h3>
                        <p class="text-xs text-text-secondary mb-3">Top 10 instrumentos con mayor pérdida acumulada</p>
                        <div class="chart-container" style="height: 300px;">
                            <canvas id="informe-chart-pnl-asc"></canvas>
                        </div>
                    </div>
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-1">Ganancias/Pérdidas por Símbolo (Mejor Ratio)</h3>
                        <p class="text-xs text-text-secondary mb-3">Instrumentos con mejor proporción de trades ganadores</p>
                        <div class="chart-container" style="height: 300px;">
                            <canvas id="informe-chart-wl-desc"></canvas>
                        </div>
                    </div>
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-1">Ganancias/Pérdidas por Símbolo (Peor Ratio)</h3>
                        <p class="text-xs text-text-secondary mb-3">Instrumentos con menor proporción de trades ganadores</p>
                        <div class="chart-container" style="height: 300px;">
                            <canvas id="informe-chart-wl-asc"></canvas>
                        </div>
                    </div>
                    
                    <!-- NUEVA GRÁFICA: Win Rate Long vs Short por Símbolo -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-1">Win Rate Long vs Short por Símbolo</h3>
                        <p class="text-xs text-text-secondary mb-3">Porcentaje de aciertos por instrumento separado por dirección (todos los símbolos operados)</p>
                        <div class="chart-container" style="height: 400px; overflow-y: auto;">
                            <canvas id="informe-chart-winrate-by-symbol"></canvas>
                        </div>
                    </div>
                    
                    <!-- NUEVA GRÁFICA: Promedio P&L por Trade por Símbolo -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-1">Promedio P&L por Trade - Long vs Short</h3>
                        <p class="text-xs text-text-secondary mb-3">Rendimiento promedio por operación en cada dirección (todos los símbolos operados)</p>
                        <div class="chart-container" style="height: 400px; overflow-y: auto;">
                            <canvas id="informe-chart-avgpl-by-symbol"></canvas>
                        </div>
                    </div>
                    
                    <!-- NUEVA GRÁFICA 1: P&L Long vs Short por Símbolo -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-1">P&L Long vs Short por Símbolo</h3>
                        <p class="text-xs text-text-secondary mb-3">Comparación de rendimiento entre operaciones largas y cortas por instrumento</p>
                        <div class="chart-container" style="height: 400px; overflow-y: auto;">
                            <canvas id="informe-chart-long-short-symbol"></canvas>
                        </div>
                    </div>
                    
                    <!-- NUEVA GRÁFICA 2: Win Rate Long vs Short -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-1">Win Rate: Long vs Short</h3>
                        <p class="text-xs text-text-secondary mb-3">Porcentaje de aciertos comparativo entre operaciones largas y cortas</p>
                        <div class="chart-container" style="height: 300px;">
                            <canvas id="informe-chart-winrate-long-short"></canvas>
                        </div>
                    </div>
                    
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-1">Volumen Agregado por Símbolo</h3>
                        <p class="text-xs text-text-secondary mb-3">Top 10 instrumentos más operados por volumen</p>
                        <div class="chart-container" style="height: 300px;">
                            <canvas id="informe-chart-volume-symbol"></canvas>
                        </div>
                    </div>
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-1">Volumen Diario</h3>
                        <p class="text-xs text-text-secondary mb-3">Evolución del volumen operado día a día</p>
                        <div class="chart-container" style="height: 300px;">
                            <canvas id="informe-chart-daily-volume"></canvas>
                        </div>
                    </div>
                </div>
            </div>
            <div id="informe-metricas-content" class="informe-sub-section-container">
                <div id="informe-metricas-data-view">
                    <h3 class="text-2xl font-bold mb-6 w-full text-left">Métricas Detalladas de Operaciones</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-8">
                        <div class="metric-card p-4">
                            <p class="text-sm text-text-secondary">Trades Totales</p>
                            <p id="informe-metricas-total-trades" class="text-2xl font-bold text-white">0</p>
                        </div>
                        <div class="metric-card p-4">
                            <p class="text-sm text-text-secondary">Trades Ganadores</p>
                            <p id="informe-metricas-winning-trades" class="text-2xl font-bold text-positive">0</p>
                            <p id="informe-metricas-winning-trades-percent" class="text-sm text-positive">0%</p>
                        </div>
                        <div class="metric-card p-4">
                            <p class="text-sm text-text-secondary">Trades Perdedores</p>
                            <p id="informe-metricas-losing-trades" class="text-2xl font-bold text-negative">0</p>
                            <p id="informe-metricas-losing-trades-percent" class="text-sm text-negative">0%</p>
                        </div>
                        <div class="metric-card p-4">
                            <p class="text-sm text-text-secondary">Trades Breakeven</p>
                            <p id="informe-metricas-breakeven-trades" class="text-2xl font-bold text-neutral">0</p>
                            <p id="informe-metricas-breakeven-trades-percent" class="text-sm text-neutral">0%</p>
                        </div>
                        <div class="metric-card p-4">
                            <p class="text-sm text-text-secondary">Trades Long</p>
                            <p id="informe-metricas-long-trades" class="text-2xl font-bold text-positive">0</p>
                            <p id="informe-metricas-long-trades-percent" class="text-sm text-positive">0%</p>
                        </div>
                        <div class="metric-card p-4">
                            <p class="text-sm text-text-secondary">Trades Short</p>
                            <p id="informe-metricas-short-trades" class="text-2xl font-bold text-negative">0</p>
                            <p id="informe-metricas-short-trades-percent" class="text-sm text-negative">0%</p>
                        </div>
                        <div class="metric-card p-4">
                            <p class="text-sm text-text-secondary">Días Ganadores</p>
                            <p id="informe-metricas-winning-days" class="text-2xl font-bold text-positive">0</p>
                            <p id="informe-metricas-winning-days-percent" class="text-sm text-positive">0%</p>
                        </div>
                        <div class="metric-card p-4">
                            <p class="text-sm text-text-secondary">Días Perdedores</p>
                            <p id="informe-metricas-losing-days" class="text-2xl font-bold text-negative">0</p>
                            <p id="informe-metricas-losing-days-percent" class="text-sm text-negative">0%</p>
                        </div>
                    </div>

                    <h3 class="text-2xl font-bold mb-6 w-full text-left">Promedios y Máximos de Operaciones</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-8">
                        <div class="metric-card p-4">
                            <p class="text-sm text-text-secondary">Trades Promedio / Día</p>
                            <p id="informe-metricas-avg-trades-day" class="text-2xl font-bold text-white">0.00</p>
                        </div>
                        <div class="metric-card p-4">
                            <p class="text-sm text-text-secondary">Trades Promedio / Mes</p>
                            <p id="informe-metricas-avg-trades-month" class="text-2xl font-bold text-white">0.00</p>
                        </div>
                        <div class="metric-card p-4">
                            <p class="text-sm text-text-secondary">Trades Promedio / Año</p>
                            <p id="informe-metricas-avg-trades-year" class="text-2xl font-bold text-white">0.00</p>
                        </div>
                        <div class="metric-card p-4">
                            <p class="text-sm text-text-secondary">Máx. Trades / Día</p>
                            <p id="informe-metricas-max-trades-day" class="text-2xl font-bold text-white">0</p>
                        </div>
                        <div class="metric-card p-4">
                            <p class="text-sm text-text-secondary">Máx. Trades / Mes</p>
                            <p id="informe-metricas-max-trades-month" class="text-2xl font-bold text-white">0</p>
                        </div>
                        <div class="metric-card p-4">
                            <p class="text-sm text-text-secondary">Máx. Trades / Año</p>
                            <p id="informe-metricas-max-trades-year" class="text-2xl font-bold text-white">0</p>
                        </div>
                    </div>

                    <!-- Métrica de Barra: Distribución Win/Loss -->
                    <div class="metric-card p-6 mb-8">
                        <h3 class="text-xl font-bold mb-4 text-white">Distribución de Resultados</h3>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                            <!-- Barra de distribución Win/Loss -->
                            <div class="md:col-span-2">
                                <div class="mb-4">
                                    <div class="flex justify-between mb-2">
                                        <span class="text-sm text-text-secondary">Operaciones Ganadoras</span>
                                        <span id="informe-win-count-bar" class="text-sm font-semibold text-green">0 (0%)</span>
                                    </div>
                                    <div class="w-full bg-surface-light rounded-full h-8 overflow-hidden">
                                        <div id="informe-win-bar" class="bg-gradient-to-r from-green-500 to-green-400 h-8 flex items-center justify-end px-3 transition-all duration-500" style="width: 0%">
                                            <span class="text-xs font-bold text-bg" id="informe-win-amount-bar">$0.00</span>
                                        </div>
                                    </div>
                                </div>
                                <div class="mb-4">
                                    <div class="flex justify-between mb-2">
                                        <span class="text-sm text-text-secondary">Operaciones Perdedoras</span>
                                        <span id="informe-loss-count-bar" class="text-sm font-semibold text-negative">0 (0%)</span>
                                    </div>
                                    <div class="w-full bg-surface-light rounded-full h-8 overflow-hidden">
                                        <div id="informe-loss-bar" class="bg-gradient-to-r from-red-500 to-red-400 h-8 flex items-center justify-end px-3 transition-all duration-500" style="width: 0%">
                                            <span class="text-xs font-bold text-bg" id="informe-loss-amount-bar">$0.00</span>
                                        </div>
                                    </div>
                                </div>
                                <div>
                                    <div class="flex justify-between mb-2">
                                        <span class="text-sm text-text-secondary">Break Even</span>
                                        <span id="informe-breakeven-count-bar" class="text-sm font-semibold text-text-secondary">0 (0%)</span>
                                    </div>
                                    <div class="w-full bg-surface-light rounded-full h-8 overflow-hidden">
                                        <div id="informe-breakeven-bar" class="bg-gradient-to-r from-gray-500 to-gray-400 h-8 flex items-center justify-end px-3 transition-all duration-500" style="width: 0%">
                                            <span class="text-xs font-bold text-bg" id="informe-breakeven-count-text">0</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <!-- Métricas complementarias -->
                            <div class="flex flex-col justify-center gap-4">
                                <div class="text-center p-4 bg-surface rounded-lg">
                                    <p class="text-xs text-text-secondary mb-1">Ratio Win/Loss</p>
                                    <p id="informe-win-loss-ratio-bar" class="text-2xl font-bold text-white">0.00</p>
                                </div>
                                <div class="text-center p-4 bg-surface rounded-lg">
                                    <p class="text-xs text-text-secondary mb-1">Expectativa Matemática</p>
                                    <p id="informe-math-expectancy-bar" class="text-2xl font-bold text-white">$0.00</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- NUEVA MÉTRICA DE BARRA 3: Distribución de Tipos de Operaciones -->
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                        <div class="metric-card">
                            <h3 class="text-lg font-semibold mb-2">Distribución de Tipos de Operaciones</h3>
                            <p class="text-xs text-text-secondary mb-3">Cantidad y P/L por tipo de posición (Long/Short)</p>
                            <div class="chart-container" style="height: 300px;">
                                <canvas id="informe-long-short-chart"></canvas>
                            </div>
                        </div>
                        
                        <div class="metric-card">
                            <h3 class="text-lg font-semibold mb-2">Estilos de Trading por Duración</h3>
                            <p class="text-xs text-text-secondary mb-3">Clasificación por tiempo de retención</p>
                            <div class="chart-container" style="height: 300px;">
                                <canvas id="informe-trading-styles-chart"></canvas>
                            </div>
                        </div>
                    </div>

                    <h3 class="text-2xl font-bold mb-6 w-full text-left">Rendimiento General</h3>
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                        <div class="metric-card lg:col-span-1">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <h3 class="text-lg font-semibold">Evolución de la Cuenta</h3>
                                <button onclick="openFullscreenChart('informe-metricas-evolution-chart', 'Evolución de la Cuenta - Informe')" style="background: #39FF14; color: black; border: none; padding: 5px 12px; border-radius: 5px; cursor: pointer; font-size: 11px; font-weight: bold;">
                                    <i class="fas fa-expand"></i>
                                </button>
                            </div>
                            <div class="time-range-buttons mb-3 text-sm">
                                <button data-range="1W" class="time-range-btn">1S</button>
                                <button data-range="1M" class="time-range-btn">1M</button>
                                <button data-range="3M" class="time-range-btn">3M</button>
                                <button data-range="6M" class="time-range-btn">6M</button>
                                <button data-range="1Y" class="time-range-btn">1A</button>
                                <button data-range="ALL" class="time-range-btn active">Todo</button>
                            </div>
                            <div class="chart-container" style="height: 350px;">
                                <canvas id="informe-metricas-evolution-chart"></canvas>
                            </div>
                        </div>

                        <div class="metric-card">
                            <h3 class="text-lg font-semibold mb-2">Puntuación de Rendimiento</h3>
                            <div class="chart-container" style="height: 350px;">
                                <canvas id="informe-metricas-radar-chart"></canvas>
                            </div>
                        </div>
                    </div>

                    <!-- Nuevos módulos de Reducción acumulada y P&L acumulado -->
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                        <div class="metric-card">
                            <h3 class="text-lg font-semibold mb-2">Reducción acumulada</h3>
                            <div class="time-range-buttons mb-3 text-sm">
                                <button data-range="1W" class="time-range-btn drawdown-range-btn">1S</button>
                                <button data-range="1M" class="time-range-btn drawdown-range-btn">1M</button>
                                <button data-range="3M" class="time-range-btn drawdown-range-btn">3M</button>
                                <button data-range="6M" class="time-range-btn drawdown-range-btn">6M</button>
                                <button data-range="1Y" class="time-range-btn drawdown-range-btn">1A</button>
                                <button data-range="ALL" class="time-range-btn drawdown-range-btn active">Todo</button>
                            </div>
                            <div class="chart-container" style="height: 350px;">
                                <canvas id="reduccion-acumulada-chart"></canvas>
                            </div>
                        </div>

                        <div class="metric-card">
                            <h3 class="text-lg font-semibold mb-2">P&L acumulado</h3>
                            <div class="time-range-buttons mb-3 text-sm">
                                <button data-range="1W" class="time-range-btn pnl-range-btn">1S</button>
                                <button data-range="1M" class="time-range-btn pnl-range-btn">1M</button>
                                <button data-range="3M" class="time-range-btn pnl-range-btn">3M</button>
                                <button data-range="6M" class="time-range-btn pnl-range-btn">6M</button>
                                <button data-range="1Y" class="time-range-btn pnl-range-btn">1A</button>
                                <button data-range="ALL" class="time-range-btn pnl-range-btn active">Todo</button>
                            </div>
                            <div class="chart-container" style="height: 350px;">
                                <canvas id="pnl-acumulado-chart"></canvas>
                            </div>
                        </div>
                    </div>

                    <!-- Nuevos gráficos: P&L Neto Diario y Wins/Losses por Día -->
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                        <div class="metric-card">
                            <h3 class="text-lg font-semibold mb-2">P&L Neto Diario</h3>
                            <div class="chart-container" style="height: 350px;">
                                <canvas id="cuentas-daily-pnl-chart"></canvas>
                            </div>
                        </div>

                        <div class="metric-card">
                            <h3 class="text-lg font-semibold mb-2">Victorias/Derrotas por Día</h3>
                            <div class="chart-container" style="height: 350px;">
                                <canvas id="cuentas-daily-winloss-chart"></canvas>
                            </div>
                        </div>
                    </div>
                    
                    <!-- NUEVAS MÉTRICAS CRÍTICAS DE GESTIÓN DE RIESGO -->
                    <h3 class="text-2xl font-bold mb-6 w-full text-left mt-8">Gestión de Riesgo y Capital</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-8">
                        <div class="metric-card p-4">
                            <p class="text-sm text-text-secondary">Tamaño Promedio de Posición</p>
                            <p class="text-xs text-text-secondary mb-2">Lotes/Contratos promedio</p>
                            <p id="informe-metricas-avg-position-size" class="text-2xl font-bold text-white">0.00</p>
                        </div>
                        <div class="metric-card p-4">
                            <p class="text-sm text-text-secondary">Riesgo Promedio por Trade</p>
                            <p class="text-xs text-text-secondary mb-2">% del capital arriesgado</p>
                            <p id="informe-metricas-avg-risk-percent" class="text-2xl font-bold text-yellow">0.00%</p>
                        </div>
                        <div class="metric-card p-4">
                            <p class="text-sm text-text-secondary">R:R Promedio Realizado</p>
                            <p class="text-xs text-text-secondary mb-2">Reward to Risk real</p>
                            <p id="informe-metricas-avg-rr-realized" class="text-2xl font-bold text-primary">0.00</p>
                        </div>
                        <div class="metric-card p-4">
                            <p class="text-sm text-text-secondary">Capital Utilizado Promedio</p>
                            <p class="text-xs text-text-secondary mb-2">% de cuenta en uso</p>
                            <p id="informe-metricas-capital-usage" class="text-2xl font-bold text-white">0.00%</p>
                        </div>
                    </div>
                    
                    <!-- Gráficas de Gestión de Riesgo -->
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                        <div class="metric-card">
                            <h3 class="text-lg font-semibold mb-2">Distribución de Tamaño de Posición</h3>
                            <p class="text-xs text-text-secondary mb-3">Cantidad de trades por rango de tamaño</p>
                            <div class="chart-container" style="height: 350px;">
                                <canvas id="informe-metricas-position-size-distribution-chart"></canvas>
                            </div>
                        </div>
                        
                        <div class="metric-card">
                            <h3 class="text-lg font-semibold mb-2">P/L por Nivel de Riesgo</h3>
                            <p class="text-xs text-text-secondary mb-3">Rendimiento según % de capital arriesgado</p>
                            <div class="chart-container" style="height: 350px;">
                                <canvas id="informe-metricas-pl-by-risk-chart"></canvas>
                            </div>
                        </div>
                    </div>
                    
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                        <div class="metric-card">
                            <h3 class="text-lg font-semibold mb-2">R:R Realizado vs Planificado</h3>
                            <p class="text-xs text-text-secondary mb-3">Comparación entre objetivo y resultado real</p>
                            <div class="chart-container" style="height: 350px;">
                                <canvas id="informe-metricas-rr-comparison-chart"></canvas>
                            </div>
                        </div>
                        
                        <div class="metric-card">
                            <h3 class="text-lg font-semibold mb-2">Rendimiento por Capital Utilizado</h3>
                            <p class="text-xs text-text-secondary mb-3">P/L promedio vs % de capital en uso</p>
                            <div class="chart-container" style="height: 350px;">
                                <canvas id="informe-metricas-capital-efficiency-chart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
                <div id="informe-metricas-no-data" class="text-center p-8 text-text-secondary" style="display: none;">
                    No hay datos de operaciones para mostrar en el período o cuenta seleccionada.
                </div>
            </div>
            
            <!-- Nueva Sección: MÉTRICAS AVANZADAS -->
            <div id="informe-metricas-avanzadas-content" class="informe-sub-section-container">
                <h3 class="text-2xl font-bold mb-6 text-white">Métricas Profesionales Avanzadas</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-8">
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">Expectancy Ratio</p>
                        <p class="text-xs text-text-secondary mb-2">Ganancia esperada por trade</p>
                        <p id="informe-expectancy-ratio" class="text-2xl font-bold text-positive">$0.00</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">Kelly Criterion %</p>
                        <p class="text-xs text-text-secondary mb-2">Óptimo % de riesgo por trade</p>
                        <p id="informe-kelly-criterion" class="text-2xl font-bold text-primary">0.00%</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">Sharpe Ratio</p>
                        <p class="text-xs text-text-secondary mb-2">Retorno ajustado por riesgo</p>
                        <p id="informe-sharpe-ratio" class="text-2xl font-bold text-white">0.00</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">Sortino Ratio</p>
                        <p class="text-xs text-text-secondary mb-2">Retorno vs downside risk</p>
                        <p id="informe-sortino-ratio" class="text-2xl font-bold text-white">0.00</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">Calmar Ratio</p>
                        <p class="text-xs text-text-secondary mb-2">Retorno anual / Max DD</p>
                        <p id="informe-calmar-ratio" class="text-2xl font-bold text-white">0.00</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">Recovery Factor</p>
                        <p class="text-xs text-text-secondary mb-2">Ganancia neta / Max DD</p>
                        <p id="informe-recovery-factor" class="text-2xl font-bold text-positive">0.00</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">Risk of Ruin %</p>
                        <p class="text-xs text-text-secondary mb-2">Probabilidad de ruina</p>
                        <p id="informe-risk-of-ruin" class="text-2xl font-bold text-red">0.00%</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">Z-Score</p>
                        <p class="text-xs text-text-secondary mb-2">Consistencia de resultados</p>
                        <p id="informe-z-score" class="text-2xl font-bold text-white">0.00</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">MAE Promedio</p>
                        <p class="text-xs text-text-secondary mb-2">Max Adverse Excursion</p>
                        <p id="informe-avg-mae" class="text-2xl font-bold text-red">$0.00</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">MFE Promedio</p>
                        <p class="text-xs text-text-secondary mb-2">Max Favorable Excursion</p>
                        <p id="informe-avg-mfe" class="text-2xl font-bold text-green">$0.00</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">Racha Ganadora Máxima</p>
                        <p class="text-xs text-text-secondary mb-2">Consecutivos</p>
                        <p id="informe-max-win-streak" class="text-2xl font-bold text-positive">0</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">Racha Perdedora Máxima</p>
                        <p class="text-xs text-text-secondary mb-2">Consecutivos</p>
                        <p id="informe-max-loss-streak" class="text-2xl font-bold text-negative">0</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">Consistency Score</p>
                        <p class="text-xs text-text-secondary mb-2">0-100 (más alto = mejor)</p>
                        <p id="informe-consistency-score" class="text-2xl font-bold text-primary">0</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">Payoff Ratio</p>
                        <p class="text-xs text-text-secondary mb-2">Avg Win / Avg Loss</p>
                        <p id="informe-payoff-ratio" class="text-2xl font-bold text-white">0.00</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">Tiempo Total Operando</p>
                        <p class="text-xs text-text-secondary mb-2">Días activos</p>
                        <p id="informe-total-trading-days" class="text-2xl font-bold text-white">0</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">R-Múltiplo Promedio</p>
                        <p class="text-xs text-text-secondary mb-2">Retorno vs riesgo inicial</p>
                        <p id="informe-avg-r-multiple" class="text-2xl font-bold text-white">0.00R</p>
                    </div>
                </div>

                <!-- NUEVAS MÉTRICAS DE BARRA 1 y 2 -->
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                    <!-- MÉTRICA 1: Distribución de P/L por Rango -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-2">Distribución de P/L por Rango</h3>
                        <p class="text-xs text-text-secondary mb-3">Cantidad de trades por rango de resultado</p>
                        <div class="chart-container" style="height: 350px;">
                            <canvas id="informe-pl-range-chart"></canvas>
                        </div>
                    </div>

                    <!-- MÉTRICA 2: Distribución de Volumen por Rango -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-2">Distribución de Volumen por Rango</h3>
                        <p class="text-xs text-text-secondary mb-3">Cantidad de trades por tamaño de lote</p>
                        <div class="chart-container" style="height: 350px;">
                            <canvas id="informe-volume-range-chart"></canvas>
                        </div>
                    </div>
                </div>

                <!-- NUEVA MÉTRICA DE BARRA 6: Distribución de Riesgo/Recompensa -->
                <div class="mb-8">
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-2">Distribución de Riesgo/Recompensa (R:R)</h3>
                        <p class="text-xs text-text-secondary mb-3">Cantidad de trades por ratio Riesgo/Recompensa planificado</p>
                        <div class="chart-container" style="height: 350px;">
                            <canvas id="informe-rr-chart"></canvas>
                        </div>
                    </div>
                </div>

                <h3 class="text-2xl font-bold mb-6 mt-8 text-white">Análisis Estadístico Avanzado</h3>
                
                <!-- Grid de 4 gráficas de barras -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <!-- Gráfica 1: Rachas Ganadoras/Perdedoras por Tipo (Long/Short) -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-3 text-gray-200">Rachas por Tipo de Posición</h3>
                        <p class="text-xs text-text-secondary mb-3">Máxima racha de wins/losses en Long y Short</p>
                        <div class="chart-container" style="height: 300px;">
                            <canvas id="metricas-avanzadas-rachas-chart"></canvas>
                        </div>
                    </div>
                    
                    <!-- Gráfica 2: Volumen de Ganancias/Pérdidas Temporal -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-3 text-gray-200">Volumen P/L por Período</h3>
                        <p class="text-xs text-text-secondary mb-3">Ganancias vs Pérdidas en día, semana y mes</p>
                        <div class="chart-container" style="height: 300px;">
                            <canvas id="metricas-avanzadas-volumen-chart"></canvas>
                        </div>
                    </div>
                    
                    <!-- Gráfica 3: Distribución de P/L por Sesión de Trading -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-3 text-gray-200">Rendimiento por Sesión</h3>
                        <p class="text-xs text-text-secondary mb-3">P/L promedio en sesión Asiática, Europea y Americana</p>
                        <div class="chart-container" style="height: 300px;">
                            <canvas id="metricas-avanzadas-sesiones-chart"></canvas>
                        </div>
                    </div>
                    
                    <!-- Gráfica 4: Win Rate por Rango Horario -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-3 text-gray-200">Win Rate por Franja Horaria</h3>
                        <p class="text-xs text-text-secondary mb-3">Porcentaje de éxito en intervalos de 4 horas</p>
                        <div class="chart-container" style="height: 300px;">
                            <canvas id="metricas-avanzadas-winrate-horario-chart"></canvas>
                        </div>
                    </div>
                </div>
                
                <!-- ANÁLISIS PSICOLÓGICO Y COMPORTAMIENTO -->
                <h3 class="text-2xl font-bold mb-6 mt-8 text-white">Análisis Psicológico y Comportamiento</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-8">
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">Racha Actual</p>
                        <p class="text-xs text-text-secondary mb-2">Wins o Losses consecutivos actuales</p>
                        <p id="informe-current-streak" class="text-2xl font-bold text-white">0</p>
                        <p id="informe-current-streak-type" class="text-xs text-text-secondary mt-1">N/A</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">Semanas Positivas Consecutivas</p>
                        <p class="text-xs text-text-secondary mb-2">Máximo de semanas seguidas en positivo</p>
                        <p id="informe-max-positive-weeks" class="text-2xl font-bold text-green">0</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">Semanas Negativas Consecutivas</p>
                        <p class="text-xs text-text-secondary mb-2">Máximo de semanas seguidas en negativo</p>
                        <p id="informe-max-negative-weeks" class="text-2xl font-bold text-red">0</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">Índice de Overtrading</p>
                        <p class="text-xs text-text-secondary mb-2">% de días con >10 operaciones</p>
                        <p id="informe-overtrading-index" class="text-2xl font-bold text-yellow">0%</p>
                    </div>
                </div>
                
                <!-- Gráficas de Análisis Psicológico -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
                    <!-- P/L Después de Wins Consecutivos -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-3 text-gray-200">P/L Después de Rachas Ganadoras</h3>
                        <p class="text-xs text-text-secondary mb-3">Rendimiento del siguiente trade después de N wins consecutivos</p>
                        <div class="chart-container" style="height: 300px;">
                            <canvas id="metricas-avanzadas-pl-after-wins-chart"></canvas>
                        </div>
                    </div>
                    
                    <!-- P/L Después de Losses Consecutivos -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-3 text-gray-200">P/L Después de Rachas Perdedoras</h3>
                        <p class="text-xs text-text-secondary mb-3">Rendimiento del siguiente trade después de N losses consecutivos</p>
                        <div class="chart-container" style="height: 300px;">
                            <canvas id="metricas-avanzadas-pl-after-losses-chart"></canvas>
                        </div>
                    </div>
                    
                    <!-- Revenge Trading Detector -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-3 text-gray-200">Detector de Revenge Trading</h3>
                        <p class="text-xs text-text-secondary mb-3">P/L en trades tomados <30min después de una pérdida</p>
                        <div class="chart-container" style="height: 300px;">
                            <canvas id="metricas-avanzadas-revenge-trading-chart"></canvas>
                        </div>
                    </div>
                    
                    <!-- Overtrading Analysis -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-3 text-gray-200">Análisis de Overtrading</h3>
                        <p class="text-xs text-text-secondary mb-3">P/L promedio vs número de operaciones por día</p>
                        <div class="chart-container" style="height: 300px;">
                            <canvas id="metricas-avanzadas-overtrading-chart"></canvas>
                        </div>
                    </div>
                </div>

                <!-- Nuevas Gráficas: Distribución de P/L y Performance Mensual -->
                <h3 class="text-2xl font-bold mb-6 mt-8 text-white">Análisis de Rendimiento</h3>
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                    <!-- Distribución de P/L (Histograma) -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-3 text-gray-200">Distribución de P/L</h3>
                        <p class="text-xs text-text-secondary mb-3">Histograma de ganancias y pérdidas por trade</p>
                        <div class="chart-container" style="height: 400px;">
                            <canvas id="pl-distribution-histogram-chart"></canvas>
                        </div>
                    </div>
                    
                    <!-- Performance por Mes (Barras comparativas) -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-3 text-gray-200">Performance por Mes</h3>
                        <p class="text-xs text-text-secondary mb-3">Comparación de P/L mensual (Ganancias vs Pérdidas)</p>
                        <div class="chart-container" style="height: 400px;">
                            <canvas id="monthly-performance-chart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
            
            <div id="informe-simbolos-content" class="informe-sub-section-container">
                <!-- Contenido dinámico generado por refreshSimbolos() -->
            </div>
            
            <!-- Nueva Sección: TIEMPO -->
            <div id="informe-tiempo-content" class="informe-sub-section-container">
                <h3 class="text-2xl font-bold mb-4">Métricas de Tiempo</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-8">
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">Duración Win Promedio</p>
                        <p class="text-xs text-text-secondary mb-2">Tiempo promedio en trades ganadores</p>
                        <p id="informe-tiempo-avg-win-duration" class="text-2xl font-bold text-green">N/A</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">Duración Loss Promedio</p>
                        <p class="text-xs text-text-secondary mb-2">Tiempo promedio en trades perdedores</p>
                        <p id="informe-tiempo-avg-loss-duration" class="text-2xl font-bold text-red">N/A</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">Mejor Hora de Trading</p>
                        <p class="text-xs text-text-secondary mb-2">Hora con mayor P/L total</p>
                        <p id="informe-tiempo-best-hour" class="text-2xl font-bold text-green">N/A</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">Peor Hora de Trading</p>
                        <p class="text-xs text-text-secondary mb-2">Hora con menor P/L total</p>
                        <p id="informe-tiempo-worst-hour" class="text-2xl font-bold text-red">N/A</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">Trade Ganador Más Largo</p>
                        <p class="text-xs text-text-secondary mb-2">Máxima duración en trade ganador</p>
                        <p id="informe-tiempo-longest-win" class="text-2xl font-bold text-white">N/A</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">Trade Perdedor Más Largo</p>
                        <p class="text-xs text-text-secondary mb-2">Máxima duración en trade perdedor</p>
                        <p id="informe-tiempo-longest-loss" class="text-2xl font-bold text-white">N/A</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">Trade Ganador Más Rápido</p>
                        <p class="text-xs text-text-secondary mb-2">Mínima duración en trade ganador</p>
                        <p id="informe-tiempo-fastest-win" class="text-2xl font-bold text-green">N/A</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">Tiempo Promedio por Trade</p>
                        <p class="text-xs text-text-secondary mb-2">Duración promedio de todos los trades</p>
                        <p id="informe-tiempo-avg-trade-duration" class="text-2xl font-bold text-white">N/A</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">Tiempo Inactivo Total</p>
                        <p class="text-xs text-text-secondary mb-2">Tiempo acumulado esperando entre trades</p>
                        <p id="informe-tiempo-inactive-time" class="text-2xl font-bold text-white">0h</p>
                    </div>
                </div>

                <!-- Gráficas de Tiempo -->
                <h3 class="text-2xl font-bold mb-4 mt-8">Análisis Visual de Tiempo</h3>
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-2">Duración Promedio: Wins vs Losses</h3>
                        <p class="text-xs text-text-secondary mb-3">Comparación de tiempo en trades ganadores y perdedores</p>
                        <div class="chart-container" style="height: 300px;">
                            <canvas id="tiempo-duration-comparison-chart"></canvas>
                        </div>
                    </div>
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-2">Rendimiento por Hora del Día</h3>
                        <p class="text-xs text-text-secondary mb-3">P/L total por cada hora (00:00 - 23:00)</p>
                        <div class="chart-container" style="height: 300px;">
                            <canvas id="tiempo-hourly-pl-chart"></canvas>
                        </div>
                    </div>
                </div>
                
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-2">Rendimiento por Día de la Semana</h3>
                        <p class="text-xs text-text-secondary mb-3">P/L total por día (Lunes - Domingo)</p>
                        <div class="chart-container" style="height: 300px;">
                            <canvas id="tiempo-daily-pl-chart"></canvas>
                        </div>
                    </div>
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-2">Distribución de Duración de Trades</h3>
                        <p class="text-xs text-text-secondary mb-3">Cantidad de trades por rango de duración</p>
                        <div class="chart-container" style="height: 300px;">
                            <canvas id="tiempo-duration-distribution-chart"></canvas>
                        </div>
                    </div>
                    
                    <!-- NUEVO: Distribución de Resultado por Rango de Duración -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-2">Resultado por Rango de Duración</h3>
                        <p class="text-xs text-text-secondary mb-3">P/L promedio según duración del trade</p>
                        <div class="chart-container" style="height: 300px;">
                            <canvas id="tiempo-pl-by-duration-chart"></canvas>
                        </div>
                    </div>

                    <!-- NUEVA MÉTRICA: Tiempo Inactivo Total -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-2">Tiempo Inactivo Total</h3>
                        <p class="text-xs text-text-secondary mb-3">Tiempo acumulado esperando entre trades - Mide tu disciplina y paciencia</p>
                        <div class="flex flex-col items-center justify-center h-full" style="height: 300px;">
                            <div class="text-center">
                                <p class="text-xs text-text-secondary mb-3">Total de Tiempo Inactivo</p>
                                <p id="informe-tiempo-inactive-time-chart" class="text-6xl font-bold text-primary mb-4">0h</p>
                                <div class="grid grid-cols-2 gap-4 mt-6">
                                    <div class="p-3 bg-surface rounded-lg">
                                        <p class="text-xs text-text-secondary mb-1">Tiempo Promedio entre Trades</p>
                                        <p id="informe-tiempo-avg-inactive" class="text-xl font-bold text-white">0h</p>
                                    </div>
                                    <div class="p-3 bg-surface rounded-lg">
                                        <p class="text-xs text-text-secondary mb-1">Máximo Tiempo Inactivo</p>
                                        <p id="informe-tiempo-max-inactive" class="text-xl font-bold text-white">0h</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- NUEVAS MÉTRICAS DE BARRA 4 y 7 -->
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                    <!-- MÉTRICA 4: Distribución de Sesiones de Trading -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-2">Distribución de Sesiones de Trading</h3>
                        <p class="text-xs text-text-secondary mb-3">Cantidad y rendimiento por sesión horaria global</p>
                        <div class="chart-container" style="height: 300px;">
                            <canvas id="informe-sessions-chart"></canvas>
                        </div>
                    </div>

                    <!-- MÉTRICA 7: Distribución Temporal de Actividad -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-2">Distribución Temporal de Actividad</h3>
                        <p class="text-xs text-text-secondary mb-3">Cantidad de trades y rendimiento por día de la semana</p>
                        <div class="chart-container" style="height: 300px;">
                            <canvas id="informe-weekday-chart"></canvas>
                        </div>
                    </div>
                </div>

                <!-- HEAT MAP: HORA × DÍA DE LA SEMANA -->
                <div class="metric-card mb-8">
                    <h3 class="text-lg font-semibold mb-2">🔥 Heat Map: Rendimiento por Hora y Día</h3>
                    <p class="text-xs text-text-secondary mb-4">P/L acumulado por hora del día y día de la semana - Identifica tus mejores/peores momentos para operar</p>
                    
                    <div id="tiempo-heatmap-container" class="overflow-x-auto">
                        <!-- Heat map se generará dinámicamente -->
                    </div>
                    
                    <div class="mt-4 flex items-center justify-center gap-4 text-xs flex-wrap">
                        <div class="flex items-center gap-2">
                            <div class="w-4 h-4 rounded" style="background: #ff4136;"></div>
                            <span>Pérdidas grandes</span>
                        </div>
                        <div class="flex items-center gap-2">
                            <div class="w-4 h-4 rounded" style="background: #ff8577;"></div>
                            <span>Pérdidas pequeñas</span>
                        </div>
                        <div class="flex items-center gap-2">
                            <div class="w-4 h-4 rounded" style="background: #2a2a2a;"></div>
                            <span>Sin datos</span>
                        </div>
                        <div class="flex items-center gap-2">
                            <div class="w-4 h-4 rounded" style="background: #85e085;"></div>
                            <span>Ganancias pequeñas</span>
                        </div>
                        <div class="flex items-center gap-2">
                            <div class="w-4 h-4 rounded" style="background: #2ecc40;"></div>
                            <span>Ganancias grandes</span>
                        </div>
                    </div>
                </div>
                
                <!-- NUEVO: Gráfico Scatter - Calidad de Ejecución -->
                <div class="metric-card mb-8">
                    <h3 class="text-lg font-semibold mb-2">📊 Calidad de Ejecución: Duración vs Resultado</h3>
                    <p class="text-xs text-text-secondary mb-4">Análisis de la relación entre tiempo de retención y resultado en múltiplos de riesgo (R). Identifica si cierras muy rápido las ganadoras o mantienes mucho tiempo las perdedoras.</p>
                    <div class="chart-container" style="height: 400px;">
                        <canvas id="tiempo-execution-quality-scatter"></canvas>
                    </div>
                    <div class="mt-4 grid grid-cols-2 md:grid-cols-4 gap-4 text-xs">
                        <div class="p-3 bg-surface rounded-lg">
                            <p class="text-text-secondary mb-1">Zona Óptima</p>
                            <p class="font-bold text-green">Duración media con R+ alto</p>
                        </div>
                        <div class="p-3 bg-surface rounded-lg">
                            <p class="text-text-secondary mb-1">Problema Común</p>
                            <p class="font-bold text-red">Pérdidas largas (mantener esperanza)</p>
                        </div>
                        <div class="p-3 bg-surface rounded-lg">
                            <p class="text-text-secondary mb-1">Oportunidad</p>
                            <p class="font-bold text-yellow">Ganancias cortas (dejar correr)</p>
                        </div>
                        <div class="p-3 bg-surface rounded-lg">
                            <p class="text-text-secondary mb-1">Total Trades</p>
                            <p id="tiempo-scatter-total-trades" class="font-bold text-white">0</p>
                        </div>
                    </div>
                </div>

                <!-- NUEVAS MÉTRICAS CRÍTICAS DE TIEMPO -->
                <h3 class="text-2xl font-bold mb-4 mt-8">Análisis de Exposición y Sesiones</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-8">
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">Tiempo en Mercado</p>
                        <p class="text-xs text-text-secondary mb-2">Total de horas operando</p>
                        <p id="informe-tiempo-market-exposure" class="text-2xl font-bold text-primary">0h</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">Exposición Promedio/Trade</p>
                        <p class="text-xs text-text-secondary mb-2">Duración media en mercado</p>
                        <p id="informe-tiempo-avg-exposure" class="text-2xl font-bold text-white">0h</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">Mejor Sesión</p>
                        <p class="text-xs text-text-secondary mb-2">Sesión con mayor P/L</p>
                        <p id="informe-tiempo-best-session" class="text-2xl font-bold text-green">N/A</p>
                    </div>
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">Peor Sesión</p>
                        <p class="text-xs text-text-secondary mb-2">Sesión con menor P/L</p>
                        <p id="informe-tiempo-worst-session" class="text-2xl font-bold text-red">N/A</p>
                    </div>
                </div>
                
                <!-- Gráficas de Sesiones y Exposición -->
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-2">P/L por Sesión de Mercado</h3>
                        <p class="text-xs text-text-secondary mb-3">Rendimiento en sesión Asiática (00-08), Europea (08-16), Americana (16-00)</p>
                        <div class="chart-container" style="height: 300px;">
                            <canvas id="tiempo-session-pl-chart"></canvas>
                        </div>
                    </div>
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-2">Trades por Sesión de Mercado</h3>
                        <p class="text-xs text-text-secondary mb-3">Cantidad de operaciones por sesión</p>
                        <div class="chart-container" style="height: 300px;">
                            <canvas id="tiempo-session-count-chart"></canvas>
                        </div>
                    </div>
                </div>
                
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-2">Tiempo en Mercado: Wins vs Losses</h3>
                        <p class="text-xs text-text-secondary mb-3">Comparación de exposición en operaciones ganadoras y perdedoras</p>
                        <div class="chart-container" style="height: 300px;">
                            <canvas id="tiempo-exposure-comparison-chart"></canvas>
                        </div>
                    </div>
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-2">Win Rate por Sesión de Mercado</h3>
                        <p class="text-xs text-text-secondary mb-3">Porcentaje de éxito en cada sesión</p>
                        <div class="chart-container" style="height: 300px;">
                            <canvas id="tiempo-session-winrate-chart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
            
            <div id="informe-graficos-content" class="informe-sub-section-container">
                <div class="mt-6">
                    <h3 class="text-2xl font-bold mb-6 text-white">Análisis Visual Avanzado</h3>
                    
                    <!-- RENDIMIENTO TEMPORAL -->
                    <div class="mb-8">
                        <h4 class="text-lg font-semibold mb-6 text-gray-300">Rendimiento Temporal</h4>
                        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                            <!-- Ganancias por Semana -->
                            <div class="metric-card p-6">
                                <div class="mb-4">
                                    <h3 class="text-xl font-bold text-white mb-2">Ganancias por Semana</h3>
                                    <p class="text-sm text-text-secondary">Distribución de P&L semanal</p>
                                </div>
                                <div class="mb-4 grid grid-cols-2 gap-3">
                                    <div class="p-3 bg-surface rounded-lg">
                                        <p class="text-xs text-text-secondary mb-1">Mejor Semana</p>
                                        <p id="best-week-value" class="text-xl font-bold text-green">$0.00</p>
                                    </div>
                                    <div class="p-3 bg-surface rounded-lg">
                                        <p class="text-xs text-text-secondary mb-1">Peor Semana</p>
                                        <p id="worst-week-value" class="text-xl font-bold text-red">$0.00</p>
                                    </div>
                                </div>
                                <div class="chart-container" style="height: 320px;">
                                    <canvas id="ganancias-semana-chart"></canvas>
                                </div>
                            </div>
                            
                            <!-- Ganancias por Mes -->
                            <div class="metric-card p-6">
                                <div class="mb-4">
                                    <h3 class="text-xl font-bold text-white mb-2">Ganancias por Mes</h3>
                                    <p class="text-sm text-text-secondary">Evolución mensual del rendimiento</p>
                                </div>
                                <div class="mb-4 grid grid-cols-2 gap-3">
                                    <div class="p-3 bg-surface rounded-lg">
                                        <p class="text-xs text-text-secondary mb-1">Mejor Mes</p>
                                        <p id="best-month-value" class="text-xl font-bold text-green">$0.00</p>
                                    </div>
                                    <div class="p-3 bg-surface rounded-lg">
                                        <p class="text-xs text-text-secondary mb-1">Peor Mes</p>
                                        <p id="worst-month-value" class="text-xl font-bold text-red">$0.00</p>
                                    </div>
                                </div>
                                <div class="chart-container" style="height: 320px;">
                                    <canvas id="ganancias-mes-chart"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- ANÁLISIS DE PATRONES -->
                    <div class="mb-8">
                        <h4 class="text-lg font-semibold mb-6 text-gray-300">Análisis de Patrones</h4>
                        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                            <!-- Posición (Largo vs Corto) -->
                            <div class="metric-card p-6">
                                <div class="mb-4">
                                    <h3 class="text-xl font-bold text-white mb-2">Posición (Largo vs Corto)</h3>
                                    <p class="text-sm text-text-secondary">Distribución de direcciones operadas</p>
                                </div>
                                <div class="mb-4 grid grid-cols-2 gap-3">
                                    <div class="p-3 bg-surface rounded-lg">
                                        <p class="text-xs text-text-secondary mb-1">Longs</p>
                                        <p id="long-count" class="text-xl font-bold text-green">0</p>
                                    </div>
                                    <div class="p-3 bg-surface rounded-lg">
                                        <p class="text-xs text-text-secondary mb-1">Shorts</p>
                                        <p id="short-count" class="text-xl font-bold text-red">0</p>
                                    </div>
                                </div>
                                <div class="chart-container" style="height: 320px;">
                                    <canvas id="posicion-chart"></canvas>
                                </div>
                            </div>
                            
                            <!-- Operaciones por Hora del Día -->
                            <div class="metric-card p-6">
                                <div class="mb-4">
                                    <h3 class="text-xl font-bold text-white mb-2">Operaciones por Hora del Día</h3>
                                    <p class="text-sm text-text-secondary">Actividad horaria de trading</p>
                                </div>
                                <div class="mb-4 grid grid-cols-2 gap-3">
                                    <div class="p-3 bg-surface rounded-lg">
                                        <p class="text-xs text-text-secondary mb-1">Hora Más Activa</p>
                                        <p id="most-active-hour" class="text-xl font-bold text-primary">--:--</p>
                                    </div>
                                    <div class="p-3 bg-surface rounded-lg">
                                        <p class="text-xs text-text-secondary mb-1">Total Operaciones</p>
                                        <p id="hourly-total-ops" class="text-xl font-bold text-white">0</p>
                                    </div>
                                </div>
                                <div class="chart-container" style="height: 320px;">
                                    <canvas id="hora-dia-chart"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- GESTIÓN DE RIESGO -->
                    <div class="mb-8">
                        <h4 class="text-lg font-semibold mb-6 text-gray-300">Gestión de Riesgo</h4>
                        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                            <!-- Drawdown Máximo -->
                            <div class="metric-card p-6">
                                <div class="mb-4">
                                    <h3 class="text-xl font-bold text-white mb-2">Drawdown Máximo</h3>
                                    <p class="text-sm text-text-secondary">Mayor pérdida desde el pico</p>
                                </div>
                                <div class="mb-4 grid grid-cols-2 gap-3">
                                    <div class="p-3 bg-surface rounded-lg">
                                        <p class="text-xs text-text-secondary mb-1">Drawdown Máx</p>
                                        <p id="max-drawdown-value" class="text-xl font-bold text-red">$0.00</p>
                                    </div>
                                    <div class="p-3 bg-surface rounded-lg">
                                        <p class="text-xs text-text-secondary mb-1">Recuperación</p>
                                        <p id="drawdown-recovery" class="text-xl font-bold text-green">0%</p>
                                    </div>
                                </div>
                                <div class="chart-container" style="height: 320px;">
                                    <canvas id="drawdown-chart"></canvas>
                                </div>
                            </div>
                            
                            <!-- Evolución del Balance -->
                            <div class="metric-card p-6">
                                <div class="mb-4">
                                    <h3 class="text-xl font-bold text-white mb-2">Evolución del Balance</h3>
                                    <p class="text-sm text-text-secondary">Progresión acumulada del P&L</p>
                                </div>
                                <div class="mb-4 grid grid-cols-2 gap-3">
                                    <div class="p-3 bg-surface rounded-lg">
                                        <p class="text-xs text-text-secondary mb-1">Balance Inicial</p>
                                        <p id="initial-balance-value" class="text-xl font-bold text-white">$0.00</p>
                                    </div>
                                    <div class="p-3 bg-surface rounded-lg">
                                        <p class="text-xs text-text-secondary mb-1">Balance Actual</p>
                                        <p id="current-balance-value" class="text-xl font-bold text-green">$0.00</p>
                                    </div>
                                </div>
                                <div class="chart-container" style="height: 320px;">
                                    <canvas id="balance-evolution-chart"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- MÉTRICAS CRÍTICAS DE GRÁFICOS - REDISEÑADAS -->
                    <div class="mb-8">
                        <h4 class="text-lg font-semibold mb-6 text-gray-300">Análisis de Consistencia y Volatilidad</h4>
                        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                            <!-- Volatilidad de Retornos Mensuales -->
                            <div class="metric-card p-6">
                                <div class="mb-4">
                                    <h3 class="text-xl font-bold text-white mb-2">Volatilidad de Retornos Mensuales</h3>
                                    <p class="text-sm text-text-secondary">Análisis de consistencia en retornos mes a mes</p>
                                </div>
                                <div class="mb-4 p-4 bg-surface rounded-lg">
                                    <div class="flex justify-between items-center">
                                        <div>
                                            <p class="text-xs text-text-secondary mb-1">Volatilidad</p>
                                            <p id="volatility-value" class="text-2xl font-bold text-primary">$0.00</p>
                                        </div>
                                        <div class="text-right">
                                            <p class="text-xs text-text-secondary mb-1">Promedio Mensual</p>
                                            <p id="volatility-avg" class="text-2xl font-bold text-green">$0.00</p>
                                        </div>
                                    </div>
                                </div>
                                <div class="chart-container" style="height: 320px;">
                                    <canvas id="graficos-monthly-volatility-chart"></canvas>
                                </div>
                            </div>
                            
                            <!-- Resultado Final vs Stop Loss -->
                            <div class="metric-card p-6">
                                <div class="mb-4">
                                    <h3 class="text-xl font-bold text-white mb-2">Resultado Final vs Stop Loss</h3>
                                    <p class="text-sm text-text-secondary">Distribución de cierres con TP o SL activado</p>
                                </div>
                                <div class="mb-4 grid grid-cols-3 gap-3">
                                    <div class="p-3 bg-surface rounded-lg text-center">
                                        <p class="text-xs text-text-secondary mb-1">TP Hit</p>
                                        <p id="tp-hit-count" class="text-xl font-bold text-green">0</p>
                                    </div>
                                    <div class="p-3 bg-surface rounded-lg text-center">
                                        <p class="text-xs text-text-secondary mb-1">SL Hit</p>
                                        <p id="sl-hit-count" class="text-xl font-bold text-red">0</p>
                                    </div>
                                    <div class="p-3 bg-surface rounded-lg text-center">
                                        <p class="text-xs text-text-secondary mb-1">Manual</p>
                                        <p id="manual-close-count" class="text-xl font-bold text-green">0</p>
                                    </div>
                                </div>
                                <div class="chart-container" style="height: 320px;">
                                    <canvas id="graficos-result-vs-sl-chart"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- NUEVA SUBSECCIÓN: COMISIONES -->
            <div id="informe-comisiones-content" class="informe-sub-section-container">
                <div class="mt-6">
                    <h3 class="text-2xl font-bold mb-6 text-white">Análisis de Costos y Comisiones</h3>
                    
                    <!-- Métricas Escritas de Comisiones - MEJORADAS -->
                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-8">
                        <div class="metric-card p-6 border-l-4 border-red">
                            <div class="flex justify-between items-start mb-2">
                                <div>
                                    <p class="text-xs uppercase tracking-wide text-text-secondary mb-1">Comisiones Totales</p>
                                    <p class="text-xs text-text-secondary">Total pagado en fees</p>
                                </div>
                                <i class="fas fa-dollar-sign text-2xl text-red opacity-50"></i>
                            </div>
                            <p id="comisiones-total" class="text-4xl font-bold text-red mt-3">$0.00</p>
                            <div class="mt-3 pt-3 border-t border-surface-light">
                                <div class="flex justify-between text-xs">
                                    <span class="text-text-secondary">Avg por Trade:</span>
                                    <span id="comisiones-avg-trade-inline" class="font-semibold text-white">$0.00</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="metric-card p-6 border-l-4 border-yellow">
                            <div class="flex justify-between items-start mb-2">
                                <div>
                                    <p class="text-xs uppercase tracking-wide text-text-secondary mb-1">Impacto en Ganancias</p>
                                    <p class="text-xs text-text-secondary">% de P/L consumido</p>
                                </div>
                                <i class="fas fa-percent text-2xl text-yellow opacity-50"></i>
                            </div>
                            <p id="comisiones-ratio-total" class="text-4xl font-bold text-yellow mt-3">0.00%</p>
                            <div class="mt-3 pt-3 border-t border-surface-light">
                                <div class="flex justify-between text-xs">
                                    <span class="text-text-secondary">Trades Impactados:</span>
                                    <span id="comisiones-impact-winrate" class="font-semibold text-red">0</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="metric-card p-6 border-l-4 border-primary">
                            <div class="flex justify-between items-start mb-2">
                                <div>
                                    <p class="text-xs uppercase tracking-wide text-text-secondary mb-1">Promedio Mensual</p>
                                    <p class="text-xs text-text-secondary">Costo por mes</p>
                                </div>
                                <i class="fas fa-calendar text-2xl text-primary opacity-50"></i>
                            </div>
                            <p id="comisiones-per-month" class="text-4xl font-bold text-white mt-3">$0.00</p>
                            <div class="mt-3 pt-3 border-t border-surface-light">
                                <div class="flex justify-between text-xs">
                                    <span class="text-text-secondary">Por Día:</span>
                                    <span id="comisiones-per-day" class="font-semibold text-white">$0.00</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Tarjetas adicionales -->
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
                        <div class="metric-card p-6">
                            <div class="flex justify-between items-center mb-4">
                                <div>
                                    <p class="text-sm text-text-secondary">Rango de Comisiones</p>
                                    <p class="text-xs text-text-secondary">Mínima y Máxima</p>
                                </div>
                                <i class="fas fa-arrows-alt-h text-xl text-gray-400"></i>
                            </div>
                            <div class="grid grid-cols-2 gap-4">
                                <div class="p-4 bg-surface rounded-lg">
                                    <p class="text-xs text-text-secondary mb-1">Mínima</p>
                                    <p id="comisiones-min" class="text-2xl font-bold text-primary">$0.00</p>
                                </div>
                                <div class="p-4 bg-surface rounded-lg">
                                    <p class="text-xs text-text-secondary mb-1">Máxima</p>
                                    <p id="comisiones-max" class="text-2xl font-bold text-red">$0.00</p>
                                </div>
                            </div>
                        </div>
                        
                        <div class="metric-card p-6">
                            <div class="flex justify-between items-center mb-4">
                                <div>
                                    <p class="text-sm text-text-secondary">Estadísticas Adicionales</p>
                                    <p class="text-xs text-text-secondary">Resumen general</p>
                                </div>
                                <i class="fas fa-chart-bar text-xl text-gray-400"></i>
                            </div>
                            <div class="space-y-3">
                                <div class="flex justify-between">
                                    <span class="text-xs text-text-secondary">Total Trades:</span>
                                    <span id="comisiones-total-trades" class="text-sm font-semibold text-white">0</span>
                                </div>
                                <div class="flex justify-between">
                                    <span class="text-xs text-text-secondary">Costo Promedio:</span>
                                    <span id="comisiones-avg-trade" class="text-sm font-semibold text-yellow">$0.00</span>
                                </div>
                                <div class="flex justify-between">
                                    <span class="text-xs text-text-secondary">Símbolos Operados:</span>
                                    <span id="comisiones-symbols-count" class="text-sm font-semibold text-white">0</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- NUEVA MÉTRICA DE BARRA 5: Distribución de Comisiones por Rango -->
                    <div class="mb-8">
                        <div class="metric-card">
                            <h3 class="text-lg font-semibold mb-2">Distribución de Comisiones por Rango</h3>
                            <p class="text-xs text-text-secondary mb-3">Cantidad de trades por rango de comisión pagada</p>
                            <div class="chart-container" style="height: 350px;">
                                <canvas id="informe-commissions-chart"></canvas>
                            </div>
                        </div>
                    </div>

                    <!-- Gráficas de Comisiones -->
                    <div class="mb-8">
                        <h4 class="text-lg font-semibold mb-4 text-gray-300">Análisis de Costos por Símbolo</h4>
                        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                            <div class="metric-card">
                                <h3 class="text-lg font-semibold mb-2">Comisiones Totales por Símbolo</h3>
                                <p class="text-xs text-text-secondary mb-2">Total de comisiones pagadas (Top 15)</p>
                                <div class="chart-container" style="height: 350px;">
                                    <canvas id="comisiones-by-symbol-chart"></canvas>
                                </div>
                            </div>
                            <div class="metric-card">
                                <h3 class="text-lg font-semibold mb-2">Ratio Comisión/P/L por Símbolo</h3>
                                <p class="text-xs text-text-secondary mb-2">% de ganancia consumido por comisiones (Top 15)</p>
                                <div class="chart-container" style="height: 350px;">
                                    <canvas id="comisiones-ratio-symbol-chart"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="mb-8">
                        <h4 class="text-lg font-semibold mb-4 text-gray-300">Evolución Temporal de Comisiones</h4>
                        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                            <div class="metric-card">
                                <h3 class="text-lg font-semibold mb-2">Comisiones por Mes</h3>
                                <p class="text-xs text-text-secondary mb-2">Evolución mensual de fees pagados</p>
                                <div class="chart-container" style="height: 350px;">
                                    <canvas id="comisiones-monthly-chart"></canvas>
                                </div>
                            </div>
                            <div class="metric-card">
                                <h3 class="text-lg font-semibold mb-2">Comisiones vs P/L Neto</h3>
                                <p class="text-xs text-text-secondary mb-2">Comparación de fees con ganancias netas</p>
                                <div class="chart-container" style="height: 350px;">
                                    <canvas id="comisiones-vs-pl-chart"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="mb-8">
                        <h4 class="text-lg font-semibold mb-4 text-gray-300">Distribución y Eficiencia</h4>
                        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                            <div class="metric-card">
                                <h3 class="text-lg font-semibold mb-2">Distribución de Comisiones</h3>
                                <p class="text-xs text-text-secondary mb-2">Rangos de fees por operación</p>
                                <div class="chart-container" style="height: 350px;">
                                    <canvas id="comisiones-distribution-chart"></canvas>
                                </div>
                            </div>
                            <div class="metric-card">
                                <h3 class="text-lg font-semibold mb-2">P/L Neto después de Comisiones por Símbolo</h3>
                                <p class="text-xs text-text-secondary mb-2">Ganancia real (Top 15)</p>
                                <div class="chart-container" style="height: 350px;">
                                    <canvas id="comisiones-net-pl-symbol-chart"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Commission Impact (Barras apiladas) -->
                    <div class="mb-8">
                        <h4 class="text-lg font-semibold mb-4 text-gray-300">Impacto de Comisiones</h4>
                        <div class="metric-card">
                            <h3 class="text-lg font-semibold mb-2">Commission Impact (P/L Bruto vs Neto)</h3>
                            <p class="text-xs text-text-secondary mb-2">Comparación de ganancia antes y después de comisiones por mes</p>
                            <div class="chart-container" style="height: 400px;">
                                <canvas id="commission-impact-chart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- DAILY JOURNAL SECTION -->
        <section id="daily-journal" class="section-container">
            <div class="section-toolbar">
                <div class="toolbar-left">
                    <h2 class="text-2xl font-bold">Daily Journal</h2>
                    <div class="flex items-center gap-3 ml-6">
                        <div id="daily-journal-account-logo" class="w-14 h-14 rounded-xl flex items-center justify-center" style="display: none;">
                            <img id="daily-journal-account-logo-img" src="" alt="" class="w-14 h-14 rounded-xl object-contain">
                        </div>
                        <select id="daily-journal-account-select" class="w-48">
                            <option value="all">Todas las cuentas</option>
                        </select>
                    </div>
                </div>
                <div class="toolbar-right">
                    <button class="action-btn" id="daily-journal-filters-btn">
                        <i class="fas fa-filter"></i>
                        <span>Filtros</span>
                    </button>
                    <button class="action-btn" id="daily-journal-download-btn">
                        <i class="fas fa-download"></i>
                        <span>Descargar</span>
                    </button>
                </div>
            </div>

            <div class="grid grid-cols-1 lg:grid-cols-4 gap-6">
                <!-- Lista de días (3 columnas) -->
                <div class="lg:col-span-3">
                    <div id="daily-journal-list" class="space-y-4">
                        <!-- Los días se renderizan aquí dinámicamente -->
                    </div>
                </div>

                <!-- Panel lateral con calendario (1 columna) -->
                <div class="lg:col-span-1">
                    <div class="metric-card sticky top-4">
                        <h3 class="text-lg font-semibold mb-4">Calendario</h3>
                        <div id="daily-journal-calendar-mini" class="daily-journal-mini-calendar">
                            <!-- Calendario renderizado dinámicamente -->
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section id="calendar" class="section-container">
            <div class="section-toolbar">
                <div class="toolbar-left">
                    <div class="flex items-center gap-3">
                        <div id="calendar-account-logo" class="w-14 h-14 rounded-xl flex items-center justify-center" style="display: none;">
                            <img id="calendar-account-logo-img" src="" alt="" class="w-14 h-14 rounded-xl object-contain">
                        </div>
                        <select id="calendar-account-select" class="w-48"><option value="all">Todas las cuentas</option></select>
                    </div>
                    
                    <div id="calendar-month-navigation" class="flex items-center">
                        <button id="prev-month" class="mr-2 px-3 py-2"><i class="fas fa-chevron-left"></i></button>
                        <h2 id="current-month" class="text-xl font-semibold mx-4 w-40 text-center">Abril 2025</h2>
                        <button id="next-month" class="ml-2 px-3 py-2"><i class="fas fa-chevron-right"></i></button>
                    </div>
                    
                    <div class="filter-group">
                        <select id="calendar-currency-select" class="currency-selector">
                            <option value="USD">USD</option>
                            <option value="EUR">EUR</option>
                            <option value="%">%</option>
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <select id="calendar-view-select" class="currency-selector" style="min-width: 100px;">
                            <option value="general">General</option>
                            <option value="monthly">Mensual</option>
                        </select>
                    </div>
                </div>
                
                <div class="toolbar-right">
                    <button class="action-btn" id="calendar-filters-btn">
                        <i class="fas fa-filter"></i>
                        <span>Filtros</span>
                    </button>
                    <button class="action-btn" id="calendar-download-btn">
                        <i class="fas fa-download"></i>
                        <span>Descargar</span>
                    </button>
                </div>
            </div>
            <div id="monthly-calendar-view">
                <div class="grid grid-cols-8 gap-2 text-center font-bold p-2 mb-2 text-text-secondary"><div>Dom</div><div>Lun</div><div>Mar</div><div>Mié</div><div>Jue</div><div>Vie</div><div>Sáb</div><div>Semana</div></div>
                <div id="calendar-grid" class="grid grid-cols-8 gap-2"></div>
            </div>
            <div id="yearly-calendar-view" class="hidden">
                <!-- Contenedor para los 12 calendarios -->
            </div>
            <div class="mt-8"><h3 class="text-xl font-semibold mb-4">Resumen Mensual</h3><div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4"><div class="metric-card"><h4 class="text-base mb-1 text-text-secondary">P&L Mensual</h4><p id="monthly-pl" class="text-2xl font-bold text-green">$0.00</p></div><div class="metric-card"><h4 class="text-base mb-1 text-text-secondary">Días Operados</h4><p id="monthly-trading-days" class="text-2xl font-bold text-white">0</p></div><div class="metric-card"><h4 class="text-base mb-1 text-text-secondary">Días Ganadores</h4><p id="monthly-winning-days" class="text-2xl font-bold text-green">0</p></div><div class="metric-card"><h4 class="text-base mb-1 text-text-secondary">Días Perdedores</h4><p id="monthly-losing-days" class="text-2xl font-bold text-red">0</p></div></div></div>
            
            <!-- Gráficas de Calendario -->
            <div class="mt-8">
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                    <!-- Tendencia Semanal -->
                    <div class="chart-card">
                        <h3 class="text-lg font-semibold mb-1">Tendencia Semanal</h3>
                        <p class="text-xs text-text-secondary mb-3">P&L acumulado de cada semana del mes actual</p>
                        <div class="chart-container" style="height: 280px;">
                            <canvas id="calendar-weekly-trend-chart"></canvas>
                        </div>
                    </div>
                    
                    <!-- P&L por Semana del Mes -->
                    <div class="chart-card">
                        <h3 class="text-lg font-semibold mb-1">P&L por Semana del Mes</h3>
                        <p class="text-xs text-text-secondary mb-3">Comparación de rendimiento entre semanas (Sem 1-5)</p>
                        <div class="chart-container" style="height: 280px;">
                            <canvas id="calendar-monthly-weeks-chart"></canvas>
                        </div>
                    </div>
                    
                    <!-- P&L por Día de la Semana -->
                    <div class="chart-card">
                        <h3 class="text-lg font-semibold mb-1">P&L por Día de la Semana</h3>
                        <p class="text-xs text-text-secondary mb-3">Ganancia/pérdida total por cada día (Dom-Sáb)</p>
                        <div class="chart-container" style="height: 280px;">
                            <canvas id="calendar-daily-pl-chart"></canvas>
                        </div>
                    </div>
                    
                    <!-- Win Rate por Día de la Semana -->
                    <div class="chart-card">
                        <h3 class="text-lg font-semibold mb-1">Win Rate por Día de la Semana</h3>
                        <p class="text-xs text-text-secondary mb-3">Porcentaje de operaciones ganadoras por día de la semana</p>
                        <div class="chart-container" style="height: 280px;">
                            <canvas id="calendar-daily-winrate-chart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section id="operations" class="section-container">
            <div class="section-toolbar">
                <div class="toolbar-left">
                    <h2 class="text-2xl font-bold">Registro de Operaciones</h2>
                </div>
                <div class="toolbar-right">
                    <button id="add-operation-btn" class="action-btn primary">
                        <i class="fas fa-plus mr-2"></i>Añadir Operación
                    </button>
                    <button class="action-btn" id="operations-filters-btn">
                        <i class="fas fa-filter"></i>
                        <span>Filtros</span>
                    </button>
                    <button class="action-btn" id="operations-download-btn">
                        <i class="fas fa-download"></i>
                        <span>Descargar</span>
                    </button>
                </div>
            </div>

            <!-- Operations View Tabs -->
            <div class="nav-tabs flex mb-6">
                <div class="nav-tab operations-view-tab active" data-view="table">Vista Tabla</div>
                <div class="nav-tab operations-view-tab" data-view="heatmap">Heatmap</div>
                <div class="nav-tab operations-view-tab" data-view="instrument">Por Instrumento</div>
                <div class="nav-tab operations-view-tab" data-view="setup">Por Setup</div>
            </div>

            <!-- Métricas de Performance -->
            <div id="operations-view-table" class="operations-view-content">
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                <!-- Net Cumulative P&L Card -->
                <div class="metric-card">
                    <div class="flex items-start justify-between mb-3">
                        <div>
                            <p class="text-text-secondary text-sm mb-1">P&L Bruto Total</p>
                            <p id="ops-cumulative-pl" class="text-3xl font-bold text-success">$0.00</p>
                        </div>
                        <div class="text-success bg-success bg-opacity-10 rounded-lg p-2">
                            <i class="fas fa-chart-line text-xl"></i>
                        </div>
                    </div>
                    <div style="height: 100px; width: 100%; position: relative;">
                        <canvas id="ops-cumulative-chart"></canvas>
                    </div>
                    <div class="grid grid-cols-2 gap-2 mt-3 pt-3 border-t border-border text-xs">
                        <div>
                            <span class="text-text-secondary block mb-1">Comisiones:</span>
                            <span id="ops-total-fees" class="font-semibold text-red">$0.00</span>
                        </div>
                        <div>
                            <span class="text-text-secondary block mb-1">P&L Neto:</span>
                            <span id="ops-net-pl" class="font-semibold text-success">$0.00</span>
                        </div>
                    </div>
                </div>

                <!-- Profit Factor Card -->
                <div class="metric-card">
                    <div class="flex items-start justify-between mb-3">
                        <div>
                            <p class="text-text-secondary text-sm mb-1 flex items-center">
                                Profit Factor
                                <i class="fas fa-info-circle text-xs ml-1 cursor-help" title="Ganancias brutas / Pérdidas brutas"></i>
                            </p>
                            <p id="ops-profit-factor" class="text-3xl font-bold text-primary">0.00</p>
                        </div>
                        <div class="text-primary bg-primary bg-opacity-10 rounded-lg p-2">
                            <i class="fas fa-balance-scale text-xl"></i>
                        </div>
                    </div>
                    <div class="mt-4">
                        <!-- Gauge visual -->
                        <div class="relative h-3 bg-surface rounded-full overflow-hidden">
                            <div id="ops-pf-gauge" class="h-full transition-all duration-500" style="width: 0%; background: linear-gradient(to right, #ef4444, #eab308, #22c55e);"></div>
                        </div>
                        <div class="flex justify-between text-xs text-text-secondary mt-1">
                            <span>Poor</span>
                            <span>Good</span>
                            <span>Excellent</span>
                        </div>
                    </div>
                    <div class="flex items-center justify-between mt-3 pt-3 border-t border-border">
                        <span class="text-xs text-text-secondary">Gross Win</span>
                        <span id="ops-gross-win" class="text-sm font-semibold text-success">$0</span>
                    </div>
                </div>

                <!-- Trade Win % Card -->
                <div class="metric-card">
                    <div class="flex items-start justify-between mb-3">
                        <div>
                            <p class="text-text-secondary text-sm mb-1">Trade Win %</p>
                            <p id="ops-win-rate" class="text-3xl font-bold text-accent">0%</p>
                        </div>
                        <div class="text-accent bg-accent bg-opacity-10 rounded-lg p-2">
                            <i class="fas fa-bullseye text-xl"></i>
                        </div>
                    </div>
                    <div class="mt-4">
                        <!-- Donut chart simulado -->
                        <div class="relative mx-auto" style="width: 120px; height: 120px;">
                            <svg viewBox="0 0 36 36" class="circular-chart">
                                <path class="circle-bg"
                                    stroke="#2a2a2a"
                                    stroke-width="3"
                                    fill="none"
                                    d="M18 2.0845
                                    a 15.9155 15.9155 0 0 1 0 31.831
                                    a 15.9155 15.9155 0 0 1 0 -31.831"
                                />
                                <path id="ops-win-circle" class="circle"
                                    stroke="#10b981"
                                    stroke-width="3"
                                    stroke-dasharray="0, 100"
                                    stroke-linecap="round"
                                    fill="none"
                                    d="M18 2.0845
                                    a 15.9155 15.9155 0 0 1 0 31.831
                                    a 15.9155 15.9155 0 0 1 0 -31.831"
                                />
                                <text x="18" y="20.35" class="percentage" fill="#fff" font-size="8" text-anchor="middle" id="ops-win-text">0%</text>
                            </svg>
                        </div>
                    </div>
                    <div class="flex items-center justify-between mt-3 pt-3 border-t border-border">
                        <span class="text-xs text-text-secondary">
                            <i class="fas fa-check-circle text-success mr-1"></i><span id="ops-total-wins">0</span> wins
                        </span>
                        <span class="text-xs text-text-secondary">
                            <i class="fas fa-times-circle text-danger mr-1"></i><span id="ops-total-losses">0</span> losses
                        </span>
                    </div>
                </div>
            </div>

             <div id="add-operation-form" class="metric-card mb-6" style="display: none;"><h3 class="text-lg font-semibold mb-4">Nueva Operación</h3><form id="operation-details-form"><div class="grid grid-cols-1 md:grid-cols-3 lg:grid-cols-4 gap-4 mb-4"><div><label class="block mb-1">Fecha</label><input type="date" id="op-date"></div><div><label class="block mb-1">Cuenta</label><select id="op-account"></select></div><div id="parent-op-container" style="display: none;"><label class="block mb-1">Operación Padre (para parciales)</label><select id="op-parent"><option value="">Ninguna</option></select></div><div class="lg:col-span-2"><label class="block mb-1">Instrumento</label><input type="text" id="op-instrument" placeholder="EURUSD, AAPL, etc."></div><div><label class="block mb-1">Precio de Entrada</label><input type="number" id="op-entry" step="any"></div><div><label class="block mb-1">Hora Entrada</label><input type="time" id="op-entry-time"></div><div><label class="block mb-1">Precio de Salida</label><input type="number" id="op-exit" step="any"></div><div><label class="block mb-1">Hora Salida</label><input type="time" id="op-exit-time"></div><div><label class="block mb-1">Volumen</label><input type="number" id="op-volume" step="any"></div><div><label class="block mb-1">Divisa</label><select id="op-currency"><option value="USD">USD</option><option value="EUR">EUR</option><option value="USDT">USDT</option></select></div><div><label class="block mb-1">Tipo</label><select id="op-type"><option value="buy">Compra (Long)</option><option value="sell">Venta (Short)</option></select></div>
                <!-- NUEVO CAMPO: SESIÓN -->
                <div>
                    <label class="block mb-1">
                        Sesión 
                        <span class="text-xs text-green" title="Detectado automáticamente según hora de entrada">
                            <i class="fas fa-clock"></i> Auto
                        </span>
                    </label>
                    <select id="op-session" disabled style="background-color: #1a1a1a; cursor: not-allowed; opacity: 1; color: var(--green); font-weight: 600;">
                        <option value="">Sin sesión</option>
                        <option value="Asia">Asia (23:00-9:00)</option>
                        <option value="Londres">Londres (9:00-15:30)</option>
                        <option value="New York">New York (15:30-23:00)</option>
                    </select>
                </div>
                <!-- FIN NUEVO CAMPO: SESIÓN -->
                <!-- NUEVO CAMPO: SETUP USADO -->
                <div>
                    <label class="block mb-1">Setup Usado</label>
                    <select id="op-setup">
                        <option value="">Ninguno</option>
                    </select>
                </div>
                <!-- FIN NUEVO CAMPO: SETUP USADO -->
                <div><label class="block mb-1">Resultado</label><div class="flex"><button type="button" id="op-win-btn" class="flex-1 mr-1 success">Ganancia</button><button type="button" id="op-loss-btn" class="flex-1 ml-1 danger">Pérdida</button></div></div>
                
                <!-- NOTAS AVANZADAS -->
                <div class="md:col-span-2">
                    <label class="block mb-1">Notas</label>
                    <div style="border: 1px solid #39FF14; border-radius: 5px; padding: 10px; background: #1a1a1a;">
                        <textarea id="op-notes" rows="3" style="width: 100%; background: #0a0a0a; border: 1px solid #333; color: white; padding: 8px; border-radius: 5px; margin-bottom: 10px;"></textarea>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <button type="button" id="op-voice-record-btn" style="background: #39FF14; color: black; border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer; font-size: 13px; font-weight: bold;">
                                <i class="fas fa-microphone"></i> Grabar Nota de Voz
                            </button>
                            <span id="op-voice-status" style="color: #888; font-size: 12px;"></span>
                            <audio id="op-voice-playback" controls style="display: none; height: 30px; flex: 1;"></audio>
                        </div>
                        <input type="hidden" id="op-voice-data" />
                    </div>
                </div>
                <!-- FIN NOTAS AVANZADAS -->
                
                <div><label class="block mb-1">P&L Manual (opcional)</label><input type="number" id="op-manual-pl" step="any" placeholder="Sobrescribe P&L calculado"></div><div><label class="block mb-1">Comisiones/Fees</label><input type="number" id="op-fees" step="0.01" placeholder="0.00" title="Comisiones cobradas por el broker"></div><div class="lg:col-span-4"><label class="block mb-1">Adjuntar Imágenes (Máx. 5)</label><input type="file" id="op-image" accept="image/png, image/jpeg, image/jpg" multiple><div id="op-image-previews-container" class="mt-2 grid grid-cols-3 sm:grid-cols-5 gap-2"></div></div></div><div class="flex justify-end"><button type="button" id="op-cancel" class="mr-2">Cancelar</button><button type="button" id="op-save" class="primary">Guardar</button></div></form></div>
            <div class="flex flex-wrap justify-between items-end mb-4"><div class="flex flex-wrap items-end space-x-4"><div><label for="filter-account" class="block mb-1 text-sm text-text-secondary">Filtrar por cuenta:</label><div class="flex items-center gap-2"><div id="filter-account-logo" class="w-14 h-14 rounded-xl flex items-center justify-center" style="display: none;"><img id="filter-account-logo-img" src="" alt="" class="w-14 h-14 rounded-xl object-contain"></div><select id="filter-account" class="w-56 h-12"><option value="all">Todas las cuentas</option></select></div></div><div class="flex items-end space-x-2"><div><label for="filter-instrument" class="block mb-1 text-sm text-text-secondary">Filtrar por instrumento:</label><input type="text" id="filter-instrument" placeholder="Escribir instrumento..." class="w-56 h-12"></div><button id="operations-date-filter-btn" class="date-filter-trigger p-2 bg-surface rounded h-12" title="Filtrar por fecha"><i class="fas fa-calendar-alt"></i></button></div></div></div>
            <div id="operations-date-filter-display" class="date-filter-display-text text-sm text-text-secondary mb-4">Sin filtro de fecha</div>
            <div class="metric-card p-0"><table id="operations-table-render" class="w-full">
                <thead>
                    <tr>
                        <th data-sort="date">Fecha</th>
                        <th data-sort="entryTime">Entrada</th>
                        <th data-sort="exitTime">Salida</th>
                        <th data-sort="accountId">Cuenta</th>
                        <th data-sort="instrument">Instrumento</th>
                        <th data-sort="type">Tipo</th>
                        <th data-sort="entry">Precio E.</th>
                        <th data-sort="exit">Precio S.</th>
                        <th data-sort="volume">Vol.</th>
                        <th data-sort="result">Resultado</th>
                        <th data-sort="pl">P&L</th>
                        <th data-sort="fees">Comis.</th>
                        <th data-sort="currency">Divisa</th>
                        <th data-sort="session">Sesión</th>
                        <th class="text-center">Setup</th>
                        <th class="text-center">Acciones</th>
                    </tr>
                </thead>
                <tbody id="operations-table"></tbody>
            </table></div>
            </div>
            <!-- FIN Vista Tabla -->

            <!-- Vista Heatmap -->
            <div id="operations-view-heatmap" class="operations-view-content" style="display: none;">
                
                <!-- Panel de Métricas Clave -->
                <div class="key-metrics-panel">
                    <div class="key-metric">
                        <div class="key-metric-label">Consistency Score</div>
                        <div class="key-metric-value" id="hm-consistency">--</div>
                        <div class="key-metric-trend" id="hm-consistency-trend">--</div>
                    </div>
                    <div class="key-metric">
                        <div class="key-metric-label">Mejor Zona</div>
                        <div class="key-metric-value" style="font-size: 1.25rem;" id="hm-best-zone">--</div>
                        <div class="key-metric-trend" id="hm-best-zone-pl">--</div>
                    </div>
                    <div class="key-metric">
                        <div class="key-metric-label">Peor Zona</div>
                        <div class="key-metric-value" style="font-size: 1.25rem;" id="hm-worst-zone">--</div>
                        <div class="key-metric-trend" id="hm-worst-zone-pl">--</div>
                    </div>
                    <div class="key-metric">
                        <div class="key-metric-label">Concentración</div>
                        <div class="key-metric-value" id="hm-concentration">--</div>
                        <div class="key-metric-trend">Top 20% horas</div>
                    </div>
                </div>

                <!-- Insight Cards -->
                <div id="heatmap-insights" class="mb-6">
                    <!-- Se llenarán dinámicamente -->
                </div>

                <div class="mb-6">
                    <h3 class="text-xl font-semibold mb-4">Performance Map - P&L por Hora y Día</h3>
                    <p class="text-sm text-text-secondary mb-4">Visualización térmica del rendimiento temporal</p>
                    
                    <!-- Controles -->
                    <div class="flex gap-4 mb-4">
                        <select id="heatmap-metric" class="px-4 py-2 bg-surface border border-border rounded">
                            <option value="pl">P&L Total</option>
                            <option value="winrate">Win Rate %</option>
                            <option value="trades">Cantidad de Trades</option>
                        </select>
                        <select id="heatmap-period" class="px-4 py-2 bg-surface border border-border rounded">
                            <option value="all">Todo el período</option>
                            <option value="30">Últimos 30 días</option>
                            <option value="90">Últimos 90 días</option>
                        </select>
                    </div>

                    <!-- Heatmap Grid -->
                    <div class="metric-card p-6">
                        <div class="overflow-x-auto">
                            <table class="heatmap-table" style="width: 100%; border-collapse: collapse;">
                                <thead>
                                    <tr>
                                        <th style="padding: 12px; text-align: left; border-bottom: 2px solid var(--border); font-weight: 600;">Hora</th>
                                        <th style="padding: 12px; text-align: center; border-bottom: 2px solid var(--border); font-weight: 600;">Dom</th>
                                        <th style="padding: 12px; text-align: center; border-bottom: 2px solid var(--border); font-weight: 600;">Lun</th>
                                        <th style="padding: 12px; text-align: center; border-bottom: 2px solid var(--border); font-weight: 600;">Mar</th>
                                        <th style="padding: 12px; text-align: center; border-bottom: 2px solid var(--border); font-weight: 600;">Mié</th>
                                        <th style="padding: 12px; text-align: center; border-bottom: 2px solid var(--border); font-weight: 600;">Jue</th>
                                        <th style="padding: 12px; text-align: center; border-bottom: 2px solid var(--border); font-weight: 600;">Vie</th>
                                        <th style="padding: 12px; text-align: center; border-bottom: 2px solid var(--border); font-weight: 600;">Sáb</th>
                                    </tr>
                                </thead>
                                <tbody id="heatmap-tbody">
                                    <!-- Se llenará dinámicamente -->
                                </tbody>
                            </table>
                        </div>
                        
                        <!-- Zonas Calientes/Frías -->
                        <div class="mt-6">
                            <div class="stats-grid">
                                <div class="stat-box">
                                    <div class="stat-label">Top Zona #1</div>
                                    <div class="stat-value" style="color: var(--green);" id="hm-top1">--</div>
                                    <div class="stat-subvalue" id="hm-top1-val">--</div>
                                </div>
                                <div class="stat-box">
                                    <div class="stat-label">Top Zona #2</div>
                                    <div class="stat-value" style="color: var(--green);" id="hm-top2">--</div>
                                    <div class="stat-subvalue" id="hm-top2-val">--</div>
                                </div>
                                <div class="stat-box">
                                    <div class="stat-label">Top Zona #3</div>
                                    <div class="stat-value" style="color: var(--green);" id="hm-top3">--</div>
                                    <div class="stat-subvalue" id="hm-top3-val">--</div>
                                </div>
                                <div class="stat-box">
                                    <div class="stat-label">Zona Débil #1</div>
                                    <div class="stat-value" style="color: var(--red);" id="hm-weak1">--</div>
                                    <div class="stat-subvalue" id="hm-weak1-val">--</div>
                                </div>
                                <div class="stat-box">
                                    <div class="stat-label">Zona Débil #2</div>
                                    <div class="stat-value" style="color: var(--red);" id="hm-weak2">--</div>
                                    <div class="stat-subvalue" id="hm-weak2-val">--</div>
                                </div>
                                <div class="stat-box">
                                    <div class="stat-label">Zona Débil #3</div>
                                    <div class="stat-value" style="color: var(--red);" id="hm-weak3">--</div>
                                    <div class="stat-subvalue" id="hm-weak3-val">--</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <!-- FIN Vista Heatmap -->

            <!-- Vista por Instrumento -->
            <div id="operations-view-instrument" class="operations-view-content" style="display: none;">
                
                <!-- Panel de Métricas Clave -->
                <div class="key-metrics-panel">
                    <div class="key-metric">
                        <div class="key-metric-label">R-Multiple Promedio</div>
                        <div class="key-metric-value" id="inst-rmultiple">--</div>
                        <div class="key-metric-trend" id="inst-rmultiple-trend">--</div>
                    </div>
                    <div class="key-metric">
                        <div class="key-metric-label">Expectancy</div>
                        <div class="key-metric-value" id="inst-expectancy">--</div>
                        <div class="key-metric-trend">Por trade</div>
                    </div>
                    <div class="key-metric">
                        <div class="key-metric-label">Mejores Instrumentos</div>
                        <div class="key-metric-value" style="font-size: 1.5rem;" id="inst-best-count">--</div>
                        <div class="key-metric-trend">Superan promedio</div>
                    </div>
                    <div class="key-metric">
                        <div class="key-metric-label">Consistency</div>
                        <div class="key-metric-value" id="inst-consistency">--</div>
                        <div class="key-metric-trend" id="inst-consistency-trend">--</div>
                    </div>
                </div>

                <!-- Insight Cards -->
                <div id="instrument-insights" class="mb-6">
                    <!-- Se llenarán dinámicamente -->
                </div>

                <div class="mb-6">
                    <h3 class="text-xl font-semibold mb-4">Análisis por Instrumento</h3>
                    <p class="text-sm text-text-secondary mb-4">Operaciones agrupadas por ticker con estadísticas detalladas</p>
                    
                    <!-- Controles -->
                    <div class="flex gap-4 mb-4">
                        <select id="instrument-sort" class="px-4 py-2 bg-surface border border-border rounded">
                            <option value="pl">Ordenar por P&L</option>
                            <option value="trades">Ordenar por Cantidad</option>
                            <option value="winrate">Ordenar por Win Rate</option>
                            <option value="expectancy">Ordenar por Expectancy</option>
                            <option value="consistency">Ordenar por Consistency</option>
                            <option value="name">Ordenar por Nombre</option>
                        </select>
                        <input type="text" id="instrument-search" placeholder="Buscar instrumento..." class="px-4 py-2 bg-surface border border-border rounded flex-1">
                    </div>

                    <!-- Lista de Instrumentos -->
                    <div id="instruments-container" class="space-y-4">
                        <!-- Se llenará dinámicamente -->
                    </div>
                </div>
            </div>
            <!-- FIN Vista por Instrumento -->

            <!-- Vista por Setup -->
            <div id="operations-view-setup" class="operations-view-content" style="display: none;">
                
                <!-- Panel de Métricas Clave -->
                <div class="key-metrics-panel">
                    <div class="key-metric">
                        <div class="key-metric-label">Edge Score Promedio</div>
                        <div class="key-metric-value" id="setup-edge-avg">--</div>
                        <div class="key-metric-trend" id="setup-edge-trend">--</div>
                    </div>
                    <div class="key-metric">
                        <div class="key-metric-label">Expectancy Global</div>
                        <div class="key-metric-value" id="setup-expectancy-avg">--</div>
                        <div class="key-metric-trend">Por trade</div>
                    </div>
                    <div class="key-metric">
                        <div class="key-metric-label">Mejor Setup</div>
                        <div class="key-metric-value" style="font-size: 1.25rem;" id="setup-best-name">--</div>
                        <div class="key-metric-trend" id="setup-best-score">--</div>
                    </div>
                    <div class="key-metric">
                        <div class="key-metric-label">Oportunidad Perdida</div>
                        <div class="key-metric-value" id="setup-opportunity">--</div>
                        <div class="key-metric-trend" id="setup-opportunity-trend">--</div>
                    </div>
                </div>

                <!-- Insight Cards -->
                <div id="setup-insights" class="mb-6">
                    <!-- Se llenarán dinámicamente -->
                </div>

                <div class="mb-6">
                    <h3 class="text-xl font-semibold mb-4">Análisis por Estrategia</h3>
                    <p class="text-sm text-text-secondary mb-4">Performance de cada setup con métricas clave de rentabilidad</p>
                    
                    <!-- Controles -->
                    <div class="flex gap-4 mb-4">
                        <select id="setup-sort" class="px-4 py-2 bg-surface border border-border rounded">
                            <option value="pl">Ordenar por P&L</option>
                            <option value="trades">Ordenar por Cantidad</option>
                            <option value="winrate">Ordenar por Win Rate</option>
                            <option value="profitfactor">Ordenar por Profit Factor</option>
                            <option value="edgescore">Ordenar por Edge Score</option>
                            <option value="expectancy">Ordenar por Expectancy</option>
                        </select>
                    </div>

                    <!-- Lista de Setups -->
                    <div id="setups-container" class="space-y-4">
                        <!-- Se llenará dinámicamente -->
                    </div>
                </div>
            </div>
            <!-- FIN Vista por Setup -->

        </section>

        <!-- Nueva Sección de Página Completa para Detalles de Operación -->
        <section id="operation-detail-page" class="section-container">
            <button id="back-to-operations-btn" class="mb-4 button"><i class="fas fa-arrow-left mr-2"></i> Volver a Operaciones</button>
            <div class="metric-card p-6">
                <h2 id="op-detail-page-title" class="text-3xl font-bold mb-6 text-primary">Detalles de la Operación</h2>

                <!-- Tabs de navegación -->
                <div class="nav-tabs flex mb-6">
                    <div class="nav-tab operation-detail-tab active" data-target="general">General</div>
                    <div class="nav-tab operation-detail-tab" data-target="metricas">Métricas</div>
                </div>

                <!-- TAB: GENERAL -->
                <div id="operation-detail-tab-general" class="operation-detail-tab-content">
                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-x-6 gap-y-4 mb-6 text-sm">
                    <div><strong>ID:</strong> <span id="op-detail-id"></span></div>
                    <div><strong>Fecha:</strong> <span id="op-detail-date"></span></div>
                    <div><strong>Cuenta:</strong> <span id="op-detail-account"></span></div>
                    <div><strong>Instrumento:</strong> <span id="op-detail-instrument"></span></div>
                    <div><strong>Tipo:</strong> <span id="op-detail-type"></span></div>
                    <div><strong>Entrada:</strong> <span id="op-detail-entry"></span></div>
                    <div><strong>Hora Entrada:</strong> <span id="op-detail-entry-time"></span></div>
                    <div><strong>Salida:</strong> <span id="op-detail-exit"></div>
                    <div><strong>Hora Salida:</strong> <span id="op-detail-exit-time"></span></div>
                    <div><strong>Volumen:</strong> <span id="op-detail-volume"></span></div>
                    <div><strong>Divisa:</strong> <span id="op-detail-currency"></span></div>
                    <div><strong>P&L Manual:</strong> <span id="op-detail-manual-pl"></span></div>
                    <div><strong>Comisión/Fee:</strong> <span id="op-detail-fee" class="text-red font-semibold"></span></div>
                    <div><strong>Sesión:</strong> <span id="op-detail-session"></span></div>
                    <div><strong>Setup Usado:</strong> <span id="op-detail-setup"></span></div>
                </div>

                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                    <div class="metric-card text-center">
                        <h4 class="text-sm text-text-secondary mb-1">Resultado</h4>
                        <p id="op-detail-result" class="text-xl font-bold"></p>
                    </div>
                    <div class="metric-card text-center">
                        <h4 class="text-sm text-text-secondary mb-1">P&L Bruto</h4>
                        <p id="op-detail-pl" class="text-xl font-bold"></p>
                    </div>
                    <div class="metric-card text-center">
                        <h4 class="text-sm text-text-secondary mb-1">P&L Neto (después fee)</h4>
                        <p id="op-detail-net-pl" class="text-xl font-bold"></p>
                    </div>
                </div>

                <div class="mb-6">
                    <h3 class="text-lg font-semibold mb-2">Notas:</h3>
                    <!-- Pestañas para notas -->
                    <div class="border border-border rounded-lg bg-surface">
                        <div class="flex border-b border-border">
                            <button class="notes-tab-btn px-4 py-2 text-sm bg-primary text-black border-r border-border active" data-tab="view">
                                Ver Notas
                            </button>
                            <button class="notes-tab-btn px-4 py-2 text-sm hover:bg-surface-light border-r border-border" data-tab="edit">
                                Editar Notas
                            </button>
                        </div>
                        <div class="p-4">
                            <div id="notes-view-content" class="notes-tab-content active">
                                <p id="op-detail-notes" class="text-sm whitespace-pre-wrap min-h-[80px]"></p>
                            </div>
                            <div id="notes-edit-content" class="notes-tab-content hidden">
                                <div id="op-detail-rich-editor-container"></div>
                                <div class="flex gap-2 mt-3">
                                    <button id="save-notes-btn" class="px-4 py-2 bg-success text-white rounded text-sm hover:bg-success/80">
                                        Guardar Notas
                                    </button>
                                    <button id="cancel-notes-btn" class="px-4 py-2 bg-surface-light text-text rounded text-sm hover:bg-surface">
                                        Cancelar
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="mb-6">
                    <h3 class="text-lg font-semibold mb-2">Imágenes Adjuntas:</h3>
                    <!-- Pestañas para imágenes -->
                    <div class="border border-border rounded-lg bg-surface">
                        <div class="flex border-b border-border">
                            <button class="images-tab-btn px-4 py-2 text-sm bg-primary text-black border-r border-border active" data-tab="view">
                                Ver Imágenes
                            </button>
                            <button class="images-tab-btn px-4 py-2 text-sm hover:bg-surface-light border-r border-border" data-tab="add">
                                Agregar Imágenes
                            </button>
                        </div>
                        <div class="p-4">
                            <div id="images-view-content" class="images-tab-content active">
                                <div id="op-detail-images" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4" style="display: grid !important; min-height: 200px;">
                                    <p class="text-sm text-text-secondary md:col-span-3 text-center">No hay imágenes adjuntas.</p>
                                </div>
                            </div>
                            <div id="images-add-content" class="images-tab-content hidden">
                                <div class="border-2 border-dashed border-border rounded-lg p-8 text-center">
                                    <input type="file" id="op-detail-image-input" multiple accept="image/*" class="hidden">
                                    <div id="drop-zone" class="cursor-pointer" onclick="document.getElementById('op-detail-image-input').click()">
                                        <i class="fas fa-cloud-upload-alt text-3xl text-text-secondary mb-2"></i>
                                        <p class="text-text-secondary mb-2">Haz clic aquí o arrastra imágenes</p>
                                        <p class="text-xs text-text-secondary">PNG, JPG, GIF hasta 10MB cada una</p>
                                    </div>
                                </div>
                                <div id="selected-images-preview" class="mt-4 grid grid-cols-2 md:grid-cols-3 gap-3 hidden">
                                    <!-- Preview de imágenes seleccionadas -->
                                </div>
                                <div class="flex gap-2 mt-4">
                                    <button id="upload-images-btn" class="px-4 py-2 bg-success text-white rounded text-sm hover:bg-success/80 hidden">
                                        Guardar Imágenes
                                    </button>
                                    <button id="cancel-images-btn" class="px-4 py-2 bg-surface-light text-text rounded text-sm hover:bg-surface">
                                        Cancelar
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Sección de Gráfico de TradingView -->
                <div class="mb-6" id="op-detail-chart-section">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-lg font-semibold">Gráfico de Trading</h3>
                    </div>

                    <!-- Panel de información -->
                    <div class="bg-surface border border-border rounded-lg overflow-hidden mb-4">
                        <div class="bg-background p-4">
                            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 text-sm">
                                <div class="flex items-center space-x-3">
                                    <div class="flex items-center justify-center w-8 h-8 rounded-full bg-green-500 bg-opacity-20">
                                        <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                                            <path d="M8 2L14 14H2L8 2Z" fill="#10B981" stroke="#059669" stroke-width="1.5"/>
                                        </svg>
                                    </div>
                                    <div>
                                        <span class="text-green-400 font-semibold">ENTRADA:</span>
                                        <span id="chart-entry-price" class="ml-2 text-white font-bold">-</span>
                                        <div id="chart-entry-time" class="text-xs text-text-secondary">-</div>
                                    </div>
                                </div>
                                <div class="flex items-center space-x-3">
                                    <div class="flex items-center justify-center w-8 h-8 rounded-full bg-red-500 bg-opacity-20">
                                        <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                                            <path d="M8 14L2 2H14L8 14Z" fill="#EF4444" stroke="#DC2626" stroke-width="1.5"/>
                                        </svg>
                                    </div>
                                    <div>
                                        <span class="text-red-400 font-semibold">SALIDA:</span>
                                        <span id="chart-exit-price" class="ml-2 text-white font-bold">-</span>
                                        <div id="chart-exit-time" class="text-xs text-text-secondary">-</div>
                                    </div>
                                </div>
                                <div class="flex items-center justify-center">
                                    <div>
                                        <span class="text-text-secondary text-xs">P&L:</span>
                                        <span id="chart-pl-display" class="ml-2 font-bold text-lg">-</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- TradingView Widget Avanzado -->
                    <div class="bg-surface border border-border rounded-lg overflow-hidden relative chart-info">
                        <!-- Contenedor del widget avanzado -->
                        <div id="tradingview-widget" style="width: 100%; height: 650px;"></div>
                    </div>
                </div>

                <!-- Sección de Parciales -->
                <div class="mb-6" id="op-detail-partials-section">
                    <h3 class="text-lg font-semibold mb-4">Posición y Parciales</h3>
                    <div class="bg-surface border border-border rounded-lg overflow-hidden">
                        <div class="overflow-x-auto">
                            <table class="w-full text-sm">
                                <thead>
                                    <tr class="bg-background border-b border-border">
                                        <th class="text-left p-3 font-semibold">Descripción</th>
                                        <th class="text-left p-3 font-semibold">Hora Entrada</th>
                                        <th class="text-left p-3 font-semibold">Hora Salida</th>
                                        <th class="text-left p-3 font-semibold">Precio Entrada</th>
                                        <th class="text-left p-3 font-semibold">Precio Salida</th>
                                        <th class="text-left p-3 font-semibold">Volumen</th>
                                        <th class="text-left p-3 font-semibold">P&L</th>
                                    </tr>
                                </thead>
                                <tbody id="op-detail-partials-table">
                                    <!-- Los parciales se llenarán dinámicamente -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                    
                    <!-- Gráficos de Running P&L -->
                    <div class="mt-6 grid grid-cols-1 lg:grid-cols-2 gap-6">
                        <!-- TRADE RUNNING P&L -->
                        <div>
                            <h3 class="text-lg font-semibold mb-3">TRADE RUNNING P&L</h3>
                            <div class="bg-surface border border-border rounded-lg p-4">
                                <div class="chart-container" style="height: 300px;">
                                    <canvas id="operation-trade-pnl-chart"></canvas>
                                </div>
                            </div>
                        </div>
                        
                        <!-- DAY RUNNING P&L (All Intraday Trades) -->
                        <div>
                            <h3 class="text-lg font-semibold mb-3">DAY RUNNING P&L (All Intraday Trades)</h3>
                            <div class="bg-surface border border-border rounded-lg p-4">
                                <div class="chart-container" style="height: 300px;">
                                    <canvas id="operation-day-pnl-chart"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Análisis de Sesión -->
                <div>
                    <h3 class="text-lg font-semibold mb-2">Análisis de Sesión:</h3>
                    <p class="text-sm mb-3">Esta operación se inició durante la sesión de: <span id="op-detail-session-current" class="font-bold text-primary">N/A</span></p>
                    <div class="overflow-x-auto">
                        <table class="w-full">
                            <thead>
                                <tr>
                                    <th>Sesión</th>
                                    <th>P&L Total</th>
                                    <th>Comisiones</th>
                                    <th>P&L Neto</th>
                                    <th>Trades</th>
                                    <th>Win %</th>
                                </tr>
                            </thead>
                            <tbody id="op-detail-session-metrics">
                                <!-- Las métricas de sesión se rellenarán aquí -->
                            </tbody>
                        </table>
                    </div>
                </div>
                </div>
                <!-- FIN TAB: GENERAL -->

                <!-- TAB: MÉTRICAS -->
                <div id="operation-detail-tab-metricas" class="operation-detail-tab-content" style="display: none;">
                    
                    <!-- Métricas Numéricas -->
                    <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-4 mb-8">
                        <div class="metric-card p-4 text-center">
                            <p class="text-xs text-text-secondary mb-1">Trades en este Ticker</p>
                            <p id="op-metric-total-trades" class="text-2xl font-bold text-white">0</p>
                        </div>
                        <div class="metric-card p-4 text-center">
                            <p class="text-xs text-text-secondary mb-1">Win Rate histórico</p>
                            <p id="op-metric-winrate" class="text-2xl font-bold text-primary">0%</p>
                        </div>
                        <div class="metric-card p-4 text-center">
                            <p class="text-xs text-text-secondary mb-1">Profit Factor</p>
                            <p id="op-metric-pf" class="text-2xl font-bold text-green">0.00</p>
                        </div>
                        <div class="metric-card p-4 text-center">
                            <p class="text-xs text-text-secondary mb-1">R:R Promedio</p>
                            <p id="op-metric-rr" class="text-2xl font-bold text-yellow">0.00</p>
                        </div>
                        <div class="metric-card p-4 text-center">
                            <p class="text-xs text-text-secondary mb-1">P&L Total Ticker</p>
                            <p id="op-metric-total-pl" class="text-2xl font-bold">$0.00</p>
                        </div>
                        <div class="metric-card p-4 text-center">
                            <p class="text-xs text-text-secondary mb-1">Mejor Trade</p>
                            <p id="op-metric-best-trade" class="text-xl font-bold text-green">$0.00</p>
                        </div>
                        <div class="metric-card p-4 text-center">
                            <p class="text-xs text-text-secondary mb-1">Peor Trade</p>
                            <p id="op-metric-worst-trade" class="text-xl font-bold text-red">$0.00</p>
                        </div>
                        <div class="metric-card p-4 text-center">
                            <p class="text-xs text-text-secondary mb-1">Duración Promedio</p>
                            <p id="op-metric-avg-duration" class="text-xl font-bold text-white">0h 0m</p>
                        </div>
                        <div class="metric-card p-4 text-center">
                            <p class="text-xs text-text-secondary mb-1">Ranking de Este Trade</p>
                            <p id="op-metric-ranking" class="text-xl font-bold text-primary">-</p>
                        </div>
                        <div class="metric-card p-4 text-center">
                            <p class="text-xs text-text-secondary mb-1">Percentil</p>
                            <p id="op-metric-percentile" class="text-xl font-bold text-primary">-</p>
                        </div>
                    </div>

                    <!-- Gráficos de Barras -->
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                        <!-- Gráfico 1: Comparativa Este Trade vs Promedio (Horizontal) -->
                        <div class="metric-card p-4">
                            <h4 class="text-lg font-semibold mb-2">Este Trade vs Promedio</h4>
                            <p class="text-xs text-text-secondary mb-3">Compara el P&L, duración y volumen de esta operación contra el promedio histórico del instrumento</p>
                            <div class="chart-container" style="height: 280px;">
                                <canvas id="op-chart-comparison"></canvas>
                            </div>
                        </div>

                        <!-- Gráfico 2: P/L por Sesión (Vertical) -->
                        <div class="metric-card p-4">
                            <h4 class="text-lg font-semibold mb-2">P/L por Sesión</h4>
                            <p class="text-xs text-text-secondary mb-3">Rendimiento total en dólares por cada sesión de trading (Sydney, Tokyo, Londres, Nueva York)</p>
                            <div class="chart-container" style="height: 280px;">
                                <canvas id="op-chart-sessions"></canvas>
                            </div>
                        </div>

                        <!-- Gráfico 3: Win Rate por Día de la Semana (Vertical) -->
                        <div class="metric-card p-4">
                            <h4 class="text-lg font-semibold mb-2">Win Rate por Día</h4>
                            <p class="text-xs text-text-secondary mb-3">Porcentaje de operaciones ganadoras según el día de la semana</p>
                            <div class="chart-container" style="height: 280px;">
                                <canvas id="op-chart-weekdays"></canvas>
                            </div>
                        </div>

                        <!-- Gráfico 4: P/L por Día de la Semana (Vertical) -->
                        <div class="metric-card p-4">
                            <h4 class="text-lg font-semibold mb-2">P/L por Día de la Semana</h4>
                            <p class="text-xs text-text-secondary mb-3">Ganancias o pérdidas totales en dólares agrupadas por día de la semana</p>
                            <div class="chart-container" style="height: 280px;">
                                <canvas id="op-chart-pl-weekdays"></canvas>
                            </div>
                        </div>

                        <!-- Gráfico 5: Tamaños de Posición (Horizontal) -->
                        <div class="metric-card p-4">
                            <h4 class="text-lg font-semibold mb-2">Tamaños de Posición</h4>
                            <p class="text-xs text-text-secondary mb-3">P&L en dólares según el tamaño de la posición (pequeño, mediano, grande)</p>
                            <div class="chart-container" style="height: 280px;">
                                <canvas id="op-chart-position-sizes"></canvas>
                            </div>
                        </div>

                        <!-- Gráfico 6: P/L por Setup (Vertical) -->
                        <div class="metric-card p-4">
                            <h4 class="text-lg font-semibold mb-2">P/L por Setup</h4>
                            <p class="text-xs text-text-secondary mb-3">Rendimiento en dólares de cada estrategia o setup utilizado en el instrumento</p>
                            <div class="chart-container" style="height: 280px;">
                                <canvas id="op-chart-setups"></canvas>
                            </div>
                        </div>
                    </div>

                </div>
                <!-- FIN TAB: MÉTRICAS -->

            </div>
        </section>

        <!-- CHARTBOOK SECTION -->
        <section id="chartbook" class="section-container">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-xl font-semibold">Chartbook - Galería de Trades</h2>
                <div class="flex items-center space-x-2">
                    <div class="flex items-center gap-2">
                        <div id="chartbook-account-logo" class="w-14 h-14 rounded-xl flex items-center justify-center">
                            <img id="chartbook-account-logo-img" src="logos/primexbt-logo.png" alt="" style="width: 56px; height: 56px; object-fit: contain;" class="rounded-xl" loading="lazy">
                        </div>
                        <select id="chartbook-account-select" class="bg-surface text-white border border-border rounded-lg px-4 py-2 focus:outline-none focus:border-primary w-48">
                            <option value="all">Todas las cuentas</option>
                        </select>
                    </div>
                    <select id="chartbook-filter" class="currency-selector">
                        <option value="all">Todos los trades</option>
                        <option value="wins">Solo victorias</option>
                        <option value="losses">Solo pérdidas</option>
                        <option value="with-images">Con imágenes</option>
                    </select>
                </div>
            </div>
            
            <div id="chartbook-stats" class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-6">
                <div class="metric-card p-4">
                    <p class="text-sm text-text-secondary">Total Trades</p>
                    <p id="chartbook-total-trades" class="text-2xl font-bold text-white">0</p>
                </div>
                <div class="metric-card p-4">
                    <p class="text-sm text-text-secondary">Con Imágenes</p>
                    <p id="chartbook-with-images" class="text-2xl font-bold text-primary">0</p>
                </div>
                <div class="metric-card p-4">
                    <p class="text-sm text-text-secondary">Victorias</p>
                    <p id="chartbook-wins" class="text-2xl font-bold text-positive">0</p>
                </div>
                <div class="metric-card p-4">
                    <p class="text-sm text-text-secondary">Pérdidas</p>
                    <p id="chartbook-losses" class="text-2xl font-bold text-negative">0</p>
                </div>
            </div>

            <div id="chartbook-container" class="space-y-4">
                <!-- Trades con imágenes se renderizarán aquí -->
            </div>
        </section>

        <!-- PLAYBOOK SECTION -->
        <section id="playbook" class="section-container">
            <!-- Pestañas de Navegación -->
            <div class="nav-tabs flex mb-6">
                <div class="nav-tab playbook-tab active" data-target="playbook-setups-view">Setups</div>
                <div class="nav-tab playbook-tab" data-target="playbook-analysis-view">Análisis</div>
                <div class="nav-tab playbook-tab" data-target="playbook-comparative-view">Comparativa</div>
                <div class="nav-tab playbook-tab" data-target="playbook-backtest-view">Backtesting</div>
                <div class="nav-tab playbook-tab" data-target="playbook-management-view">Gestión</div>
            </div>

            <!-- VISTA: Setups (Principal) -->
            <div id="playbook-setups-view" class="playbook-view active">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-xl font-semibold">📖 Playbook - Mis Setups de Trading</h2>
                <button id="add-setup-btn" class="primary">
                    <i class="fas fa-plus mr-2"></i>Nuevo Setup
                </button>
            </div>

            <div id="playbook-stats" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-6">
                <div class="metric-card p-4">
                    <div class="flex items-center justify-between mb-2">
                        <p class="text-sm text-text-secondary">Total Setups</p>
                        <i class="fas fa-book text-primary"></i>
                    </div>
                    <p id="playbook-total-setups" class="text-3xl font-bold text-white">0</p>
                    <p id="playbook-by-category" class="text-xs text-text-secondary mt-1">Por categoría</p>
                </div>
                <div class="metric-card p-4">
                    <div class="flex items-center justify-between mb-2">
                        <p class="text-sm text-text-secondary">Rating Promedio</p>
                        <i class="fas fa-star text-yellow"></i>
                    </div>
                    <p id="playbook-avg-rating" class="text-3xl font-bold text-yellow">0.0</p>
                    <div id="playbook-rating-stars" class="text-sm mt-1">☆☆☆☆☆</div>
                </div>
                <div class="metric-card p-4">
                    <div class="flex items-center justify-between mb-2">
                        <p class="text-sm text-text-secondary">Más Usado</p>
                        <i class="fas fa-fire text-red"></i>
                    </div>
                    <p id="playbook-most-used-name" class="text-lg font-bold text-white truncate">-</p>
                    <p id="playbook-most-used-count" class="text-xs text-text-secondary mt-1">0 veces</p>
                </div>
                <div class="metric-card p-4">
                    <div class="flex items-center justify-between mb-2">
                        <p class="text-sm text-text-secondary">Mejor Winrate</p>
                        <i class="fas fa-trophy text-success"></i>
                    </div>
                    <p id="playbook-best-wr-name" class="text-lg font-bold text-success truncate">-</p>
                    <p id="playbook-best-wr-value" class="text-xs text-text-secondary mt-1">0%</p>
                </div>
            </div>

            <!-- Performance Table por Setup -->
            <div class="metric-card mb-6" id="playbook-performance-section" style="display:none;">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-lg font-semibold mb-1">Rendimiento por Setup</h3>
                    <p class="text-xs text-text-secondary mb-2">Comparación de resultados entre diferentes estrategias</p>
                    <button id="toggle-performance-table" class="text-sm text-primary hover:underline">
                        <i class="fas fa-chart-bar mr-1"></i>Ver Estadísticas
                    </button>
                </div>
                <div id="playbook-performance-table-container" style="display:none;">
                    <div class="overflow-x-auto">
                        <table class="w-full text-sm">
                            <thead>
                                <tr class="border-b border-border">
                                    <th class="text-left p-2">Setup</th>
                                    <th class="text-center p-2">Trades</th>
                                    <th class="text-center p-2">Winrate</th>
                                    <th class="text-center p-2">Avg Win</th>
                                    <th class="text-center p-2">Avg Loss</th>
                                    <th class="text-center p-2">P/L Total</th>
                                    <th class="text-center p-2">Profit Factor</th>
                                    <th class="text-center p-2">Última Vez</th>
                                </tr>
                            </thead>
                            <tbody id="playbook-performance-tbody">
                                <!-- Rendered by JS -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

            <!-- Modal para agregar/editar setup -->
            <div id="setup-modal" class="modal" style="display: none;">
                <div class="modal-content" style="max-width: 900px; max-height: 90vh; overflow-y: auto;">
                    <div class="modal-header" style="position: sticky; top: 0; background: var(--surface); z-index: 100; padding-bottom: 1rem; border-bottom: 1px solid var(--border);">
                        <h3 class="text-xl font-semibold" id="setup-modal-title">Nuevo Setup</h3>
                        <button id="close-setup-modal" class="text-2xl">&times;</button>
                    </div>

                    <div class="modal-body" style="padding: 1.5rem 0;">
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                            <div>
                                <label class="block mb-1">Nombre del Setup *</label>
                                <input type="text" id="setup-name" placeholder="Ej: Breakout Pullback" class="w-full">
                            </div>
                            <div>
                                <label class="block mb-1">Categoría *</label>
                                <div class="flex gap-2">
                                    <select id="setup-category" class="flex-1">
                                        <!-- Se llena dinámicamente -->
                                    </select>
                                    <button id="add-category-btn" class="px-3 py-2 bg-primary text-background rounded hover:bg-primary-dark" title="Nueva categoría">
                                        <i class="fas fa-plus"></i>
                                    </button>
                                </div>
                            </div>
                        </div>

                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                            <div>
                                <label class="block mb-1">Rating (1-5 estrellas) *</label>
                                <div id="setup-rating-selector" class="flex items-center space-x-2">
                                    <span class="star cursor-pointer text-3xl opacity-30 hover:opacity-100 transition-opacity" data-value="1">⭐</span>
                                    <span class="star cursor-pointer text-3xl opacity-30 hover:opacity-100 transition-opacity" data-value="2">⭐</span>
                                    <span class="star cursor-pointer text-3xl opacity-30 hover:opacity-100 transition-opacity" data-value="3">⭐</span>
                                    <span class="star cursor-pointer text-3xl opacity-30 hover:opacity-100 transition-opacity" data-value="4">⭐</span>
                                    <span class="star cursor-pointer text-3xl opacity-30 hover:opacity-100 transition-opacity" data-value="5">⭐</span>
                                </div>
                                <input type="hidden" id="setup-rating" value="0">
                            </div>
                            <div>
                                <label class="block mb-1">Grado de Calidad *</label>
                                <select id="setup-grade" class="w-full">
                                    <option value="">Seleccionar grado...</option>
                                    <option value="P">🏆 P - Premium</option>
                                    <option value="A+">💎 A+ - Excelente Alto</option>
                                    <option value="A">✨ A - Excelente</option>
                                    <option value="B+">⭐ B+ - Bueno Alto</option>
                                    <option value="B">👍 B - Bueno</option>
                                </select>
                            </div>
                        </div>

                        <div class="mb-4">
                            <label class="block mb-1">Tags / Estrategias</label>
                            <div class="flex gap-2 mb-2">
                                <input type="text" id="setup-tag-input" placeholder="Agregar tag..." class="flex-1">
                                <button id="add-tag-btn" class="px-4 py-2 bg-primary text-background rounded hover:bg-primary-dark">
                                    <i class="fas fa-plus mr-1"></i>Agregar
                                </button>
                            </div>
                            <div id="setup-tags-container" class="flex flex-wrap gap-2 min-h-[40px] p-2 bg-background rounded border border-border">
                                <!-- Tags se muestran aquí -->
                            </div>
                        </div>

                        <div class="mb-4">
                            <label class="block mb-1">Descripción</label>
                            <textarea id="setup-description" rows="4" placeholder="Describe tu setup, condiciones de entrada, stop loss, take profit..." class="w-full"></textarea>
                        </div>

                        <div class="mb-4">
                            <label class="block mb-1">Imágenes (opcional)</label>
                            <input type="file" id="setup-images" accept="image/*" multiple class="w-full">
                            <p class="text-xs text-text-secondary mt-1">Puedes subir múltiples imágenes de ejemplo</p>
                            <div id="setup-images-preview" class="grid grid-cols-3 gap-2 mt-2">
                                <!-- Preview de imágenes -->
                            </div>
                        </div>
                    </div>

                    <div class="modal-footer" style="position: sticky; bottom: 0; background: var(--surface); z-index: 100; padding-top: 1rem; border-top: 1px solid var(--border); display: flex; justify-content: flex-end; gap: 0.5rem;">
                        <button id="cancel-setup-btn" class="px-6 py-2">Cancelar</button>
                        <button id="save-setup-btn" class="primary px-6 py-2">Guardar Setup</button>
                    </div>
                </div>
            </div>

            <div id="playbook-container" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                <!-- Setups se renderizarán aquí -->
            </div>
            
            <!-- MODAL: DETALLES DEL PLAYBOOK (PANTALLA COMPLETA) -->
            <div id="setup-details-modal" class="modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 9999; background-color: rgba(0,0,0,1);">
                <div class="modal-content" style="width: 100vw; height: 100vh; max-width: 100vw; max-height: 100vh; border-radius: 0; padding: 0; margin: 0; background-color: #000000;">
                    <!-- Header Fijo -->
                    <div class="sticky top-0 z-50 border-b border-border" style="background-color: #000000;">
                        <div class="flex items-center justify-between p-6">
                            <div class="flex items-center gap-4">
                                <button id="close-setup-details-modal" class="text-3xl text-text-secondary hover:text-white transition-colors">
                                    <i class="fas fa-times"></i>
                                </button>
                                <div>
                                    <h2 id="setup-details-title" class="text-2xl font-bold"></h2>
                                    <p id="setup-details-subtitle" class="text-sm text-text-secondary"></p>
                                </div>
                            </div>
                            <div class="flex items-center gap-3">
                                <span id="setup-details-rating" class="text-3xl"></span>
                                <span id="setup-details-grade" class="text-3xl"></span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Contenido Scrolleable -->
                    <div class="overflow-y-auto" style="height: calc(100vh - 100px); background-color: #000000;">
                        <div class="p-8" style="background-color: #000000;">
                            <!-- KPIs Principales -->
                            <div class="grid grid-cols-2 md:grid-cols-4 gap-6 mb-8">
                                <div class="metric-card text-center p-6">
                                    <div class="text-4xl font-bold text-primary" id="detail-total-trades">0</div>
                                    <div class="text-sm text-text-secondary mt-2">Total Trades</div>
                                </div>
                                <div class="metric-card text-center p-6">
                                    <div class="text-4xl font-bold text-success" id="detail-win-rate">0%</div>
                                    <div class="text-sm text-text-secondary mt-2">Win Rate</div>
                                </div>
                                <div class="metric-card text-center p-6">
                                    <div class="text-4xl font-bold" id="detail-profit-factor">0.00</div>
                                    <div class="text-sm text-text-secondary mt-2">Profit Factor</div>
                                </div>
                                <div class="metric-card text-center p-6">
                                    <div class="text-4xl font-bold text-primary" id="detail-total-pl">$0.00</div>
                                    <div class="text-sm text-text-secondary mt-2">P/L Total</div>
                                </div>
                            </div>
                            
                            <!-- Grid de 2 Columnas -->
                            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8">
                                <!-- Columna Izquierda: Gráficas de Análisis -->
                                <div class="space-y-6">
                                    <!-- Performance Score -->
                                    <div class="metric-card">
                                        <h3 class="text-lg font-semibold mb-1">Puntuación de Rendimiento</h3>
                                        <p class="text-xs text-text-secondary mb-3">Radar de métricas clave del setup</p>
                                        <div class="chart-container" style="height: 350px;">
                                            <canvas id="setup-detail-performance-chart"></canvas>
                                        </div>
                                    </div>
                                    
                                    <!-- Expectancy Breakdown -->
                                    <div class="metric-card">
                                        <h3 class="text-lg font-semibold mb-1">Expectancy Breakdown</h3>
                                        <p class="text-xs text-text-secondary mb-3">Desglose de ganancias vs pérdidas promedio</p>
                                        <div class="chart-container" style="height: 300px;">
                                            <canvas id="setup-detail-expectancy-chart"></canvas>
                                        </div>
                                        <div class="grid grid-cols-2 gap-4 mt-4">
                                            <div class="text-center p-3 bg-surface rounded">
                                                <div class="text-sm text-text-secondary">Avg Win</div>
                                                <div class="text-xl font-bold text-success" id="detail-avg-win">$0.00</div>
                                            </div>
                                            <div class="text-center p-3 bg-surface rounded">
                                                <div class="text-sm text-text-secondary">Avg Loss</div>
                                                <div class="text-xl font-bold text-danger" id="detail-avg-loss">$0.00</div>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <!-- Rendimiento Diario -->
                                    <div class="metric-card">
                                        <h3 class="text-lg font-semibold mb-1">Rendimiento Diario</h3>
                                        <p class="text-xs text-text-secondary mb-3">P&L diario del setup seleccionado</p>
                                        <div class="chart-container" style="height: 300px;">
                                            <canvas id="setup-detail-daily-pl-chart"></canvas>
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Columna Derecha: Notas y Descripción -->
                                <div class="space-y-6">
                                    <!-- Descripción del Setup -->
                                    <div class="metric-card">
                                        <div class="flex items-center justify-between mb-4">
                                            <h3 class="text-lg font-semibold">📋 Descripción del Setup</h3>
                                        </div>
                                        <div id="setup-details-description" class="text-sm text-text-secondary whitespace-pre-wrap">
                                            <!-- Descripción -->
                                        </div>
                                    </div>
                                    
                                    <!-- Editor de Notas Avanzado -->
                                    <div class="metric-card">
                                        <div class="flex items-center justify-between mb-4">
                                            <h3 class="text-lg font-semibold">📝 Notas Estratégicas</h3>
                                            <button id="setup-notes-edit-btn" class="btn-primary text-sm">
                                                <i class="fas fa-edit mr-2"></i>Editar Notas
                                            </button>
                                        </div>
                                        
                                        <!-- Vista de Notas -->
                                        <div id="setup-notes-view">
                                            <div id="setup-notes-content" class="prose prose-invert max-w-none min-h-[300px]">
                                                <p class="text-text-secondary italic">No hay notas escritas aún. Haz clic en "Editar Notas" para comenzar.</p>
                                            </div>
                                            <button id="setup-notes-goto-notebook" class="btn-secondary text-sm mt-4">
                                                <i class="fas fa-book mr-2"></i>Ver en Notebook
                                            </button>
                                        </div>
                                        
                                        <!-- Editor de Notas -->
                                        <div id="setup-notes-edit" class="hidden">
                                            <div id="setup-notes-rich-editor-container" style="min-height: 500px;"></div>
                                            <div class="flex gap-3 mt-4">
                                                <button id="setup-notes-save-btn" class="btn-primary">
                                                    <i class="fas fa-save mr-2"></i>Guardar Notas
                                                </button>
                                                <button id="setup-notes-cancel-btn" class="btn-secondary">
                                                    <i class="fas fa-times mr-2"></i>Cancelar
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <!-- Galería de Imágenes -->
                                    <div class="metric-card" id="setup-details-images-section">
                                        <div class="flex items-center justify-between mb-4">
                                            <h3 class="text-lg font-semibold">🖼️ Galería de Imágenes</h3>
                                            <button id="setup-add-images-btn" class="btn-secondary text-sm">
                                                <i class="fas fa-plus mr-2"></i>Agregar Imágenes
                                            </button>
                                        </div>
                                        <div id="setup-details-images-grid" class="grid grid-cols-2 gap-4">
                                            <!-- Imágenes -->
                                        </div>
                                        
                                        <!-- Input para agregar imágenes (oculto) -->
                                        <input type="file" id="setup-details-image-input" accept="image/*" multiple class="hidden">
                                    </div>
                                    
                                    <!-- Métricas Adicionales -->
                                    <div class="metric-card">
                                        <h3 class="text-lg font-semibold mb-1">Métricas Detalladas</h3>
                                        <p class="text-xs text-text-secondary mb-3">Indicadores clave de rendimiento del setup</p>
                                        <div class="grid grid-cols-2 gap-4">
                                            <div class="p-3 bg-surface rounded">
                                                <div class="text-sm text-text-secondary">Expectancy</div>
                                                <div class="text-lg font-bold" id="detail-expectancy">$0.00</div>
                                            </div>
                                            <div class="p-3 bg-surface rounded">
                                                <div class="text-sm text-text-secondary">Última Vez</div>
                                                <div class="text-lg font-bold" id="detail-last-used">-</div>
                                            </div>
                                            <div class="p-3 bg-surface rounded">
                                                <div class="text-sm text-text-secondary">Categoría</div>
                                                <div class="text-lg font-bold" id="detail-category">-</div>
                                            </div>
                                            <div class="p-3 bg-surface rounded">
                                                <div class="text-sm text-text-secondary">Tags</div>
                                                <div id="detail-tags" class="flex flex-wrap gap-1 mt-1">
                                                    <!-- Tags -->
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            </div>

            <!-- VISTA: Análisis Individual -->
            <div id="playbook-analysis-view" class="playbook-view" style="display:none;">
                <h2 class="text-xl font-semibold mb-6">Análisis de Setup Individual</h2>
                
                <!-- Selector de Setup -->
                <div class="metric-card mb-6">
                    <div class="flex items-center gap-4">
                        <label class="text-sm font-semibold">Seleccionar Setup:</label>
                        <select id="individual-setup-select" class="flex-1">
                            <option value="">Seleccionar setup para analizar...</option>
                        </select>
                    </div>
                </div>

                <!-- Contenedor de resultados (solo visible cuando se selecciona un setup) -->
                <div id="individual-analysis-results" style="display:none;">
                    <!-- KPIs del Setup Individual -->
                    <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
                        <div class="metric-card text-center">
                            <div class="text-2xl font-bold text-primary" id="ind-total-trades">0</div>
                            <div class="text-sm text-text-secondary">Total Trades</div>
                        </div>
                        <div class="metric-card text-center">
                            <div class="text-2xl font-bold text-success" id="ind-win-rate">0%</div>
                            <div class="text-sm text-text-secondary">Win Rate</div>
                        </div>
                        <div class="metric-card text-center">
                            <div class="text-2xl font-bold" id="ind-profit-factor">0.00</div>
                            <div class="text-sm text-text-secondary">Profit Factor</div>
                        </div>
                        <div class="metric-card text-center">
                            <div class="text-2xl font-bold text-primary" id="ind-expectancy">$0.00</div>
                            <div class="text-sm text-text-secondary">Expectancy</div>
                        </div>
                    </div>

                    <!-- Gráficas en Grid 2 Columnas (como Informe) -->
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                        <!-- 1. PERFORMANCE SCORE (PRIMERO) -->
                        <div class="metric-card">
                            <h3 class="text-lg font-semibold mb-1">Puntuación de Rendimiento</h3>
                            <p class="text-xs text-text-secondary mb-3">Análisis multidimensional: Win%, Profit Factor, Avg Win/Loss, Control de Drawdown y Consistencia</p>
                            <div class="chart-container" style="height: 300px;">
                                <canvas id="ind-performance-score-chart"></canvas>
                            </div>
                        </div>

                        <!-- 2. EXPECTANCY BREAKDOWN -->
                        <div class="metric-card">
                            <h3 class="text-lg font-semibold mb-1">Expectancy Breakdown</h3>
                            <p class="text-xs text-text-secondary mb-3">Desglose matemático: (Win% × AvgWin) - (Loss% × AvgLoss) = $ esperado por trade</p>
                            <div class="chart-container" style="height: 300px;">
                                <canvas id="expectancy-breakdown-chart"></canvas>
                            </div>
                        </div>

                        <!-- 3. WIN/LOSS MAGNITUDE DISTRIBUTION -->
                        <div class="metric-card">
                            <h3 class="text-lg font-semibold mb-2">📏 Win/Loss Magnitude Distribution</h3>
                            <p class="text-xs text-text-secondary mb-3">Distribución del tamaño de ganancias vs pérdidas: ¿Ganas más cuando aciertas?</p>
                            <div class="chart-container" style="height: 300px;">
                                <canvas id="magnitude-distribution-chart"></canvas>
                            </div>
                        </div>

                        <!-- 4. CONSECUTIVE TRADE SEQUENCES -->
                        <div class="metric-card">
                            <h3 class="text-lg font-semibold mb-2">🔄 Consecutive Trade Sequences</h3>
                            <p class="text-xs text-text-secondary mb-3">Rendimiento del siguiente trade después de rachas: ¿Mejoras o emperas tras wins/losses?</p>
                            <div class="chart-container" style="height: 300px;">
                                <canvas id="consecutive-sequences-chart"></canvas>
                            </div>
                        </div>

                        <!-- 5. DRAWDOWN RECOVERY RATE -->
                        <div class="metric-card">
                            <h3 class="text-lg font-semibold mb-1">Drawdown Recovery Rate</h3>
                            <p class="text-xs text-text-secondary mb-2">Velocidad de recuperación de pérdidas máximas</p>
                            <p class="text-xs text-text-secondary mb-3">Trades necesarios para recuperar después de pérdidas: Resiliencia del setup</p>
                            <div class="chart-container" style="height: 300px;">
                                <canvas id="drawdown-recovery-chart"></canvas>
                            </div>
                        </div>

                        <!-- 6. DISTRIBUCIÓN POR HORARIO -->
                        <div class="metric-card">
                            <h3 class="text-lg font-semibold mb-1">Distribución por Horario</h3>
                            <p class="text-xs text-text-secondary mb-3">P&L agregado por franja horaria: Identifica tus mejores horas de trading</p>
                            <div class="chart-container" style="height: 300px;">
                                <canvas id="ind-hourly-distribution-chart"></canvas>
                            </div>
                        </div>

                        <!-- 7. RENDIMIENTO POR DÍA DE SEMANA -->
                        <div class="metric-card">
                            <h3 class="text-lg font-semibold mb-1">Rendimiento por Día de Semana</h3>
                            <p class="text-xs text-text-secondary mb-2">P&L promedio por cada día de la semana</p>
                            <p class="text-xs text-text-secondary mb-3">P&L total por día: Descubre tus mejores días</p>
                            <div class="chart-container" style="height: 300px;">
                                <canvas id="ind-weekday-bar-chart"></canvas>
                            </div>
                        </div>

                        <!-- 8. NET DAILY P&L -->
                        <div class="metric-card">
                            <h3 class="text-lg font-semibold mb-1">Net Daily P&L</h3>
                            <p class="text-xs text-text-secondary mb-3">Resultado diario neto de todas las operaciones</p>
                            <p class="text-xs text-text-secondary mb-3">P&L diario neto: Visualiza tu rendimiento día a día</p>
                            <div class="chart-container" style="height: 300px;">
                                <canvas id="ind-net-daily-pl-chart"></canvas>
                            </div>
                        </div>
                    </div>

                    <!-- Métricas Adicionales del Setup -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-1">Métricas Detalladas</h3>
                        <p class="text-xs text-text-secondary mb-3">Indicadores avanzados de rendimiento</p>
                        <div class="grid grid-cols-2 md:grid-cols-3 gap-4">
                            <div>
                                <p class="text-sm text-text-secondary">Avg Win</p>
                                <p class="text-lg font-bold text-success" id="ind-avg-win">$0.00</p>
                            </div>
                            <div>
                                <p class="text-sm text-text-secondary">Avg Loss</p>
                                <p class="text-lg font-bold text-danger" id="ind-avg-loss">$0.00</p>
                            </div>
                            <div>
                                <p class="text-sm text-text-secondary">Performance Score</p>
                                <p class="text-lg font-bold" id="ind-perf-score">0/100</p>
                            </div>
                            <div>
                                <p class="text-sm text-text-secondary">Consistencia</p>
                                <p class="text-lg font-bold" id="ind-consistency">0%</p>
                            </div>
                            <div>
                                <p class="text-sm text-text-secondary">Total P&L</p>
                                <p class="text-lg font-bold" id="ind-total-pl">$0.00</p>
                            </div>
                            <div>
                                <p class="text-sm text-text-secondary">Categoría</p>
                                <p class="text-lg font-bold" id="ind-category">-</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- VISTA: Comparativa -->
            <div id="playbook-comparative-view" class="playbook-view" style="display:none;">
                <h2 class="text-xl font-semibold mb-6">Comparativa de Setups</h2>
                
                <!-- KPIs Principales -->
                <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
                    <div class="metric-card text-center">
                        <div class="text-2xl font-bold text-primary" id="comp-total-setups">0</div>
                        <div class="text-sm text-text-secondary">Total Setups</div>
                    </div>
                    <div class="metric-card text-center">
                        <div class="text-2xl font-bold text-success" id="comp-total-trades">0</div>
                        <div class="text-sm text-text-secondary">Trades Ejecutados</div>
                    </div>
                    <div class="metric-card text-center">
                        <div class="text-2xl font-bold text-primary" id="comp-avg-expectancy">$0.00</div>
                        <div class="text-sm text-text-secondary">Expectancy Promedio</div>
                    </div>
                    <div class="metric-card text-center">
                        <div class="text-2xl font-bold" id="comp-best-setup">-</div>
                        <div class="text-sm text-text-secondary">Mejor Setup</div>
                    </div>
                </div>

                <!-- Expectancy (Esperanza Matemática) -->
                <div class="metric-card mb-6">
                    <h3 class="text-lg font-semibold mb-1">Expectancy por Setup ($/Trade)</h3>
                    <p class="text-xs text-text-secondary mb-3">Cuánto dinero generas por cada dólar que arriesgas en promedio</p>
                    <canvas id="expectancy-bar-chart" style="max-height: 350px;"></canvas>
                    <div id="expectancy-details" class="mt-4 grid grid-cols-1 md:grid-cols-2 gap-3">
                        <!-- Detalles de expectancy -->
                    </div>
                </div>

                <!-- Puntuación de Rendimiento -->
                <div class="metric-card mb-6">
                    <h3 class="text-lg font-semibold mb-1">Puntuación de Rendimiento por Setup</h3>
                    <p class="text-xs text-text-secondary mb-3">Puntuación basada en: Winrate (30%), Profit Factor (30%), Expectancy (20%), Consistencia (20%)</p>
                    <canvas id="performance-score-chart" style="max-height: 350px;"></canvas>
                    <div class="mt-4 overflow-x-auto">
                        <table class="w-full text-sm">
                            <thead>
                                <tr class="border-b border-border">
                                    <th class="text-left p-2">Setup</th>
                                    <th class="text-center p-2">Score</th>
                                    <th class="text-center p-2">Win%</th>
                                    <th class="text-center p-2">PF</th>
                                    <th class="text-center p-2">Exp</th>
                                    <th class="text-center p-2">Consist.</th>
                                </tr>
                            </thead>
                            <tbody id="performance-score-table">
                                <!-- Tabla de scores -->
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- Activo vs Setup (Gráfico Circular) -->
                <div class="metric-card mb-6">
                    <h3 class="text-lg font-semibold mb-1">Distribución: Activos por Setup</h3>
                    <p class="text-xs text-text-secondary mb-3">Relación entre instrumentos operados y estrategias utilizadas</p>
                    <p class="text-sm text-text-secondary mb-4">Qué setup funciona mejor en cada tipo de activo</p>
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                        <div>
                            <canvas id="asset-setup-pie-chart" style="max-height: 300px;"></canvas>
                        </div>
                        <div id="asset-setup-details" class="grid grid-cols-3 gap-3">
                            <!-- Detalles por activo -->
                        </div>
                    </div>
                </div>

                <!-- Rendimiento por Día de Semana - Gráfica de Barras -->
                <div class="metric-card mb-6">
                    <h3 class="text-lg font-semibold mb-1">Rendimiento por Día de Semana</h3>
                    <p class="text-xs text-text-secondary mb-3">Comparación de resultados por cada día de la semana</p>
                    <div class="chart-container" style="height: 300px;">
                        <canvas id="playbook-weekday-bar-chart"></canvas>
                    </div>
                </div>

                <!-- Matriz de Correlación Setup-Resultado -->
                <div class="metric-card mb-6">
                    <h3 class="text-lg font-semibold mb-4">🔥 Heatmap: Rendimiento por Día de Semana</h3>
                    <div class="overflow-x-auto">
                        <div id="weekday-heatmap" style="min-width: 600px;">
                            <!-- Heatmap generado dinámicamente -->
                        </div>
                    </div>
                </div>

                <!-- Análisis de Consistencia -->
                <div class="metric-card">
                    <h3 class="text-lg font-semibold mb-1">Análisis de Consistencia</h3>
                    <p class="text-xs text-text-secondary mb-3">Estabilidad del rendimiento a lo largo del tiempo</p>
                    <p class="text-sm text-text-secondary mb-4">Qué tan consistente es cada setup a lo largo del tiempo</p>
                    <canvas id="consistency-line-chart" style="max-height: 300px;"></canvas>
                </div>
            </div>

            <!-- VISTA: Backtesting -->
            <div id="playbook-backtest-view" class="playbook-view" style="display:none;">
                <h2 class="text-xl font-semibold mb-6">🔬 Backtesting de Setups</h2>
                
                <!-- Selector de Setup -->
                <div class="metric-card mb-6">
                    <div class="flex items-center gap-4 mb-4">
                        <select id="backtest-setup-select" class="flex-1">
                            <option value="">Seleccionar setup para analizar...</option>
                        </select>
                        <button id="backtest-analyze-btn" class="primary px-6 py-2" disabled>
                            <i class="fas fa-chart-line mr-2"></i>Analizar
                        </button>
                    </div>
                </div>

                <!-- Resultados de Backtesting -->
                <div id="backtest-results" style="display:none;">
                    <!-- Métricas Generales -->
                    <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
                        <div class="metric-card text-center">
                            <div class="text-2xl font-bold text-primary" id="bt-total-trades">-</div>
                            <div class="text-sm text-text-secondary">Total Trades</div>
                        </div>
                        <div class="metric-card text-center">
                            <div class="text-2xl font-bold text-success" id="bt-win-rate">-</div>
                            <div class="text-sm text-text-secondary">Win Rate</div>
                        </div>
                        <div class="metric-card text-center">
                            <div class="text-2xl font-bold" id="bt-profit-factor">-</div>
                            <div class="text-sm text-text-secondary">Profit Factor</div>
                        </div>
                        <div class="metric-card text-center">
                            <div class="text-2xl font-bold" id="bt-avg-rr">-</div>
                            <div class="text-sm text-text-secondary">Avg R:R</div>
                        </div>
                    </div>

                    <!-- Curva de Equity -->
                    <div class="metric-card mb-6">
                        <h3 class="text-lg font-semibold mb-1">Curva de Equity</h3>
                        <p class="text-xs text-text-secondary mb-3">Evolución del capital a lo largo del tiempo</p>
                        <canvas id="equity-curve-chart" style="max-height: 300px;"></canvas>
                    </div>

                    <!-- Heatmap de Rendimiento -->
                    <div class="metric-card mb-6">
                        <h3 class="text-lg font-semibold mb-4">🔥 Heatmap de Rendimiento por Hora/Día</h3>
                        <div id="performance-heatmap" class="overflow-x-auto"></div>
                    </div>

                    <!-- Timeline de Operaciones -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-1">Timeline de Operaciones</h3>
                        <p class="text-xs text-text-secondary mb-3">Línea temporal de trades ejecutados</p>
                        <div class="overflow-x-auto">
                            <table class="w-full" id="backtest-trades-table">
                                <thead>
                                    <tr>
                                        <th>Fecha</th>
                                        <th>Símbolo</th>
                                        <th>Tipo</th>
                                        <th>P&L</th>
                                        <th>R:R</th>
                                        <th>Tags</th>
                                    </tr>
                                </thead>
                                <tbody></tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>

            <!-- VISTA: Gestión -->
            <div id="playbook-management-view" class="playbook-view" style="display:none;">
                <h2 class="text-xl font-semibold mb-6">⚙️ Gestión de Playbook</h2>
                
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <!-- Exportar/Importar -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-4">💾 Exportar/Importar</h3>
                        <div class="space-y-3">
                            <button id="export-all-setups" class="primary w-full">
                                <i class="fas fa-download mr-2"></i>Exportar Todos los Setups (JSON)
                            </button>
                            <button id="export-by-grade" class="w-full">
                                <i class="fas fa-filter mr-2"></i>Exportar por Grado
                            </button>
                            <button id="import-setups-trigger" class="w-full">
                                <i class="fas fa-upload mr-2"></i>Importar Setups
                            </button>
                            <input type="file" id="import-setups-file" accept=".json" style="display:none;">
                            <p class="text-xs text-text-secondary mt-2">
                                <i class="fas fa-info-circle mr-1"></i>
                                Los setups se exportan en formato JSON compatible
                            </p>
                        </div>
                    </div>

                    <!-- Checklist de Validación -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-4">✅ Checklist de Validación</h3>
                        <div class="space-y-2 mb-4" id="setup-checklist">
                            <label class="flex items-center">
                                <input type="checkbox" class="mr-2" checked disabled>
                                <span class="text-sm">Todos los setups tienen nombre</span>
                            </label>
                            <label class="flex items-center">
                                <input type="checkbox" class="mr-2" id="check-all-categorized">
                                <span class="text-sm">Todos tienen categoría</span>
                            </label>
                            <label class="flex items-center">
                                <input type="checkbox" class="mr-2" id="check-all-graded">
                                <span class="text-sm">Todos tienen grado asignado</span>
                            </label>
                            <label class="flex items-center">
                                <input type="checkbox" class="mr-2" id="check-all-rated">
                                <span class="text-sm">Todos tienen rating</span>
                            </label>
                            <label class="flex items-center">
                                <input type="checkbox" class="mr-2" id="check-all-described">
                                <span class="text-sm">Todos tienen descripción</span>
                            </label>
                        </div>
                        <button id="validate-all-setups" class="primary w-full">
                            <i class="fas fa-check-double mr-2"></i>Validar Todos
                        </button>
                    </div>

                    <!-- Alertas y Notificaciones -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-4">🔔 Alertas</h3>
                        <div class="space-y-3">
                            <div>
                                <label class="block text-sm mb-1">Alertar si Win Rate cae debajo de:</label>
                                <div class="flex items-center gap-2">
                                    <input type="number" id="alert-winrate" min="0" max="100" value="50" class="flex-1">
                                    <span class="text-sm">%</span>
                                </div>
                            </div>
                            <div>
                                <label class="block text-sm mb-1">Alertar si Profit Factor es menor a:</label>
                                <input type="number" id="alert-pf" min="0" step="0.1" value="1.5" class="w-full">
                            </div>
                            <div>
                                <label class="block text-sm mb-1">Alertar si setup no usado en (días):</label>
                                <input type="number" id="alert-unused-days" min="1" value="30" class="w-full">
                            </div>
                            <button id="save-alerts-config" class="primary w-full">
                                <i class="fas fa-bell mr-2"></i>Guardar Configuración
                            </button>
                        </div>
                    </div>

                    <!-- Estadísticas Generales -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-1">Estadísticas</h3>
                        <p class="text-xs text-text-secondary mb-3">Resumen de métricas del setup</p>
                        <div class="space-y-2 text-sm">
                            <div class="flex justify-between">
                                <span class="text-text-secondary">Total de Setups:</span>
                                <span class="font-semibold" id="stats-total-setups">0</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-text-secondary">Setups Premium (P):</span>
                                <span class="font-semibold text-yellow-500" id="stats-premium">0</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-text-secondary">Categorías únicas:</span>
                                <span class="font-semibold" id="stats-categories">0</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-text-secondary">Tags únicos:</span>
                                <span class="font-semibold" id="stats-tags">0</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-text-secondary">Rating promedio:</span>
                                <span class="font-semibold" id="stats-avg-rating">0.0</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- MODAL: Asignar Setup a Operación -->
        <div id="assign-setup-modal" class="modal" style="display: none;">
            <div class="modal-content" style="max-width: 600px;">
                <div class="flex justify-between items-center mb-6">
                    <h3 class="text-xl font-semibold">📖 Asignar Setup a Operación</h3>
                    <button id="close-assign-setup-modal" class="text-2xl hover:text-primary">&times;</button>
                </div>

                <input type="hidden" id="assign-setup-operation-id">

                <div class="mb-4">
                    <p class="text-sm text-text-secondary mb-4">Selecciona una estrategia de tu Playbook para catalogar esta operación:</p>
                    
                    <div id="assign-setup-list" class="space-y-2 max-h-96 overflow-y-auto">
                        <!-- Se renderizarán los setups disponibles aquí -->
                    </div>
                </div>

                <div class="flex justify-between items-center mt-6">
                    <button id="remove-setup-btn" class="text-red-500 hover:text-red-400" style="display: none;">
                        <i class="fas fa-times-circle mr-1"></i>Quitar Setup
                    </button>
                    <button id="cancel-assign-setup-btn" class="ml-auto">Cancelar</button>
                </div>
            </div>
        </div>

        <!-- MODALES DE NOTEBOOK -->
        
        <!-- MODAL: Nueva Carpeta -->
        <div id="new-folder-modal" class="modal" style="display: none;">
            <div class="modal-content" style="max-width: 500px;">
                <div class="flex justify-between items-center mb-6">
                    <h3 class="text-xl font-semibold">📁 Nueva Carpeta</h3>
                    <button class="close-modal text-2xl hover:text-primary" data-modal="new-folder-modal">&times;</button>
                </div>
                <div class="mb-4">
                    <label class="block mb-2">Nombre de la carpeta</label>
                    <input type="text" id="folder-name-input" placeholder="Ej: Operaciones, Playbook, Ideas..." class="w-full">
                </div>
                <div class="mb-4">
                    <label class="block mb-2">Icono (opcional)</label>
                    <div class="grid grid-cols-8 gap-2" id="folder-icon-picker">
                        <button type="button" class="folder-icon-option p-2 hover:bg-surface-light rounded text-2xl" data-icon="📁">📁</button>
                        <button type="button" class="folder-icon-option p-2 hover:bg-surface-light rounded text-2xl" data-icon="📂">📂</button>
                        <button type="button" class="folder-icon-option p-2 hover:bg-surface-light rounded text-2xl" data-icon="📊">📊</button>
                        <button type="button" class="folder-icon-option p-2 hover:bg-surface-light rounded text-2xl" data-icon="📈">📈</button>
                        <button type="button" class="folder-icon-option p-2 hover:bg-surface-light rounded text-2xl" data-icon="📖">📖</button>
                        <button type="button" class="folder-icon-option p-2 hover:bg-surface-light rounded text-2xl" data-icon="💡">💡</button>
                        <button type="button" class="folder-icon-option p-2 hover:bg-surface-light rounded text-2xl" data-icon="🎯">🎯</button>
                        <button type="button" class="folder-icon-option p-2 hover:bg-surface-light rounded text-2xl" data-icon="⭐">⭐</button>
                    </div>
                    <input type="hidden" id="selected-folder-icon" value="📁">
                </div>
                <div class="flex justify-end gap-2">
                    <button class="close-modal px-4 py-2" data-modal="new-folder-modal">Cancelar</button>
                    <button id="save-folder-btn" class="primary px-4 py-2">Crear Carpeta</button>
                </div>
            </div>
        </div>

        <!-- MODAL: Grabar Voz -->
        <div id="voice-recorder-modal" class="modal" style="display: none;">
            <div class="modal-content" style="max-width: 500px;">
                <div class="flex justify-between items-center mb-6">
                    <h3 class="text-xl font-semibold">🎤 Grabar Nota de Voz</h3>
                    <button class="close-modal text-2xl hover:text-primary" data-modal="voice-recorder-modal">&times;</button>
                </div>
                <div class="text-center">
                    <div id="recording-indicator" class="hidden mb-4">
                        <div class="inline-block w-4 h-4 bg-danger rounded-full animate-pulse mr-2"></div>
                        <span class="text-danger font-semibold">Grabando...</span>
                        <div class="text-3xl font-bold mt-2" id="recording-time">00:00</div>
                    </div>
                    <div class="flex justify-center gap-4 mt-6">
                        <button id="start-recording-btn" class="primary px-6 py-3 rounded-lg">
                            <i class="fas fa-microphone mr-2"></i>Iniciar Grabación
                        </button>
                        <button id="stop-recording-btn" class="px-6 py-3 bg-danger rounded-lg hidden">
                            <i class="fas fa-stop mr-2"></i>Detener
                        </button>
                    </div>
                    <div id="audio-preview" class="mt-6 hidden">
                        <audio id="audio-playback" controls class="w-full"></audio>
                        <div class="flex justify-center gap-2 mt-4">
                            <button id="save-audio-btn" class="primary px-4 py-2">
                                <i class="fas fa-save mr-2"></i>Guardar
                            </button>
                            <button id="cancel-audio-btn" class="px-4 py-2">
                                <i class="fas fa-times mr-2"></i>Descartar
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- MODAL: Agregar/Editar Cuenta Funded -->
        <div id="funded-account-modal" class="modal" style="display: none;">
            <div class="modal-content" style="max-width: 700px;">
                <div class="flex justify-between items-center mb-6">
                    <h3 class="text-xl font-semibold" id="funded-modal-title">Nueva Cuenta Funded</h3>
                    <button id="close-funded-modal" class="text-2xl hover:text-primary">&times;</button>
                </div>

                <form id="funded-account-form">
                    <input type="hidden" id="funded-account-id">

                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                        <!-- Nombre de la Cuenta -->
                        <div class="md:col-span-2">
                            <label class="block mb-1 text-sm font-medium">Nombre de la Cuenta *</label>
                            <input type="text" id="funded-name" placeholder="Ej: FTPROPLUS77156392084" required class="w-full">
                        </div>

                        <!-- Empresa (Prop Firm) -->
                        <div>
                            <label class="block mb-1 text-sm font-medium">Empresa (Prop Firm) *</label>
                            <select id="funded-company" required class="w-full">
                                <option value="">Seleccionar...</option>
                                <option value="Funding Ticks">Funding Ticks</option>
                                <option value="Alpha Futures">Alpha Futures</option>
                                <option value="Topstep">Topstep</option>
                                <option value="My Funded Futures">My Funded Futures</option>
                                <option value="Earn2Trade">Earn2Trade</option>
                                <option value="The Trading Pit">The Trading Pit</option>
                                <option value="Apex Trader Funding">Apex Trader Funding</option>
                                <option value="Take Profit Trader">Take Profit Trader</option>
                                <option value="Tradeify">Tradeify</option>
                                <option value="TheSers">TheSers</option>
                                <option value="Otra">Otra (personalizada)</option>
                            </select>
                        </div>

                        <!-- Empresa personalizada (si selecciona "Otra") -->
                        <div id="funded-custom-company-container" style="display: none;">
                            <label class="block mb-1 text-sm font-medium">Nombre de la Empresa</label>
                            <input type="text" id="funded-custom-company" placeholder="Nombre personalizado" class="w-full">
                        </div>

                        <!-- Tipo de Cuenta -->
                        <div>
                            <label class="block mb-1 text-sm font-medium">Tipo de Cuenta *</label>
                            <select id="funded-type" required class="w-full">
                                <option value="evaluation">Evaluación</option>
                                <option value="live">Live</option>
                            </select>
                        </div>

                        <!-- Estado -->
                        <div>
                            <label class="block mb-1 text-sm font-medium">Estado *</label>
                            <select id="funded-status" required class="w-full">
                                <option value="active">Activa</option>
                                <option value="suspended">Suspendida</option>
                            </select>
                        </div>

                        <!-- Tarifa de Activación (Gastos) -->
                        <div>
                            <label class="block mb-1 text-sm font-medium">Tarifa de Activación (€) *</label>
                            <input type="number" id="funded-fee" step="0.01" placeholder="0.00" required class="w-full">
                            <p class="text-xs text-text-secondary mt-1">Coste de la evaluación o cuenta</p>
                        </div>

                        <!-- Balance de la Cuenta -->
                        <div>
                            <label class="block mb-1 text-sm font-medium">Balance de la Cuenta (€) *</label>
                            <input type="number" id="funded-balance" step="0.01" placeholder="0.00" required class="w-full">
                            <p class="text-xs text-text-secondary mt-1">Balance actual de la cuenta</p>
                        </div>

                        <!-- Fecha de Activación -->
                        <div>
                            <label class="block mb-1 text-sm font-medium">Fecha de Activación *</label>
                            <input type="date" id="funded-activation-date" required class="w-full">
                        </div>

                        <!-- Ganancias (solo para live) -->
                        <div id="funded-earnings-container" style="display: none;">
                            <label class="block mb-1 text-sm font-medium">Ganancias Acumuladas (€)</label>
                            <input type="number" id="funded-earnings" step="0.01" placeholder="0.00" class="w-full">
                            <p class="text-xs text-text-secondary mt-1">Total de retiros realizados</p>
                        </div>

                        <!-- Número de Retiros -->
                        <div id="funded-withdrawals-container" style="display: none;">
                            <label class="block mb-1 text-sm font-medium">Número de Retiros</label>
                            <input type="number" id="funded-withdrawals-count" placeholder="0" min="0" class="w-full">
                        </div>

                        <!-- Notas (opcional) -->
                        <div class="md:col-span-2">
                            <label class="block mb-1 text-sm font-medium">Notas (Opcional)</label>
                            <textarea id="funded-notes" rows="3" placeholder="Observaciones, objetivos, estrategias..." class="w-full"></textarea>
                        </div>
                    </div>

                    <div class="flex justify-end gap-2 mt-6">
                        <button type="button" id="cancel-funded-account" class="px-4 py-2 bg-surface hover:bg-surface-hover rounded">
                            Cancelar
                        </button>
                        <button type="submit" class="primary px-6 py-2">
                            <i class="fas fa-save mr-2"></i>Guardar
                        </button>
                    </div>
                </form>
            </div>
        </div>

        <!-- MODAL DE ANÁLISIS DEL DÍA / NOTEBOOK DEL DÍA -->
        <div id="day-analysis-modal" class="modal" style="display: none;">
            <div class="modal-content" style="max-width: 1400px; max-height: 90vh; overflow-y: auto;">
                <div class="flex justify-between items-center mb-6 sticky top-0 bg-background z-10 pb-4 border-b border-border">
                    <div>
                        <h3 class="text-2xl font-semibold" id="day-analysis-title">Análisis del Día</h3>
                        <p class="text-sm text-text-secondary mt-1" id="day-analysis-date"></p>
                    </div>
                    <button id="close-day-analysis-modal" class="text-2xl hover:text-primary">&times;</button>
                </div>

                <!-- Resumen del día -->
                <div class="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-8 gap-4 mb-6">
                    <div class="metric-card p-4 text-center">
                        <p class="text-xs text-text-secondary mb-1">Net P&L</p>
                        <p id="day-analysis-net-pl" class="text-xl font-bold">$0.00</p>
                    </div>
                    <div class="metric-card p-4 text-center">
                        <p class="text-xs text-text-secondary mb-1">Trades</p>
                        <p id="day-analysis-trades" class="text-xl font-bold">0</p>
                    </div>
                    <div class="metric-card p-4 text-center">
                        <p class="text-xs text-text-secondary mb-1">Winners</p>
                        <p id="day-analysis-winners" class="text-xl font-bold text-green">0</p>
                    </div>
                    <div class="metric-card p-4 text-center">
                        <p class="text-xs text-text-secondary mb-1">Losers</p>
                        <p id="day-analysis-losers" class="text-xl font-bold text-red">0</p>
                    </div>
                    <div class="metric-card p-4 text-center">
                        <p class="text-xs text-text-secondary mb-1">Winrate</p>
                        <p id="day-analysis-winrate" class="text-xl font-bold text-primary">0%</p>
                    </div>
                    <div class="metric-card p-4 text-center">
                        <p class="text-xs text-text-secondary mb-1">Gross P&L</p>
                        <p id="day-analysis-gross-pl" class="text-xl font-bold">$0.00</p>
                    </div>
                    <div class="metric-card p-4 text-center">
                        <p class="text-xs text-text-secondary mb-1">Comisiones</p>
                        <p id="day-analysis-commissions" class="text-xl font-bold">$0.00</p>
                    </div>
                    <div class="metric-card p-4 text-center">
                        <p class="text-xs text-text-secondary mb-1">Profit Factor</p>
                        <p id="day-analysis-pf" class="text-xl font-bold">0.00</p>
                    </div>
                </div>

                <!-- Pestañas -->
                <div class="border border-border rounded-lg bg-surface mb-6">
                    <div class="flex border-b border-border">
                        <button class="day-analysis-tab-btn px-6 py-3 text-sm bg-primary text-black border-r border-border active" data-tab="notes">
                            <i class="fas fa-sticky-note mr-2"></i>Notas
                        </button>
                        <button class="day-analysis-tab-btn px-6 py-3 text-sm hover:bg-surface-light border-r border-border" data-tab="images">
                            <i class="fas fa-images mr-2"></i>Imágenes Adjuntas
                        </button>
                    </div>
                    
                    <div class="p-6">
                        <!-- Tab: Notas -->
                        <div id="day-analysis-notes-content" class="day-analysis-tab-content active">
                            <div class="mb-4">
                                <div class="flex justify-between items-center mb-3">
                                    <h4 class="text-lg font-semibold">Notas del Día</h4>
                                    <button id="day-analysis-edit-notes-btn" class="btn-secondary">
                                        <i class="fas fa-edit mr-2"></i>Editar Notas
                                    </button>
                                </div>
                                <div id="day-analysis-notes-view" class="min-h-[200px] p-4 bg-background border border-border rounded">
                                    <p class="text-text-secondary italic">Sin notas agregadas para este día.</p>
                                </div>
                                <div id="day-analysis-notes-edit" class="hidden">
                                    <div id="day-analysis-rich-editor-container"></div>
                                    <div class="flex gap-2 mt-3">
                                        <button id="day-analysis-save-notes-btn" class="btn-primary">
                                            <i class="fas fa-save mr-2"></i>Guardar Notas
                                        </button>
                                        <button id="day-analysis-cancel-notes-btn" class="btn-secondary">
                                            <i class="fas fa-times mr-2"></i>Cancelar
                                        </button>
                                        <button id="day-analysis-goto-notebook-btn" class="btn-secondary ml-auto" title="Ver en Notebook">
                                            <i class="fas fa-book mr-2"></i>Ver en Notebook
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Tab: Imágenes -->
                        <div id="day-analysis-images-content" class="day-analysis-tab-content hidden">
                            <div class="mb-4">
                                <div class="flex justify-between items-center mb-3">
                                    <h4 class="text-lg font-semibold">Imágenes del Día</h4>
                                    <button id="day-analysis-add-images-btn" class="btn-primary">
                                        <i class="fas fa-plus mr-2"></i>Agregar Imágenes
                                    </button>
                                </div>
                                <div id="day-analysis-images-view" class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
                                    <!-- Imágenes se renderizan aquí -->
                                </div>
                                <div id="day-analysis-images-upload" class="hidden">
                                    <input type="file" id="day-analysis-image-input" accept="image/*" multiple class="mb-3">
                                    <div id="day-analysis-image-preview" class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4 mb-3">
                                        <!-- Preview de imágenes -->
                                    </div>
                                    <div class="flex gap-2">
                                        <button id="day-analysis-upload-images-btn" class="btn-primary">
                                            <i class="fas fa-upload mr-2"></i>Subir Imágenes
                                        </button>
                                        <button id="day-analysis-cancel-images-btn" class="btn-secondary">
                                            <i class="fas fa-times mr-2"></i>Cancelar
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <section id="accounts" class="section-container">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-xl font-semibold">Gestión de Cuentas</h2>
                <div class="flex items-center space-x-2">
                    <button id="add-account-btn" class="primary"><i class="fas fa-plus mr-2"></i>Agregar Cuenta</button>
                    <!-- Toggle to hide amounts for streaming -->
                    <button id="toggle-hide-amounts" class="p-2 rounded border" title="Ocultar importes (stream)" aria-pressed="false" style="display:inline-flex;align-items:center;justify-content:center;">
                        <i id="toggle-hide-amounts-icon" class="fas fa-eye-slash" aria-hidden="true" style="width:16px; height:16px;"></i>
                        <span class="sr-only">Ocultar importes</span>
                    </button>
                </div>
            </div>

            <!-- Modal de selección de broker (pantalla completa) -->
            <div id="broker-selection-modal" style="display: none;">
                <!-- Este div ahora se mostrará dentro de la sección accounts reemplazando todo -->
            </div>

            <!-- Modal de configuración de cuenta -->
            <div id="account-config-modal" class="fixed inset-0 z-[9999] flex items-center justify-center" style="display: none; background-color: rgba(10, 10, 15, 0.98);">
                <div class="bg-surface rounded-xl shadow-2xl max-w-2xl w-full mx-4 max-h-[90vh] overflow-y-auto">
                    <div class="p-6 border-b border-border">
                        <div class="flex justify-between items-center">
                            <div>
                                <h3 class="text-2xl font-bold mb-1">Add Trades</h3>
                                <p class="text-text-secondary text-sm">Configure your trading account</p>
                            </div>
                            <button id="close-account-modal" class="text-text-secondary hover:text-white transition-colors">
                                <i class="fas fa-times text-xl"></i>
                            </button>
                        </div>
                    </div>

                    <div class="p-6">
                        <!-- Plataforma seleccionada -->
                        <div class="bg-surface-light rounded-lg p-4 mb-6 flex items-center">
                            <div id="selected-broker-logo" class="w-16 h-16 rounded-xl mr-4 overflow-hidden">
                                <!-- Logo dinámico -->
                            </div>
                            <div>
                                <p class="text-sm text-text-secondary">Selected Broker</p>
                                <p id="selected-broker-name" class="text-lg font-semibold">-</p>
                            </div>
                        </div>

                        <!-- Formulario -->
                        <div class="space-y-4">
                            <div>
                                <label class="block mb-2 text-sm font-medium">Account Name</label>
                                <input type="text" id="acc-name-modal" placeholder="FTMO, PropFirm, etc." class="w-full bg-background border border-border rounded-lg px-4 py-3 focus:outline-none focus:border-primary">
                            </div>

                            <div>
                                <label class="block mb-2 text-sm font-medium">Tipo de Cuenta</label>
                                <select id="acc-type-modal" class="w-full bg-background border border-border rounded-lg px-4 py-3 focus:outline-none focus:border-primary">
                                    <option value="personal">💰 Capital Propio</option>
                                    <option value="funded">🏆 Cuenta de Fondeo</option>
                                </select>
                                <p class="text-xs text-text-secondary mt-1">Define si esta cuenta es con tu capital o una cuenta fondeada</p>
                            </div>

                            <div class="grid grid-cols-2 gap-4">
                                <div>
                                    <label class="block mb-2 text-sm font-medium">Initial Balance</label>
                                    <input type="number" id="acc-balance-modal" step="0.01" placeholder="100000" class="w-full bg-background border border-border rounded-lg px-4 py-3 focus:outline-none focus:border-primary">
                                </div>
                                <div>
                                    <label class="block mb-2 text-sm font-medium">Currency</label>
                                    <select id="acc-currency-modal" class="w-full bg-background border border-border rounded-lg px-4 py-3 focus:outline-none focus:border-primary">
                                        <option value="USD">USD</option>
                                        <option value="EUR">EUR</option>
                                        <option value="USDT">USDT</option>
                                    </select>
                                </div>
                            </div>

                            <!-- Campos específicos para Tradovate -->
                            <div id="tradovate-fields-modal" style="display: none;">
                                <div class="bg-surface-light border border-primary rounded-lg p-4">
                                    <h4 class="text-sm font-semibold mb-3 flex items-center">
                                        <i class="fas fa-key mr-2 text-primary"></i>Tradovate Credentials
                                    </h4>
                                    <div class="space-y-3">
                                        <div>
                                            <label class="block mb-1 text-sm">Tradovate Username</label>
                                            <input type="text" id="tradovate-username-modal" placeholder="TDU19938704" class="w-full bg-background border border-border rounded-lg px-4 py-2 focus:outline-none focus:border-primary">
                                        </div>
                                        <div>
                                            <label class="block mb-1 text-sm">Password</label>
                                            <input type="password" id="tradovate-password-modal" placeholder="Password" class="w-full bg-background border border-border rounded-lg px-4 py-2 focus:outline-none focus:border-primary">
                                        </div>
                                        <div>
                                            <label class="block mb-1 text-sm">Account ID</label>
                                            <input type="text" id="tradovate-account-id-modal" placeholder="FTPROPLUS095027643815" class="w-full bg-background border border-border rounded-lg px-4 py-2 focus:outline-none focus:border-primary">
                                        </div>
                                        <div class="flex items-center">
                                            <label class="flex items-center cursor-pointer">
                                                <input type="checkbox" id="tradovate-auto-sync-modal" class="mr-2">
                                                <span class="text-sm">Auto sync</span>
                                            </label>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="p-6 border-t border-border flex justify-end space-x-3">
                        <button id="cancel-account-modal" class="px-6 py-3 rounded-lg border border-border hover:bg-surface-light transition-colors">Cancel</button>
                        <button id="save-account-modal" class="px-6 py-3 rounded-lg bg-primary hover:bg-primary-dark transition-colors font-semibold">Continue</button>
                    </div>
                </div>
            </div>

            <!-- Formulario antiguo (oculto, mantener por compatibilidad) -->
            <div id="add-account-form" class="metric-card mb-6" style="display: none;"><h3 class="text-lg font-semibold mb-4">Nueva Cuenta</h3><div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4"><div><label class="block mb-1">Nombre de la cuenta</label><input type="text" id="acc-name" placeholder="FTMO, PropFirm, etc."></div><div><label class="block mb-1">Tipo de Cuenta</label><select id="acc-type"><option value="personal">💰 Capital Propio</option><option value="funded">🏆 Cuenta de Fondeo</option></select></div><div><label class="block mb-1">Balance inicial</label><input type="number" id="acc-balance" step="0.01" placeholder="100000"></div><div><label class="block mb-1">Divisa</label><select id="acc-currency"><option value="USD">USD</option><option value="EUR">EUR</option><option value="USDT">USDT</option></select></div><div><label class="block mb-1">Plataforma</label><select id="acc-platform"><option value="meta-trader-4">Meta Trader 4</option><option value="meta-trader-5">Meta Trader 5</option><option value="ninjatrader">NinjaTrader 8</option><option value="ctrader">cTrader</option><option value="tradingview">TradingView</option><option value="tradovate">Tradovate</option><option value="topstepx">TopStepX</option><option value="bingx">BingX</option><option value="bitget">Bitget</option><option value="mexc">MEXC</option><option value="lbank">LBank</option><option value="blofin">BloFin</option><option value="primexbt-crypto">PrimeXBT Crypto</option><option value="primexbt-cfds">PrimeXBT CFDs</option><option value="bitunix">Bitunix</option><option value="other">Otra</option></select></div></div>
            
            <!-- Campos específicos para Tradovate -->
            <div id="tradovate-fields" class="mb-4" style="display: none;">
                <div class="bg-surface-light border border-primary rounded-lg p-4">
                    <h4 class="text-sm font-semibold mb-3 flex items-center">
                        <i class="fas fa-key mr-2 text-primary"></i>Credenciales de Tradovate
                    </h4>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                            <label class="block mb-1 text-sm">Usuario Tradovate</label>
                            <input type="text" id="tradovate-username" placeholder="TDU19938704" class="w-full">
                        </div>
                        <div>
                            <label class="block mb-1 text-sm">Contraseña</label>
                            <input type="password" id="tradovate-password" placeholder="Contraseña" class="w-full">
                        </div>
                        <div>
                            <label class="block mb-1 text-sm">Account ID</label>
                            <input type="text" id="tradovate-account-id" placeholder="FTPROPLUS095027643815" class="w-full">
                        </div>
                        <div class="flex items-center">
                            <label class="flex items-center cursor-pointer">
                                <input type="checkbox" id="tradovate-auto-sync" class="mr-2">
                                <span class="text-sm">Sincronización automática</span>
                            </label>
                        </div>
                    </div>
                    <div class="mt-3 text-xs text-text-secondary">
                        <i class="fas fa-info-circle mr-1"></i>
                        Los trades se importarán automáticamente desde tu cuenta de Tradovate
                    </div>
                </div>
            </div>
            
            <div class="flex justify-end"><button id="acc-cancel" class="mr-2">Cancelar</button><button id="acc-save" class="primary">Guardar</button></div></div>
            
            <!-- Contenedor principal de cuentas -->
            <div id="accounts-main-container">
                <div id="accounts-container" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6"></div>
            </div>

            <!-- Pantalla de selección de broker (reemplaza accounts-main-container) -->
            <div id="broker-selection-screen" style="display: none;">
                <div class="max-w-3xl mx-auto">
                    <div class="flex justify-between items-center mb-8">
                        <div>
                            <p class="text-text-secondary text-sm mb-1">Add Trades</p>
                            <h2 class="text-3xl font-bold">Choose Broker</h2>
                        </div>
                        <button id="close-broker-screen" class="text-text-secondary hover:text-white transition-colors">
                            <i class="fas fa-times text-2xl"></i>
                        </button>
                    </div>

                    <!-- Buscador -->
                    <div class="mb-8">
                        <div class="relative">
                            <input type="text" id="broker-search" placeholder="Start typing for broker name" class="w-full bg-surface border border-border rounded-lg px-4 py-3 pl-12 focus:outline-none focus:border-primary text-white">
                            <i class="fas fa-search absolute left-4 top-1/2 transform -translate-y-1/2 text-text-secondary"></i>
                        </div>
                    </div>

                    <!-- Popular Brokers -->
                    <div class="mb-8">
                        <h3 class="text-sm font-semibold mb-4 text-text-secondary">Popular Brokers</h3>
                        <div class="grid grid-cols-2 md:grid-cols-3 gap-4" id="broker-grid">
                            <!-- Se llenará dinámicamente -->
                        </div>
                    </div>

                    <!-- Otros brokers (dropdown) -->
                    <div>
                        <button id="show-all-brokers-btn" class="w-full bg-surface hover:bg-surface-light border border-border rounded-lg px-4 py-3 text-left flex items-center justify-between transition-colors">
                            <span class="text-sm font-medium">Show all brokers</span>
                            <i class="fas fa-chevron-down text-text-secondary"></i>
                        </button>
                        <div id="all-brokers-list" class="mt-2 bg-surface border border-border rounded-lg overflow-hidden" style="display: none; max-height: 300px; overflow-y: auto;">
                            <!-- Se llenará dinámicamente -->
                        </div>
                    </div>

                    <!-- Botón Continue -->
                    <div class="mt-12">
                        <button class="w-full bg-surface hover:bg-surface-light text-text-secondary py-3 rounded-lg transition-colors" disabled>
                            Continue
                        </button>
                    </div>
                </div>
            </div>
            <div id="selected-account-details" class="mt-8" style="display: none;">
                <h3 id="account-detail-name" class="text-xl font-semibold mb-4">Detalles de la Cuenta</h3>
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                    <div class="metric-card">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <h3 class="text-lg font-semibold">Evolución de la Cuenta</h3>
                            <button onclick="openFullscreenChart('account-detail-chart', 'Evolución de la Cuenta - Detalles')" style="background: #39FF14; color: black; border: none; padding: 5px 12px; border-radius: 5px; cursor: pointer; font-size: 11px; font-weight: bold;">
                                <i class="fas fa-expand"></i>
                            </button>
                        </div>
                        <div class="time-range-buttons mb-3 text-sm" id="account-detail-time-range">
                            <button data-range="1W" class="time-range-btn">1S</button>
                            <button data-range="1M" class="time-range-btn">1M</button>
                            <button data-range="3M" class="time-range-btn">3M</button>
                            <button data-range="6M" class="time-range-btn">6M</button>
                            <button data-range="1Y" class="time-range-btn">1A</button>
                            <button data-range="ALL" class="time-range-btn active">Todo</button>
                        </div>
                        <div class="chart-container"><canvas id="account-detail-chart"></canvas></div>
                    </div>
                    <div class="metric-card p-6">
                        <h3 class="text-lg font-semibold mb-4">Métricas de la Cuenta</h3>
                        <div class="grid grid-cols-2 gap-x-8 gap-y-4 mb-4">
                            <div><p class="text-sm text-text-secondary">P&L Total</p><p id="account-detail-pl" class="text-2xl font-bold">$0.00</p></div>
                            <div><p class="text-sm text-text-secondary">Win Rate</p><p id="account-detail-winrate" class="text-2xl font-bold">0%</p></div>
                            <div><p class="text-sm text-text-secondary">Operaciones</p><p id="account-detail-trades" class="text-2xl font-bold">0</p></div>
                            <div><p class="text-sm text-text-secondary">Profit Factor</p><p id="account-detail-pf" class="text-2xl font-bold">0.00</p></div>
                        </div>
                        <h3 class="text-lg font-semibold mb-2 mt-4">Puntuación de Rendimiento</h3>
                        <div class="chart-container" style="height: 220px;">
                            <canvas id="account-detail-radar-chart"></canvas>
                        </div>
                    </div>
                </div>
                <div class="grid grid-cols-1 xl:grid-cols-3 gap-6">
                    <div class="metric-card xl:col-span-1">
                        <h3 class="text-lg font-semibold mb-3">Estadísticas Adicionales</h3>
                        <dl class="space-y-3 text-sm">
                            <div class="flex justify-between"><dt>Drawdown Máximo:</dt><dd id="account-detail-drawdown" class="font-semibold text-red">$0.00 (0%)</dd></div>
                            <div class="flex justify-between"><dt>Ratio Ganancia/Pérdida Prom:</dt><dd id="account-detail-avg-w-l-ratio" class="font-semibold">0.00</dd></div>
                            <div class="flex justify-between"><dt>Racha Ganadora Máx:</dt><dd id="account-detail-win-streak" class="font-semibold">0</dd></div>
                            <div class="flex justify-between"><dt>Racha Perdedora Máx:</dt><dd id="account-detail-loss-streak" class="font-semibold">0</dd></div>
                            <div class="flex justify-between"><dt>Tiempo Prom. por Operación:</dt><dd id="account-detail-hold-time" class="font-semibold">N/A</dd></div>
                        </dl>
                        <h3 class="text-lg font-semibold mt-6 mb-3">Análisis Long/Short</h3>
                        <table class="w-full text-xs"><thead><tr><th>Tipo</th><th>Trades</th><th>P&L</th><th>Win%</th></tr></thead><tbody id="account-long-short-analysis"></tbody></table>
                    </div>
                    <div class="metric-card xl:col-span-2 grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div><h3 class="text-lg font-semibold mb-2">Mejores Operaciones</h3><table class="w-full"><thead><tr><th>Fecha</th><th>Instrumento</th><th>P&L</th></tr></thead><tbody id="best-trades"></tbody></table></div>
                        <div><h3 class="text-lg font-semibold mb-2">Peores Operaciones</h3><table class="w-full"><thead><tr><th>Fecha</th><th>Instrumento</th><th>P&L</th></tr></thead><tbody id="worst-trades"></tbody></table></div>
                    </div>
                </div>

                <!-- Nuevos módulos de Reducción acumulada y P&L acumulado para Account Details -->
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mt-8">
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-2">Reducción acumulada</h3>
                        <div class="time-range-buttons mb-3 text-sm">
                            <button data-range="1W" class="time-range-btn account-drawdown-range-btn">1S</button>
                            <button data-range="1M" class="time-range-btn account-drawdown-range-btn">1M</button>
                            <button data-range="3M" class="time-range-btn account-drawdown-range-btn">3M</button>
                            <button data-range="6M" class="time-range-btn account-drawdown-range-btn">6M</button>
                            <button data-range="1Y" class="time-range-btn account-drawdown-range-btn">1A</button>
                            <button data-range="ALL" class="time-range-btn account-drawdown-range-btn active">Todo</button>
                        </div>
                        <div class="chart-container" style="height: 350px;">
                            <canvas id="account-reduccion-acumulada-chart"></canvas>
                        </div>
                    </div>

                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-2">P&L acumulado</h3>
                        <div class="time-range-buttons mb-3 text-sm">
                            <button data-range="1W" class="time-range-btn account-pnl-range-btn">1S</button>
                            <button data-range="1M" class="time-range-btn account-pnl-range-btn">1M</button>
                            <button data-range="3M" class="time-range-btn account-pnl-range-btn">3M</button>
                            <button data-range="6M" class="time-range-btn account-pnl-range-btn">6M</button>
                            <button data-range="1Y" class="time-range-btn account-pnl-range-btn">1A</button>
                            <button data-range="ALL" class="time-range-btn account-pnl-range-btn active">Todo</button>
                        </div>
                        <div class="chart-container" style="height: 350px;">
                            <canvas id="account-pnl-acumulado-chart"></canvas>
                        </div>
                    </div>
                </div>

                <!-- Nuevos gráficos: P&L Neto Diario y Wins/Losses por Día -->
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mt-8">
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-2">P&L Neto Diario</h3>
                        <div class="chart-container" style="height: 350px;">
                            <canvas id="account-daily-pnl-chart"></canvas>
                        </div>
                    </div>

                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-2">Victorias/Derrotas por Día</h3>
                        <div class="chart-container" style="height: 350px;">
                            <canvas id="account-daily-winloss-chart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- ===== SECTION: NOTEBOOK ===== -->
        <section id="notebook" class="section-container">
            <!-- Header con título y botones -->
            <div class="flex items-center justify-between mb-4">
                <h1 class="text-3xl font-bold">📓 Notebook - Mis Notas</h1>
                <button id="new-folder-btn" class="px-3 py-2 bg-surface border border-border rounded hover:bg-surface-light text-sm">
                    <i class="fas fa-folder-plus mr-2"></i>Nueva Carpeta
                </button>
            </div>

            <!-- Carpetas verticales sin scroll -->
            <div class="mb-4 bg-surface rounded-lg border border-border p-3">
                <div id="folders-list" class="flex flex-wrap gap-2">
                    <!-- Carpetas se renderizan aquí -->
                </div>
            </div>

            <!-- Búsqueda y Nueva Nota -->
            <div class="flex gap-3 mb-4">
                <div class="flex-1">
                    <input type="text" id="search-notes" placeholder="🔍 Buscar notas..." class="w-full text-lg px-4 py-3">
                </div>
                <button id="new-note-btn" class="primary px-6 py-3 text-lg font-semibold">
                    <i class="fas fa-plus mr-2"></i>Nueva Nota
                </button>
            </div>

            <div class="grid grid-cols-12 gap-4" style="height: calc(100vh - 320px);">
                <!-- LISTA DE NOTAS -->
                <div class="col-span-3 bg-surface rounded-lg border border-border overflow-hidden flex flex-col">
                    <div id="notes-list" class="flex-1 overflow-y-auto p-2">
                        <!-- Notas se renderizan aquí -->
                    </div>
                </div>

                <!-- EDITOR DE NOTA -->
                <div class="col-span-9 bg-surface rounded-lg border border-border overflow-hidden flex flex-col">
                    <div id="note-editor-empty" class="flex-1 flex items-center justify-center text-text-secondary">
                        <div class="text-center">
                            <i class="fas fa-sticky-note text-6xl mb-4 opacity-20"></i>
                            <p class="text-lg">Selecciona una nota o crea una nueva</p>
                        </div>
                    </div>

                    <div id="note-editor-container" class="flex-1 flex-col" style="display: none;">
                        <!-- Header con título -->
                        <div class="p-4 border-b border-border">
                            <input type="text" id="note-title" placeholder="Título de la nota..." class="w-full text-2xl font-bold bg-transparent border-none outline-none">
                            <div class="flex items-center gap-4 mt-2 text-xs text-text-secondary">
                                <span id="note-date">Creada: -</span>
                                <span id="note-folder">Carpeta: -</span>
                            </div>
                        </div>

                        <!-- Toolbar -->
                        <div class="px-4 py-2 border-b border-border flex items-center gap-2 flex-wrap">
                            <button id="bold-btn" class="p-2 hover:bg-surface-light rounded" title="Negrita">
                                <i class="fas fa-bold"></i>
                            </button>
                            <button id="italic-btn" class="p-2 hover:bg-surface-light rounded" title="Cursiva">
                                <i class="fas fa-italic"></i>
                            </button>
                            <button id="underline-btn" class="p-2 hover:bg-surface-light rounded" title="Subrayado">
                                <i class="fas fa-underline"></i>
                            </button>
                            <div class="w-px h-6 bg-border"></div>
                            <button id="h1-btn" class="p-2 hover:bg-surface-light rounded text-sm font-bold" title="Título 1">H1</button>
                            <button id="h2-btn" class="p-2 hover:bg-surface-light rounded text-sm font-bold" title="Título 2">H2</button>
                            <button id="h3-btn" class="p-2 hover:bg-surface-light rounded text-sm font-bold" title="Título 3">H3</button>
                            <div class="w-px h-6 bg-border"></div>
                            <button id="ul-btn" class="p-2 hover:bg-surface-light rounded" title="Lista">
                                <i class="fas fa-list-ul"></i>
                            </button>
                            <button id="ol-btn" class="p-2 hover:bg-surface-light rounded" title="Lista numerada">
                                <i class="fas fa-list-ol"></i>
                            </button>
                            <div class="w-px h-6 bg-border"></div>
                            <button id="image-btn" class="p-2 hover:bg-surface-light rounded" title="Insertar imagen">
                                <i class="fas fa-image"></i>
                            </button>
                            <button id="voice-btn" class="p-2 hover:bg-surface-light rounded" title="Grabar voz">
                                <i class="fas fa-microphone"></i>
                            </button>
                            <input type="file" id="image-upload" accept="image/*" style="display:none;">
                            <div class="ml-auto flex gap-2">
                                <button id="fullscreen-note-btn" class="p-2 hover:bg-surface-light rounded" title="Pantalla completa">
                                    <i class="fas fa-expand"></i>
                                </button>
                                <button id="delete-note-btn" class="p-2 text-danger hover:bg-surface-light rounded" title="Eliminar nota">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </div>
                        </div>

                        <!-- Editor de contenido -->
                        <div id="note-content" contenteditable="true" class="flex-1 p-6 overflow-y-auto focus:outline-none" style="min-height: 500px; max-height: calc(100vh - 400px);">
                            <!-- Contenido editable -->
                        </div>

                        <!-- Footer con metadata -->
                        <div class="p-3 border-t border-border text-xs text-text-secondary flex items-center justify-between">
                            <span id="note-word-count">0 palabras</span>
                            <span id="note-updated">Guardado automáticamente</span>
                        </div>
                    </div>
                </div>
            </div>
        </section>

                <!-- ===== SECTION: FUNDED ===== -->
                <section id="funded" class="section-container">

                    <!-- Pestañas de Navegación (Estilo igual que Informe) -->
                    <div class="nav-tabs flex mb-6">
                        <div class="nav-tab funded-tab active" data-target="funded-accounts-view">Dashboard</div>
                        <div class="nav-tab funded-tab" data-target="funded-cuentas-view">Cuentas</div>
                        <div class="nav-tab funded-tab" data-target="funded-calendar-view">Calendario Financiero</div>
                        <div class="nav-tab funded-tab" data-target="funded-metrics-view">Métricas</div>
                    </div>

        

                    <!-- VISTA: Cuentas (Principal) -->

                    <div id="funded-accounts-view" class="funded-view active">

                        <!-- Header con título y botones de acción -->

                        <div class="flex flex-wrap justify-between items-center mb-6 gap-4">

                            <h2 class="text-xl font-semibold">Gestión de Cuentas Fondeadas</h2>

                            <div class="flex items-center gap-2">

                                <button id="funded-date-filter-btn" class="date-filter-trigger p-2 bg-surface rounded" title="Filtrar por fecha">

                                    <i class="fas fa-calendar-alt"></i>

                                </button>

                                <button id="add-funded-account-btn" class="primary">

                                    <i class="fas fa-plus mr-2"></i>Nueva Cuenta

                                </button>

                            </div>

                        </div>

                        

                        <!-- Filtro de fecha display -->

                        <div id="funded-date-filter-display" class="date-filter-display-text text-sm text-text-secondary mb-4">

                            Sin filtro de fecha

                        </div>

        

                        <!-- Métricas principales -->

                        <div class="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-6 gap-4 mb-6">

                            <div class="metric-card text-center">

                                <div class="flex items-center justify-center mb-2">

                                    <i class="fas fa-graduation-cap text-green text-2xl"></i>

                                </div>

                                <h4 class="text-sm text-text-secondary mb-1">Evaluaciones</h4>

                                <p id="funded-evaluations" class="text-2xl font-bold">0</p>

                            </div>

        

                            <div class="metric-card text-center">

                                <div class="flex items-center justify-center mb-2">

                                    <i class="fas fa-hourglass-half text-warning text-2xl"></i>

                                </div>

                                <h4 class="text-sm text-text-secondary mb-1">En Progreso</h4>

                                <p id="funded-in-progress" class="text-2xl font-bold text-warning">0</p>

                            </div>

        

                            <div class="metric-card text-center">

                                <div class="flex items-center justify-center mb-2">

                                    <i class="fas fa-check-circle text-primary text-2xl"></i>

                                </div>

                                <h4 class="text-sm text-text-secondary mb-1">Cuentas Live</h4>

                                <p id="funded-live-accounts" class="text-2xl font-bold text-primary">0</p>

                            </div>

        

                            <div class="metric-card text-center">

                                <div class="flex items-center justify-center mb-2">

                                    <i class="fas fa-chart-pie text-yellow text-2xl"></i>

                                </div>

                                <h4 class="text-sm text-text-secondary mb-1">Funding Ratio</h4>

                                <p id="funded-ratio" class="text-2xl font-bold text-yellow">0%</p>

                            </div>

        

                            <div class="metric-card text-center">

                                <div class="flex items-center justify-center mb-2">

                                    <i class="fas fa-money-bill-wave text-red text-2xl"></i>

                                </div>

                                <h4 class="text-sm text-text-secondary mb-1">Gastos Totales</h4>

                                <p id="funded-total-expenses" class="text-2xl font-bold text-red">€0.00</p>

                            </div>

        

                            <div class="metric-card text-center">

                                <div class="flex items-center justify-center mb-2">

                                    <i class="fas fa-hand-holding-usd text-green text-2xl"></i>

                                </div>

                                <h4 class="text-sm text-text-secondary mb-1">Ganancias Totales</h4>

                                <p id="funded-total-earnings" class="text-2xl font-bold text-green">€0.00</p>

                            </div>

                        </div>

        

                        <!-- Beneficio Neto destacado -->

                        <div class="metric-card mb-6 bg-gradient-to-r from-green/10 to-primary/10 border-2 border-green/30">

                            <div class="grid grid-cols-1 md:grid-cols-3 gap-6">

                                <!-- Beneficio Neto -->
                                <div class="flex items-center gap-4">

                                    <div class="w-16 h-16 rounded-full bg-green/20 flex items-center justify-center">

                                        <i class="fas fa-trophy text-green text-3xl"></i>

                                    </div>

                                    <div>

                                        <h4 class="text-sm text-text-secondary mb-1">Beneficio Neto</h4>

                                        <p id="funded-net-profit" class="text-4xl font-bold text-green">€0.00</p>

                                    </div>

                                </div>

                                <!-- ROI -->
                                <div class="flex items-center gap-4">

                                    <div class="w-16 h-16 rounded-full bg-primary/20 flex items-center justify-center">

                                        <i class="fas fa-percentage text-primary text-3xl"></i>

                                    </div>

                                    <div>

                                        <h4 class="text-sm text-text-secondary mb-1">ROI</h4>

                                        <p id="funded-roi-display" class="text-4xl font-bold text-primary">0%</p>

                                    </div>

                                </div>

                                <!-- Capital Total -->
                                <div class="flex items-center gap-4">

                                    <div class="w-16 h-16 rounded-full flex items-center justify-center" style="background: rgba(57, 255, 20, 0.2);">

                                        <i class="fas fa-sack-dollar text-3xl" style="color: #39FF14;"></i>

                                    </div>

                                    <div>

                                        <h4 class="text-sm text-text-secondary mb-1">Capital Total</h4>

                                        <p id="funded-total-balance-display" class="text-4xl font-bold" style="color: #39FF14;">€0.00</p>

                                    </div>

                                </div>

                            </div>

                        </div>

        

                        <!-- Gráfico de evolución + Estadísticas -->

                        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-6">

                            <!-- Evolución de la Cuenta -->

                            <div class="metric-card lg:col-span-2">

                                <h3 class="text-lg font-semibold mb-4">Evolución del Capital</h3>

                                <p class="text-xs text-text-secondary mb-3">Curva acumulada de retiros y ganancias</p>

                                <div class="chart-container" style="height: 300px;">

                                    <canvas id="funded-evolution-chart"></canvas>

                                </div>

                            </div>

        

                            <!-- Estadísticas Diarias -->

                            <div class="metric-card">

                                <h3 class="text-lg font-semibold mb-4">Estadísticas</h3>

                                <div class="space-y-4">

                                    <div class="flex items-center justify-between p-3 bg-surface rounded">

                                        <div class="flex items-center gap-2">

                                            <i class="fas fa-arrow-up text-green"></i>

                                            <span class="text-sm">Mejor Día</span>

                                        </div>

                                        <p id="funded-best-day" class="font-bold text-green">€0.00</p>

                                    </div>

        

                                    <div class="flex items-center justify-between p-3 bg-surface rounded">

                                        <div class="flex items-center gap-2">

                                            <i class="fas fa-arrow-down text-red"></i>

                                            <span class="text-sm">Peor Día</span>

                                        </div>

                                        <p id="funded-worst-day" class="font-bold text-red">€0.00</p>

                                    </div>

        

                                    <div class="flex items-center justify-between p-3 bg-surface rounded">

                                        <div class="flex items-center gap-2">

                                            <i class="fas fa-chart-line text-primary"></i>

                                            <span class="text-sm">Promedio Diario</span>

                                        </div>

                                        <p id="funded-avg-daily" class="font-bold">€0.00</p>

                                    </div>

        

                                    <div class="flex items-center justify-between p-3 bg-surface rounded">

                                        <div class="flex items-center gap-2">

                                            <i class="fas fa-coins text-warning"></i>

                                            <span class="text-sm">Retiros</span>

                                        </div>

                                        <p id="funded-withdrawals" class="font-bold text-warning">0</p>

                                    </div>

                                </div>

                            </div>

                        </div>

        

                        <!-- Análisis por Empresa -->

                        <div class="mb-6">

                            <h3 class="text-xl font-semibold mb-4">Análisis por Empresa</h3>

                            <p class="text-sm text-text-secondary mb-4">Rendimiento detallado de cada prop firm</p>

        

                            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">

                                <!-- Top Empresas por ROI -->

                                <div class="metric-card">

                                    <div class="flex items-center gap-2 mb-4">

                                        <i class="fas fa-trophy text-warning text-xl"></i>

                                        <h4 class="text-lg font-semibold">Top Empresas por ROI</h4>

                                    </div>

                                    <div id="funded-top-roi" class="space-y-3">

                                        <!-- Se llenará dinámicamente -->

                                        <p class="text-sm text-text-secondary text-center py-8">No hay datos disponibles</p>

                                    </div>

                                </div>

        

                                <!-- Top Empresas por Retiros -->

                                <div class="metric-card">

                                    <div class="flex items-center gap-2 mb-4">

                                        <i class="fas fa-money-bill-wave text-green text-xl"></i>

                                        <h4 class="text-lg font-semibold">Top Empresas por Retiros</h4>

                                    </div>

                                    <div id="funded-top-withdrawals" class="space-y-3">

                                        <!-- Se llenará dinámicamente -->

                                        <p class="text-sm text-text-secondary text-center py-8">No hay datos disponibles</p>

                                    </div>

                                </div>

                            </div>

        

                            <!-- Tabla de Todas las Empresas -->

                            <div class="metric-card">

                                <h4 class="text-lg font-semibold mb-4">Todas las Empresas</h4>

                                <div class="overflow-x-auto">

                                    <table class="w-full">

                                        <thead>

                                            <tr>

                                                <th class="text-left">Empresa</th>

                                                <th class="text-center">Cuentas</th>

                                                <th class="text-right">Gastos</th>

                                                <th class="text-right">Retiros</th>

                                                <th class="text-right">Beneficio</th>

                                                <th class="text-right">ROI</th>

                                            </tr>

                                        </thead>

                                        <tbody id="funded-companies-table">

                                            <tr>

                                                <td colspan="6" class="text-center text-text-secondary py-8">

                                                    No hay empresas registradas

                                                </td>

                                            </tr>

                                        </tbody>

                                    </table>

                                </div>

                            </div>

                        </div>

        

                        <!-- Gestión de Cuentas -->

                        <div class="metric-card">

                            <div class="flex flex-wrap justify-between items-center mb-4 gap-4">

                                <h3 class="text-xl font-semibold">Listado de Cuentas</h3>

                                

                                <!-- Filtros de Estado -->

                                <div class="flex flex-wrap gap-2">

                                    <button class="funded-filter-btn active" data-filter="all">

                                        <i class="fas fa-list mr-1"></i>Todas

                                    </button>

                                    <button class="funded-filter-btn" data-filter="evaluation">

                                        <i class="fas fa-graduation-cap mr-1"></i>Evaluación

                                    </button>

                                    <button class="funded-filter-btn" data-filter="live">

                                        <i class="fas fa-check-circle mr-1"></i>Live

                                    </button>

                                    <button class="funded-filter-btn" data-filter="active">

                                        <i class="fas fa-play-circle mr-1"></i>Activas

                                    </button>

                                    <button class="funded-filter-btn" data-filter="suspended">

                                        <i class="fas fa-ban mr-1"></i>Suspendidas

                                    </button>

                                </div>

                            </div>

        

                            <!-- Tabla de Cuentas -->

                            <div class="overflow-x-auto">

                                <table class="w-full">

                                    <thead>

                                        <tr>

                                            <th class="text-left">Nombre</th>

                                            <th class="text-center">Tipo</th>

                                            <th class="text-center">Estado</th>

                                            <th class="text-left">Empresa</th>

                                            <th class="text-right">Capital</th>

                                            <th class="text-right">Gastos</th>

                                            <th class="text-right">Ganancias</th>

                                            <th class="text-right">Beneficio</th>

                                            <th class="text-center">Acciones</th>

                                        </tr>

                                    </thead>

                                    <tbody id="funded-accounts-table">

                                        <tr>

                                            <td colspan="9" class="text-center text-text-secondary py-8">

                                                No hay cuentas. Haz clic en "Nueva Cuenta" para empezar.

                                            </td>

                                        </tr>

                                    </tbody>

                                </table>

                            </div>

        

                            <!-- Paginación (si es necesario) -->

                            <div id="funded-pagination" class="flex justify-center mt-6 gap-2" style="display: none;">

                                <!-- Se llenará dinámicamente -->

                            </div>

                        </div>

                    </div>

                    <!-- VISTA: CUENTAS - Análisis Individual y Comparativo -->
                    <div id="funded-cuentas-view" class="funded-view">

                        <!-- Embudo de Conversión -->
                        <div class="metric-card mb-6">
                            <h3 class="text-xl font-bold mb-1">Embudo de Conversión de Cuentas</h3>
                            <p class="text-xs text-text-secondary mb-2">Seguimiento del progreso hacia cuentas fondeadas</p>
                            <p class="text-xs text-text-secondary mb-6">Análisis del ciclo de vida de tus cuentas funded</p>
                            
                            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-8">
                                <!-- Métricas del Embudo -->
                                <div class="metric-card bg-surface-light text-center p-4">
                                    <div class="flex items-center justify-center mb-2">
                                        <i class="fas fa-shopping-cart text-blue text-2xl"></i>
                                    </div>
                                    <h4 class="text-sm text-text-secondary mb-1">Total Compradas</h4>
                                    <p id="funnel-total" class="text-3xl font-bold text-blue">0</p>
                                </div>

                                <div class="metric-card bg-surface-light text-center p-4">
                                    <div class="flex items-center justify-center mb-2">
                                        <i class="fas fa-check-circle text-green text-2xl"></i>
                                    </div>
                                    <h4 class="text-sm text-text-secondary mb-1">Aprobadas (Live)</h4>
                                    <p id="funnel-approved" class="text-3xl font-bold text-green">0</p>
                                    <p id="funnel-approved-percent" class="text-xs text-text-secondary mt-1">0%</p>
                                </div>

                                <div class="metric-card bg-surface-light text-center p-4">
                                    <div class="flex items-center justify-center mb-2">
                                        <i class="fas fa-heartbeat text-primary text-2xl"></i>
                                    </div>
                                    <h4 class="text-sm text-text-secondary mb-1">Activas Ahora</h4>
                                    <p id="funnel-active" class="text-3xl font-bold text-primary">0</p>
                                    <p id="funnel-survival-rate" class="text-xs text-text-secondary mt-1">Tasa supervivencia: 0%</p>
                                </div>

                                <div class="metric-card bg-surface-light text-center p-4">
                                    <div class="flex items-center justify-center mb-2">
                                        <i class="fas fa-euro-sign text-yellow text-2xl"></i>
                                    </div>
                                    <h4 class="text-sm text-text-secondary mb-1">Costo por Live</h4>
                                    <p id="funnel-cost-per-live" class="text-3xl font-bold text-yellow">€0</p>
                                </div>
                            </div>

                            <!-- Embudo Visual -->
                            <div class="flex flex-col items-center gap-2 mb-6">
                                <div class="w-full max-w-3xl">
                                    <div class="relative h-8 bg-blue rounded" style="width: 100%;" id="funnel-bar-total">
                                        <span class="absolute inset-0 flex items-center justify-center text-sm font-bold text-white">Compradas: 0</span>
                                    </div>
                                </div>
                                <i class="fas fa-arrow-down text-text-secondary"></i>
                                <div class="w-full max-w-2xl">
                                    <div class="relative h-8 bg-green rounded" style="width: 80%;" id="funnel-bar-approved">
                                        <span class="absolute inset-0 flex items-center justify-center text-sm font-bold text-white">Aprobadas: 0</span>
                                    </div>
                                </div>
                                <i class="fas fa-arrow-down text-text-secondary"></i>
                                <div class="w-full max-w-xl">
                                    <div class="relative h-8 bg-primary rounded" style="width: 60%;" id="funnel-bar-active">
                                        <span class="absolute inset-0 flex items-center justify-center text-sm font-bold text-white">Activas: 0</span>
                                    </div>
                                </div>
                            </div>

                            <!-- Métricas de Tiempo -->
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <div class="p-4 bg-surface-light rounded-lg">
                                    <div class="flex items-center gap-3 mb-2">
                                        <i class="fas fa-clock text-primary text-xl"></i>
                                        <h4 class="text-sm font-semibold">Tiempo Promedio en Evaluación</h4>
                                    </div>
                                    <p id="avg-eval-time" class="text-2xl font-bold text-primary">0 días</p>
                                </div>

                                <div class="p-4 bg-surface-light rounded-lg">
                                    <div class="flex items-center gap-3 mb-2">
                                        <i class="fas fa-hourglass-half text-green text-xl"></i>
                                        <h4 class="text-sm font-semibold">Tiempo Promedio Evaluación → Live</h4>
                                    </div>
                                    <p id="avg-eval-to-live" class="text-2xl font-bold text-green">0 días</p>
                                </div>
                            </div>
                        </div>

                        <!-- Timeline de Cuentas -->
                        <div class="metric-card mb-6">
                            <h3 class="text-xl font-bold mb-1">Timeline de Cuentas</h3>
                            <p class="text-xs text-text-secondary mb-2">Línea de tiempo del proceso de fondeo</p>
                            <p class="text-xs text-text-secondary mb-4">Ciclo de vida de cada cuenta fondeada</p>
                            
                            <div id="accounts-timeline-container" class="space-y-4">
                                <!-- Se generará dinámicamente -->
                            </div>
                        </div>

                        <!-- Comparador de Cuentas -->
                        <div class="metric-card mb-6">
                            <h3 class="text-xl font-bold mb-2">⚖️ Comparador de Cuentas</h3>
                            <p class="text-xs text-text-secondary mb-4">Selecciona hasta 4 cuentas para comparar su rendimiento</p>
                            
                            <!-- Selector de Cuentas -->
                            <div class="mb-6">
                                <label class="block mb-2 text-sm font-medium">Selecciona cuentas para comparar:</label>
                                <div id="comparator-selector" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-3">
                                    <!-- Se generará dinámicamente -->
                                </div>
                            </div>

                            <!-- Tabla Comparativa -->
                            <div id="comparator-results" class="overflow-x-auto" style="display: none;">
                                <h4 class="text-lg font-semibold mb-3">Comparación de Métricas</h4>
                                <table class="w-full mb-6">
                                    <thead>
                                        <tr>
                                            <th class="text-left">Métrica</th>
                                            <th id="comp-header-1" class="text-center">Cuenta 1</th>
                                            <th id="comp-header-2" class="text-center" style="display: none;">Cuenta 2</th>
                                            <th id="comp-header-3" class="text-center" style="display: none;">Cuenta 3</th>
                                            <th id="comp-header-4" class="text-center" style="display: none;">Cuenta 4</th>
                                        </tr>
                                    </thead>
                                    <tbody id="comparator-table-body">
                                        <!-- Se generará dinámicamente -->
                                    </tbody>
                                </table>

                                <!-- Gráfico Comparativo -->
                                <h4 class="text-lg font-semibold mb-3">Gráfico de Rendimiento</h4>
                                <div class="chart-container" style="height: 400px;">
                                    <canvas id="comparator-chart"></canvas>
                                </div>
                            </div>
                        </div>

                        <!-- Proyección de Rentabilidad -->
                        <div class="metric-card mb-6">
                            <h3 class="text-xl font-bold mb-1">Proyección de Rentabilidad</h3>
                            <p class="text-xs text-text-secondary mb-2">Estimación de ganancias futuras basada en rendimiento histórico</p>
                            <p class="text-xs text-text-secondary mb-4">Estimación de recuperación de inversión por cuenta</p>
                            
                            <div id="profitability-projections" class="space-y-4">
                                <!-- Se generará dinámicamente -->
                            </div>
                        </div>

                    </div>

        

                    <!-- VISTA: Calendario Financiero -->

                    <div id="funded-calendar-view" class="funded-view">

                        <!-- Calendario Financiero Funded -->
                        <div class="metric-card" id="funded-calendar-card">
                            <div class="flex items-center justify-between mb-4">
                                <h3 class="text-lg font-semibold">Calendario Financiero</h3>
                                <div class="flex items-center gap-4">
                                    <div class="flex items-center gap-2">
                                        <span class="text-xs flex items-center gap-1">
                                            <span class="inline-block w-3 h-3 rounded-full bg-green"></span>
                                            Ingresos
                                        </span>
                                        <span class="text-xs flex items-center gap-1">
                                            <span class="inline-block w-3 h-3 rounded-full bg-red"></span>
                                            Gastos
                                        </span>
                                    </div>
                                    <div class="flex items-center gap-2">
                                        <button id="funded-calendar-prev" class="p-2 hover:bg-surface-light rounded">
                                            <i class="fas fa-chevron-left text-sm"></i>
                                        </button>
                                        <span id="funded-calendar-month-year" class="text-sm font-semibold min-w-[120px] text-center"></span>
                                        <button id="funded-calendar-next" class="p-2 hover:bg-surface-light rounded">
                                            <i class="fas fa-chevron-right text-sm"></i>
                                        </button>
                                    </div>
                                </div>
                            </div>
                            <div id="funded-calendar-container" class="overflow-x-auto">
                                <!-- El calendario se generará dinámicamente aquí -->
                            </div>
                        </div>

                        <!-- Métricas de Barras - Tendencia Semanal y Rendimiento por Día -->
                        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mt-6">
                            <!-- Tendencia Semanal -->
                            <div class="metric-card">
                                <h3 class="text-lg font-semibold mb-1">Tendencia Semanal</h3>
                                <p class="text-xs text-text-secondary mb-3">Balance neto por semana del mes</p>
                                <div id="funded-weekly-trend-bars" class="space-y-2">
                                    <!-- Se generará dinámicamente -->
                                </div>
                            </div>

                            <!-- Rendimiento por Día de la Semana -->
                            <div class="metric-card">
                                <h3 class="text-lg font-semibold mb-1">Rendimiento por Día de la Semana</h3>
                                <p class="text-xs text-text-secondary mb-3">Balance promedio según día de la semana</p>
                                <div id="funded-weekday-performance-bars" class="space-y-2">
                                    <!-- Se generará dinámicamente -->
                                </div>
                            </div>
                        </div>

                    </div>

                    

                    <!-- Vista a Pantalla Completa del Día (fuera de las pestañas para que se superponga) -->
                    
                    <!-- Botón de cerrar FUERA del contenedor scrollable -->
                    <button id="close-funded-day-fullscreen" class="fixed top-6 right-6 bg-red text-white rounded-full w-12 h-12 items-center justify-center hover:bg-red-dark transition-all shadow-xl hidden" style="z-index: 999999;">
                        <i class="fas fa-times text-xl"></i>
                    </button>

                    <div id="funded-day-fullscreen" class="fixed top-0 left-0 w-screen h-screen bg-black overflow-y-auto" style="display: none; z-index: 99999;">

                        <div class="max-w-7xl mx-auto px-6 py-6">
                        
                        <div class="flex items-center justify-between mb-6">

                            <div>

                                <button id="funded-day-back-btn" class="text-primary hover:text-primary-light mb-2">

                                    <i class="fas fa-arrow-left mr-2"></i>Volver al Calendario

                                </button>

                                <h2 class="text-2xl font-bold" id="funded-day-title">Detalles del Día</h2>

                                <p class="text-text-secondary" id="funded-day-date"></p>

                            </div>

                            <div class="text-right">

                                <p class="text-sm text-text-secondary mb-1">Balance del Día</p>

                                <p class="text-3xl font-bold" id="funded-day-balance">€0.00</p>

                            </div>

                        </div>

        

                        <!-- Grid principal -->

                        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">

                            <!-- Columna Izquierda: Movimientos y Estadísticas -->

                            <div class="lg:col-span-2 space-y-6">

                                <!-- Movimientos del día -->

                                <div class="metric-card">

                                    <h3 class="text-lg font-semibold mb-1">Movimientos del Día</h3>
                                    <p class="text-xs text-text-secondary mb-3">Transacciones y cambios registrados</p>

                                    <div id="funded-day-movements" class="space-y-3">

                                        <!-- Se llenará dinámicamente -->

                                    </div>

                                </div>

        

                                <!-- Estadísticas en Barras -->

                                <div class="metric-card">

                                    <h3 class="text-lg font-semibold mb-1">Estadísticas de Retiros</h3>
                                    <p class="text-xs text-text-secondary mb-3">Resumen de payouts recibidos</p>

                                    <div class="space-y-4">

                                        <!-- Total Acumulado -->

                                        <div>

                                            <div class="flex justify-between text-sm mb-2">

                                                <span>Total Acumulado de Retiros</span>

                                                <span class="font-semibold" id="stat-total-withdrawals">€0.00</span>

                                            </div>

                                            <div class="w-full bg-surface-light rounded-full h-3">

                                                <div id="stat-total-bar" class="bg-green h-3 rounded-full transition-all" style="width: 0%"></div>

                                            </div>

                                        </div>

        

                                        <!-- Promedio de Retiros -->

                                        <div>

                                            <div class="flex justify-between text-sm mb-2">

                                                <span>Promedio por Retiro</span>

                                                <span class="font-semibold" id="stat-avg-withdrawals">€0.00</span>

                                            </div>

                                            <div class="w-full bg-surface-light rounded-full h-3">

                                                <div id="stat-avg-bar" class="bg-green h-3 rounded-full transition-all" style="width: 0%"></div>

                                            </div>

                                        </div>

        

                                        <!-- Total Gastos -->

                                        <div>

                                            <div class="flex justify-between text-sm mb-2">

                                                <span>Total Gastos Acumulados</span>

                                                <span class="font-semibold text-red" id="stat-total-expenses">€0.00</span>

                                            </div>

                                            <div class="w-full bg-surface-light rounded-full h-3">

                                                <div id="stat-expenses-bar" class="bg-red h-3 rounded-full transition-all" style="width: 0%"></div>

                                            </div>

                                        </div>

        

                                        <!-- Ratio Retiros/Gastos -->

                                        <div>

                                            <div class="flex justify-between text-sm mb-2">

                                                <span>Ratio Ganancias/Gastos</span>

                                                <span class="font-semibold" id="stat-ratio">0.00x</span>

                                            </div>

                                            <div class="w-full bg-surface-light rounded-full h-3">

                                                <div id="stat-ratio-bar" class="bg-primary h-3 rounded-full transition-all" style="width: 0%"></div>

                                            </div>

                                        </div>

        

                                        <!-- Número de Retiros -->

                                        <div class="grid grid-cols-2 gap-4 mt-4">

                                            <div class="bg-surface-light p-4 rounded-lg text-center">

                                                <p class="text-sm text-text-secondary mb-1">Retiros Totales</p>

                                                <p class="text-2xl font-bold text-green" id="stat-count-withdrawals">0</p>

                                            </div>

                                            <div class="bg-surface-light p-4 rounded-lg text-center">

                                                <p class="text-sm text-text-secondary mb-1">Gastos Totales</p>

                                                <p class="text-2xl font-bold text-red" id="stat-count-expenses">0</p>

                                            </div>

                                        </div>

                                    </div>

                                </div>

                            </div>

        

                            <!-- Columna Derecha: Notas Avanzadas -->

                            <div class="space-y-6">

                                <!-- Notas Avanzadas con Etiquetas -->

                                <div class="metric-card">

                                    <h3 class="text-lg font-semibold mb-4">📝 Notas del Día</h3>

                                    

                                    <!-- Etiquetas -->

                                    <div class="mb-4">

                                        <label class="text-sm text-text-secondary mb-2 block">🏷️ Etiquetas</label>

                                        <div class="flex flex-wrap gap-2 mb-3" id="funded-day-tags">

                                            <!-- Se llenará dinámicamente -->

                                        </div>

                                        <input 

                                            type="text" 

                                            id="new-tag-input" 

                                            placeholder="Nueva etiqueta (presiona Enter)..."

                                            class="w-full p-2 bg-surface-light border border-border rounded text-sm focus:border-primary focus:outline-none"

                                        />

                                    </div>



                                    <!-- Editor de Notas Avanzadas -->

                                    <div>

                                        <div class="flex items-center justify-between mb-3">

                                            <label class="text-sm text-text-secondary">Notas Avanzadas</label>

                                            <button id="edit-notes-btn" class="text-sm px-3 py-1 border border-border rounded hover:border-primary transition-all">

                                                <i class="fas fa-edit mr-1"></i>Editar Notas

                                            </button>

                                        </div>



                                        <!-- Vista de Notas (Read-only) -->

                                        <div id="notes-display" class="w-full min-h-[300px] p-4 bg-surface-light border border-border rounded-lg text-sm" style="display: block;">

                                            <p class="text-text-secondary italic">No hay notas escritas aún. Haz clic en "Editar Notas" para comenzar.</p>

                                        </div>



                                        <!-- Editor Modal de Notas -->

                                        <div id="notes-editor-modal" class="fixed inset-0 bg-black bg-opacity-75 z-50 hidden flex items-center justify-center" style="display: none;">

                                            <div class="bg-surface rounded-lg shadow-2xl flex flex-col max-w-5xl w-full mx-4 max-h-[90vh]">

                                                <!-- Header del Editor -->

                                                <div class="flex items-center justify-between p-4 border-b border-border">

                                                    <h3 class="text-xl font-bold">Notas del Día</h3>

                                                    <button id="close-editor-btn" class="text-2xl text-text-secondary hover:text-text">

                                                        <i class="fas fa-times"></i>

                                                    </button>

                                                </div>



                                                <!-- Toolbar de Formato -->

                                                <div class="flex flex-wrap items-center gap-1 p-3 border-b border-border bg-surface-light overflow-x-auto">

                                                    <!-- Formato de texto -->

                                                    <button onclick="formatText('bold')" class="p-2 hover:bg-surface rounded" title="Negrita">

                                                        <i class="fas fa-bold"></i>

                                                    </button>

                                                    <button onclick="formatText('italic')" class="p-2 hover:bg-surface rounded" title="Cursiva">

                                                        <i class="fas fa-italic"></i>

                                                    </button>

                                                    <button onclick="formatText('underline')" class="p-2 hover:bg-surface rounded" title="Subrayado">

                                                        <i class="fas fa-underline"></i>

                                                    </button>

                                                    <button onclick="formatText('strikeThrough')" class="p-2 hover:bg-surface rounded" title="Tachado">

                                                        <i class="fas fa-strikethrough"></i>

                                                    </button>

                                                    

                                                    <div class="w-px h-6 bg-border mx-1"></div>



                                                    <!-- Alineación -->

                                                    <button onclick="formatText('justifyLeft')" class="p-2 hover:bg-surface rounded" title="Alinear izquierda">

                                                        <i class="fas fa-align-left"></i>

                                                    </button>

                                                    <button onclick="formatText('justifyCenter')" class="p-2 hover:bg-surface rounded" title="Centrar">

                                                        <i class="fas fa-align-center"></i>

                                                    </button>

                                                    <button onclick="formatText('justifyRight')" class="p-2 hover:bg-surface rounded" title="Alinear derecha">

                                                        <i class="fas fa-align-right"></i>

                                                    </button>

                                                    <button onclick="formatText('justifyFull')" class="p-2 hover:bg-surface rounded" title="Justificar">

                                                        <i class="fas fa-align-justify"></i>

                                                    </button>



                                                    <div class="w-px h-6 bg-border mx-1"></div>



                                                    <!-- Listas -->

                                                    <button onclick="formatText('insertUnorderedList')" class="p-2 hover:bg-surface rounded" title="Lista con viñetas">

                                                        <i class="fas fa-list-ul"></i>

                                                    </button>

                                                    <button onclick="formatText('insertOrderedList')" class="p-2 hover:bg-surface rounded" title="Lista numerada">

                                                        <i class="fas fa-list-ol"></i>

                                                    </button>

                                                    <button onclick="formatText('indent')" class="p-2 hover:bg-surface rounded" title="Aumentar sangría">

                                                        <i class="fas fa-indent"></i>

                                                    </button>

                                                    <button onclick="formatText('outdent')" class="p-2 hover:bg-surface rounded" title="Disminuir sangría">

                                                        <i class="fas fa-outdent"></i>

                                                    </button>



                                                    <div class="w-px h-6 bg-border mx-1"></div>



                                                    <!-- Estilo de texto -->

                                                    <select id="format-block" onchange="formatText('formatBlock', this.value); this.selectedIndex=0;" class="px-2 py-1 bg-surface border border-border rounded text-sm">

                                                        <option value="" selected>Normal</option>

                                                        <option value="h1">Título 1</option>

                                                        <option value="h2">Título 2</option>

                                                        <option value="h3">Título 3</option>

                                                        <option value="p">Párrafo</option>

                                                    </select>



                                                    <div class="w-px h-6 bg-border mx-1"></div>



                                                    <!-- Colores -->

                                                    <input type="color" id="text-color" onchange="formatText('foreColor', this.value)" class="w-8 h-8 rounded cursor-pointer" value="#ffffff" title="Color de texto">

                                                    <input type="color" id="bg-color" onchange="formatText('hiliteColor', this.value)" class="w-8 h-8 rounded cursor-pointer" value="#ffeb3b" title="Color de fondo">



                                                    <div class="w-px h-6 bg-border mx-1"></div>



                                                    <!-- Insertar -->

                                                    <button onclick="insertImageFundedNotes()" class="p-2 hover:bg-surface rounded" title="Insertar imagen">

                                                        <i class="fas fa-image"></i>

                                                    </button>

                                                    <button onclick="insertLink()" class="p-2 hover:bg-surface rounded" title="Insertar enlace">

                                                        <i class="fas fa-link"></i>

                                                    </button>

                                                    <button onclick="formatText('removeFormat')" class="p-2 hover:bg-surface rounded text-red" title="Limpiar formato">

                                                        <i class="fas fa-eraser"></i>

                                                    </button>

                                                </div>



                                                <!-- Input oculto para imágenes -->

                                                <input type="file" id="funded-notes-image-input" accept="image/*" style="display: none;">



                                                <!-- Área de Edición -->

                                                <div class="overflow-y-auto p-4" style="max-height: 500px;">

                                                    <div 

                                                        id="funded-day-notes-editor" 

                                                        contenteditable="true"

                                                        class="w-full min-h-[300px] p-4 bg-background border border-border rounded-lg focus:border-primary focus:outline-none text-base"

                                                        placeholder="Escribe las notas del día..."

                                                    ></div>

                                                </div>



                                                <!-- Footer con Acciones -->

                                                <div class="flex items-center justify-between p-4 border-t border-border gap-4">

                                                    <div class="flex items-center gap-2">

                                                        <!-- Nota de Voz -->

                                                        <button id="voice-note-btn" class="flex items-center gap-2 px-4 py-2 bg-surface-light border border-border rounded hover:border-primary transition-all">

                                                            <i class="fas fa-microphone"></i>

                                                            <span>Nota de Voz</span>

                                                        </button>

                                                        <button id="download-note-btn" class="p-2 bg-surface-light border border-border rounded hover:border-primary transition-all" title="Descargar nota">

                                                            <i class="fas fa-download"></i>

                                                        </button>

                                                    </div>



                                                    <div class="flex items-center gap-2">

                                                        <span class="text-xs text-text-secondary" id="editor-char-count">0 caracteres</span>

                                                        <button id="editor-cancel-btn" class="px-4 py-2 border border-border rounded hover:bg-surface-light transition-all">

                                                            Cancelar

                                                        </button>

                                                        <button id="editor-save-btn" class="primary px-4 py-2">

                                                            <i class="fas fa-save mr-2"></i>Guardar Notas

                                                        </button>

                                                    </div>

                                                </div>

                                            </div>

                                        </div>

                                    </div>

                                </div>

                                <!-- Calendario de Navegación Rápida -->
                                <div class="metric-card">
                                    <h3 class="text-lg font-semibold mb-4">Calendario</h3>
                                    <div id="funded-day-mini-calendar" class="daily-journal-mini-calendar">
                                        <!-- Calendario renderizado dinámicamente -->
                                    </div>
                                </div>

                            </div>

                        </div>

                        <!-- Galería de Imágenes - Abajo del todo y más amplia -->

                        <div class="metric-card mt-6">

                            <h3 class="text-lg font-semibold mb-4">🖼️ Galería de Imágenes (máx. 3)</h3>

                            

                            <!-- Preview de imágenes - Grid más amplio -->

                            <div id="funded-day-images-preview" class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">

                                <!-- Se llenará dinámicamente -->

                            </div>



                            <!-- Botón para añadir imagen -->

                            <div class="flex flex-col items-center gap-2">

                                <input 

                                    type="file" 

                                    id="funded-day-image-input" 

                                    accept="image/*" 

                                    class="hidden"

                                />

                                <button 

                                    id="add-day-image-btn" 

                                    class="w-full max-w-md p-4 border-2 border-dashed border-border rounded-lg hover:border-primary hover:bg-surface-light transition-all text-center"

                                >

                                    <i class="fas fa-image mr-2 text-lg"></i>Añadir Imagen

                                </button>

                                <p class="text-xs text-text-secondary text-center">

                                    Soporta JPG, PNG, GIF (máx. 5MB por imagen) - Haz clic en cualquier imagen para verla a pantalla completa

                                </p>

                            </div>

                        </div>
                        </div>

                    </div>

                    <!-- VISTA: Métricas del Negocio -->
                    <div id="funded-metrics-view" class="funded-view">
                        <h2 class="text-2xl font-bold mb-1">Métricas del Negocio de Cuentas Fondeadas</h2>
                        <p class="text-sm text-text-secondary mb-5">Análisis completo de rentabilidad y ROI de prop firms</p>
                        
                        <!-- Métricas Principales -->
                        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-8">
                            <div class="metric-card p-4">
                                <p class="text-sm text-text-secondary">ROI Total</p>
                                <p class="text-xs text-text-secondary mb-2">Retiros / Gastos</p>
                                <p id="funded-metrics-roi" class="text-2xl font-bold text-green">0%</p>
                            </div>
                            <div class="metric-card p-4">
                                <p class="text-sm text-text-secondary">Balance Neto</p>
                                <p class="text-xs text-text-secondary mb-2">Retiros - Gastos</p>
                                <p id="funded-metrics-balance" class="text-2xl font-bold text-green">€0.00</p>
                            </div>
                            <div class="metric-card p-4">
                                <p class="text-sm text-text-secondary">Tasa de Éxito</p>
                                <p class="text-xs text-text-secondary mb-2">Live / Total</p>
                                <p id="funded-metrics-success-rate" class="text-2xl font-bold text-green">0%</p>
                            </div>
                            <div class="metric-card p-4">
                                <p class="text-sm text-text-secondary">Retiros Totales</p>
                                <p class="text-xs text-text-secondary mb-2">Suma de retiros</p>
                                <p id="funded-metrics-total-withdrawals" class="text-2xl font-bold text-green">€0.00</p>
                            </div>
                        </div>

                        <!-- Gráficos de Barras -->
                        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                            <!-- ROI por Empresa -->
                            <div class="metric-card">
                                <h3 class="text-lg font-semibold mb-1">ROI por Empresa</h3>
                                <p class="text-xs text-text-secondary mb-2">Retorno de inversión por prop firm</p>
                                <p class="text-xs text-text-secondary mb-3">Retorno de inversión por compañía</p>
                                <div id="funded-roi-by-company-bars" class="space-y-3">
                                    <!-- Se generará dinámicamente -->
                                </div>
                            </div>

                            <!-- Retiros por Empresa -->
                            <div class="metric-card">
                                <h3 class="text-lg font-semibold mb-1">Retiros por Empresa</h3>
                                <p class="text-xs text-text-secondary mb-2">Tendencia de pagos históricos</p>
                                <p class="text-xs text-text-secondary mb-3">Total de retiros por compañía</p>
                                <div id="funded-withdrawals-by-company-bars" class="space-y-3">
                                    <!-- Se generará dinámicamente -->
                                </div>
                            </div>
                        </div>

                        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                            <!-- Distribución de Cuentas por Empresa -->
                            <div class="metric-card">
                                <h3 class="text-lg font-semibold mb-1">Distribución de Cuentas</h3>
                                <p class="text-xs text-text-secondary mb-2">Proporción de cuentas por tipo</p>
                                <p class="text-xs text-text-secondary mb-3">Cantidad de cuentas por empresa</p>
                                <div id="funded-accounts-by-company-bars" class="space-y-3">
                                    <!-- Se generará dinámicamente -->
                                </div>
                            </div>

                            <!-- Tasa de Éxito por Empresa -->
                            <div class="metric-card">
                                <h3 class="text-lg font-semibold mb-2">✅ Tasa de Éxito por Empresa</h3>
                                <p class="text-xs text-text-secondary mb-3">Porcentaje de evaluaciones aprobadas</p>
                                <div id="funded-success-rate-by-company-bars" class="space-y-3">
                                    <!-- Se generará dinámicamente -->
                                </div>
                            </div>
                        </div>

                        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                            <!-- Balance Neto por Empresa -->
                            <div class="metric-card">
                                <h3 class="text-lg font-semibold mb-2">💵 Balance Neto por Empresa</h3>
                                <p class="text-xs text-text-secondary mb-3">Retiros menos gastos por compañía</p>
                                <div id="funded-balance-by-company-bars" class="space-y-3">
                                    <!-- Se generará dinámicamente -->
                                </div>
                            </div>

                            <!-- Gastos Totales por Empresa -->
                            <div class="metric-card">
                                <h3 class="text-lg font-semibold mb-2">💳 Gastos por Empresa</h3>
                                <p class="text-xs text-text-secondary mb-3">Total invertido por compañía</p>
                                <div id="funded-expenses-by-company-bars" class="space-y-3">
                                    <!-- Se generará dinámicamente -->
                                </div>
                            </div>
                        </div>

                        <!-- Distribución de Estados -->
                        <div class="metric-card mb-8">
                            <h3 class="text-lg font-semibold mb-1">Distribución por Estado de Cuentas</h3>
                            <p class="text-xs text-text-secondary mb-2">Cuentas activas, pausadas y finalizadas</p>
                            <p class="text-xs text-text-secondary mb-3">Comparación entre evaluaciones, en progreso y cuentas live</p>
                            <div id="funded-status-distribution-bars" class="space-y-3">
                                <!-- Se generará dinámicamente -->
                            </div>
                        </div>

                        <!-- Gráficos Verticales -->
                        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-8">
                            <!-- Gráfico 1: Retiros por Empresa -->
                            <div class="metric-card">
                                <h3 class="text-lg font-semibold mb-1">Retiros por Empresa</h3>
                                <p class="text-xs text-text-secondary mb-2">Monto retirado por cada prop firm</p>
                                <p class="text-xs text-text-secondary mb-3">Comparación de ingresos por prop firm</p>
                                <div style="height: 300px;">
                                    <canvas id="funded-vertical-chart-1"></canvas>
                                </div>
                            </div>

                            <!-- Gráfico 2: Balance por Empresa -->
                            <div class="metric-card">
                                <h3 class="text-lg font-semibold mb-2">💵 Balance por Empresa</h3>
                                <p class="text-xs text-text-secondary mb-3">Beneficio neto después de gastos</p>
                                <div style="height: 300px;">
                                    <canvas id="funded-vertical-chart-2"></canvas>
                                </div>
                            </div>

                            <!-- Gráfico 3: Distribución de Estados -->
                            <div class="metric-card">
                                <h3 class="text-lg font-semibold mb-1">Estados de Cuentas</h3>
                                <p class="text-xs text-text-secondary mb-2">Clasificación por estado actual</p>
                                <p class="text-xs text-text-secondary mb-3">Distribución por tipo de cuenta</p>
                                <div style="height: 300px;">
                                    <canvas id="funded-vertical-chart-3"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>

                </section>

        <!-- Modal de Retiros -->
        <div id="withdrawal-modal" class="modal" style="display: none;">
            <div class="modal-content" style="max-width: 500px;">
                <div class="flex items-center justify-between mb-6">
                    <h3 id="withdrawal-modal-title" class="text-xl font-bold">Registrar Retiro</h3>
                    <button id="close-withdrawal-modal" class="text-text-secondary hover:text-text">
                        <i class="fas fa-times text-2xl"></i>
                    </button>
                </div>

                <form id="withdrawal-form">
                    <input type="hidden" id="withdrawal-account-id">
                    
                    <div class="space-y-4">
                        <!-- Cuenta -->
                        <div>
                            <label class="block mb-2 text-sm font-medium">Cuenta</label>
                            <input type="text" id="withdrawal-account-name" readonly class="w-full bg-surface-light border border-border rounded-lg px-4 py-3 text-text-secondary cursor-not-allowed">
                        </div>

                        <!-- Monto del Retiro -->
                        <div>
                            <label class="block mb-2 text-sm font-medium">
                                Monto del Retiro <span class="text-red">*</span>
                            </label>
                            <div class="relative">
                                <span class="absolute left-4 top-1/2 transform -translate-y-1/2 text-text-secondary">€</span>
                                <input type="number" id="withdrawal-amount" step="0.01" min="0" required placeholder="0.00" class="w-full bg-background border border-border rounded-lg px-4 py-3 pl-8 focus:outline-none focus:border-primary">
                            </div>
                        </div>

                        <!-- Fecha del Retiro -->
                        <div>
                            <label class="block mb-2 text-sm font-medium">Fecha del Retiro</label>
                            <input type="date" id="withdrawal-date" required class="w-full bg-background border border-border rounded-lg px-4 py-3 focus:outline-none focus:border-primary">
                        </div>

                        <!-- Notas (opcional) -->
                        <div>
                            <label class="block mb-2 text-sm font-medium">Notas (opcional)</label>
                            <textarea id="withdrawal-notes" rows="3" placeholder="Detalles adicionales del retiro..." class="w-full bg-background border border-border rounded-lg px-4 py-3 focus:outline-none focus:border-primary resize-none"></textarea>
                        </div>
                    </div>

                    <div class="flex gap-3 mt-6">
                        <button type="button" id="cancel-withdrawal-btn" class="flex-1 px-4 py-3 border border-border rounded-lg hover:bg-surface-light transition-colors">
                            Cancelar
                        </button>
                        <button type="submit" class="flex-1 px-4 py-3 bg-primary text-black rounded-lg hover:bg-secondary transition-colors font-semibold">
                            <i class="fas fa-check mr-2"></i>Registrar Retiro
                        </button>
                    </div>
                </form>
            </div>
        </div>

        <!-- AUDICIÓN SECTION -->
        <section id="audicion" class="section-container">
            <!-- Header Público (solo visible en vista pública) -->
            <div id="audicion-public-header" style="display: none; position: sticky; top: 0; z-index: 999; background: var(--bg-primary); border-bottom: 1px solid var(--border); padding: 1rem 2rem;">
                <div style="max-width: 1400px; margin: 0 auto; display: flex; justify-content: space-between; align-items: center;">
                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                        <div style="display: flex; align-items: center; justify-content: center;">
                            <img src="logos/traders-survivor-logo.png" alt="Trading Survivor" style="width: 50px; height: 50px; object-fit: contain; filter: drop-shadow(0 0 1px rgba(57, 255, 20, 0.4));">
                        </div>
                        <span style="font-size: 1.25rem; font-weight: bold; color: var(--text);">Trading Survivor</span>
                    </div>
                    <div style="display: flex; gap: 1rem;">
                        <a href="/" style="padding: 0.5rem 1rem; background: transparent; color: var(--text); border: 1px solid var(--border); border-radius: 8px; text-decoration: none; display: flex; align-items: center; gap: 0.5rem; transition: all 0.2s;">
                            <i class="fas fa-home"></i>Inicio
                        </a>
                        <a href="/#registro" style="padding: 0.5rem 1rem; background: linear-gradient(135deg, #39ff14, #28e000); color: #000; border-radius: 8px; text-decoration: none; display: flex; align-items: center; gap: 0.5rem; font-weight: 600; transition: all 0.2s;">
                            <i class="fas fa-user-plus"></i>Crear mi cuenta gratis
                        </a>
                    </div>
                </div>
            </div>
            
            <!-- Header con selector -->
            <div class="flex flex-col md:flex-row justify-between items-start md:items-center gap-4 mb-6">
                <h2 class="text-2xl font-semibold">Audición de Trading</h2>
                <div class="flex items-center gap-3">
                    <select id="audicion-account-select" class="bg-surface border border-border rounded px-3 py-1.5 text-white text-xs">
                        <option value="all">Todas las cuentas</option>
                    </select>
                    <button id="audicion-filter-dates-btn-header" class="text-xs px-3 py-1.5 bg-surface-light hover:bg-surface border border-border rounded transition-colors">
                        <i class="fas fa-calendar-alt mr-1"></i>Filtrar por fecha
                    </button>
                </div>
            </div>

            <!-- Perfil del Trader - Grid con 3 módulos -->
            <div class="grid grid-cols-1 lg:grid-cols-12 gap-4 mb-6">
                <!-- Módulo 1: Datos del Trader con Foto -->
                <div class="metric-card p-6 lg:col-span-5">
                    <div class="flex flex-col items-center text-center space-y-4">
                        <!-- Avatar -->
                        <div class="relative flex-shrink-0">
                            <div id="audicion-user-avatar" class="w-24 h-24 rounded-full bg-gradient-to-br from-primary to-accent flex items-center justify-center text-white text-3xl font-bold overflow-hidden shadow-lg">
                                D
                            </div>
                        </div>
                        
                        <!-- Info del Usuario -->
                        <div class="w-full">
                            <div class="flex flex-col items-center space-y-1 mb-1">
                                <div class="flex items-center space-x-2">
                                    <h3 id="audicion-username" class="text-xl font-bold">Usuario</h3>
                                    <i class="fas fa-check-circle text-primary" title="Cuenta Verificada"></i>
                                </div>
                            </div>
                            <p id="audicion-user-email" class="text-text-secondary text-sm mb-3">email@example.com</p>
                            <div class="flex flex-col items-center space-y-2 text-xs text-text-secondary">
                                <span><i class="fas fa-calendar-alt mr-1"></i>Miembro desde <span id="audicion-member-since">Dic 2024</span></span>
                                <span><i class="fas fa-chart-line mr-1"></i>Trading desde <span id="audicion-trading-since">Ene 2023</span></span>
                                <span class="inline-flex items-center space-x-1 bg-green bg-opacity-20 text-green text-xs px-2 py-1 rounded-full mt-2">
                                    <i class="fas fa-check-circle" style="font-size: 10px;"></i>
                                    <span>Verificado</span>
                                </span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Módulo 2: Link Público de Audición -->
                <div class="metric-card p-4 lg:col-span-3" id="audicion-public-link-section">
                    <div class="flex flex-col justify-center h-full space-y-2">
                        <div class="flex items-center justify-center mb-1">
                            <svg class="w-6 h-6 text-primary" fill="currentColor" viewBox="0 0 24 24">
                                <path d="M12 2L2 7v10c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V7l-10-5z"/>
                            </svg>
                        </div>
                        <h4 class="text-center text-xs font-semibold text-text-secondary mb-2">Link Público</h4>
                        <div class="flex items-center space-x-1">
                            <input type="text" id="audicion-public-link" readonly class="flex-1 bg-background border border-border rounded px-2 py-1.5 text-xs text-primary text-center" value="Haz clic en Compartir">
                            <button id="copy-audicion-link" class="btn-outline text-xs px-2 py-1.5" title="Copiar link">
                                <i class="fas fa-copy"></i>
                            </button>
                        </div>
                        <button id="share-audicion-btn" class="btn-primary text-xs px-3 py-1.5 w-full">
                            <i class="fas fa-share-alt mr-1"></i>Generar Link
                        </button>
                        <button id="audicion-privacy-settings-btn" class="text-xs px-3 py-2 w-full rounded transition-all" style="border: 1px solid rgba(148, 163, 184, 0.3); background: rgba(148, 163, 184, 0.05); color: #94A3B8; font-weight: 500;">
                            <i class="fas fa-sliders-h mr-2"></i>Configuración de Privacidad
                        </button>
                        <p class="text-xs text-text-secondary text-center mt-1">
                            Personaliza qué información mostrar
                        </p>
                    </div>
                </div>

                <!-- Módulo 3: P&L Neto Semanal (Gráfico de Barras) -->
                <div class="metric-card p-5 lg:col-span-4">
                    <div class="flex items-center justify-between mb-3">
                        <h4 class="text-sm font-semibold">P&L Neto Semanal</h4>
                        <i class="fas fa-chart-bar text-primary text-sm"></i>
                    </div>
                    <div style="height: 220px;">
                        <canvas id="audicion-weekly-chart"></canvas>
                    </div>
                </div>
            </div>

            <!-- Métricas Principales con Gauges -->
            <div class="grid grid-cols-2 lg:grid-cols-4 gap-4 mb-6">
                <!-- P&L Total -->
                <div class="metric-card p-5">
                    <h4 class="text-xs font-medium text-text-secondary uppercase tracking-wide mb-3">P&L Total</h4>
                    <div class="flex items-center justify-center mb-3" style="height: 140px;">
                        <canvas id="gauge-pl-total" width="140" height="140"></canvas>
                    </div>
                    <p id="audicion-pl-total" class="text-2xl font-bold text-center mb-2" style="color: #39ff14;">$0.00</p>
                    <div class="flex items-center justify-center space-x-3 text-xs">
                        <span style="color: #39ff14;"><span id="audicion-total-wins">0</span> Wins</span>
                        <span style="color: #ff4136;"><span id="audicion-total-losses">0</span> Losses</span>
                    </div>
                </div>

                <!-- Win Rate -->
                <div class="metric-card p-5">
                    <h4 class="text-xs font-medium text-text-secondary uppercase tracking-wide mb-3">Win Rate</h4>
                    <div class="flex items-center justify-center mb-3" style="height: 140px;">
                        <canvas id="gauge-win-rate" width="140" height="140"></canvas>
                    </div>
                    <p id="audicion-win-rate" class="text-2xl font-bold text-center mb-2">0%</p>
                    <div class="flex items-center justify-center space-x-2 text-xs text-text-secondary">
                        <span><span id="audicion-winners">0</span>W</span>
                        <span>·</span>
                        <span><span id="audicion-losers">0</span>L</span>
                        <span>·</span>
                        <span><span id="audicion-breakeven">0</span>BE</span>
                    </div>
                </div>

                <!-- Profit Factor -->
                <div class="metric-card p-5">
                    <h4 class="text-xs font-medium text-text-secondary uppercase tracking-wide mb-3">Profit Factor</h4>
                    <div class="flex items-center justify-center mb-3" style="height: 140px;">
                        <canvas id="gauge-profit-factor" width="140" height="140"></canvas>
                    </div>
                    <p id="audicion-profit-factor" class="text-2xl font-bold text-center mb-2">0.00</p>
                    <div class="text-xs text-text-secondary text-center">
                        Ratio: <span id="audicion-pf-ratio">1:1</span>
                    </div>
                </div>

                <!-- Day Win % -->
                <div class="metric-card p-5">
                    <h4 class="text-xs font-medium text-text-secondary uppercase tracking-wide mb-3">Day Win %</h4>
                    <div class="flex items-center justify-center mb-3" style="height: 140px;">
                        <canvas id="gauge-day-win" width="140" height="140"></canvas>
                    </div>
                    <p id="audicion-day-win-rate" class="text-2xl font-bold text-center mb-2">0%</p>
                    <div class="flex items-center justify-center space-x-3 text-xs text-text-secondary">
                        <span style="color: #39ff14;"><span id="audicion-winning-days">0</span> días+</span>
                        <span style="color: #ff4136;"><span id="audicion-losing-days">0</span> días-</span>
                    </div>
                </div>
            </div>

            <!-- Curvas de Rendimiento -->
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-4 mb-6">
                <!-- Curva de Profit -->
                <div class="metric-card p-5">
                    <div class="flex items-center justify-between mb-4">
                        <h4 class="text-sm font-semibold">Curva de Profit Acumulado</h4>
                        <div class="flex items-center space-x-2">
                            <span class="text-xs px-2 py-1 bg-primary bg-opacity-20 text-primary rounded">Profit</span>
                        </div>
                    </div>
                    <div style="height: 220px;">
                        <canvas id="audicion-profit-curve"></canvas>
                    </div>
                </div>

                <!-- Curva de Drawdown -->
                <div class="metric-card p-5">
                    <div class="flex items-center justify-between mb-4">
                        <h4 class="text-sm font-semibold">Curva de Drawdown</h4>
                        <div class="flex items-center space-x-2">
                            <span class="text-xs px-2 py-1 bg-red bg-opacity-20 text-red rounded">Drawdown</span>
                        </div>
                    </div>
                    <div style="height: 220px;">
                        <canvas id="audicion-drawdown-curve"></canvas>
                    </div>
                </div>
            </div>

            <!-- Últimos Trades -->
            <div class="metric-card p-6 mb-6">
                <div class="flex justify-between items-center mb-4">
                    <h4 class="text-lg font-semibold">Últimos Trades</h4>
                    <div class="flex items-center gap-2">
                        <button id="audicion-filter-dates-btn" class="text-xs px-3 py-1 bg-surface-light hover:bg-surface border border-border rounded transition-colors">
                            <i class="fas fa-calendar-alt mr-1"></i>Filtrar por fecha
                        </button>
                        <span class="bg-primary bg-opacity-20 text-primary text-xs px-3 py-1 rounded-full">
                            <i class="fas fa-check-circle mr-1"></i>Verificado
                        </span>
                    </div>
                </div>
                
                <div class="overflow-x-auto">
                    <table class="w-full" id="audicion-latest-trades">
                        <thead>
                            <tr class="text-xs text-text-secondary border-b border-border">
                                <th class="text-left py-3 px-2 font-medium">FECHA</th>
                                <th class="text-left py-3 px-2 font-medium">SÍMBOLO</th>
                                <th class="text-center py-3 px-2 font-medium">DIRECCIÓN</th>
                                <th class="text-center py-3 px-2 font-medium">SESIÓN</th>
                                <th class="text-center py-3 px-2 font-medium">RESULTADO</th>
                                <th class="text-right py-3 px-2 font-medium">P&L</th>
                            </tr>
                        </thead>
                        <tbody class="text-sm">
                            <!-- Dinámico -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Estadísticas Adicionales -->
            <div class="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-4 mb-6">
                <!-- Mejor Trade -->
                <div class="metric-card p-4">
                    <div class="flex flex-col">
                        <div class="flex items-center space-x-2 mb-2">
                            <div class="w-8 h-8 rounded-full bg-primary bg-opacity-20 flex items-center justify-center">
                                <i class="fas fa-trophy text-primary text-xs"></i>
                            </div>
                            <p class="text-xs text-text-secondary">Mejor Trade</p>
                        </div>
                        <p id="audicion-best-trade" class="text-lg font-bold text-primary">$0.00</p>
                    </div>
                </div>

                <!-- Peor Trade -->
                <div class="metric-card p-4">
                    <div class="flex flex-col">
                        <div class="flex items-center space-x-2 mb-2">
                            <div class="w-8 h-8 rounded-full bg-red bg-opacity-20 flex items-center justify-center">
                                <i class="fas fa-exclamation-triangle text-red text-xs"></i>
                            </div>
                            <p class="text-xs text-text-secondary">Peor Trade</p>
                        </div>
                        <p id="audicion-worst-trade" class="text-lg font-bold text-red">$0.00</p>
                    </div>
                </div>

                <!-- Promedio por Trade -->
                <div class="metric-card p-4">
                    <div class="flex flex-col">
                        <div class="flex items-center space-x-2 mb-2">
                            <div class="w-8 h-8 rounded-full bg-accent bg-opacity-20 flex items-center justify-center">
                                <i class="fas fa-chart-line text-accent text-xs"></i>
                            </div>
                            <p class="text-xs text-text-secondary">Promedio</p>
                        </div>
                        <p id="audicion-avg-trade" class="text-lg font-bold">$0.00</p>
                    </div>
                </div>

                <!-- Win Rate -->
                <div class="metric-card p-4">
                    <div class="flex flex-col">
                        <div class="flex items-center space-x-2 mb-2">
                            <div class="w-8 h-8 rounded-full bg-green bg-opacity-20 flex items-center justify-center">
                                <i class="fas fa-percentage text-green text-xs"></i>
                            </div>
                            <p class="text-xs text-text-secondary">Win Rate</p>
                        </div>
                        <p id="audicion-win-rate" class="text-lg font-bold text-green">0%</p>
                    </div>
                </div>

                <!-- Profit Factor -->
                <div class="metric-card p-4">
                    <div class="flex flex-col">
                        <div class="flex items-center space-x-2 mb-2">
                            <div class="w-8 h-8 rounded-full bg-yellow bg-opacity-20 flex items-center justify-center">
                                <i class="fas fa-balance-scale text-yellow text-xs"></i>
                            </div>
                            <p class="text-xs text-text-secondary">Profit Factor</p>
                        </div>
                        <p id="audicion-profit-factor" class="text-lg font-bold">0.00</p>
                    </div>
                </div>

                <!-- R:R Promedio -->
                <div class="metric-card p-4">
                    <div class="flex flex-col">
                        <div class="flex items-center space-x-2 mb-2">
                            <div class="w-8 h-8 rounded-full bg-primary bg-opacity-20 flex items-center justify-center">
                                <i class="fas fa-arrows-alt-h text-primary text-xs"></i>
                            </div>
                            <p class="text-xs text-text-secondary">R:R Avg</p>
                        </div>
                        <p id="audicion-avg-rr" class="text-lg font-bold">1:0</p>
                    </div>
                </div>
            </div>

            <!-- Análisis Detallado de Wins vs Losses -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <!-- Trades Ganadores -->
                <div class="metric-card p-5">
                    <h5 class="text-sm font-semibold mb-4 flex items-center">
                        <i class="fas fa-arrow-up text-green mr-2"></i>
                        Análisis de Trades Ganadores
                    </h5>
                    <div class="space-y-3">
                        <div class="flex justify-between items-center">
                            <span class="text-xs text-text-secondary">Total Wins</span>
                            <span id="audicion-total-wins" class="font-semibold text-green">0</span>
                        </div>
                        <div class="flex justify-between items-center">
                            <span class="text-xs text-text-secondary">Promedio Win</span>
                            <span id="audicion-avg-win" class="font-semibold text-green">$0.00</span>
                        </div>
                        <div class="flex justify-between items-center">
                            <span class="text-xs text-text-secondary">Mayor Win</span>
                            <span id="audicion-largest-win" class="font-semibold text-green">$0.00</span>
                        </div>
                        <div class="flex justify-between items-center">
                            <span class="text-xs text-text-secondary">Duración Promedio</span>
                            <span id="audicion-avg-win-duration" class="font-semibold">0h 0m</span>
                        </div>
                    </div>
                </div>

                <!-- Trades Perdedores -->
                <div class="metric-card p-5">
                    <h5 class="text-sm font-semibold mb-4 flex items-center">
                        <i class="fas fa-arrow-down text-red mr-2"></i>
                        Análisis de Trades Perdedores
                    </h5>
                    <div class="space-y-3">
                        <div class="flex justify-between items-center">
                            <span class="text-xs text-text-secondary">Total Losses</span>
                            <span id="audicion-total-losses" class="font-semibold text-red">0</span>
                        </div>
                        <div class="flex justify-between items-center">
                            <span class="text-xs text-text-secondary">Promedio Loss</span>
                            <span id="audicion-avg-loss" class="font-semibold text-red">$0.00</span>
                        </div>
                        <div class="flex justify-between items-center">
                            <span class="text-xs text-text-secondary">Mayor Loss</span>
                            <span id="audicion-largest-loss" class="font-semibold text-red">$0.00</span>
                        </div>
                        <div class="flex justify-between items-center">
                            <span class="text-xs text-text-secondary">Duración Promedio</span>
                            <span id="audicion-avg-loss-duration" class="font-semibold">0h 0m</span>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Modal de Filtro de Fechas para Audición -->
        <div id="audicion-date-range-modal" class="fixed inset-0 z-50 flex items-center justify-center p-4 hidden" style="background-color: rgba(0,0,0,0.95);">
            <div class="relative bg-surface border border-border rounded-lg shadow-lg p-6 w-full max-w-lg">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-xl font-semibold">Seleccionar Rango de Fechas</h3>
                    <button id="audicion-date-range-close-btn" class="p-2 -mr-2 rounded-full hover:bg-surface-light"><i class="fas fa-times"></i></button>
                </div>
                <div class="flex flex-col md:flex-row gap-6">
                    <!-- Predefined Ranges -->
                    <div class="w-full md:w-1/3 border-b md:border-b-0 md:border-r border-border pb-4 md:pb-0 md:pr-6">
                        <h4 class="text-sm font-semibold mb-3">Rangos Rápidos</h4>
                        <div class="space-y-2">
                            <button class="w-full text-left p-2 rounded hover:bg-surface-light audicion-date-range-preset" data-range="today">Hoy</button>
                            <button class="w-full text-left p-2 rounded hover:bg-surface-light audicion-date-range-preset" data-range="this_week">Esta Semana</button>
                            <button class="w-full text-left p-2 rounded hover:bg-surface-light audicion-date-range-preset" data-range="this_month">Este Mes</button>
                            <button class="w-full text-left p-2 rounded hover:bg-surface-light audicion-date-range-preset" data-range="last_7_days">Últimos 7 días</button>
                            <button class="w-full text-left p-2 rounded hover:bg-surface-light audicion-date-range-preset" data-range="last_30_days">Últimos 30 días</button>
                            <button class="w-full text-left p-2 rounded hover:bg-surface-light audicion-date-range-preset" data-range="this_year">Este Año</button>
                        </div>
                    </div>
                    <!-- Calendar -->
                    <div class="w-full md:w-2/3">
                        <div class="flex justify-between items-center mb-3">
                            <button id="audicion-calendar-prev-month" class="p-2 rounded-full hover:bg-surface-light"><i class="fas fa-chevron-left"></i></button>
                            <h4 id="audicion-calendar-month-year" class="font-semibold text-lg"></h4>
                            <button id="audicion-calendar-next-month" class="p-2 rounded-full hover:bg-surface-light"><i class="fas fa-chevron-right"></i></button>
                        </div>
                        <div class="grid grid-cols-7 gap-1 text-center text-sm mb-2 text-text-secondary">
                            <div>Do</div><div>Lu</div><div>Ma</div><div>Mi</div><div>Ju</div><div>Vi</div><div>Sá</div>
                        </div>
                        <div id="audicion-calendar-days" class="grid grid-cols-7 gap-1">
                            <!-- Calendar days will be generated here -->
                        </div>
                    </div>
                </div>
                <div class="mt-6 border-t border-border pt-4 flex justify-between items-center">
                    <div class="flex items-center gap-2 text-sm">
                        <input type="text" id="audicion-date-range-start-input" class="bg-surface-light p-2 rounded w-32 text-center" placeholder="Inicio" readonly>
                        <span>-</span>
                        <input type="text" id="audicion-date-range-end-input" class="bg-surface-light p-2 rounded w-32 text-center" placeholder="Fin" readonly>
                    </div>
                    <div class="space-x-2">
                        <button id="audicion-date-range-clear-btn" class="secondary">Limpiar</button>
                        <button id="audicion-date-range-apply-btn" class="primary">Aplicar</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Modal de Configuración de Privacidad -->
        <div id="audicion-privacy-modal" class="fixed inset-0 z-50 flex items-center justify-center p-4 hidden" style="background-color: rgba(0,0,0,0.95);">
            <div class="relative bg-surface border border-border rounded-lg shadow-2xl w-full max-w-2xl" style="animation: fadeInScale 0.3s ease-out;">
                <!-- Header -->
                <div class="flex justify-between items-center p-6 border-b border-border">
                    <div>
                        <h3 class="text-xl font-semibold text-text">Configuración de Privacidad</h3>
                        <p class="text-xs text-text-secondary mt-1">Personaliza qué información se muestra en tu audición pública</p>
                    </div>
                    <button id="audicion-privacy-close-btn" class="p-2 rounded-full hover:bg-surface-light transition-colors">
                        <i class="fas fa-times text-xl text-text-secondary"></i>
                    </button>
                </div>

                <!-- Content -->
                <div class="p-6" style="max-height: 70vh; overflow-y: auto;">
                    <!-- Información Personal -->
                    <div class="mb-6">
                        <h4 class="text-sm font-semibold text-text uppercase tracking-wider mb-4 flex items-center">
                            <i class="fas fa-user mr-2 text-primary" style="font-size: 14px;"></i>
                            Información Personal
                        </h4>
                        <div class="space-y-3 pl-6">
                            <div class="flex justify-between items-center p-3 bg-background rounded border border-border hover:border-primary transition-colors">
                                <div>
                                    <p class="text-sm font-medium text-text">Mostrar correo electrónico</p>
                                    <p class="text-xs text-text-secondary">Visible para otros traders</p>
                                </div>
                                <label class="privacy-switch">
                                    <input type="checkbox" id="privacy-show-email" checked>
                                    <span class="privacy-slider"></span>
                                </label>
                            </div>
                            <div class="flex justify-between items-center p-3 bg-background rounded border border-border hover:border-primary transition-colors">
                                <div>
                                    <p class="text-sm font-medium text-text">Mostrar fecha de registro</p>
                                    <p class="text-xs text-text-secondary">Antigüedad en la plataforma</p>
                                </div>
                                <label class="privacy-switch">
                                    <input type="checkbox" id="privacy-show-member-since" checked>
                                    <span class="privacy-slider"></span>
                                </label>
                            </div>
                            <div class="flex justify-between items-center p-3 bg-background rounded border border-border hover:border-primary transition-colors">
                                <div>
                                    <p class="text-sm font-medium text-text">Mostrar foto de perfil</p>
                                    <p class="text-xs text-text-secondary">Avatar personalizado</p>
                                </div>
                                <label class="privacy-switch">
                                    <input type="checkbox" id="privacy-show-avatar" checked>
                                    <span class="privacy-slider"></span>
                                </label>
                            </div>
                        </div>
                    </div>

                    <!-- Métricas Financieras -->
                    <div class="mb-6">
                        <h4 class="text-sm font-semibold text-text uppercase tracking-wider mb-4 flex items-center">
                            <i class="fas fa-chart-bar mr-2 text-primary" style="font-size: 14px;"></i>
                            Métricas Financieras
                        </h4>
                        <div class="space-y-3 pl-6">
                            <div class="flex justify-between items-center p-3 bg-background rounded border border-border hover:border-primary transition-colors">
                                <div>
                                    <p class="text-sm font-medium text-text">Mostrar P&L exacto</p>
                                    <p class="text-xs text-text-secondary">Desactiva para mostrar solo porcentajes</p>
                                </div>
                                <label class="privacy-switch">
                                    <input type="checkbox" id="privacy-show-exact-pl" checked>
                                    <span class="privacy-slider"></span>
                                </label>
                            </div>
                            <div class="flex justify-between items-center p-3 bg-background rounded border border-border hover:border-primary transition-colors">
                                <div>
                                    <p class="text-sm font-medium text-text">Mostrar mejor/peor trade</p>
                                    <p class="text-xs text-text-secondary">Estadísticas de extremos</p>
                                </div>
                                <label class="privacy-switch">
                                    <input type="checkbox" id="privacy-show-best-worst" checked>
                                    <span class="privacy-slider"></span>
                                </label>
                            </div>
                            <div class="flex justify-between items-center p-3 bg-background rounded border border-border hover:border-primary transition-colors">
                                <div>
                                    <p class="text-sm font-medium text-text">Mostrar trades individuales</p>
                                    <p class="text-xs text-text-secondary">Tabla de últimos trades</p>
                                </div>
                                <label class="privacy-switch">
                                    <input type="checkbox" id="privacy-show-trades-table" checked>
                                    <span class="privacy-slider"></span>
                                </label>
                            </div>
                        </div>
                    </div>

                    <!-- Gráficos -->
                    <div class="mb-6">
                        <h4 class="text-sm font-semibold text-text uppercase tracking-wider mb-4 flex items-center">
                            <i class="fas fa-chart-line mr-2 text-primary" style="font-size: 14px;"></i>
                            Gráficos
                        </h4>
                        <div class="space-y-3 pl-6">
                            <div class="flex justify-between items-center p-3 bg-background rounded border border-border hover:border-primary transition-colors">
                                <div>
                                    <p class="text-sm font-medium text-text">Curva de profit</p>
                                    <p class="text-xs text-text-secondary">Evolución del P&L acumulado</p>
                                </div>
                                <label class="privacy-switch">
                                    <input type="checkbox" id="privacy-show-profit-curve" checked>
                                    <span class="privacy-slider"></span>
                                </label>
                            </div>
                            <div class="flex justify-between items-center p-3 bg-background rounded border border-border hover:border-primary transition-colors">
                                <div>
                                    <p class="text-sm font-medium text-text">Curva de drawdown</p>
                                    <p class="text-xs text-text-secondary">Caídas del capital</p>
                                </div>
                                <label class="privacy-switch">
                                    <input type="checkbox" id="privacy-show-drawdown-curve" checked>
                                    <span class="privacy-slider"></span>
                                </label>
                            </div>
                            <div class="flex justify-between items-center p-3 bg-background rounded border border-border hover:border-primary transition-colors">
                                <div>
                                    <p class="text-sm font-medium text-text">Gráfico semanal</p>
                                    <p class="text-xs text-text-secondary">P&L por día de la semana</p>
                                </div>
                                <label class="privacy-switch">
                                    <input type="checkbox" id="privacy-show-weekly-chart" checked>
                                    <span class="privacy-slider"></span>
                                </label>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Footer -->
                <div class="flex justify-between items-center p-6 border-t border-border bg-surface-light">
                    <button id="audicion-privacy-reset-btn" class="px-4 py-2 text-sm text-text-secondary hover:text-text border border-border rounded hover:bg-surface transition-colors">
                        <i class="fas fa-undo mr-2"></i>Restablecer
                    </button>
                    <button id="audicion-privacy-save-btn" class="px-6 py-2 text-sm font-semibold bg-primary text-black rounded hover:bg-secondary transition-colors">
                        <i class="fas fa-check mr-2"></i>Guardar Cambios
                    </button>
                </div>
            </div>
        </div>

        <!-- Modal para Generar Link Público de Audición -->
        <div id="public-link-modal" class="public-link-modal">
            <div class="public-link-modal-content">
                <div class="public-link-modal-header">
                    <h3><i class="fas fa-share-alt mr-2"></i>Generar Link Público de Audición</h3>
                    <button class="close-modal-btn" id="close-public-link-modal">
                        <i class="fas fa-times"></i>
                    </button>
                </div>

                <div class="public-link-card">
                    <h4 class="text-sm font-semibold mb-3">Link Generado</h4>
                    <div class="public-link-input-group">
                        <input type="text" id="generated-public-link" class="public-link-input" readonly placeholder="El link se generará aquí...">
                        <button class="copy-link-btn" id="copy-public-link-btn">
                            <i class="fas fa-copy mr-1"></i>Copiar
                        </button>
                    </div>
                    <p class="text-xs text-text-secondary">
                        <i class="fas fa-info-circle mr-1"></i>Este link permite ver tu audición en modo de solo lectura
                    </p>
                </div>

                <div class="public-link-card">
                    <h4 class="text-sm font-semibold mb-3">Opciones de Compartir</h4>
                    <div class="audicion-options">
                        <div class="audicion-option-card">
                            <label>
                                <input type="checkbox" id="share-metrics" checked>
                                <span>Compartir métricas principales</span>
                            </label>
                        </div>
                        <div class="audicion-option-card">
                            <label>
                                <input type="checkbox" id="share-trades" checked>
                                <span>Compartir historial de trades</span>
                            </label>
                        </div>
                        <div class="audicion-option-card">
                            <label>
                                <input type="checkbox" id="share-charts">
                                <span>Compartir gráficos</span>
                            </label>
                        </div>
                        <div class="audicion-option-card">
                            <label>
                                <input type="checkbox" id="share-personal-info">
                                <span>Compartir información personal</span>
                            </label>
                        </div>
                    </div>
                </div>

                <div class="flex gap-3 justify-end mt-6">
                    <button class="secondary" id="cancel-public-link">Cancelar</button>
                    <button class="primary" id="generate-public-link-btn">
                        <i class="fas fa-link mr-2"></i>Generar Link
                    </button>
                </div>
            </div>
        </div>

        <!-- ========================================== -->
        <!--         SECCIÓN SOCIAL MEDIA             -->
        <!-- ========================================== -->
        <section id="social-media" class="section-container">
            <!-- Header -->
            <div class="flex flex-col md:flex-row justify-between items-start md:items-center gap-4 mb-6">
                <div>
                    <h2 class="text-2xl font-semibold mb-2">Social Media - Comunidad de Traders</h2>
                    <p class="text-text-secondary text-sm">Conecta con traders, comparte conocimiento y mejora en comunidad</p>
                </div>
                <div class="flex items-center gap-3">
                    <button id="social-media-timeframe-1m" class="text-xs px-3 py-1.5 bg-primary text-white rounded">
                        1m
                    </button>
                    <button id="social-media-timeframe-3m" class="text-xs px-3 py-1.5 bg-surface-light hover:bg-surface border border-border rounded">
                        3m
                    </button>
                    <button id="social-media-timeframe-1y" class="text-xs px-3 py-1.5 bg-surface-light hover:bg-surface border border-border rounded">
                        1y
                    </button>
                    <button id="social-media-timeframe-all" class="text-xs px-3 py-1.5 bg-surface-light hover:bg-surface border border-border rounded">
                        all
                    </button>
                </div>
            </div>

            <!-- Pestañas de Navegación -->
            <div class="nav-tabs flex mb-6 border-b border-border">
                <div id="social-tab-ranking" class="nav-tab social-tab active" data-tab="ranking">
                    <i class="fas fa-trophy mr-2"></i>Ranking
                </div>
                <div id="social-tab-following" class="nav-tab social-tab" data-tab="following">
                    <i class="fas fa-users mr-2"></i>Siguiendo
                </div>
                <div id="social-tab-groups" class="nav-tab social-tab" data-tab="groups">
                    <i class="fas fa-user-friends mr-2"></i>Grupos
                </div>
            </div>

            <!-- TAB: RANKING -->
            <div id="social-content-ranking" class="social-tab-content active">
                <!-- Tabla de clasificación -->
            <div class="metric-card p-0 overflow-hidden">
                <div class="p-6 bg-surface-light border-b border-border">
                    <h3 class="text-lg font-semibold mb-2">
                        Principales carteras
                        <i class="fas fa-trophy text-primary ml-2" style="font-size: 16px;"></i>
                    </h3>
                    <p class="text-sm text-text-secondary">
                        Rankings basados en rendimiento verificado
                        <span style="margin-left: 8px; color: #39ff14; font-size: 11px;">
                            • Haz clic en <strong>SEGUIR</strong> para conectar con traders
                        </span>
                    </p>
                </div>

                <div class="overflow-x-auto">
                    <table class="w-full" id="social-media-leaderboard">
                        <thead class="bg-surface-light">
                            <tr class="text-left text-xs text-text-secondary uppercase tracking-wider">
                                <th class="px-6 py-4 w-12 text-center">#</th>
                                <th class="px-6 py-4">Trader</th>
                                <th class="px-6 py-4 text-center">Beneficio</th>
                                <th class="px-6 py-4 text-center">% Ganancia</th>
                                <th class="px-6 py-4 text-center">Win Rate</th>
                                <th class="px-6 py-4 text-center">Trades</th>
                            </tr>
                        </thead>
                        <tbody id="social-media-tbody" class="divide-y divide-border">
                            <!-- Los traders se cargarán aquí dinámicamente -->
                            <tr>
                                <td colspan="6" class="px-6 py-12 text-center text-text-secondary">
                                    <i class="fas fa-users text-4xl mb-3 opacity-50"></i>
                                    <p class="text-lg">No hay traders públicos aún</p>
                                    <p class="text-sm mt-2">Sé el primero en compartir tu rendimiento activando el perfil público en Configuración</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Sidebar de clasificación -->
            <div class="mt-6 grid grid-cols-1 lg:grid-cols-3 gap-4">
                <div class="metric-card p-6">
                    <h3 class="text-lg font-semibold mb-4">
                        <i class="fas fa-table mr-2 text-primary"></i>
                        Tabla de clasificación
                    </h3>
                    <div class="space-y-4">
                        <div class="flex items-center justify-between">
                            <div class="flex items-center space-x-2">
                                <i class="fas fa-medal text-yellow-500"></i>
                                <span class="text-sm">Beneficio</span>
                            </div>
                            <span class="text-xs text-text-secondary">Total P&L Neto</span>
                        </div>
                        <div class="flex items-center justify-between">
                            <div class="flex items-center space-x-2">
                                <i class="fas fa-percentage text-green"></i>
                                <span class="text-sm">Ganancia promedio</span>
                            </div>
                            <span class="text-xs text-text-secondary">ROI %</span>
                        </div>
                        <div class="flex items-center justify-between">
                            <div class="flex items-center space-x-2">
                                <i class="fas fa-chart-line text-green-500"></i>
                                <span class="text-sm">Operaciones ganadoras</span>
                            </div>
                            <span class="text-xs text-text-secondary">Win Rate %</span>
                        </div>
                    </div>
                </div>

                <div class="metric-card p-6">
                    <h3 class="text-lg font-semibold mb-4">
                        <i class="fas fa-info-circle mr-2 text-accent"></i>
                        ¿Cómo funciona?
                    </h3>
                    <div class="space-y-3 text-sm text-text-secondary">
                        <p><i class="fas fa-check text-green-500 mr-2"></i>Vincula tus cuentas de trading</p>
                        <p><i class="fas fa-check text-green-500 mr-2"></i>Activa el perfil público en Configuración</p>
                        <p><i class="fas fa-check text-green-500 mr-2"></i>Tu rendimiento se verifica automáticamente</p>
                        <p><i class="fas fa-check text-green-500 mr-2"></i>Aparece en el ranking público</p>
                    </div>
                </div>

                <div class="metric-card p-6">
                    <h3 class="text-lg font-semibold mb-4">
                        <i class="fas fa-star mr-2 text-yellow-500"></i>
                        Iconos de estrellas
                    </h3>
                    <div class="space-y-3 text-sm">
                        <div class="flex items-center justify-between">
                            <div class="flex items-center space-x-2">
                                <i class="fas fa-star text-yellow-500"></i>
                                <span>Rentable el mes pasado</span>
                            </div>
                        </div>
                        <div class="flex items-center justify-between">
                            <div class="flex items-center space-x-2">
                                <i class="fas fa-star text-yellow-500"></i>
                                <i class="fas fa-star text-yellow-500"></i>
                                <span>Rentable últimos 3 meses</span>
                            </div>
                        </div>
                        <div class="flex items-center justify-between">
                            <div class="flex items-center space-x-2">
                                <i class="fas fa-star text-yellow-500"></i>
                                <i class="fas fa-star text-yellow-500"></i>
                                <i class="fas fa-star text-yellow-500"></i>
                                <span>Rentable todo el año</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            </div>
            <!-- FIN TAB: RANKING -->

            <!-- TAB: SIGUIENDO (FOLLOWING) -->
            <div id="social-content-following" class="social-tab-content" style="display: none;">
                <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                    <!-- Panel Izquierdo: Lista de Traders Seguidos -->
                    <div class="lg:col-span-1">
                        <div class="metric-card p-6">
                            <div class="flex items-center justify-between mb-4">
                                <h3 class="text-lg font-semibold">
                                    <i class="fas fa-user-check text-primary mr-2"></i>
                                    Siguiendo
                                </h3>
                                <span id="following-count" class="px-3 py-1 bg-primary text-background rounded-full text-sm font-bold">0</span>
                            </div>
                            
                            <div id="following-list" class="space-y-3 max-h-[600px] overflow-y-auto">
                                <!-- Traders seguidos se cargarán aquí -->
                                <div class="text-center py-12 text-text-secondary">
                                    <i class="fas fa-user-plus text-4xl mb-3 opacity-50"></i>
                                    <p class="text-sm">No sigues a ningún trader aún</p>
                                    <p class="text-xs mt-2">Ve al Ranking y sigue a traders interesantes</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Panel Derecho: Feed de Actividad -->
                    <div class="lg:col-span-2">
                        <div class="metric-card p-6">
                            <h3 class="text-lg font-semibold mb-4">
                                <i class="fas fa-stream text-primary mr-2"></i>
                                Feed de Actividad
                            </h3>

                            <div id="activity-feed" class="space-y-4 max-h-[600px] overflow-y-auto">
                                <!-- Feed de actividad se cargará aquí -->
                                <div class="text-center py-12 text-text-secondary">
                                    <i class="fas fa-chart-line text-4xl mb-3 opacity-50"></i>
                                    <p class="text-sm">No hay actividad reciente</p>
                                    <p class="text-xs mt-2">Los trades de traders que sigas aparecerán aquí</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <!-- FIN TAB: SIGUIENDO -->

            <!-- TAB: GRUPOS PRIVADOS -->
            <div id="social-content-groups" class="social-tab-content" style="display: none;">
                <div class="grid grid-cols-1 lg:grid-cols-4 gap-6">
                    <!-- Panel Izquierdo: Lista de Grupos -->
                    <div class="lg:col-span-1">
                        <div class="metric-card p-4">
                            <div class="flex items-center justify-between mb-4">
                                <h3 class="text-md font-semibold">Mis Grupos</h3>
                                <button id="create-group-btn" class="px-3 py-1.5 bg-primary text-background rounded-lg text-xs font-bold hover:bg-secondary transition-all">
                                    <i class="fas fa-folder-plus mr-1"></i>Crear
                                </button>
                            </div>

                            <div id="groups-list" class="space-y-2 max-h-[500px] overflow-y-auto">
                                <!-- Grupos se cargarán aquí -->
                                <div class="text-center py-8 text-text-secondary text-sm">
                                    <i class="fas fa-users text-3xl mb-2 opacity-50"></i>
                                    <p class="text-xs">No tienes grupos aún</p>
                                </div>
                            </div>
                        </div>

                        <!-- Buscar Grupos Públicos -->
                        <div class="metric-card p-4 mt-4">
                            <h3 class="text-md font-semibold mb-3">Buscar Grupos</h3>
                            <input 
                                type="text" 
                                id="search-groups-input" 
                                placeholder="Buscar grupos..." 
                                class="w-full px-3 py-2 bg-surface border border-border rounded-lg text-sm mb-3"
                            >
                            <div id="public-groups-list" class="space-y-2 max-h-[200px] overflow-y-auto">
                                <!-- Grupos públicos se cargarán aquí -->
                            </div>
                        </div>
                    </div>

                    <!-- Panel Principal: Chat del Grupo -->
                    <div class="lg:col-span-3">
                        <div id="no-group-selected" class="metric-card p-12 text-center text-text-secondary">
                            <i class="fas fa-comments text-6xl mb-4 opacity-30"></i>
                            <p class="text-lg">Selecciona un grupo para ver el chat</p>
                            <p class="text-sm mt-2">O crea uno nuevo para empezar a conversar</p>
                        </div>

                        <div id="group-chat-container" class="metric-card" style="display: none;">
                            <!-- Header del Grupo -->
                            <div class="p-4 border-b border-border bg-surface-light">
                                <div class="flex items-center justify-between">
                                    <div class="flex items-center gap-3">
                                        <div id="group-chat-avatar" class="w-12 h-12 bg-primary rounded-lg flex items-center justify-center text-xl font-bold">
                                            #
                                        </div>
                                        <div>
                                            <h3 id="group-chat-name" class="text-lg font-bold">Nombre del Grupo</h3>
                                            <p id="group-chat-members" class="text-xs text-text-secondary">0 miembros</p>
                                        </div>
                                    </div>
                                    <div class="flex items-center gap-2">
                                        <button id="group-invite-btn" class="px-3 py-2 bg-primary text-background rounded-lg text-xs font-bold hover:bg-secondary transition-all" title="Invitar miembros">
                                            <i class="fas fa-user-plus mr-1"></i>Invitar
                                        </button>
                                        <button id="group-info-btn" class="px-3 py-2 text-text-secondary hover:text-primary">
                                            <i class="fas fa-info-circle"></i>
                                        </button>
                                        <button id="group-settings-btn" class="px-3 py-2 text-text-secondary hover:text-primary">
                                            <i class="fas fa-cog"></i>
                                        </button>
                                    </div>
                                </div>
                            </div>

                            <!-- Área de Mensajes -->
                            <div id="group-messages-container" class="p-4 overflow-y-auto bg-background" style="height: 450px;">
                                <!-- Mensajes se cargarán aquí -->
                            </div>

                            <!-- Input de Mensaje -->
                            <div class="p-4 border-t border-border bg-surface-light">
                                <div class="flex items-end gap-3">
                                    <button id="attach-image-btn" class="px-3 py-2 text-text-secondary hover:text-primary transition-all">
                                        <i class="fas fa-image text-xl"></i>
                                    </button>
                                    <input 
                                        type="file" 
                                        id="group-image-input" 
                                        accept="image/*" 
                                        style="display: none;"
                                    >
                                    <div class="flex-1">
                                        <textarea 
                                            id="group-message-input" 
                                            placeholder="Escribe un mensaje..." 
                                            rows="1"
                                            class="w-full px-4 py-2 bg-surface border border-border rounded-lg resize-none focus:outline-none focus:border-primary"
                                            style="max-height: 120px;"
                                        ></textarea>
                                    </div>
                                    <button id="send-message-btn" class="px-4 py-2 bg-primary text-background rounded-lg font-bold hover:bg-secondary transition-all">
                                        <i class="fas fa-paper-plane mr-2"></i>Enviar
                                    </button>
                                </div>
                                <div id="image-preview-container" class="mt-3" style="display: none;">
                                    <div class="relative inline-block">
                                        <img id="image-preview" src="" alt="" class="max-h-32 rounded-lg">
                                        <button id="remove-image-preview" class="absolute -top-2 -right-2 w-6 h-6 bg-red text-white rounded-full flex items-center justify-center text-xs">
                                            <i class="fas fa-times"></i>
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <!-- FIN TAB: GRUPOS -->

            <!-- MODAL: INVITAR A GRUPO -->
            <div id="invite-group-modal" class="fixed inset-0 bg-black bg-opacity-75 z-50 hidden flex items-center justify-center">
                <div class="bg-[#0a0a0a] rounded-lg shadow-2xl w-full max-w-md mx-4" style="background-color: #0a0a0a !important;">
                    <div class="flex items-center justify-between p-6 border-b-2 border-primary">
                        <h3 class="text-xl font-bold text-primary">Invitar a <span id="invite-modal-group-name" class="text-primary"></span></h3>
                        <button id="close-invite-modal" class="text-2xl text-primary hover:text-white">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>

                    <div class="p-6 space-y-4 text-white">
                        <!-- Input de Email -->
                        <div>
                            <label class="block text-sm font-semibold mb-2 text-white">Email del usuario</label>
                            <div class="flex gap-2">
                                <input 
                                    type="email" 
                                    id="invite-email-input" 
                                    placeholder="usuario@email.com"
                                    class="flex-1 px-4 py-2 bg-background border border-border rounded-lg text-white"
                                >
                                <button id="send-invite-btn" class="px-4 py-2 bg-primary text-black rounded-lg font-bold hover:opacity-80 transition-all">
                                    Enviar
                                </button>
                            </div>
                            <p class="text-xs text-text-secondary mt-2">La invitación expirará en 7 días</p>
                        </div>

                        <!-- Invitaciones Pendientes -->
                        <div>
                            <h4 class="text-sm font-semibold mb-2 text-primary">Invitaciones Pendientes</h4>
                            <div id="pending-invites-list" class="space-y-2 max-h-48 overflow-y-auto">
                                <div class="text-center py-4 text-text-secondary text-xs">
                                    No hay invitaciones pendientes
                                </div>
                            </div>
                        </div>

                        <!-- Link de Invitación -->
                        <div id="invite-link-section" class="border-t-2 border-primary pt-4">
                            <h4 class="text-sm font-semibold mb-2 text-primary">Compartir invitación</h4>
                            
                            <!-- Link de invitación -->
                            <div class="flex gap-2 mb-3">
                                <input 
                                    type="text" 
                                    id="invite-link-input" 
                                    readonly
                                    class="flex-1 px-3 py-2 bg-background border border-border rounded-lg text-xs font-mono text-white"
                                >
                                <button id="copy-invite-link-btn" class="px-3 py-2 bg-primary text-black hover:opacity-80 border-2 border-primary rounded-lg text-xs transition-all" title="Copiar link">
                                    <i class="fas fa-copy"></i>
                                </button>
                            </div>

                            <!-- Botones de compartir -->
                            <div class="grid grid-cols-3 gap-2">
                                <button onclick="shareViaWhatsApp()" class="flex items-center justify-center gap-2 px-3 py-2 bg-[#25D366] hover:bg-[#1fb855] text-white rounded-lg text-xs font-semibold transition-all">
                                    <i class="fab fa-whatsapp text-base"></i>
                                    <span>WhatsApp</span>
                                </button>
                                <button onclick="shareViaTelegram()" class="flex items-center justify-center gap-2 px-3 py-2 bg-[#0088cc] hover:bg-[#0077b3] text-white rounded-lg text-xs font-semibold transition-all">
                                    <i class="fab fa-telegram text-base"></i>
                                    <span>Telegram</span>
                                </button>
                                <button onclick="shareViaDiscord()" class="flex items-center justify-center gap-2 px-3 py-2 bg-[#5865F2] hover:bg-[#4752c4] text-white rounded-lg text-xs font-semibold transition-all">
                                    <i class="fab fa-discord text-base"></i>
                                    <span>Discord</span>
                                </button>
                            </div>
                            
                            <p class="text-xs text-text-secondary mt-2 text-center">
                                <i class="fas fa-info-circle"></i> El link expira en 7 días
                            </p>
                        </div>
                    </div>
                </div>
            </div>
            <!-- FIN MODAL: INVITAR A GRUPO -->

            <!-- MODAL: CREAR GRUPO -->
            <div id="create-group-modal" class="fixed inset-0 bg-black bg-opacity-75 z-50 hidden flex items-center justify-center">
                <div class="bg-[#0a0a0a] rounded-lg shadow-2xl w-full max-w-md mx-4" style="background-color: #0a0a0a !important;">
                    <div class="flex items-center justify-between p-6 border-b-2 border-primary">
                        <h3 class="text-xl font-bold text-primary">Crear Nuevo Grupo</h3>
                        <button id="close-create-group-modal" class="text-2xl text-primary hover:text-white">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>

                    <div class="p-6 space-y-4 text-white">
                        <div>
                            <label class="block text-sm font-semibold mb-2 text-white">Nombre del Grupo</label>
                            <input 
                                type="text" 
                                id="new-group-name" 
                                placeholder="Ej: Traders de Futuros"
                                class="w-full px-4 py-2 bg-background border border-border rounded-lg text-white"
                                maxlength="50"
                            >
                        </div>

                        <div>
                            <label class="block text-sm font-semibold mb-2 text-white">Descripción</label>
                            <textarea 
                                id="new-group-description" 
                                placeholder="Describe de qué trata el grupo..."
                                rows="3"
                                class="w-full px-4 py-2 bg-background border border-border rounded-lg resize-none text-white"
                                maxlength="200"
                            ></textarea>
                        </div>

                        <div>
                            <label class="block text-sm font-semibold mb-2 text-white">Privacidad</label>
                            <select id="new-group-privacy" class="w-full px-4 py-2 bg-background border border-border rounded-lg text-white">
                                <option value="private">🔒 Privado - Solo por invitación</option>
                                <option value="public">🌍 Público - Cualquiera puede unirse</option>
                            </select>
                        </div>

                        <div>
                            <label class="block text-sm font-semibold mb-2 text-white">Emoji del Grupo</label>
                            <select id="new-group-emoji" class="w-full px-4 py-2 bg-background border border-border rounded-lg text-2xl text-white">
                                <option value="📊">📊 Gráficos</option>
                                <option value="💰">💰 Dinero</option>
                                <option value="🚀">🚀 Cohete</option>
                                <option value="📈">📈 Tendencia</option>
                                <option value="💎">💎 Diamante</option>
                                <option value="🎯">🎯 Diana</option>
                                <option value="⚡">⚡ Rayo</option>
                                <option value="🔥">🔥 Fuego</option>
                            </select>
                        </div>
                    </div>

                    <div class="flex justify-end gap-3 p-6 border-t-2 border-primary">
                        <button id="cancel-create-group" class="px-4 py-2 border-2 border-border rounded-lg hover:bg-surface-light transition-all text-white">
                            Cancelar
                        </button>
                        <button id="confirm-create-group" class="px-4 py-2 bg-primary text-black rounded-lg font-bold hover:opacity-80 transition-all">
                            <i class="fas fa-users mr-2"></i>Crear Grupo
                        </button>
                    </div>
                </div>
            </div>

            <!-- MODAL: INFO DEL GRUPO -->
            <div id="group-info-modal" class="fixed inset-0 bg-black bg-opacity-75 z-50 hidden flex items-center justify-center">
                <div class="bg-[#0a0a0a] rounded-lg shadow-2xl w-full max-w-lg mx-4 max-h-[90vh] overflow-y-auto" style="background-color: #0a0a0a !important;">
                    <div class="flex items-center justify-between p-6 border-b-2 border-primary">
                        <h3 class="text-xl font-bold text-primary">Información del Grupo</h3>
                        <button id="close-group-info-modal" class="text-2xl text-primary hover:text-white">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>

                    <div class="p-6 space-y-6 text-white">
                        <!-- Info básica -->
                        <div class="text-center">
                            <div id="group-info-emoji" class="text-6xl mb-3">📊</div>
                            <h4 id="group-info-name" class="text-2xl font-bold mb-2 text-primary">Nombre del Grupo</h4>
                            <p id="group-info-description" class="text-text-secondary">Descripción del grupo</p>
                        </div>

                        <!-- Miembros -->
                        <div class="border-t-2 border-primary pt-4">
                            <h5 class="text-lg font-semibold mb-3 text-primary">
                                <i class="fas fa-users mr-2"></i>
                                Miembros (<span id="group-info-members-count">0</span>)
                            </h5>
                            <div id="group-members-list" class="space-y-2 max-h-64 overflow-y-auto">
                                <!-- Lista de miembros -->
                            </div>
                        </div>

                        <!-- Invitar miembros -->
                        <div class="border-t-2 border-primary pt-4">
                            <h5 class="text-lg font-semibold mb-3 text-primary">
                                <i class="fas fa-user-plus mr-2"></i>
                                Invitar Traders
                            </h5>
                            <input 
                                type="text" 
                                id="search-traders-to-invite" 
                                placeholder="Buscar trader..."
                                class="w-full px-4 py-2 bg-background border border-border rounded-lg mb-3 text-white"
                            >
                            <div id="traders-invite-list" class="space-y-2 max-h-48 overflow-y-auto">
                                <!-- Lista de traders para invitar -->
                            </div>
                        </div>
                    </div>

                    <div class="flex justify-end gap-3 p-6 border-t-2 border-primary">
                        <button id="leave-group-btn" class="px-4 py-2 border-2 border-red text-red rounded-lg hover:bg-red hover:text-white transition-all">
                            <i class="fas fa-sign-out-alt mr-2"></i>Salir del Grupo
                        </button>
                    </div>
                </div>
            </div>

            <!-- MODAL: CONFIGURACIÓN DE GRUPO -->
            <div id="group-settings-modal" class="fixed inset-0 bg-black bg-opacity-75 z-50 hidden flex items-center justify-center">
                <div class="bg-[#0a0a0a] rounded-lg shadow-2xl w-full max-w-2xl mx-4 max-h-[90vh] overflow-y-auto" style="background-color: #0a0a0a !important;">
                    <div class="flex items-center justify-between p-6 border-b-2 border-primary">
                        <h3 class="text-xl font-bold text-primary">
                            <i class="fas fa-cog mr-2"></i>Configuración del Grupo
                        </h3>
                        <button id="close-group-settings-modal" class="text-2xl text-primary hover:text-white">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>

                    <div class="p-6 space-y-6 text-white">
                        <!-- Invitar desde Ranking -->
                        <div class="border-2 border-primary rounded-lg p-4">
                            <h5 class="text-lg font-semibold mb-3 text-primary">
                                <i class="fas fa-user-plus mr-2"></i>
                                Invitar Trader desde Ranking
                            </h5>
                            <p class="text-sm text-text-secondary mb-3">Busca traders del ranking público por su nombre de usuario</p>
                            
                            <div class="flex gap-2 mb-3">
                                <input 
                                    type="text" 
                                    id="search-ranking-username" 
                                    placeholder="Ej: @daniel.hdz, daniel, etc..."
                                    class="flex-1 px-4 py-2 bg-background border border-border rounded-lg text-white"
                                >
                                <button id="search-ranking-btn" class="px-4 py-2 bg-primary text-background rounded-lg font-bold hover:bg-secondary transition-all">
                                    <i class="fas fa-search"></i>
                                </button>
                            </div>

                            <!-- Resultados de búsqueda -->
                            <div id="ranking-search-results" class="space-y-2 max-h-64 overflow-y-auto">
                                <div class="text-center py-4 text-text-secondary text-sm">
                                    <i class="fas fa-search text-2xl mb-2 opacity-50"></i>
                                    <p>Busca traders del ranking para invitar</p>
                                </div>
                            </div>
                        </div>

                        <!-- Zona de Peligro -->
                        <div class="border-2 border-red rounded-lg p-4 bg-red bg-opacity-10">
                            <h5 class="text-lg font-semibold mb-3 text-red">
                                <i class="fas fa-exclamation-triangle mr-2"></i>
                                Zona de Peligro
                            </h5>
                            <p class="text-sm text-text-secondary mb-3">Esta acción es irreversible. Solo los administradores pueden borrar el grupo.</p>
                            
                            <button id="delete-group-btn" class="px-4 py-2 bg-red text-white rounded-lg font-bold hover:opacity-80 transition-all disabled:opacity-50 disabled:cursor-not-allowed">
                                <i class="fas fa-trash-alt mr-2"></i>Borrar Grupo Permanentemente
                            </button>
                            
                            <p id="delete-group-admin-notice" class="text-xs text-text-secondary mt-2" style="display: none;">
                                <i class="fas fa-info-circle mr-1"></i>Solo el administrador puede borrar el grupo
                            </p>
                        </div>
                    </div>

                    <div class="flex justify-end gap-3 p-6 border-t-2 border-primary">
                        <button id="close-settings-modal-btn" class="px-4 py-2 border-2 border-border rounded-lg hover:bg-surface-light transition-all text-white">
                            Cerrar
                        </button>
                    </div>
                </div>
            </div>

        </section>

        <section id="finances" class="section-container">
            <div class="flex flex-wrap justify-between items-center mb-6">
                <h2 class="text-xl font-semibold">Finanzas Manuales (Ingresos/Gastos)</h2>
                <div class="flex items-center space-x-2">
                    <button id="add-finance-entry-btn" class="primary"><i class="fas fa-plus mr-2"></i>Añadir Movimiento</button>
                    <button id="toggle-hide-amounts-finances" class="p-2 rounded border" title="Ocultar importes (stream)" aria-pressed="false" style="display:inline-flex;align-items:center;justify-content:center;">
                        <i id="toggle-hide-amounts-finances-icon" class="fas fa-eye-slash" aria-hidden="true" style="width:16px; height:16px;"></i>
                        <span class="sr-only">Ocultar importes</span>
                    </button>
                </div>
            </div>

            <!-- Pestañas de navegación -->
            <div class="nav-tabs flex mb-6">
                <div id="finances-tab-dashboard" class="nav-tab finances-tab active">Dashboard</div>
                <div id="finances-tab-capital-propio" class="nav-tab finances-tab">Capital Propio</div>
                <div id="finances-tab-funded" class="nav-tab finances-tab">Funded</div>
                <div id="finances-tab-movements" class="nav-tab finances-tab">Movimientos</div>
                <div id="finances-tab-calendar" class="nav-tab finances-tab">Calendario</div>
                <div id="finances-tab-trackerbank" class="nav-tab finances-tab">TrackerBank</div>
            </div>
            <div id="add-finance-entry-form" class="metric-card mb-6" style="display: none;">
                <h3 class="text-lg font-semibold mb-4">Nuevo Movimiento Financiero</h3>
                <form id="finance-entry-details-form">
                    <div class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-4">
                        <div>
                            <label class="block mb-1">Fecha</label>
                            <input type="date" id="finance-date" class="w-full">
                        </div>
                        <div>
                            <label class="block mb-1">Monto (+/-)</label>
                            <input type="number" id="finance-amount" step="any" placeholder="Ej: 500 o -150" class="w-full">
                        </div>
                        <div>
                            <label class="block mb-1">Divisa</label>
                            <select id="finance-currency" class="w-full">
                                <option value="USD">USD</option>
                                <option value="EUR">EUR</option>
                                <option value="USDT">USDT</option>
                            </select>
                        </div>
                        <div>
                            <label class="block mb-1">Tipo de Cuenta</label>
                            <select id="finance-account-type" class="w-full">
                                <option value="capital-propio">Capital Propio</option>
                                <option value="funded">Cuenta Funded</option>
                                <option value="personal">Cuenta Personal</option>
                            </select>
                        </div>
                        <div>
                            <label class="block mb-1">Tipo de Movimiento</label>
                            <select id="finance-movement-type" class="w-full">
                                <option value="gasto">💸 Gasto</option>
                                <option value="retiro">🏦 Retiro a Cuenta Corriente</option>
                                <option value="ingreso">💰 Ingreso</option>
                            </select>
                        </div>
                        <div id="finance-bank-container" style="display: none;">
                            <label class="block mb-1">Banco Destino</label>
                            <select id="finance-bank" class="w-full">
                                <option value="revolut">🟣 Revolut</option>
                                <option value="wise">🟢 Wise</option>
                            </select>
                        </div>
                        <div id="finance-category-container" style="display: none;">
                            <label class="block mb-1">Categoría de Gasto</label>
                            <select id="finance-category" class="w-full">
                                <option value="plataforma">📊 Plataforma</option>
                                <option value="educacion">📚 Educación</option>
                                <option value="herramientas">🛠️ Herramientas</option>
                                <option value="servicios">💻 Servicios</option>
                                <option value="otros">📎 Otros</option>
                            </select>
                        </div>
                    </div>
                    
                    <!-- Descripción Simple -->
                    <div class="mb-4">
                        <label class="block mb-1">Descripción Corta</label>
                        <input type="text" id="finance-description" placeholder="Ej: TradingView Pro, Curso Forex Avanzado, VPS Mensual..." class="w-full">
                    </div>
                    
                    <!-- Descripción / Notas Avanzadas -->
                    <div class="mb-4">
                        <div class="flex items-center justify-between mb-2">
                            <label class="block">Descripción / Notas</label>
                            <button type="button" id="edit-finance-notes-btn" class="text-sm px-3 py-1 border border-border rounded hover:border-primary transition-all">
                                <i class="fas fa-edit mr-1"></i>Editor Avanzado
                            </button>
                        </div>
                        <div id="finance-notes-display" class="w-full min-h-[100px] p-3 bg-surface-light border border-border rounded-lg text-sm">
                            <p class="text-text-secondary italic">Sin descripción. Usa el editor avanzado para añadir notas detalladas.</p>
                        </div>
                        <input type="hidden" id="finance-notes-hidden" value="">
                    </div>
                    
                    <div class="flex justify-end gap-2">
                        <button type="button" id="finance-cancel-btn" class="px-4 py-2 border border-border rounded hover:bg-surface-light">Cancelar</button>
                        <button type="button" id="finance-save-btn" class="primary px-4 py-2">Guardar</button>
                    </div>
                </form>
            </div>

            <!-- Modal de Editor de Notas para Finanzas -->
            <div id="finance-notes-editor-modal" class="fixed inset-0 bg-black bg-opacity-75 z-50 hidden flex items-center justify-center">
                <div class="bg-surface rounded-lg shadow-2xl flex flex-col max-w-5xl w-full mx-4 max-h-[90vh]">
                    <!-- Header -->
                    <div class="flex items-center justify-between p-4 border-b border-border">
                        <h3 class="text-xl font-bold">Descripción / Notas del Movimiento</h3>
                        <button id="close-finance-editor-btn" class="text-2xl text-text-secondary hover:text-text">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>

                    <!-- Toolbar -->
                    <div class="flex flex-wrap items-center gap-1 p-3 border-b border-border bg-surface-light overflow-x-auto">
                        <button onclick="formatFinanceText('bold')" class="p-2 hover:bg-surface rounded" title="Negrita">
                            <i class="fas fa-bold"></i>
                        </button>
                        <button onclick="formatFinanceText('italic')" class="p-2 hover:bg-surface rounded" title="Cursiva">
                            <i class="fas fa-italic"></i>
                        </button>
                        <button onclick="formatFinanceText('underline')" class="p-2 hover:bg-surface rounded" title="Subrayado">
                            <i class="fas fa-underline"></i>
                        </button>
                        <button onclick="formatFinanceText('strikeThrough')" class="p-2 hover:bg-surface rounded" title="Tachado">
                            <i class="fas fa-strikethrough"></i>
                        </button>
                        
                        <div class="w-px h-6 bg-border mx-1"></div>

                        <button onclick="formatFinanceText('justifyLeft')" class="p-2 hover:bg-surface rounded" title="Alinear izquierda">
                            <i class="fas fa-align-left"></i>
                        </button>
                        <button onclick="formatFinanceText('justifyCenter')" class="p-2 hover:bg-surface rounded" title="Centrar">
                            <i class="fas fa-align-center"></i>
                        </button>
                        <button onclick="formatFinanceText('justifyRight')" class="p-2 hover:bg-surface rounded" title="Alinear derecha">
                            <i class="fas fa-align-right"></i>
                        </button>

                        <div class="w-px h-6 bg-border mx-1"></div>

                        <button onclick="formatFinanceText('insertUnorderedList')" class="p-2 hover:bg-surface rounded" title="Lista">
                            <i class="fas fa-list-ul"></i>
                        </button>
                        <button onclick="formatFinanceText('insertOrderedList')" class="p-2 hover:bg-surface rounded" title="Lista numerada">
                            <i class="fas fa-list-ol"></i>
                        </button>

                        <div class="w-px h-6 bg-border mx-1"></div>

                        <select id="finance-format-block" onchange="formatFinanceText('formatBlock', this.value); this.selectedIndex=0;" class="px-2 py-1 bg-surface border border-border rounded text-sm">
                            <option value="" selected>Normal</option>
                            <option value="h1">Título 1</option>
                            <option value="h2">Título 2</option>
                            <option value="h3">Título 3</option>
                            <option value="p">Párrafo</option>
                        </select>

                        <div class="w-px h-6 bg-border mx-1"></div>

                        <input type="color" id="finance-text-color" onchange="formatFinanceText('foreColor', this.value)" class="w-8 h-8 rounded cursor-pointer" value="#ffffff" title="Color de texto">
                        <input type="color" id="finance-bg-color" onchange="formatFinanceText('hiliteColor', this.value)" class="w-8 h-8 rounded cursor-pointer" value="#ffeb3b" title="Color de fondo">

                        <div class="w-px h-6 bg-border mx-1"></div>

                        <button onclick="insertFinanceLink()" class="p-2 hover:bg-surface rounded" title="Insertar enlace">
                            <i class="fas fa-link"></i>
                        </button>
                        <button onclick="formatFinanceText('removeFormat')" class="p-2 hover:bg-surface rounded text-red" title="Limpiar formato">
                            <i class="fas fa-eraser"></i>
                        </button>
                    </div>

                    <!-- Área de Edición -->
                    <div class="overflow-y-auto p-4" style="max-height: 500px;">
                        <div 
                            id="finance-notes-editor" 
                            contenteditable="true"
                            class="w-full min-h-[300px] p-4 bg-background border border-border rounded-lg focus:border-primary focus:outline-none text-base"
                            placeholder="Escribe la descripción y notas del movimiento financiero..."
                        ></div>
                    </div>

                    <!-- Footer -->
                    <div class="flex items-center justify-between p-4 border-t border-border gap-4">
                        <div class="flex items-center gap-2">
                            <button id="finance-voice-note-btn" class="flex items-center gap-2 px-4 py-2 bg-surface-light border border-border rounded hover:border-primary transition-all">
                                <i class="fas fa-microphone"></i>
                                <span>Nota de Voz</span>
                            </button>
                        </div>

                        <div class="flex items-center gap-2">
                            <span class="text-xs text-text-secondary" id="finance-editor-char-count">0 caracteres</span>
                            <button id="finance-editor-cancel-btn" class="px-4 py-2 border border-border rounded hover:bg-surface-light transition-all">
                                Cancelar
                            </button>
                            <button id="finance-editor-save-btn" class="primary px-4 py-2">
                                <i class="fas fa-check mr-2"></i>Aplicar
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- ====== CONTENIDO DE DASHBOARD PRINCIPAL ====== -->
            <div id="finances-view-dashboard">
                <div class="flex flex-wrap justify-between items-start mb-6 gap-4">
                    <div>
                        <h3 class="text-2xl font-bold mb-2">Dashboard Financiero Principal</h3>
                        <p class="text-sm text-text-secondary">Visión general de Capital Propio y Cuentas Funded</p>
                    </div>
                    <div class="flex items-center space-x-2">
                        <button id="finances-dashboard-date-filter-btn" class="date-filter-trigger p-2 bg-surface rounded" title="Filtrar por fecha">
                            <i class="fas fa-calendar-alt"></i>
                        </button>
                        <div id="finances-dashboard-date-filter-display" class="date-filter-display-text text-sm text-text-secondary">Sin filtro de fecha</div>
                    </div>
                </div>

                <!-- Métricas Principales -->
                <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-5 gap-4 mb-6">
                    <div class="metric-card text-center p-4">
                        <h4 class="text-sm text-text-secondary">Balance Total</h4>
                        <p id="dashboard-total-balance" class="text-2xl font-bold text-white hide-amount">$0.00</p>
                        <p class="text-xs text-text-secondary mt-1">Capital + Funded</p>
                    </div>
                    <div class="metric-card text-center p-4">
                        <h4 class="text-sm text-text-secondary">Capital Propio</h4>
                        <p id="dashboard-capital-balance" class="text-2xl font-bold text-green hide-amount">$0.00</p>
                        <p class="text-xs text-text-secondary mt-1">Balance neto</p>
                    </div>
                    <div class="metric-card text-center p-4">
                        <h4 class="text-sm text-text-secondary">Funded Total</h4>
                        <p id="dashboard-funded-balance" class="text-2xl font-bold text-primary hide-amount">$0.00</p>
                        <p class="text-xs text-text-secondary mt-1">Balance neto</p>
                    </div>
                    <div class="metric-card text-center p-4">
                        <h4 class="text-sm text-text-secondary">Ingresos Totales</h4>
                        <p id="dashboard-total-income" class="text-2xl font-bold text-green hide-amount">$0.00</p>
                        <p class="text-xs text-text-secondary mt-1">Este período</p>
                    </div>
                    <div class="metric-card text-center p-4">
                        <h4 class="text-sm text-text-secondary">Gastos Totales</h4>
                        <p id="dashboard-total-expenses" class="text-2xl font-bold text-red hide-amount">$0.00</p>
                        <p class="text-xs text-text-secondary mt-1">Este período</p>
                    </div>
                </div>

                <!-- Gráficos de Donut y Barras -->
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                    <!-- Distribución de Capital (Donut) -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-2">Distribución de Capital</h3>
                        <p class="text-xs text-text-secondary mb-3">Capital Propio vs Funded</p>
                        <div class="chart-container" style="height: 350px;">
                            <canvas id="dashboard-capital-distribution-chart"></canvas>
                        </div>
                    </div>

                    <!-- Distribución de Ganancias (Donut) -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-2">Distribución de Ganancias</h3>
                        <p class="text-xs text-text-secondary mb-3">Ingresos por tipo de cuenta</p>
                        <div class="chart-container" style="height: 350px;">
                            <canvas id="dashboard-income-distribution-chart"></canvas>
                        </div>
                    </div>
                </div>

                <!-- Gráficos de Barras Verticales -->
                <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-6">
                    <!-- Top 3 Fuentes de Ingreso -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-2">Top 3 Fuentes de Ingreso</h3>
                        <p class="text-xs text-text-secondary mb-3">Mayores ingresos del período</p>
                        <div class="chart-container" style="height: 300px;">
                            <canvas id="dashboard-top3-income-chart"></canvas>
                        </div>
                    </div>

                    <!-- Comparativa Mensual (5 meses) -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-2">Evolución Últimos 5 Meses</h3>
                        <p class="text-xs text-text-secondary mb-3">Balance neto mensual</p>
                        <div class="chart-container" style="height: 300px;">
                            <canvas id="dashboard-monthly-evolution-chart"></canvas>
                        </div>
                    </div>

                    <!-- Capital Propio vs Funded (Comparativa) -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-2">Capital vs Funded</h3>
                        <p class="text-xs text-text-secondary mb-3">Comparativa de rendimiento</p>
                        <div class="chart-container" style="height: 300px;">
                            <canvas id="dashboard-capital-vs-funded-chart"></canvas>
                        </div>
                    </div>
                </div>

                <!-- Evolución Total del Balance -->
                <div class="metric-card mb-6">
                    <div class="flex items-center justify-between mb-4">
                        <h3 class="text-lg font-semibold">Evolución del Balance Total</h3>
                        <button id="dashboard-expand-evolution-btn" class="text-sm px-3 py-1 border border-border rounded hover:border-primary transition-all">
                            <i class="fas fa-expand mr-2"></i>Ver en Pantalla Completa
                        </button>
                    </div>
                    <div class="chart-container" style="height: 400px;">
                        <canvas id="dashboard-total-evolution-chart"></canvas>
                    </div>
                </div>
            </div>
            <!-- Fin de Dashboard -->

            <!-- ====== CONTENIDO DE CAPITAL PROPIO ====== -->
            <div id="finances-view-capital-propio" class="hidden">
                <div class="flex flex-wrap justify-between items-start mb-6 gap-4">
                    <div>
                        <h3 class="text-2xl font-bold mb-2">Capital Propio</h3>
                        <p class="text-sm text-text-secondary">Gestión y análisis de cuentas propias</p>
                    </div>
                    <div class="flex items-center space-x-2">
                        <!-- Selector de Cuenta -->
                        <div class="relative flex items-center gap-2">
                            <div id="capital-propio-account-logo" class="w-14 h-14 rounded-xl flex items-center justify-center" style="display: none;">
                                <img id="capital-propio-account-logo-img" src="" alt="" class="w-14 h-14 rounded-xl object-contain">
                            </div>
                            <div class="relative">
                                <select id="capital-propio-account-select" class="account-select-with-logo" style="padding: 10px 15px; border-radius: 8px; background: var(--surface); border: 1px solid var(--border); color: var(--text); font-size: 14px; font-weight: 600; cursor: pointer; appearance: none; min-width: 200px;">
                                    <option value="all">Todas las cuentas</option>
                                </select>
                                <i class="fas fa-chevron-down" style="position: absolute; right: 15px; top: 50%; transform: translateY(-50%); pointer-events: none; color: var(--text-secondary); font-size: 12px;"></i>
                            </div>
                        </div>
                        <button id="capital-date-filter-btn" class="date-filter-trigger p-2 bg-surface rounded" title="Filtrar por fecha">
                            <i class="fas fa-calendar-alt"></i>
                        </button>
                        <div id="capital-date-filter-display" class="date-filter-display-text text-sm text-text-secondary">Sin filtro de fecha</div>
                    </div>
                </div>

                <!-- Métricas de Capital Propio -->
                <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-5 gap-4 mb-6">
                    <div class="metric-card text-center p-4">
                        <h4 class="text-sm text-text-secondary">Balance Total</h4>
                        <p id="capital-total-balance" class="text-2xl font-bold text-white hide-amount">$0.00</p>
                    </div>
                    <div class="metric-card text-center p-4">
                        <h4 class="text-sm text-text-secondary">Ganancias</h4>
                        <p id="capital-total-profit" class="text-2xl font-bold text-green hide-amount">$0.00</p>
                    </div>
                    <div class="metric-card text-center p-4">
                        <h4 class="text-sm text-text-secondary">Gastos</h4>
                        <p id="capital-total-expenses" class="text-2xl font-bold text-red hide-amount">$0.00</p>
                    </div>
                    <div class="metric-card text-center p-4">
                        <h4 class="text-sm text-text-secondary">ROI</h4>
                        <p id="capital-roi" class="text-2xl font-bold text-primary">0%</p>
                    </div>
                    <div class="metric-card text-center p-4">
                        <h4 class="text-sm text-text-secondary">Crecimiento</h4>
                        <p id="capital-growth" class="text-2xl font-bold text-green">0%</p>
                    </div>
                </div>

                <!-- Gráficos de Capital Propio -->
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                    <!-- Evolución del Capital -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-2">Evolución del Capital</h3>
                        <p class="text-xs text-text-secondary mb-3">Crecimiento en el tiempo</p>
                        <div class="chart-container" style="height: 350px;">
                            <canvas id="capital-evolution-chart"></canvas>
                        </div>
                    </div>

                    <!-- Distribución de Ingresos/Gastos (Donut) -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-2">Ingresos vs Gastos</h3>
                        <p class="text-xs text-text-secondary mb-3">Distribución del capital propio</p>
                        <div class="chart-container" style="height: 350px;">
                            <canvas id="capital-income-expenses-donut"></canvas>
                        </div>
                    </div>
                </div>

                <!-- Tabla de Cuentas de Capital Propio -->
                <div class="metric-card mb-6">
                    <div class="flex items-center justify-between mb-4">
                        <div>
                            <h3 class="text-lg font-semibold">Cuentas de Capital Propio</h3>
                            <p class="text-xs text-text-secondary mt-1">Detalle de cada cuenta personal (<span id="capital-accounts-count">0</span> cuentas)</p>
                        </div>
                    </div>
                    <div class="overflow-x-auto">
                        <table id="capital-accounts-table" class="w-full">
                            <thead>
                                <tr>
                                    <th class="text-left">Cuenta</th>
                                    <th class="text-right">Balance Inicial</th>
                                    <th class="text-right">Balance Actual</th>
                                    <th class="text-right">P/L Neto</th>
                                    <th class="text-center">Operaciones (W/L)</th>
                                    <th class="text-right">ROI</th>
                                    <th class="text-center">Divisa</th>
                                    <th class="text-center">Estado</th>
                                </tr>
                            </thead>
                            <tbody id="capital-accounts-tbody"></tbody>
                        </table>
                    </div>
                </div>

                <!-- Más Gráficos -->
                <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-6">
                    <!-- Rendimiento Mensual -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-2">Rendimiento Mensual</h3>
                        <p class="text-xs text-text-secondary mb-3">Últimos 5 meses</p>
                        <div class="chart-container" style="height: 300px;">
                            <canvas id="capital-monthly-performance-chart"></canvas>
                        </div>
                    </div>

                    <!-- Top 3 Movimientos -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-2">Top 3 Movimientos</h3>
                        <p class="text-xs text-text-secondary mb-3">Mayores transacciones</p>
                        <div class="chart-container" style="height: 300px;">
                            <canvas id="capital-top3-movements-chart"></canvas>
                        </div>
                    </div>

                    <!-- Tendencia Semanal -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-2">Tendencia Semanal</h3>
                        <p class="text-xs text-text-secondary mb-3">Últimas 5 semanas</p>
                        <div class="chart-container" style="height: 300px;">
                            <canvas id="capital-weekly-trend-chart"></canvas>
                        </div>
                    </div>
                </div>

                <!-- Análisis por Períodos -->
                <div class="metric-card mb-6">
                    <h3 class="text-lg font-semibold mb-4">Análisis por Períodos</h3>
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                        <!-- Análisis Mensual -->
                        <div class="p-4 bg-surface-light rounded-lg border border-border">
                            <h4 class="text-sm font-semibold mb-3 text-primary">📅 Mes Actual</h4>
                            <div class="space-y-2">
                                <div class="flex justify-between">
                                    <span class="text-sm text-text-secondary">Balance Neto:</span>
                                    <span id="capital-monthly-balance" class="text-sm font-bold hide-amount">$0.00</span>
                                </div>
                                <div class="flex justify-between">
                                    <span class="text-sm text-text-secondary">P/L:</span>
                                    <span id="capital-monthly-pl" class="text-sm font-bold hide-amount">$0.00</span>
                                </div>
                                <div class="flex justify-between">
                                    <span class="text-sm text-text-secondary">Operaciones:</span>
                                    <span id="capital-monthly-trades" class="text-sm font-bold">0</span>
                                </div>
                                <div class="flex justify-between">
                                    <span class="text-sm text-text-secondary">ROI Mensual:</span>
                                    <span id="capital-monthly-roi" class="text-sm font-bold">0%</span>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Análisis Trimestral -->
                        <div class="p-4 bg-surface-light rounded-lg border border-border">
                            <h4 class="text-sm font-semibold mb-3 text-primary">📊 Trimestre Actual</h4>
                            <div class="space-y-2">
                                <div class="flex justify-between">
                                    <span class="text-sm text-text-secondary">Balance Neto:</span>
                                    <span id="capital-quarterly-balance" class="text-sm font-bold hide-amount">$0.00</span>
                                </div>
                                <div class="flex justify-between">
                                    <span class="text-sm text-text-secondary">P/L:</span>
                                    <span id="capital-quarterly-pl" class="text-sm font-bold hide-amount">$0.00</span>
                                </div>
                                <div class="flex justify-between">
                                    <span class="text-sm text-text-secondary">Operaciones:</span>
                                    <span id="capital-quarterly-trades" class="text-sm font-bold">0</span>
                                </div>
                                <div class="flex justify-between">
                                    <span class="text-sm text-text-secondary">ROI Trimestral:</span>
                                    <span id="capital-quarterly-roi" class="text-sm font-bold">0%</span>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Análisis Anual -->
                        <div class="p-4 bg-surface-light rounded-lg border border-border">
                            <h4 class="text-sm font-semibold mb-3 text-primary">📈 Año Actual</h4>
                            <div class="space-y-2">
                                <div class="flex justify-between">
                                    <span class="text-sm text-text-secondary">Balance Neto:</span>
                                    <span id="capital-yearly-balance" class="text-sm font-bold hide-amount">$0.00</span>
                                </div>
                                <div class="flex justify-between">
                                    <span class="text-sm text-text-secondary">P/L:</span>
                                    <span id="capital-yearly-pl" class="text-sm font-bold hide-amount">$0.00</span>
                                </div>
                                <div class="flex justify-between">
                                    <span class="text-sm text-text-secondary">Operaciones:</span>
                                    <span id="capital-yearly-trades" class="text-sm font-bold">0</span>
                                </div>
                                <div class="flex justify-between">
                                    <span class="text-sm text-text-secondary">ROI Anual:</span>
                                    <span id="capital-yearly-roi" class="text-sm font-bold">0%</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Tabla de Movimientos de Capital Propio -->
                <div class="metric-card mb-6">
                    <h3 class="text-lg font-semibold mb-4">Movimientos de Capital Propio</h3>
                    <div class="overflow-x-auto">
                        <table id="capital-movements-table" class="w-full">
                            <thead>
                                <tr>
                                    <th class="text-left">Fecha</th>
                                    <th class="text-left">Descripción</th>
                                    <th class="text-right">Monto</th>
                                    <th class="text-center">Divisa</th>
                                </tr>
                            </thead>
                            <tbody id="capital-movements-tbody"></tbody>
                        </table>
                    </div>
                </div>
            </div>
            <!-- Fin de Capital Propio -->

            <!-- ====== CONTENIDO DE FUNDED ====== -->
            <div id="finances-view-funded" class="hidden">
                <div class="flex flex-wrap justify-between items-start mb-6 gap-4">
                    <div>
                        <h3 class="text-2xl font-bold mb-2">Cuentas Funded</h3>
                        <p class="text-sm text-text-secondary">Gestión operativa de cuentas de fondeo</p>
                    </div>
                    <div class="flex items-center space-x-2">
                        <!-- Selector de Cuenta Funded -->
                        <div class="relative flex items-center gap-2">
                            <div id="funded-account-logo" class="w-14 h-14 rounded-xl flex items-center justify-center" style="display: none;">
                                <img id="funded-account-logo-img" src="" alt="" class="w-14 h-14 rounded-xl object-contain">
                            </div>
                            <div class="relative">
                                <select id="funded-account-select" class="account-select-with-logo" style="padding: 10px 15px; border-radius: 8px; background: var(--surface); border: 1px solid var(--border); color: var(--text); font-size: 14px; font-weight: 600; cursor: pointer; appearance: none; min-width: 200px;">
                                    <option value="all">Todas las cuentas</option>
                                </select>
                                <i class="fas fa-chevron-down" style="position: absolute; right: 15px; top: 50%; transform: translateY(-50%); pointer-events: none; color: var(--text-secondary); font-size: 12px;"></i>
                            </div>
                        </div>
                        <button id="funded-date-filter-btn" class="date-filter-trigger p-2 bg-surface rounded" title="Filtrar por fecha">
                            <i class="fas fa-calendar-alt"></i>
                        </button>
                        <div id="funded-date-filter-display" class="date-filter-display-text text-sm text-text-secondary">Sin filtro de fecha</div>
                    </div>
                </div>

                <!-- Capital Live Activo Destacado -->
                <div class="metric-card mb-6 bg-gradient-to-r from-green/10 to-primary/10 border-2" style="border-color: #39FF14;">
                    <div class="flex items-center gap-4">
                        <div class="w-20 h-20 rounded-full flex items-center justify-center" style="background: rgba(57, 255, 20, 0.2);">
                            <i class="fas fa-sack-dollar text-5xl" style="color: #39FF14;"></i>
                        </div>
                        <div class="flex-1">
                            <h4 class="text-sm text-text-secondary mb-1">Capital Total en Cuentas Live Activas</h4>
                            <p id="funded-live-capital-total" class="text-5xl font-bold hide-amount" style="color: #39FF14;">€0.00</p>
                            <p class="text-xs text-text-secondary mt-2">
                                <span id="funded-live-count-display">0 cuentas live activas</span> • 
                                <span id="funded-avg-balance-display">Promedio: €0</span>
                            </p>
                        </div>
                    </div>
                </div>

                <!-- Métricas de Funded -->
                <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-6 gap-4 mb-6">
                    <div class="metric-card text-center p-4">
                        <h4 class="text-sm text-text-secondary">Balance Total</h4>
                        <p id="funded-total-balance" class="text-2xl font-bold text-white hide-amount">$0.00</p>
                    </div>
                    <div class="metric-card text-center p-4">
                        <h4 class="text-sm text-text-secondary">Ganancias</h4>
                        <p id="funded-total-profit" class="text-2xl font-bold text-green hide-amount">$0.00</p>
                    </div>
                    <div class="metric-card text-center p-4">
                        <h4 class="text-sm text-text-secondary">Gastos Operativos</h4>
                        <p id="funded-total-expenses" class="text-2xl font-bold text-red hide-amount">$0.00</p>
                    </div>
                    <div class="metric-card text-center p-4">
                        <h4 class="text-sm text-text-secondary">ROI Funded</h4>
                        <p id="funded-roi" class="text-2xl font-bold text-primary">0%</p>
                    </div>
                    <div class="metric-card text-center p-4">
                        <h4 class="text-sm text-text-secondary">Rentabilidad</h4>
                        <p id="funded-profitability" class="text-2xl font-bold text-green">0%</p>
                    </div>
                    <div class="metric-card text-center p-4">
                        <h4 class="text-sm text-text-secondary">Cuentas Activas</h4>
                        <p id="funded-active-accounts" class="text-2xl font-bold text-white">0</p>
                    </div>
                </div>

                <!-- Gráficos de Funded -->
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                    <!-- Balance por Cuenta -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-2">Balance por Cuenta</h3>
                        <p class="text-xs text-text-secondary mb-3">Balance de cuentas live activas</p>
                        <div class="chart-container" style="height: 350px;">
                            <canvas id="funded-evolution-chart"></canvas>
                        </div>
                    </div>

                    <!-- Ganancias vs Gastos (Donut) -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-2">Ganancias vs Gastos</h3>
                        <p class="text-xs text-text-secondary mb-3">Comparación: Retiros vs Inversión en cuentas</p>
                        <div class="chart-container" style="height: 350px;">
                            <canvas id="funded-expenses-donut"></canvas>
                        </div>
                    </div>
                </div>

                <!-- Más Gráficos de Funded -->
                <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-6">
                    <!-- Ganancias vs Gastos -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-2">Ganancias vs Gastos</h3>
                        <p class="text-xs text-text-secondary mb-3">Últimos 5 meses</p>
                        <div class="chart-container" style="height: 300px;">
                            <canvas id="funded-profit-expenses-chart"></canvas>
                        </div>
                    </div>

                    <!-- Balance por Cuenta -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-2">Balance por Cuenta</h3>
                        <p class="text-xs text-text-secondary mb-3">Cuentas live activas</p>
                        <div class="chart-container" style="height: 300px;">
                            <canvas id="funded-account-performance-chart"></canvas>
                        </div>
                    </div>

                    <!-- Tendencia Mensual -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-2">Tendencia Mensual</h3>
                        <p class="text-xs text-text-secondary mb-3">Balance neto mensual</p>
                        <div class="chart-container" style="height: 300px;">
                            <canvas id="funded-monthly-trend-chart"></canvas>
                        </div>
                    </div>
                </div>

                <!-- Tabla de Movimientos Funded -->
                <div class="metric-card mb-6">
                    <h3 class="text-lg font-semibold mb-4">Movimientos de Cuentas Funded</h3>
                    <div class="overflow-x-auto">
                        <table id="funded-movements-table" class="w-full">
                            <thead>
                                <tr>
                                    <th class="text-left">Fecha</th>
                                    <th class="text-left">Descripción</th>
                                    <th class="text-left">Cuenta</th>
                                    <th class="text-right">Monto</th>
                                    <th class="text-right">Balance</th>
                                    <th class="text-center">Divisa</th>
                                    <th class="text-center">Tipo</th>
                                </tr>
                            </thead>
                            <tbody id="funded-movements-tbody"></tbody>
                        </table>
                    </div>
                </div>
            </div>
            <!-- Fin de Funded -->
            
            <!-- Contenido de Movimientos -->
            <div id="finances-view-movements" class="hidden">
             <div class="flex flex-wrap justify-between items-start mb-6 gap-4">
                <div><label class="block mb-2 text-text-secondary">Filtrar por fecha:</label><div class="flex items-center space-x-2"><button id="finances-date-filter-btn" class="date-filter-trigger p-2 bg-surface rounded" title="Filtrar por fecha"><i class="fas fa-calendar-alt"></i></button><div id="finances-date-filter-display" class="date-filter-display-text text-sm text-text-secondary">Sin filtro de fecha</div></div></div>
                <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-5 gap-4 w-full lg:w-auto">
                    <div class="metric-card text-center p-3"><h4 class="text-sm text-text-secondary">P/L de Trading</h4><p id="finance-trading-pl" class="text-xl font-bold text-green hide-amount">$0.00</p></div>
                    <div class="metric-card text-center p-3"><h4 class="text-sm text-text-secondary">Win Rate</h4><p id="finance-win-rate" class="text-xl font-bold text-green">0%</p></div>
                    <div class="metric-card text-center p-3"><h4 class="text-sm text-text-secondary">Ingresos</h4><p id="finance-total-income" class="text-xl font-bold text-green hide-amount">$0.00</p></div>
                    <div class="metric-card text-center p-3"><h4 class="text-sm text-text-secondary">Gastos</h4><p id="finance-total-expenses" class="text-xl font-bold text-red hide-amount">$0.00</p></div>
                    <div class="metric-card text-center p-3"><h4 class="text-sm text-text-secondary">Balance Neto</h4><p id="finance-net-balance" class="text-xl font-bold text-white hide-amount">$0.00</p></div>
                </div>
            </div>
            <!-- Registro de Movimientos - Ancho completo -->
            <div class="metric-card mb-6">
                <h3 class="text-lg font-semibold mb-4">Registro de Movimientos</h3>
                <div class="overflow-x-auto">
                    <table id="finances-table" class="w-full">
                        <thead>
                            <tr>
                                <th class="text-left">Fecha</th>
                                <th class="text-left">Descripción / Notas</th>
                                <th class="text-right">Monto</th>
                                <th class="text-center">Divisa</th>
                                <th class="text-center">Acciones</th>
                            </tr>
                        </thead>
                        <tbody id="finances-table-body"></tbody>
                    </table>
                </div>
            </div>

            <!-- Evolución Financiera - Ancho completo con vista expandible -->
            <div class="metric-card mb-6">
                <div class="flex items-center justify-between mb-4">
                    <h3 class="text-lg font-semibold">Evolución Financiera</h3>
                    <button id="expand-evolution-chart-btn" class="text-sm px-3 py-1 border border-border rounded hover:border-primary transition-all">
                        <i class="fas fa-expand mr-2"></i>Ver en Pantalla Completa
                    </button>
                </div>
                <div class="chart-container" style="height: 400px;">
                    <canvas id="finances-evolution-chart"></canvas>
                </div>
            </div>

            <!-- Modal de Gráfico en Pantalla Completa -->
            <div id="evolution-chart-fullscreen" class="fixed inset-0 bg-black bg-opacity-95 z-50 hidden flex items-center justify-center p-4">
                <div class="w-full h-full flex flex-col">
                    <div class="flex items-center justify-between mb-4">
                        <h3 class="text-2xl font-bold">Evolución Financiera</h3>
                        <button id="close-evolution-fullscreen-btn" class="text-2xl text-text-secondary hover:text-text">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <div class="flex-1 bg-surface rounded-lg p-4">
                        <canvas id="finances-evolution-chart-fullscreen"></canvas>
                    </div>
                </div>
            </div>

            <!-- Nueva fila: Flujo de Caja y Profit vs Expenses -->
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                <div class="metric-card">
                    <h3 class="text-lg font-semibold mb-2">Flujo de Caja Mensual</h3>
                    <p class="text-xs text-text-secondary mb-3">Comparación de ingresos (trading + manuales) vs gastos</p>
                    <div class="chart-container" style="height: 350px;">
                        <canvas id="finances-cashflow-chart"></canvas>
                    </div>
                </div>
                <div class="metric-card">
                    <h3 class="text-lg font-semibold mb-2">Profit vs Expenses</h3>
                    <p class="text-xs text-text-secondary mb-3">Ganancias de trading comparadas con gastos totales</p>
                    <div class="chart-container" style="height: 350px;">
                        <canvas id="finances-profit-expenses-chart"></canvas>
                    </div>
                </div>
            </div>
            </div>
            <!-- Fin de Movimientos -->

            <!-- Contenido de Calendario -->
            <div id="finances-view-calendar" class="hidden">
            <!-- Calendario Financiero -->
            <div class="metric-card">
                <div class="flex items-center justify-between mb-4">
                    <h3 class="text-lg font-semibold">Calendario Financiero</h3>
                    <div class="flex items-center gap-4">
                        <div class="flex items-center gap-2">
                            <span class="text-xs flex items-center gap-1">
                                <span class="inline-block w-3 h-3 rounded-full bg-green"></span>
                                Ingresos
                            </span>
                            <span class="text-xs flex items-center gap-1">
                                <span class="inline-block w-3 h-3 rounded-full bg-red"></span>
                                Gastos
                            </span>
                            <span class="text-xs flex items-center gap-1">
                                <span class="inline-block w-3 h-3 rounded-full bg-green"></span>
                                Trading
                            </span>
                        </div>
                        <div class="flex items-center gap-2">
                            <button id="finances-calendar-prev" class="p-2 hover:bg-surface-light rounded">
                                <i class="fas fa-chevron-left text-sm"></i>
                            </button>
                            <span id="finances-calendar-month-year" class="text-sm font-semibold min-w-[120px] text-center"></span>
                            <button id="finances-calendar-next" class="p-2 hover:bg-surface-light rounded">
                                <i class="fas fa-chevron-right text-sm"></i>
                            </button>
                        </div>
                    </div>
                </div>
                <div id="finances-calendar-container" class="overflow-x-auto">
                    <!-- El calendario se generará dinámicamente aquí -->
                </div>
            </div>

            <!-- Métricas de Barras - Tendencia Semanal y Rendimiento por Día -->
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mt-6">
                <!-- Tendencia Semanal -->
                <div class="metric-card">
                    <h3 class="text-lg font-semibold mb-1">Tendencia Semanal</h3>
                    <p class="text-xs text-text-secondary mb-2">Balance neto por semana en capital</p>
                    <p class="text-xs text-text-secondary mb-4">Balance neto por semana del mes</p>
                    <div id="finances-weekly-trend-bars" class="space-y-2">
                        <!-- Se generará dinámicamente -->
                    </div>
                </div>

                <!-- Rendimiento por Día de la Semana -->
                <div class="metric-card">
                    <h3 class="text-lg font-semibold mb-1">Rendimiento por Día de la Semana</h3>
                    <p class="text-xs text-text-secondary mb-2">Balance promedio por día en capital</p>
                    <p class="text-xs text-text-secondary mb-4">Balance promedio según día de la semana</p>
                    <div id="finances-weekday-performance-bars" class="space-y-2">
                        <!-- Se generará dinámicamente -->
                    </div>
                </div>
            </div>

            </div>
            <!-- Fin de Calendario -->

            <!-- ====== CONTENIDO DE TRACKERBANK ====== -->
            <div id="finances-view-trackerbank" class="hidden">
                <div class="flex flex-wrap justify-between items-start mb-6 gap-4">
                    <div>
                        <h3 class="text-2xl font-bold mb-2">🏦 TrackerBank - Control de Efectivo</h3>
                        <p class="text-sm text-text-secondary">Gestión total de tu dinero: Trading, Retiros y Gastos</p>
                    </div>
                    <div class="flex items-center space-x-3">
                        <!-- Toggle Cuenta Corriente -->
                        <div class="flex items-center gap-2 px-3 py-2 bg-surface rounded border border-border">
                            <span class="text-sm text-text-secondary">💳 Cuenta Corriente:</span>
                            <label class="relative inline-flex items-center cursor-pointer">
                                <input type="checkbox" id="trackerbank-bank-account-toggle" class="sr-only peer">
                                <div class="w-11 h-6 bg-gray-700 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-primary"></div>
                            </label>
                            <select id="trackerbank-bank-select" class="text-sm bg-surface border border-border rounded px-2 py-1" style="display: none;">
                                <option value="revolut">🟣 Revolut</option>
                                <option value="wise">🟢 Wise</option>
                            </select>
                        </div>
                        <button id="trackerbank-date-filter-btn" class="date-filter-trigger p-2 bg-surface rounded" title="Filtrar por fecha">
                            <i class="fas fa-calendar-alt"></i>
                        </button>
                        <div id="trackerbank-date-filter-display" class="date-filter-display-text text-sm text-text-secondary">Sin filtro de fecha</div>
                    </div>
                </div>

                <!-- Métricas Principales -->
                <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-6 gap-4 mb-6">
                    <div class="metric-card text-center p-4" style="background: linear-gradient(135deg, rgba(57,255,20,0.1) 0%, rgba(0,0,0,0.3) 100%); border: 2px solid #39FF14;">
                        <h4 class="text-sm text-text-secondary mb-2">Total Generado</h4>
                        <p id="trackerbank-total-generated" class="text-3xl font-bold hide-amount" style="color: #39FF14;">$0.00</p>
                        <p class="text-xs text-text-secondary mt-1">P/L de Trading</p>
                    </div>
                    <div class="metric-card text-center p-4">
                        <h4 class="text-sm text-text-secondary mb-2">📊 En Cuenta Trading</h4>
                        <p id="trackerbank-in-trading" class="text-2xl font-bold text-primary hide-amount">$0.00</p>
                        <p class="text-xs text-text-secondary mt-1">Capital activo</p>
                    </div>
                    <div class="metric-card text-center p-4">
                        <h4 class="text-sm text-text-secondary mb-2">🏦 Retirado a Banco</h4>
                        <p id="trackerbank-withdrawn" class="text-2xl font-bold text-blue hide-amount">$0.00</p>
                        <p class="text-xs text-text-secondary mt-1">Cuenta corriente</p>
                    </div>
                    <div class="metric-card text-center p-4">
                        <h4 class="text-sm text-text-secondary mb-2">💸 Gastos Totales</h4>
                        <p id="trackerbank-total-expenses" class="text-2xl font-bold text-red hide-amount">$0.00</p>
                        <p class="text-xs text-text-secondary mt-1">Operacionales</p>
                    </div>
                    <div class="metric-card text-center p-4">
                        <h4 class="text-sm text-text-secondary mb-2">📈 Capital Propio</h4>
                        <p id="trackerbank-own-capital" class="text-2xl font-bold text-green hide-amount">$0.00</p>
                        <p class="text-xs text-text-secondary mt-1">Balance neto</p>
                    </div>
                    <div class="metric-card text-center p-4">
                        <h4 class="text-sm text-text-secondary mb-2">🎯 Funded Total</h4>
                        <p id="trackerbank-funded-capital" class="text-2xl font-bold text-yellow hide-amount">$0.00</p>
                        <p class="text-xs text-text-secondary mt-1">Balance neto</p>
                    </div>
                </div>

                <!-- Gráfico de Evolución Principal -->
                <div class="metric-card mb-6">
                    <div class="flex justify-between items-center mb-4">
                        <div>
                            <h3 class="text-lg font-semibold mb-1">Evolución de Capital</h3>
                            <p class="text-xs text-text-secondary mb-2">Crecimiento del capital personal a lo largo del tiempo</p>
                            <p class="text-xs text-text-secondary">Crecimiento del dinero en cuenta de trading</p>
                        </div>
                        <button id="trackerbank-evolution-fullscreen" class="p-2 hover:bg-surface-light rounded" title="Pantalla completa">
                            <i class="fas fa-expand text-sm"></i>
                        </button>
                    </div>
                    
                    <!-- Pestañas de Filtro -->
                    <div class="flex flex-wrap gap-2 mb-4">
                        <button class="trackerbank-evolution-filter active" data-filter="all" style="padding: 6px 12px; border-radius: 6px; font-size: 12px; background: var(--primary); color: white; border: none; cursor: pointer;">
                            📊 Total
                        </button>
                        <button class="trackerbank-evolution-filter" data-filter="own-balance-gains" style="padding: 6px 12px; border-radius: 6px; font-size: 12px; background: var(--surface); color: var(--text); border: 1px solid var(--border); cursor: pointer;">
                            💰 Capital Propio + Ganancias
                        </button>
                        <button class="trackerbank-evolution-filter" data-filter="own-gains" style="padding: 6px 12px; border-radius: 6px; font-size: 12px; background: var(--surface); color: var(--text); border: 1px solid var(--border); cursor: pointer;">
                            📈 Solo Ganancias Capital
                        </button>
                        <button class="trackerbank-evolution-filter" data-filter="funded-balance-gains" style="padding: 6px 12px; border-radius: 6px; font-size: 12px; background: var(--surface); color: var(--text); border: 1px solid var(--border); cursor: pointer;">
                            🏆 Funded Balance + Ganancias
                        </button>
                        <button class="trackerbank-evolution-filter" data-filter="funded-gains" style="padding: 6px 12px; border-radius: 6px; font-size: 12px; background: var(--surface); color: var(--text); border: 1px solid var(--border); cursor: pointer;">
                            ⭐ Solo Ganancias Funded
                        </button>
                    </div>
                    
                    <div class="chart-container" style="height: 400px;">
                        <canvas id="trackerbank-evolution-chart"></canvas>
                    </div>
                </div>

                <!-- Métricas de Volumen (Gráficos de Barras) y Distribución (Donut) -->
                <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-6">
                    <!-- Volumen Mensual -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-1">Volumen Mensual</h3>
                        <p class="text-xs text-text-secondary mb-2">Operaciones realizadas por mes</p>
                        <p class="text-xs text-text-secondary mb-3">Ingresos vs Gastos vs Retiros</p>
                        <div class="chart-container" style="height: 300px;">
                            <canvas id="trackerbank-volume-chart"></canvas>
                        </div>
                    </div>

                    <!-- Distribución de Uso del Dinero -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-1">Distribución de Uso</h3>
                        <p class="text-xs text-text-secondary mb-2">Frecuencia de operación por cuenta</p>
                        <p class="text-xs text-text-secondary mb-3">¿Dónde está tu dinero?</p>
                        <div class="chart-container" style="height: 300px;">
                            <canvas id="trackerbank-distribution-chart"></canvas>
                        </div>
                    </div>

                    <!-- Categorías de Gastos -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-2">💳 Gastos por Categoría</h3>
                        <p class="text-xs text-text-secondary mb-3">Distribución de egresos</p>
                        <div class="chart-container" style="height: 300px;">
                            <canvas id="trackerbank-expenses-category-chart"></canvas>
                        </div>
                    </div>
                </div>

                <!-- Flujo de Caja -->
                <div class="metric-card mb-6">
                    <h3 class="text-lg font-semibold mb-2">💵 Flujo de Caja</h3>
                    <p class="text-xs text-text-secondary mb-4">Entradas y salidas de efectivo en el tiempo</p>
                    <div class="chart-container" style="height: 350px;">
                        <canvas id="trackerbank-cashflow-chart"></canvas>
                    </div>
                </div>

                <!-- Evolución de Cuenta Corriente (solo visible si está activada) -->
                <div id="trackerbank-bank-account-section" class="metric-card mb-6" style="display: none;">
                    <div class="flex justify-between items-center mb-4">
                        <div>
                            <h3 class="text-lg font-semibold mb-1">💳 Evolución de Cuenta Corriente</h3>
                            <p class="text-xs text-text-secondary">Balance acumulado de retiros en <span id="trackerbank-bank-name-display">Revolut</span></p>
                        </div>
                        <div class="text-right">
                            <p class="text-sm text-text-secondary">Balance Total</p>
                            <p id="trackerbank-bank-balance" class="text-2xl font-bold text-blue hide-amount">$0.00</p>
                        </div>
                    </div>
                    <div class="chart-container" style="height: 350px;">
                        <canvas id="trackerbank-bank-evolution-chart"></canvas>
                    </div>
                </div>

                <!-- Tablas de Detalles -->
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                    <!-- Historial de Retiros -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-4">🏦 Historial de Retiros</h3>
                        <p class="text-xs text-text-secondary mb-3">Haz clic en un retiro para ver detalles</p>
                        <div class="overflow-x-auto">
                            <table class="data-table w-full">
                                <thead>
                                    <tr>
                                        <th>Fecha</th>
                                        <th>Monto</th>
                                        <th>Banco</th>
                                        <th>Acumulado</th>
                                    </tr>
                                </thead>
                                <tbody id="trackerbank-withdrawals-table" style="cursor: pointer;">
                                    <tr>
                                        <td colspan="4" class="text-center text-text-secondary py-4">No hay retiros registrados</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <!-- Resumen de Gastos Recientes -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-4">💸 Gastos Recientes</h3>
                        <p class="text-xs text-text-secondary mb-3">Haz clic en un gasto para ver detalles</p>
                        <div class="overflow-x-auto">
                            <table class="data-table w-full">
                                <thead>
                                    <tr>
                                        <th>Fecha</th>
                                        <th>Descripción</th>
                                        <th>Categoría</th>
                                        <th>Monto</th>
                                    </tr>
                                </thead>
                                <tbody id="trackerbank-expenses-table" style="cursor: pointer;">
                                    <tr>
                                        <td colspan="4" class="text-center text-text-secondary py-4">No hay gastos registrados</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>

                <!-- Proyecciones y Estadísticas Avanzadas -->
                <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-6">
                    <!-- Proyección de Crecimiento -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-1">Proyección de Crecimiento</h3>
                        <p class="text-xs text-text-secondary mb-3">Estimación de crecimiento futuro del capital</p>
                        <div class="space-y-3">
                            <div class="flex justify-between items-center">
                                <span class="text-sm text-text-secondary">Promedio Mensual:</span>
                                <span id="trackerbank-avg-monthly" class="text-sm font-semibold text-green hide-amount">$0.00</span>
                            </div>
                            <div class="flex justify-between items-center">
                                <span class="text-sm text-text-secondary">Proyección 3 meses:</span>
                                <span id="trackerbank-proj-3months" class="text-sm font-semibold text-primary hide-amount">$0.00</span>
                            </div>
                            <div class="flex justify-between items-center">
                                <span class="text-sm text-text-secondary">Proyección 6 meses:</span>
                                <span id="trackerbank-proj-6months" class="text-sm font-semibold text-primary hide-amount">$0.00</span>
                            </div>
                            <div class="flex justify-between items-center">
                                <span class="text-sm text-text-secondary">Proyección 12 meses:</span>
                                <span id="trackerbank-proj-12months" class="text-sm font-semibold text-yellow hide-amount">$0.00</span>
                            </div>
                        </div>
                    </div>

                    <!-- Tasa de Ahorro -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-1">Tasa de Ahorro</h3>
                        <p class="text-xs text-text-secondary mb-3">Porcentaje del capital ahorrado vs gastos</p>
                        <div class="space-y-3">
                            <div class="flex justify-between items-center">
                                <span class="text-sm text-text-secondary">% Retirado:</span>
                                <span id="trackerbank-withdrawal-rate" class="text-sm font-semibold text-blue">0%</span>
                            </div>
                            <div class="flex justify-between items-center">
                                <span class="text-sm text-text-secondary">% En Trading:</span>
                                <span id="trackerbank-trading-rate" class="text-sm font-semibold text-primary">0%</span>
                            </div>
                            <div class="flex justify-between items-center">
                                <span class="text-sm text-text-secondary">% Gastado:</span>
                                <span id="trackerbank-expense-rate" class="text-sm font-semibold text-red">0%</span>
                            </div>
                            <div class="flex justify-between items-center">
                                <span class="text-sm text-text-secondary">Eficiencia:</span>
                                <span id="trackerbank-efficiency" class="text-sm font-semibold text-green">0%</span>
                            </div>
                        </div>
                    </div>

                    <!-- Mejores y Peores Meses -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-1">Rendimiento Histórico</h3>
                        <p class="text-xs text-text-secondary mb-3">Evolución del balance en cuentas fondeadas</p>
                        <div class="space-y-3">
                            <div>
                                <span class="text-xs text-text-secondary block mb-1">Mejor Mes:</span>
                                <div class="flex justify-between items-center">
                                    <span id="trackerbank-best-month-date" class="text-sm font-semibold">-</span>
                                    <span id="trackerbank-best-month-amount" class="text-sm font-semibold text-green hide-amount">$0.00</span>
                                </div>
                            </div>
                            <div>
                                <span class="text-xs text-text-secondary block mb-1">Peor Mes:</span>
                                <div class="flex justify-between items-center">
                                    <span id="trackerbank-worst-month-date" class="text-sm font-semibold">-</span>
                                    <span id="trackerbank-worst-month-amount" class="text-sm font-semibold text-red hide-amount">$0.00</span>
                                </div>
                            </div>
                            <div>
                                <span class="text-xs text-text-secondary block mb-1">Racha Positiva:</span>
                                <div class="flex justify-between items-center">
                                    <span id="trackerbank-positive-streak" class="text-sm font-semibold text-green">0 meses</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Fin de TrackerBank -->

            <!-- Modal para Detalles de Retiro -->
            <div id="withdrawal-detail-modal" class="modal" style="display: none;">
                <div class="modal-content" style="max-width: 600px;">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-xl font-bold">🏦 Detalles del Retiro</h2>
                        <button id="close-withdrawal-detail-modal" class="text-2xl hover:text-primary">&times;</button>
                    </div>
                    
                    <div class="space-y-4">
                        <!-- Información Principal -->
                        <div class="grid grid-cols-2 gap-4">
                            <div class="metric-card">
                                <p class="text-xs text-text-secondary mb-1">Fecha</p>
                                <p id="withdrawal-detail-date" class="text-lg font-semibold">-</p>
                            </div>
                            <div class="metric-card">
                                <p class="text-xs text-text-secondary mb-1">Monto</p>
                                <p id="withdrawal-detail-amount" class="text-lg font-bold text-blue hide-amount">$0.00</p>
                            </div>
                            <div class="metric-card">
                                <p class="text-xs text-text-secondary mb-1">Banco</p>
                                <p id="withdrawal-detail-bank" class="text-lg font-semibold">-</p>
                            </div>
                            <div class="metric-card">
                                <p class="text-xs text-text-secondary mb-1">Divisa</p>
                                <p id="withdrawal-detail-currency" class="text-lg font-semibold">-</p>
                            </div>
                        </div>

                        <!-- Descripción -->
                        <div class="metric-card">
                            <p class="text-xs text-text-secondary mb-2">Descripción</p>
                            <p id="withdrawal-detail-description" class="text-sm">Sin descripción</p>
                        </div>

                        <!-- Notas -->
                        <div class="metric-card">
                            <p class="text-xs text-text-secondary mb-2">Notas Detalladas</p>
                            <div id="withdrawal-detail-notes" class="text-sm prose prose-invert max-w-none">
                                <p class="text-text-secondary italic">Sin notas adicionales</p>
                            </div>
                        </div>
                    </div>

                    <div class="flex justify-end gap-2 mt-6">
                        <button id="withdrawal-detail-close-btn" class="primary px-4 py-2">Cerrar</button>
                    </div>
                </div>
            </div>

            <!-- Modal para Detalles de Gasto -->
            <div id="expense-detail-modal" class="modal" style="display: none;">
                <div class="modal-content" style="max-width: 600px;">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-xl font-bold">💸 Detalles del Gasto</h2>
                        <button id="close-expense-detail-modal" class="text-2xl hover:text-primary">&times;</button>
                    </div>
                    
                    <div class="space-y-4">
                        <!-- Información Principal -->
                        <div class="grid grid-cols-2 gap-4">
                            <div class="metric-card">
                                <p class="text-xs text-text-secondary mb-1">Fecha</p>
                                <p id="expense-detail-date" class="text-lg font-semibold">-</p>
                            </div>
                            <div class="metric-card">
                                <p class="text-xs text-text-secondary mb-1">Monto</p>
                                <p id="expense-detail-amount" class="text-lg font-bold text-red hide-amount">$0.00</p>
                            </div>
                            <div class="metric-card">
                                <p class="text-xs text-text-secondary mb-1">Categoría</p>
                                <p id="expense-detail-category" class="text-lg font-semibold">-</p>
                            </div>
                            <div class="metric-card">
                                <p class="text-xs text-text-secondary mb-1">Divisa</p>
                                <p id="expense-detail-currency" class="text-lg font-semibold">-</p>
                            </div>
                        </div>

                        <!-- Descripción -->
                        <div class="metric-card">
                            <p class="text-xs text-text-secondary mb-2">Descripción</p>
                            <p id="expense-detail-description" class="text-sm">Sin descripción</p>
                        </div>

                        <!-- Notas -->
                        <div class="metric-card">
                            <p class="text-xs text-text-secondary mb-2">Notas Detalladas</p>
                            <div id="expense-detail-notes" class="text-sm prose prose-invert max-w-none">
                                <p class="text-text-secondary italic">Sin notas adicionales</p>
                            </div>
                        </div>
                    </div>

                    <div class="flex justify-end gap-2 mt-6">
                        <button id="expense-detail-close-btn" class="primary px-4 py-2">Cerrar</button>
                    </div>
                </div>
            </div>

        </section>

        <section id="news" class="section-container">
            <!-- Header -->
            <div class="mb-6">
                <h2 class="text-2xl font-bold">📰 Noticias</h2>
            </div>

            <!-- TradingView Ticker Tape Widget -->
            <div class="mb-6 ticker-tape-wrapper" style="background-color: #000000 !important; border-radius: 0.5rem; overflow: hidden; padding: 0; margin: 0;">
                <script type="module" src="https://widgets.tradingview-widget.com/w/es/tv-ticker-tape.js"></script>
                <tv-ticker-tape symbols='FOREXCOM:SPXUSD,FOREXCOM:NSXUSD,FOREXCOM:DJI,FX:EURUSD,BITSTAMP:BTCUSD,BITSTAMP:ETHUSD,CMCMARKETS:GOLD,OANDA:GBPUSD,NASDAQ:AAPL,NASDAQ:GOOG,NASDAQ:NVDA,NASDAQ:MSFT,CAPITALCOM:SILVER,PEPPERSTONE:NATGAS,TVC:VIX,BINANCE:SOLUSDT,OANDA:USDJPY,FX:GER30,NASDAQ:TSLA,OANDA:USDCAD,NASDAQ:NFLX' theme="dark" transparent></tv-ticker-tape>
            </div>

            <!-- Grid de Calendario y Noticias -->
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                <!-- TradingView Calendario Económico Widget -->
                <div class="metric-card" style="min-height: 800px;">
                    <h3 class="text-xl font-bold mb-6"><i class="fas fa-calendar-alt"></i> Calendario Económico</h3>
                    <div class="tradingview-widget-container" style="height: 750px; background-color: #000000;">
                        <div class="tradingview-widget-container__widget" style="height: 100%; background-color: #000000;"></div>
                        <script type="text/javascript" src="https://s3.tradingview.com/external-embedding/embed-widget-events.js" async>
                        {
                        "colorTheme": "dark",
                        "isTransparent": false,
                        "locale": "es",
                        "importanceFilter": "-1,0,1",
                        "width": "100%",
                        "height": "100%"
                        }
                        </script>
                    </div>
                </div>

                <!-- TradingView Noticias Widget -->
                <div class="metric-card" style="min-height: 800px;">
                    <h3 class="text-xl font-bold mb-6"><i class="fas fa-newspaper"></i> Noticias de Última Hora</h3>
                    <div class="tradingview-widget-container" style="height: 750px; background-color: #000000;">
                        <div class="tradingview-widget-container__widget" style="height: 100%; background-color: #000000;"></div>
                        <script type="text/javascript" src="https://s3.tradingview.com/external-embedding/embed-widget-timeline.js" async>
                        {
                        "displayMode": "regular",
                        "feedMode": "all_symbols",
                        "colorTheme": "dark",
                        "isTransparent": false,
                        "locale": "es",
                        "width": "100%",
                        "height": "100%"
                        }
                        </script>
                    </div>
                </div>
            </div>
        </section>

        <!-- SECCIÓN: MARKET SCANNER -->
        <section id="market-scanner" class="section-container">
            <!-- Header -->
            <div class="mb-6">
                <h2 class="text-2xl font-bold">📰 Market Scanner</h2>
            </div>

            <!-- Stock Heatmap - Full Width -->
            <div class="metric-card mb-6" style="min-height: 700px;">
                <h3 class="text-xl font-bold mb-4"><i class="fas fa-chart-area"></i> Stock Heatmap - S&P 500</h3>
                <!-- TradingView Widget BEGIN -->
                <div class="tradingview-widget-container" style="height: calc(100% - 50px); width: 100%;">
                  <div class="tradingview-widget-container__widget" style="height: calc(100% - 32px); width: 100%;"></div>
                  <div class="tradingview-widget-copyright"><a href="https://www.tradingview.com/heatmap/stock/" rel="noopener nofollow" target="_blank"><span class="blue-text">Stock Heatmap</span></a><span class="trademark"> by TradingView</span></div>
                  <script type="text/javascript" src="https://s3.tradingview.com/external-embedding/embed-widget-stock-heatmap.js" async>
                  {
                  "dataSource": "SPX500",
                  "blockSize": "market_cap_basic",
                  "blockColor": "change",
                  "grouping": "sector",
                  "locale": "en",
                  "symbolUrl": "",
                  "colorTheme": "dark",
                  "exchanges": [],
                  "hasTopBar": true,
                  "isDataSetEnabled": true,
                  "isZoomEnabled": true,
                  "hasSymbolTooltip": true,
                  "isMonoSize": false,
                  "width": "100%",
                  "height": 600
                }
                  </script>
                </div>
                <!-- TradingView Widget END -->
            </div>

            <!-- Crypto Heatmap - Full Width -->
            <div class="metric-card mb-6" style="min-height: 700px;">
                <h3 class="text-xl font-bold mb-4"><i class="fab fa-bitcoin"></i> Crypto Heatmap</h3>
                <!-- TradingView Widget BEGIN -->
                <div class="tradingview-widget-container" style="height: calc(100% - 50px); width: 100%;">
                  <div class="tradingview-widget-container__widget" style="height: calc(100% - 32px); width: 100%;"></div>
                  <div class="tradingview-widget-copyright"><a href="https://www.tradingview.com/heatmap/crypto/" rel="noopener nofollow" target="_blank"><span class="blue-text">Crypto Heatmap</span></a><span class="trademark"> by TradingView</span></div>
                  <script type="text/javascript" src="https://s3.tradingview.com/external-embedding/embed-widget-crypto-coins-heatmap.js" async>
                  {
                  "dataSource": "Crypto",
                  "blockSize": "market_cap_calc",
                  "blockColor": "24h_close_change|5",
                  "locale": "en",
                  "symbolUrl": "",
                  "colorTheme": "dark",
                  "hasTopBar": true,
                  "isDataSetEnabled": true,
                  "isZoomEnabled": true,
                  "hasSymbolTooltip": true,
                  "isMonoSize": false,
                  "width": "100%",
                  "height": 600
                }
                  </script>
                </div>
                <!-- TradingView Widget END -->
            </div>

            <!-- Grid de Forex Heatmap y Market Overview -->
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <!-- Forex Heatmap -->
                <div class="metric-card" style="min-height: 500px;">
                    <h3 class="text-xl font-bold mb-4"><i class="fas fa-exchange-alt"></i> Forex Heatmap</h3>
                    <!-- TradingView Widget BEGIN -->
                    <div class="tradingview-widget-container" style="height: calc(100% - 50px); width: 100%;">
                      <div class="tradingview-widget-container__widget" style="height: calc(100% - 32px); width: 100%;"></div>
                      <div class="tradingview-widget-copyright"><a href="https://www.tradingview.com/markets/currencies/cross-rates-overview-heat-map/" rel="noopener nofollow" target="_blank"><span class="blue-text">Forex Heatmap</span></a><span class="trademark"> by TradingView</span></div>
                      <script type="text/javascript" src="https://s3.tradingview.com/external-embedding/embed-widget-forex-heat-map.js" async>
                      {
                      "colorTheme": "dark",
                      "isTransparent": false,
                      "locale": "en",
                      "currencies": [
                        "EUR",
                        "USD",
                        "JPY",
                        "GBP",
                        "CHF",
                        "AUD",
                        "CAD",
                        "NZD",
                        "CNY"
                      ],
                      "backgroundColor": "#0F0F0F",
                      "width": "100%",
                      "height": 400
                    }
                      </script>
                    </div>
                    <!-- TradingView Widget END -->
                </div>

                <!-- Market Overview -->
                <div class="metric-card" style="min-height: 650px;">
                    <h3 class="text-xl font-bold mb-4"><i class="fas fa-globe"></i> World Markets</h3>
                    <!-- TradingView Widget BEGIN -->
                    <div class="tradingview-widget-container" style="height: calc(100% - 50px); width: 100%;">
                      <div class="tradingview-widget-container__widget" style="height: calc(100% - 32px); width: 100%;"></div>
                      <div class="tradingview-widget-copyright"><a href="https://www.tradingview.com/markets/" rel="noopener nofollow" target="_blank"><span class="blue-text">World markets</span></a><span class="trademark"> by TradingView</span></div>
                      <script type="text/javascript" src="https://s3.tradingview.com/external-embedding/embed-widget-market-overview.js" async>
                      {
                      "colorTheme": "dark",
                      "dateRange": "12M",
                      "locale": "en",
                      "largeChartUrl": "",
                      "isTransparent": false,
                      "showFloatingTooltip": false,
                      "plotLineColorGrowing": "rgba(41, 98, 255, 1)",
                      "plotLineColorFalling": "rgba(41, 98, 255, 1)",
                      "gridLineColor": "rgba(240, 243, 250, 0)",
                      "scaleFontColor": "#DBDBDB",
                      "belowLineFillColorGrowing": "rgba(41, 98, 255, 0.12)",
                      "belowLineFillColorFalling": "rgba(41, 98, 255, 0.12)",
                      "belowLineFillColorGrowingBottom": "rgba(41, 98, 255, 0)",
                      "belowLineFillColorFallingBottom": "rgba(41, 98, 255, 0)",
                      "symbolActiveColor": "rgba(41, 98, 255, 0.12)",
                      "tabs": [
                        {
                          "title": "Indices",
                          "symbols": [
                            {
                              "s": "FOREXCOM:SPXUSD",
                              "d": "S&P 500 Index"
                            },
                            {
                              "s": "FOREXCOM:NSXUSD",
                              "d": "US 100 Cash CFD"
                            },
                            {
                              "s": "FOREXCOM:DJI",
                              "d": "Dow Jones Industrial Average Index"
                            },
                            {
                              "s": "INDEX:NKY",
                              "d": "Japan 225"
                            },
                            {
                              "s": "INDEX:DEU40",
                              "d": "DAX Index"
                            },
                            {
                              "s": "FOREXCOM:UKXGBP",
                              "d": "FTSE 100 Index"
                            }
                          ],
                          "originalTitle": "Indices"
                        },
                        {
                          "title": "Futures",
                          "symbols": [
                            {
                              "s": "BMFBOVESPA:ISP1!",
                              "d": "S&P 500"
                            },
                            {
                              "s": "BMFBOVESPA:EUR1!",
                              "d": "Euro"
                            },
                            {
                              "s": "CMCMARKETS:GOLD",
                              "d": "Gold"
                            },
                            {
                              "s": "PYTH:WTI3!",
                              "d": "WTI Crude Oil"
                            },
                            {
                              "s": "BMFBOVESPA:CCM1!",
                              "d": "Corn"
                            }
                          ],
                          "originalTitle": "Futures"
                        },
                        {
                          "title": "Bonds",
                          "symbols": [
                            {
                              "s": "EUREX:FGBL1!",
                              "d": "Euro Bund"
                            },
                            {
                              "s": "EUREX:FBTP1!",
                              "d": "Euro BTP"
                            },
                            {
                              "s": "EUREX:FGBM1!",
                              "d": "Euro BOBL"
                            }
                          ],
                          "originalTitle": "Bonds"
                        },
                        {
                          "title": "Forex",
                          "symbols": [
                            {
                              "s": "FX:EURUSD",
                              "d": "EUR to USD"
                            },
                            {
                              "s": "FX:GBPUSD",
                              "d": "GBP to USD"
                            },
                            {
                              "s": "FX:USDJPY",
                              "d": "USD to JPY"
                            },
                            {
                              "s": "FX:USDCHF",
                              "d": "USD to CHF"
                            },
                            {
                              "s": "FX:AUDUSD",
                              "d": "AUD to USD"
                            },
                            {
                              "s": "FX:USDCAD",
                              "d": "USD to CAD"
                            }
                          ],
                          "originalTitle": "Forex"
                        }
                      ],
                      "support_host": "https://www.tradingview.com",
                      "backgroundColor": "#0f0f0f",
                      "width": "100%",
                      "height": 550,
                      "showSymbolLogo": true,
                      "showChart": true
                    }
                      </script>
                    </div>
                    <!-- TradingView Widget END -->
                </div>
            </div>
        </section>

        <!-- MODAL FILTRO DE FECHAS -->
        <div id="calendar-date-filter-modal" class="modal" style="display: none;">
            <div class="modal-overlay" onclick="closeDateFilterModal()"></div>
            <div class="modal-content" style="max-width: 500px;">
                <div class="modal-header">
                    <h3 class="text-2xl font-bold"><i class="fas fa-calendar-week"></i> Filtrar por Fecha</h3>
                    <button onclick="closeDateFilterModal()" class="text-2xl hover:text-red">&times;</button>
                </div>
                
                <div class="modal-body">
                    <div class="space-y-4">
                        <!-- Filtros rápidos -->
                        <div>
                            <label class="block text-sm font-bold mb-2">Filtros Rápidos</label>
                            <div class="grid grid-cols-3 gap-2">
                                <button onclick="setDateFilter('today')" class="btn btn-secondary text-sm">
                                    <i class="fas fa-calendar-day"></i> Hoy
                                </button>
                                <button onclick="setDateFilter('week')" class="btn btn-secondary text-sm">
                                    <i class="fas fa-calendar-week"></i> Esta Semana
                                </button>
                                <button onclick="setDateFilter('month')" class="btn btn-secondary text-sm">
                                    <i class="fas fa-calendar"></i> Este Mes
                                </button>
                            </div>
                        </div>

                        <!-- Rango personalizado -->
                        <div>
                            <label class="block text-sm font-bold mb-2">Rango Personalizado</label>
                            <div class="grid grid-cols-2 gap-3">
                                <div>
                                    <label class="text-xs text-text-secondary">Desde</label>
                                    <input type="date" id="calendar-date-from" class="w-full px-3 py-2 bg-surface border border-border rounded text-sm" />
                                </div>
                                <div>
                                    <label class="text-xs text-text-secondary">Hasta</label>
                                    <input type="date" id="calendar-date-to" class="w-full px-3 py-2 bg-surface border border-border rounded text-sm" />
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="modal-footer flex justify-between">
                    <button onclick="clearDateFilter()" class="btn btn-secondary">
                        <i class="fas fa-undo"></i> Limpiar Filtro
                    </button>
                    <button onclick="applyDateFilter()" class="btn btn-primary">
                        <i class="fas fa-check"></i> Aplicar
                    </button>
                </div>
            </div>
        </div>

        <!-- MODAL DETALLE EVENTO ECONÓMICO -->
        <div id="economic-event-modal" class="modal" style="display: none;">
            <div class="modal-overlay" onclick="closeEconomicEventModal()"></div>
            <div class="modal-content" style="max-width: 700px;">
                <div class="modal-header">
                    <h3 class="text-2xl font-bold" id="event-modal-title"></h3>
                    <button onclick="closeEconomicEventModal()" class="text-2xl hover:text-red">&times;</button>
                </div>
                
                <div class="modal-body" style="max-height: 70vh; overflow-y: auto;">
                    <!-- País y Hora -->
                    <div class="flex items-center gap-4 mb-4 pb-4 border-b border-border">
                        <div class="text-3xl font-bold" id="event-modal-country-code"></div>
                        <div class="flex-1">
                            <p class="text-text-secondary text-xs mb-1">País</p>
                            <p class="font-bold" id="event-modal-country"></p>
                        </div>
                        <div>
                            <p class="text-text-secondary text-xs mb-1">Hora</p>
                            <p class="text-xl font-bold text-primary" id="event-modal-time"></p>
                        </div>
                        <div class="ml-auto">
                            <span class="px-3 py-1 rounded text-sm font-bold" id="event-modal-importance-badge"></span>
                        </div>
                    </div>

                    <!-- Fecha del evento -->
                    <div class="mb-4 p-3 bg-surface-light rounded-lg">
                        <p class="text-sm"><i class="fas fa-calendar-day"></i> <strong>Fecha:</strong> <span id="event-modal-date"></span></p>
                    </div>

                    <!-- Descripción -->
                    <div class="mb-4">
                        <h4 class="font-bold mb-2 text-lg"><i class="fas fa-info-circle"></i> Descripción del Evento</h4>
                        <p class="text-text-secondary" id="event-modal-description"></p>
                    </div>

                    <!-- Datos -->
                    <div class="grid grid-cols-3 gap-4 mb-4 p-4 bg-surface-light rounded-lg">
                        <div class="text-center">
                            <p class="text-text-secondary text-xs mb-1">Actual</p>
                            <p class="text-2xl font-bold text-primary" id="event-modal-actual">-</p>
                        </div>
                        <div class="text-center">
                            <p class="text-text-secondary text-xs mb-1">Pronóstico</p>
                            <p class="text-xl font-semibold" id="event-modal-forecast">-</p>
                        </div>
                        <div class="text-center">
                            <p class="text-text-secondary text-xs mb-1">Anterior</p>
                            <p class="text-lg text-text-secondary" id="event-modal-previous">-</p>
                        </div>
                    </div>

                    <!-- Impacto en Activos -->
                    <div class="mb-4">
                        <h4 class="font-bold mb-3 text-lg"><i class="fas fa-chart-line"></i> Impacto en Activos</h4>
                        <div id="event-modal-impact" class="space-y-2">
                            <!-- Se llenará dinámicamente -->
                        </div>
                    </div>

                    <!-- Interpretación -->
                    <div class="p-4 bg-surface-light rounded-lg">
                        <h4 class="font-bold mb-2 flex items-center gap-2">
                            <i class="fas fa-lightbulb text-yellow-500"></i>
                            Cómo Interpretar
                        </h4>
                        <p class="text-sm text-text-secondary" id="event-modal-interpretation"></p>
                    </div>
                </div>

                <div class="modal-footer flex justify-end">
                    <button onclick="closeEconomicEventModal()" class="btn btn-secondary">
                        <i class="fas fa-times"></i> Cerrar
                    </button>
                </div>
            </div>
        </div>

        <style>
            .modal {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .modal-overlay {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                backdrop-filter: blur(5px);
            }

            .modal-content {
                position: relative;
                background: var(--surface);
                border: 1px solid var(--border);
                border-radius: 12px;
                max-width: 90%;
                max-height: 90vh;
                overflow: hidden;
                box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
                animation: modalSlideIn 0.3s ease-out;
            }

            @keyframes modalSlideIn {
                from {
                    opacity: 0;
                    transform: translateY(-50px) scale(0.95);
                }
                to {
                    opacity: 1;
                    transform: translateY(0) scale(1);
                }
            }

            .modal-header {
                padding: 1.5rem;
                border-bottom: 1px solid var(--border);
                display: flex;
                justify-content: space-between;
                align-items: center;
            }

            .modal-body {
                padding: 1.5rem;
            }

            .modal-footer {
                padding: 1rem 1.5rem;
                border-top: 1px solid var(--border);
            }

            .economic-event-card {
                cursor: pointer;
                transition: all 0.2s;
            }

            .economic-event-card:hover {
                background: var(--surface-light);
                transform: translateX(3px);
                border-left-width: 6px !important;
            }

            .news-card-with-image {
                cursor: pointer;
                transition: all 0.2s;
            }

            .news-card-with-image:hover {
                background: var(--surface-light);
                transform: scale(1.02);
            }

            .news-thumbnail {
                width: 80px;
                height: 80px;
                object-fit: cover;
                border-radius: 8px;
                flex-shrink: 0;
                background: var(--surface);
            }

            .line-clamp-2 {
                display: -webkit-box;
                -webkit-line-clamp: 2;
                -webkit-box-orient: vertical;
                overflow: hidden;
                text-overflow: ellipsis;
            }

            .market-tab {
                padding: 0.75rem 1.5rem;
                background: transparent;
                border: none;
                color: var(--text-secondary);
                cursor: pointer;
                border-bottom: 2px solid transparent;
                transition: all 0.3s ease;
            }
            .market-tab:hover {
                color: var(--text);
            }
            .market-tab.active {
                color: var(--primary);
                border-bottom-color: var(--primary);
            }
            .market-card {
                background: var(--surface-light);
                border: 1px solid var(--border);
                border-radius: 8px;
                padding: 1rem;
                transition: all 0.3s ease;
            }
            .market-card:hover {
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(57, 255, 20, 0.1);
            }
            .market-card.positive {
                border-left: 3px solid var(--green);
            }
            .market-card.negative {
                border-left: 3px solid var(--red);
            }
            .event-importance-high {
                border-left: 4px solid #ff4136;
            }
            .event-importance-medium {
                border-left: 4px solid #ff9500;
            }
            .event-importance-low {
                border-left: 4px solid #808080;
            }
            .news-item {
                padding: 1rem;
                background: var(--surface-light);
                border-radius: 8px;
                border: 1px solid var(--border);
                transition: all 0.2s ease;
            }
            .news-item:hover {
                border-color: var(--primary);
                transform: translateX(4px);
            }
        </style>

        <section id="config" class="section-container">
            <div class="config-layout">
                <!-- Config Sidebar -->
                <aside class="config-sidebar">
                    <h2 class="config-sidebar-title">Configuración</h2>
                    <nav class="config-nav">
                        <div class="config-nav-item active" data-config-section="user-info">
                            <i class="fas fa-user"></i>
                            <span>Información de Usuario</span>
                        </div>
                        <div class="config-nav-item" data-config-section="account-security">
                            <i class="fas fa-shield-alt"></i>
                            <span>Seguridad de Cuenta</span>
                        </div>
                        <div class="config-nav-item" data-config-section="billing">
                            <i class="fas fa-credit-card"></i>
                            <span>Planes y Facturación</span>
                        </div>
                        <div class="config-nav-item" data-config-section="mentorship">
                            <i class="fas fa-graduation-cap"></i>
                            <span>Mentoría Daniel HDZ</span>
                        </div>
                        <div class="config-nav-item" data-config-section="import-export">
                            <i class="fas fa-exchange-alt"></i>
                            <span>Importar/Exportar</span>
                        </div>
                        <div class="config-nav-item" data-config-section="preferences">
                            <i class="fas fa-sliders-h"></i>
                            <span>Preferencias</span>
                        </div>
                        <div class="config-nav-item" data-config-section="notifications">
                            <i class="fas fa-bell"></i>
                            <span>Notificaciones</span>
                        </div>
                        <div class="config-nav-item" data-config-section="privacy">
                            <i class="fas fa-lock"></i>
                            <span>Privacidad y Datos</span>
                        </div>
                    </nav>
                </aside>

                <!-- Config Content Area -->
                <div class="config-content">
                    <!-- 1. INFORMACIÓN DE USUARIO -->
                    <div class="config-section active" id="config-user-info">
                        <h2 class="config-section-title">Información de Usuario</h2>
                        <p class="config-section-subtitle">Administra tu información personal y perfil</p>

                        <div class="config-card">
                            <div class="config-card-header">
                                <h3>Perfil de Usuario</h3>
                            </div>
                            <div class="config-card-body">
                                <div class="user-profile-display">
                                    <div class="user-avatar-large">
                                        <span id="config-user-avatar">D</span>
                                    </div>
                                    <div class="user-profile-info">
                                        <div class="form-group">
                                            <label>Foto de Perfil</label>
                                            <div class="flex items-center space-x-4">
                                                <div id="config-profile-preview" class="w-20 h-20 rounded-full bg-primary flex items-center justify-center text-white text-2xl font-bold overflow-hidden">
                                                    D
                                                </div>
                                                <div class="flex flex-col space-y-2">
                                                    <label for="config-profile-image" class="btn-outline cursor-pointer inline-block">
                                                        <i class="fas fa-camera mr-2"></i>Cambiar Foto
                                                    </label>
                                                    <input type="file" id="config-profile-image" accept="image/*" style="display: none;">
                                                    <button id="config-remove-profile-image" class="btn-danger text-sm" style="display: none;">
                                                        <i class="fas fa-trash mr-2"></i>Eliminar Foto
                                                    </button>
                                                </div>
                                            </div>
                                            <p class="text-xs text-text-secondary mt-2">Formatos: JPG, PNG, GIF. Tamaño máximo: 2MB</p>
                                        </div>
                                        <div class="form-group">
                                            <label>Nombre de Usuario</label>
                                            <input type="text" id="config-username" class="form-control" placeholder="Tu nombre">
                                        </div>
                                        <div class="form-group">
                                            <label>Correo Electrónico</label>
                                            <input type="email" id="config-user-email" class="form-control" disabled>
                                        </div>
                                        <div class="form-group">
                                            <label>Fecha de Registro</label>
                                            <input type="text" id="config-user-since" class="form-control" disabled value="Noviembre 2024">
                                        </div>
                                        <div class="form-group">
                                            <label>País/Ubicación</label>
                                            <select id="config-user-country" class="form-control">
                                                <option value="">Seleccionar país...</option>
                                                <option value="ES">🇪🇸 España</option>
                                                <option value="MX">🇲🇽 México</option>
                                                <option value="AR">🇦🇷 Argentina</option>
                                                <option value="CO">🇨🇴 Colombia</option>
                                                <option value="CL">🇨🇱 Chile</option>
                                                <option value="PE">🇵🇪 Perú</option>
                                                <option value="VE">🇻🇪 Venezuela</option>
                                                <option value="EC">🇪🇨 Ecuador</option>
                                                <option value="UY">🇺🇾 Uruguay</option>
                                                <option value="PY">🇵🇾 Paraguay</option>
                                                <option value="BO">🇧🇴 Bolivia</option>
                                                <option value="CR">🇨🇷 Costa Rica</option>
                                                <option value="PA">🇵🇦 Panamá</option>
                                                <option value="DO">🇩🇴 República Dominicana</option>
                                                <option value="PR">🇵🇷 Puerto Rico</option>
                                                <option value="US">🇺🇸 Estados Unidos</option>
                                                <option value="CA">🇨🇦 Canadá</option>
                                                <option value="BR">🇧🇷 Brasil</option>
                                                <option value="PT">🇵🇹 Portugal</option>
                                                <option value="GB">🇬🇧 Reino Unido</option>
                                                <option value="DE">🇩🇪 Alemania</option>
                                                <option value="FR">🇫🇷 Francia</option>
                                                <option value="IT">🇮🇹 Italia</option>
                                                <option value="OTHER">🌍 Otro</option>
                                            </select>
                                        </div>
                                    </div>
                                </div>

                                <!-- Configuración de Perfil Público -->
                                <div class="status-card status-card-info mt-6">
                                    <i class="fas fa-users status-card-icon"></i>
                                    <div>
                                        <p class="font-semibold mb-2">Perfil Público en Social Media</p>
                                        <p class="text-sm mb-4">Comparte tu rendimiento de trading con la comunidad. Tu perfil aparecerá en el ranking público y otros traders podrán ver tus estadísticas de audición.</p>
                                        <div class="flex items-center space-x-3">
                                            <label class="switch">
                                                <input type="checkbox" id="config-public-profile">
                                                <span class="slider"></span>
                                            </label>
                                            <span id="config-public-profile-label" class="text-sm font-semibold text-text-secondary">Perfil Privado</span>
                                        </div>
                                        <p class="text-xs text-text-secondary mt-3">
                                            <i class="fas fa-info-circle mr-1"></i>
                                            Al activar el perfil público, tu nombre de usuario, país y estadísticas de trading serán visibles en la sección Social Media.
                                        </p>
                                    </div>
                                </div>

                                <div class="config-actions">
                                    <button class="btn-primary" id="save-user-info">
                                        <i class="fas fa-save mr-2"></i>Guardar Cambios
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- 2. SEGURIDAD DE CUENTA -->
                    <div class="config-section" id="config-account-security">
                        <h2 class="config-section-title">Seguridad de Cuenta</h2>
                        <p class="config-section-subtitle">Gestiona tu contraseña y estado de sesión</p>

                        <!-- Estado de Sesión -->
                        <div class="config-card">
                            <div class="config-card-header">
                                <h3>Estado de Sesión</h3>
                            </div>
                            <div class="config-card-body">
                                <div id="config-auth-status-logged-out" class="alert alert-warning">
                                    <i class="fas fa-exclamation-triangle"></i>
                                    <div>
                                        <p class="font-semibold">Sin sesión activa</p>
                                        <p class="text-sm mt-1">Tus operaciones se guardan localmente. Para sincronizar en la nube, inicia sesión.</p>
                                    </div>
                                    <button id="config-show-auth-modal-btn" class="btn-primary mt-3">
                                        <i class="fas fa-sign-in-alt mr-2"></i>Iniciar Sesión
                                    </button>
                                </div>

                                <div id="config-auth-status-logged-in" class="alert alert-success" style="display: none;">
                                    <i class="fas fa-check-circle"></i>
                                    <div>
                                        <p class="font-semibold">Sesión activa</p>
                                        <p class="text-sm mt-1">Usuario: <span id="config-current-user-email"></span></p>
                                        <p class="text-xs mt-1">Datos sincronizados automáticamente</p>
                                    </div>
                                    <button id="config-logout-btn" class="btn-danger mt-3">
                                        <i class="fas fa-sign-out-alt mr-2"></i>Cerrar Sesión
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- Cambiar Contraseña -->
                        <div class="config-card">
                            <div class="config-card-header">
                                <h3>Cambiar Contraseña</h3>
                            </div>
                            <div class="config-card-body">
                                <div class="form-group">
                                    <label>Contraseña Actual</label>
                                    <input type="password" id="current-password" class="form-control" placeholder="••••••••">
                                </div>
                                <div class="form-group">
                                    <label>Nueva Contraseña</label>
                                    <input type="password" id="new-password" class="form-control" placeholder="••••••••">
                                </div>
                                <div class="form-group">
                                    <label>Confirmar Nueva Contraseña</label>
                                    <input type="password" id="confirm-password" class="form-control" placeholder="••••••••">
                                </div>
                                <div class="config-actions">
                                    <button class="btn-primary" id="change-password-btn">
                                        <i class="fas fa-key mr-2"></i>Actualizar Contraseña
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- Autenticación de Dos Factores -->
                        <div class="config-card">
                            <div class="config-card-header">
                                <h3>Autenticación de Dos Factores (2FA)</h3>
                            </div>
                            <div class="config-card-body">
                                <div class="feature-toggle">
                                    <div>
                                        <p class="font-semibold">Activar 2FA</p>
                                        <p class="text-sm text-text-secondary">Agrega una capa adicional de seguridad a tu cuenta</p>
                                    </div>
                                    <label class="toggle-switch">
                                        <input type="checkbox" id="enable-2fa">
                                        <span class="toggle-slider"></span>
                                    </label>
                                </div>
                                <p class="text-xs text-text-secondary mt-3">
                                    <i class="fas fa-info-circle mr-1"></i>
                                    Próximamente disponible
                                </p>
                            </div>
                        </div>
                    </div>

                    <!-- 3. PLANES Y FACTURACIÓN -->
                    <div class="config-section" id="config-billing">
                        <h2 class="config-section-title">Planes y Facturación</h2>
                        <p class="config-section-subtitle">Administra tu suscripción y métodos de pago</p>

                        <!-- Plan Actual -->
                        <div class="config-card">
                            <div class="config-card-header">
                                <h3>Plan Actual</h3>
                                <span class="badge-success">Activo</span>
                            </div>
                            <div class="config-card-body">
                                <div class="plan-display">
                                    <div class="plan-icon">
                                        <i class="fas fa-crown"></i>
                                    </div>
                                    <div class="plan-info">
                                        <h4>Trading Survivor Premium</h4>
                                        <p class="plan-price">$129 USD<span>/ilimitado</span></p>
                                        <p class="text-sm text-text-secondary mt-2">Suscripción de por vida • Acceso completo</p>
                                    </div>
                                </div>

                                <div class="plan-features">
                                    <h5 class="font-semibold mb-3">Beneficios Incluidos:</h5>
                                    <ul class="feature-list">
                                        <li><i class="fas fa-check"></i> Trading Journal completo e ilimitado</li>
                                        <li><i class="fas fa-check"></i> Analytics avanzado con métricas profesionales</li>
                                        <li><i class="fas fa-check"></i> Importación automática desde exchanges</li>
                                        <li><i class="fas fa-check"></i> Gráficos TradingView integrados en tiempo real</li>
                                        <li><i class="fas fa-check"></i> Calendario económico y noticias financieras</li>
                                        <li><i class="fas fa-check"></i> Exportación de reportes en PDF y Excel</li>
                                        <li><i class="fas fa-check"></i> Sincronización en la nube ilimitada</li>
                                        <li><i class="fas fa-check"></i> Múltiples cuentas de trading</li>
                                        <li><i class="fas fa-check"></i> Soporte técnico prioritario 24/7</li>
                                        <li><i class="fas fa-check"></i> Actualizaciones y nuevas funciones gratis</li>
                                    </ul>
                                </div>

                                <div class="plan-stats">
                                    <div class="stat-item">
                                        <span class="stat-value" id="total-trades-count">0</span>
                                        <span class="stat-label">Operaciones Registradas</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-value" id="total-accounts-count">0</span>
                                        <span class="stat-label">Cuentas Conectadas</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-value">Ilimitado</span>
                                        <span class="stat-label">Espacio Disponible</span>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Historial de Pagos -->
                        <div class="config-card">
                            <div class="config-card-header">
                                <h3>Historial de Facturación</h3>
                            </div>
                            <div class="config-card-body">
                                <div class="billing-history">
                                    <div class="billing-item">
                                        <div>
                                            <p class="font-semibold">Trading Survivor Premium</p>
                                            <p class="text-sm text-text-secondary">07 Nov 2024 • Pago único</p>
                                        </div>
                                        <div class="text-right">
                                            <p class="font-semibold text-primary">$129.00 USD</p>
                                            <button class="btn-link text-sm">
                                                <i class="fas fa-download mr-1"></i>Factura
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- 4. MENTORÍA CON DANIEL HDZ -->
                    <div class="config-section" id="config-mentorship">
                        <h2 class="config-section-title">Mentoría con Daniel HDZ</h2>
                        <p class="config-section-subtitle">Aprende de un trader profesional con 10+ años de experiencia</p>

                        <!-- Perfil del Mentor -->
                        <div class="config-card mentor-card">
                            <div class="config-card-body">
                                <div class="mentor-profile">
                                    <div class="mentor-avatar">
                                        <img src="https://ui-avatars.com/api/?name=Daniel+HDZ&size=120&background=39ff14&color=0a0a0a&bold=true" alt="Daniel HDZ">
                                        <div class="mentor-badge">
                                            <i class="fas fa-certificate"></i>
                                        </div>
                                    </div>
                                    <div class="mentor-info">
                                        <h3>Daniel HDZ</h3>
                                        <p class="mentor-title">Trader Profesional • Mentor Certificado</p>
                                        <div class="mentor-stats">
                                            <div class="mentor-stat">
                                                <i class="fas fa-chart-line"></i>
                                                <span>10+ años de experiencia</span>
                                            </div>
                                            <div class="mentor-stat">
                                                <i class="fas fa-users"></i>
                                                <span>500+ traders formados</span>
                                            </div>
                                            <div class="mentor-stat">
                                                <i class="fas fa-trophy"></i>
                                                <span>Rentabilidad consistente</span>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <div class="mentor-description">
                                    <h4 class="font-semibold mb-3">Sobre Daniel HDZ</h4>
                                    <p class="text-text-secondary mb-4">
                                        Trader profesional especializado en mercados financieros con más de una década de experiencia operando en Forex, Futuros y Criptomonedas. 
                                        Ha desarrollado estrategias probadas que combinan análisis técnico avanzado, gestión de riesgo institucional y psicología del trading.
                                    </p>
                                    <p class="text-text-secondary mb-4">
                                        Como mentor, Daniel se enfoca en formar traders disciplinados y rentables, enseñando no solo estrategias de trading sino también 
                                        la mentalidad y gestión emocional necesarias para tener éxito sostenible en los mercados.
                                    </p>
                                </div>

                                <div class="mentorship-services">
                                    <h4 class="font-semibold mb-3">Servicios de Mentoría</h4>
                                    <div class="services-grid">
                                        <div class="service-item">
                                            <i class="fas fa-video"></i>
                                            <h5>Sesiones 1 a 1</h5>
                                            <p>Mentoría personalizada vía Zoom</p>
                                        </div>
                                        <div class="service-item">
                                            <i class="fas fa-book"></i>
                                            <h5>Curso Completo</h5>
                                            <p>De principiante a trader profesional</p>
                                        </div>
                                        <div class="service-item">
                                            <i class="fas fa-comments"></i>
                                            <h5>Grupo VIP</h5>
                                            <p>Comunidad exclusiva de traders</p>
                                        </div>
                                        <div class="service-item">
                                            <i class="fas fa-chart-bar"></i>
                                            <h5>Análisis de Mercado</h5>
                                            <p>Señales y setups diarios</p>
                                        </div>
                                        <div class="service-item">
                                            <i class="fas fa-headset"></i>
                                            <h5>Soporte 24/7</h5>
                                            <p>Acompañamiento continuo</p>
                                        </div>
                                        <div class="service-item">
                                            <i class="fas fa-certificate"></i>
                                            <h5>Certificación</h5>
                                            <p>Diploma de trader profesional</p>
                                        </div>
                                    </div>
                                </div>

                                <div class="mentorship-contact">
                                    <h4 class="font-semibold mb-3">¿Interesado en la Mentoría?</h4>
                                    <p class="text-text-secondary mb-4">
                                        Contáctame directamente para conocer los planes disponibles y cómo podemos trabajar juntos para alcanzar tus objetivos en el trading.
                                    </p>
                                    <div class="contact-methods">
                                        <a href="mailto:daniel.hdz.trader@gmail.com" class="btn-primary">
                                            <i class="fas fa-envelope mr-2"></i>daniel.hdz.trader@gmail.com
                                        </a>
                                        <button class="btn-outline" onclick="window.open('https://wa.me/1234567890', '_blank')">
                                            <i class="fab fa-whatsapp mr-2"></i>WhatsApp
                                        </button>
                                        <button class="btn-outline" onclick="window.open('https://t.me/danielhdz', '_blank')">
                                            <i class="fab fa-telegram mr-2"></i>Telegram
                                        </button>
                                    </div>
                                </div>

                                <div class="testimonials">
                                    <h4 class="font-semibold mb-3">Testimonios</h4>
                                    <div class="testimonial-item">
                                        <div class="testimonial-header">
                                            <div class="testimonial-avatar">JM</div>
                                            <div>
                                                <p class="font-semibold">Juan Martínez</p>
                                                <div class="rating">
                                                    <i class="fas fa-star"></i>
                                                    <i class="fas fa-star"></i>
                                                    <i class="fas fa-star"></i>
                                                    <i class="fas fa-star"></i>
                                                    <i class="fas fa-star"></i>
                                                </div>
                                            </div>
                                        </div>
                                        <p class="testimonial-text">
                                            "La mentoría con Daniel transformó completamente mi trading. Pasé de perder dinero constantemente a tener rentabilidad mensual consistente."
                                        </p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- 5. IMPORTAR/EXPORTAR -->
                    <div class="config-section" id="config-import-export">
                        <h2 class="config-section-title">Importar y Exportar Datos</h2>
                        <p class="config-section-subtitle">Gestiona tus operaciones y respaldos</p>

                        <!-- Importar CSV -->
                        <div class="config-card">
                            <div class="config-card-header">
                                <h3>Importar Operaciones desde CSV</h3>
                            </div>
                            <div class="config-card-body">
                                <div class="import-zone">
                                    <div class="upload-area" id="csv-drop-zone">
                                        <i class="fas fa-cloud-upload-alt"></i>
                                        <p class="font-semibold">Arrastra tu archivo CSV aquí</p>
                                        <p class="text-sm text-text-secondary">o haz clic para seleccionar</p>
                                        <input type="file" id="config-csv-file-input" accept=".csv" style="display: none;">
                                        <button class="btn-primary mt-3" onclick="document.getElementById('config-csv-file-input').click()">
                                            <i class="fas fa-folder-open mr-2"></i>Seleccionar Archivo
                                        </button>
                                    </div>
                                </div>

                                <div class="csv-format-info mt-4">
                                    <h5 class="font-semibold mb-2">Formato del CSV:</h5>
                                    <code class="code-block">
                                        Nombre Cuenta, ID, Fecha (YYYY-MM-DD), Hora Entrada (HH:MM), Hora Salida (HH:MM), 
                                        Instrumento, Tipo (buy/sell), Entrada, Salida, Volumen, P&L, Divisa, 
                                        Tarifa/Comision, Notas
                                    </code>
                                    <p class="text-xs text-text-secondary mt-2">
                                        <i class="fas fa-info-circle mr-1"></i>
                                        <strong>ID:</strong> Usa el mismo ID para agrupar operaciones parciales de la misma posición
                                    </p>
                                </div>

                                <button class="btn-primary mt-4" id="config-import-csv-btn">
                                    <i class="fas fa-upload mr-2"></i>Importar CSV
                                </button>
                                <div id="config-csv-import-status" class="mt-3"></div>
                            </div>
                        </div>

                        <!-- Exportar Datos -->
                        <div class="config-card">
                            <div class="config-card-header">
                                <h3>Exportar Datos</h3>
                            </div>
                            <div class="config-card-body">
                                <div class="export-options">
                                    <div class="export-option">
                                        <div>
                                            <h5 class="font-semibold">Exportar como JSON</h5>
                                            <p class="text-sm text-text-secondary">Respaldo completo de todas tus operaciones y configuraciones</p>
                                        </div>
                                        <button class="btn-outline" id="config-export-json">
                                            <i class="fas fa-download mr-2"></i>Exportar JSON
                                        </button>
                                    </div>
                                    <div class="export-option">
                                        <div>
                                            <h5 class="font-semibold">Exportar como CSV</h5>
                                            <p class="text-sm text-text-secondary">Operaciones en formato CSV para Excel</p>
                                        </div>
                                        <button class="btn-outline" id="config-export-csv">
                                            <i class="fas fa-file-csv mr-2"></i>Exportar CSV
                                        </button>
                                    </div>
                                    <div class="export-option">
                                        <div>
                                            <h5 class="font-semibold">Exportar Reporte PDF</h5>
                                            <p class="text-sm text-text-secondary">Informe completo con gráficos y estadísticas</p>
                                        </div>
                                        <button class="btn-outline" id="config-export-pdf">
                                            <i class="fas fa-file-pdf mr-2"></i>Exportar PDF
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Importar Respaldo -->
                        <div class="config-card">
                            <div class="config-card-header">
                                <h3>Restaurar desde Respaldo</h3>
                            </div>
                            <div class="config-card-body">
                                <div class="alert alert-info mb-4">
                                    <i class="fas fa-info-circle"></i>
                                    <p>Importar un respaldo reemplazará todos tus datos actuales. Se recomienda hacer un respaldo antes.</p>
                                </div>
                                <label for="config-import-json" class="btn-outline cursor-pointer">
                                    <i class="fas fa-upload mr-2"></i>Seleccionar Respaldo (.json)
                                </label>
                                <input type="file" id="config-import-json" accept=".json" style="display: none;">
                            </div>
                        </div>

                        <!-- Borrar Datos -->
                        <div class="config-card border-danger">
                            <div class="config-card-header">
                                <h3>Zona de Peligro</h3>
                            </div>
                            <div class="config-card-body">
                                <div class="alert alert-danger mb-4">
                                    <i class="fas fa-exclamation-triangle"></i>
                                    <p class="font-semibold">¡Cuidado! Esta acción no se puede deshacer</p>
                                </div>
                                <button class="btn-danger" id="config-clear-data">
                                    <i class="fas fa-trash-alt mr-2"></i>Borrar Todos los Datos
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- 6. PREFERENCIAS -->
                    <div class="config-section" id="config-preferences">
                        <h2 class="config-section-title">Preferencias</h2>
                        <p class="config-section-subtitle">Personaliza tu experiencia en Trading Survivor</p>

                        <div class="config-card">
                            <div class="config-card-header">
                                <h3>Visualización</h3>
                            </div>
                            <div class="config-card-body">
                                <div class="feature-toggle">
                                    <div>
                                        <p class="font-semibold">Modo Oscuro</p>
                                        <p class="text-sm text-text-secondary">Tema oscuro activado permanentemente</p>
                                    </div>
                                    <label class="toggle-switch">
                                        <input type="checkbox" checked disabled>
                                        <span class="toggle-slider"></span>
                                    </label>
                                </div>
                                <div class="feature-toggle">
                                    <div>
                                        <p class="font-semibold">Mostrar Tooltips</p>
                                        <p class="text-sm text-text-secondary">Ayudas contextuales en gráficos</p>
                                    </div>
                                    <label class="toggle-switch">
                                        <input type="checkbox" id="config-show-tooltips" checked>
                                        <span class="toggle-slider"></span>
                                    </label>
                                </div>
                                <div class="feature-toggle">
                                    <div>
                                        <p class="font-semibold">Animaciones</p>
                                        <p class="text-sm text-text-secondary">Transiciones suaves en la interfaz</p>
                                    </div>
                                    <label class="toggle-switch">
                                        <input type="checkbox" id="config-animations" checked>
                                        <span class="toggle-slider"></span>
                                    </label>
                                </div>
                            </div>
                        </div>

                        <div class="config-card">
                            <div class="config-card-header">
                                <h3>Formato de Datos</h3>
                            </div>
                            <div class="config-card-body">
                                <div class="form-group">
                                    <label>Zona Horaria</label>
                                    <select class="form-control" id="config-timezone">
                                        <option value="UTC-5">UTC-5 (EST - New York)</option>
                                        <option value="UTC-6">UTC-6 (CST - Mexico City)</option>
                                        <option value="UTC">UTC+0 (GMT - London)</option>
                                        <option value="UTC+1">UTC+1 (CET - Madrid)</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label>Formato de Fecha</label>
                                    <select class="form-control" id="config-date-format">
                                        <option value="YYYY-MM-DD">YYYY-MM-DD (2024-11-07)</option>
                                        <option value="DD/MM/YYYY">DD/MM/YYYY (07/11/2024)</option>
                                        <option value="MM/DD/YYYY">MM/DD/YYYY (11/07/2024)</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label>Divisa Principal</label>
                                    <select class="form-control" id="config-currency">
                                        <option value="USD">USD - Dólar Estadounidense</option>
                                        <option value="EUR">EUR - Euro</option>
                                        <option value="GBP">GBP - Libra Esterlina</option>
                                        <option value="MXN">MXN - Peso Mexicano</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Botón para guardar configuración de Preferencias -->
                        <div class="mt-6 flex justify-end">
                            <button id="save-preferences-btn" class="px-6 py-3 bg-primary text-black font-semibold rounded hover:bg-secondary transition-colors">
                                <i class="fas fa-save mr-2"></i>Guardar Preferencias
                            </button>
                        </div>
                        
                        <!-- Indicador de guardado automático -->
                        <div id="preferences-save-indicator" class="mt-3 text-center text-sm text-green" style="display: none;">
                            <i class="fas fa-check-circle mr-1"></i>
                            <span>Configuración guardada correctamente</span>
                        </div>
                    </div>

                    <!-- 7. NOTIFICACIONES -->
                    <div class="config-section" id="config-notifications">
                        <h2 class="config-section-title">Notificaciones</h2>
                        <p class="config-section-subtitle">Configura cómo quieres recibir actualizaciones</p>

                        <div class="config-card">
                            <div class="config-card-header">
                                <h3>Notificaciones por Email</h3>
                            </div>
                            <div class="config-card-body">
                                <div class="feature-toggle">
                                    <div>
                                        <p class="font-semibold">Resumen Semanal</p>
                                        <p class="text-sm text-text-secondary">Recibe un resumen de tu trading cada semana</p>
                                    </div>
                                    <label class="toggle-switch">
                                        <input type="checkbox" id="notif-weekly-summary" checked>
                                        <span class="toggle-slider"></span>
                                    </label>
                                </div>
                                <div class="feature-toggle">
                                    <div>
                                        <p class="font-semibold">Alertas de Objetivos</p>
                                        <p class="text-sm text-text-secondary">Te avisamos cuando alcances tus metas</p>
                                    </div>
                                    <label class="toggle-switch">
                                        <input type="checkbox" id="notif-goals">
                                        <span class="toggle-slider"></span>
                                    </label>
                                </div>
                                <div class="feature-toggle">
                                    <div>
                                        <p class="font-semibold">Actualizaciones de Producto</p>
                                        <p class="text-sm text-text-secondary">Nuevas funciones y mejoras</p>
                                    </div>
                                    <label class="toggle-switch">
                                        <input type="checkbox" id="notif-updates" checked>
                                        <span class="toggle-slider"></span>
                                    </label>
                                </div>
                            </div>
                        </div>

                        <div class="config-card">
                            <div class="config-card-header">
                                <h3>Notificaciones Push</h3>
                            </div>
                            <div class="config-card-body">
                                <div class="alert alert-info mb-4">
                                    <i class="fas fa-info-circle"></i>
                                    <p>Las notificaciones push estarán disponibles próximamente</p>
                                </div>
                                <div class="feature-toggle">
                                    <div>
                                        <p class="font-semibold">Activar Notificaciones Push</p>
                                        <p class="text-sm text-text-secondary">Recibe alertas en tiempo real</p>
                                    </div>
                                    <label class="toggle-switch">
                                        <input type="checkbox" disabled>
                                        <span class="toggle-slider"></span>
                                    </label>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- 8. PRIVACIDAD Y DATOS -->
                    <div class="config-section" id="config-privacy">
                        <h2 class="config-section-title">Privacidad y Datos</h2>
                        <p class="config-section-subtitle">Controla tu información y privacidad</p>

                        <div class="config-card">
                            <div class="config-card-header">
                                <h3>Privacidad de Datos</h3>
                            </div>
                            <div class="config-card-body">
                                <div class="feature-toggle">
                                    <div>
                                        <p class="font-semibold">Sincronización en la Nube</p>
                                        <p class="text-sm text-text-secondary">Guardar datos en Supabase</p>
                                    </div>
                                    <label class="toggle-switch">
                                        <input type="checkbox" id="privacy-cloud-sync" checked>
                                        <span class="toggle-slider"></span>
                                    </label>
                                </div>
                                <div class="feature-toggle">
                                    <div>
                                        <p class="font-semibold">Analytics Anónimo</p>
                                        <p class="text-sm text-text-secondary">Ayúdanos a mejorar con datos anónimos</p>
                                    </div>
                                    <label class="toggle-switch">
                                        <input type="checkbox" id="privacy-analytics" checked>
                                        <span class="toggle-slider"></span>
                                    </label>
                                </div>
                            </div>
                        </div>

                        <div class="config-card">
                            <div class="config-card-header">
                                <h3>Descargar tus Datos</h3>
                            </div>
                            <div class="config-card-body">
                                <p class="text-text-secondary mb-4">
                                    Descarga una copia completa de todos tus datos personales y operaciones según GDPR
                                </p>
                                <button class="btn-outline">
                                    <i class="fas fa-download mr-2"></i>Solicitar Descarga de Datos
                                </button>
                            </div>
                        </div>

                        <div class="config-card border-danger">
                            <div class="config-card-header">
                                <h3>Eliminar Cuenta</h3>
                            </div>
                            <div class="config-card-body">
                                <div class="alert alert-danger mb-4">
                                    <i class="fas fa-exclamation-triangle"></i>
                                    <p class="font-semibold">Esta acción es permanente e irreversible</p>
                                    <p class="text-sm mt-1">Se eliminarán todos tus datos, operaciones y configuraciones</p>
                                </div>
                                <button class="btn-danger" id="delete-account-btn">
                                    <i class="fas fa-user-times mr-2"></i>Eliminar mi Cuenta
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- NUEVA SECCIÓN: PLATAFORMAS -->
        <section id="platforms" class="section-container">
            <h2 class="text-xl font-semibold mb-6">Plataformas de Trading</h2>

            <!-- Grid de Plataformas -->
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">

                <!-- BingX -->
                <div class="platform-card cursor-pointer" data-platform="bingx">
                    <div class="metric-card p-6 hover:bg-surface-light transition-all">
                        <div class="flex items-center mb-4">
                            <div class="w-16 h-16 rounded-xl flex items-center justify-center mr-4 bg-[#006FFF] overflow-hidden">
                                <img src="logos/bingx-logo.png" alt="BingX Logo" class="rounded-xl" style="width: 56px; height: 56px; object-fit: contain;" loading="lazy">
                            </div>
                            <div>
                                <h3 class="text-lg font-bold">BingX</h3>
                                <p class="text-sm text-text-secondary">Exchange Global</p>
                            </div>
                        </div>
                        <div class="space-y-2 text-sm">
                            <div class="flex justify-between">
                                <span class="text-text-secondary">Estado:</span>
                                <span id="bingx-status-indicator" class="text-yellow-400">No conectado</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-text-secondary">Última sync:</span>
                                <span id="bingx-last-sync" class="text-text-secondary">Nunca</span>
                            </div>
                        </div>
                        <div class="mt-4 flex space-x-2">
                            <div class="flex-1 h-2 bg-surface rounded-full overflow-hidden">
                                <div id="bingx-progress-bar" class="h-full bg-primary transition-all duration-300" style="width: 0%"></div>
                            </div>
                        </div>
                        <div class="mt-4 flex justify-end space-x-2">
                            <button id="bingx-import-csv" class="bg-green-600 hover:bg-green-700 text-white text-xs px-3 py-1.5 rounded-md flex items-center space-x-1 transition-colors" title="Importar CSV de BingX">
                                <i class="fas fa-file-csv text-xs"></i>
                                <span>CSV</span>
                            </button>
                            <button id="bingx-quick-sync" class="bg-green-600 hover:bg-green-700 text-white text-xs px-3 py-1.5 rounded-md flex items-center space-x-1 transition-colors" title="Sincronizar con BingX">
                                <i class="fas fa-sync-alt text-xs"></i>
                                <span>API</span>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- NinjaTrader -->
                <div class="platform-card cursor-pointer" data-platform="ninjatrader">
                    <div class="metric-card p-6 hover:bg-surface-light transition-all">
                        <div class="flex items-center mb-4">
                            <div class="w-16 h-16 rounded-xl flex items-center justify-center mr-4 bg-[#FF6600] overflow-hidden">
                                <img src="logos/ninja-logo.png" alt="NinjaTrader" class="w-full h-full object-contain" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';" loading="lazy">
                                <i class="fas fa-chart-bar text-4xl text-white" style="display:none;"></i>
                            </div>
                            <div>
                                <h3 class="text-lg font-bold">NinjaTrader 8</h3>
                                <p class="text-sm text-text-secondary">API Automation</p>
                            </div>
                        </div>
                        <div class="space-y-2 text-sm">
                            <div class="flex justify-between">
                                <span class="text-text-secondary">Estado:</span>
                                <span id="ninjatrader-status-indicator" class="text-yellow-400">No conectado</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-text-secondary">Última sync:</span>
                                <span id="ninjatrader-last-sync" class="text-text-secondary">Nunca</span>
                            </div>
                        </div>
                        <div class="mt-4 flex space-x-2">
                            <div class="flex-1 h-2 bg-surface rounded-full overflow-hidden">
                                <div id="ninjatrader-progress-bar" class="h-full bg-primary transition-all duration-300" style="width: 0%"></div>
                            </div>
                        </div>
                        <div class="mt-4 flex justify-end space-x-2">
                            <button id="ninjatrader-import-csv" class="bg-green-600 hover:bg-green-700 text-white text-xs px-3 py-1.5 rounded-md flex items-center space-x-1 transition-colors" title="Importar CSV de NinjaTrader">
                                <i class="fas fa-file-csv text-xs"></i>
                                <span>CSV</span>
                            </button>
                            <!-- Sync eliminado: Solo CSV manual para evitar egress -->
                        </div>
                    </div>
                </div>

                <!-- Tradovate -->
                <div class="platform-card cursor-pointer" data-platform="tradovate">
                    <div class="metric-card p-6 hover:bg-surface-light transition-all">
                        <div class="flex items-center mb-4">
                            <div class="w-16 h-16 rounded-xl flex items-center justify-center mr-4 bg-[#0066CC] overflow-hidden">
                                <img src="logos/tradovate-logo.png" alt="Tradovate Logo" class="rounded-xl" style="width: 56px; height: 56px; object-fit: contain;" loading="lazy">
                            </div>
                            <div>
                                <h3 class="text-lg font-bold">Tradovate</h3>
                                <p class="text-sm text-text-secondary">Futures Trading</p>
                            </div>
                        </div>
                        <div class="space-y-2 text-sm">
                            <div class="flex justify-between">
                                <span class="text-text-secondary">Estado:</span>
                                <span id="tradovate-status-indicator" class="text-yellow-400">No conectado</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-text-secondary">Última sync:</span>
                                <span id="tradovate-last-sync" class="text-text-secondary">Nunca</span>
                            </div>
                        </div>
                        <div class="mt-4 flex space-x-2">
                            <div class="flex-1 h-2 bg-surface rounded-full overflow-hidden">
                                <div id="tradovate-progress-bar" class="h-full bg-primary transition-all duration-300" style="width: 0%"></div>
                            </div>
                        </div>
                        <div class="mt-4 flex justify-end space-x-2">
                            <button id="tradovate-import-csv" class="bg-green-600 hover:bg-green-700 text-white text-xs px-3 py-1.5 rounded-md flex items-center space-x-1 transition-colors" title="Importar CSV de Tradovate">
                                <i class="fas fa-file-csv text-xs"></i>
                                <span>CSV</span>
                            </button>
                            <!-- API eliminado: Solo CSV manual para evitar egress -->
                        </div>
                    </div>
                </div>

                <!-- Bitget -->
                <div class="platform-card cursor-pointer" data-platform="bitget">
                    <div class="metric-card p-6 hover:bg-surface-light transition-all">
                        <div class="flex items-center mb-4">
                            <div class="w-16 h-16 rounded-xl flex items-center justify-center mr-4 bg-[#54FDD5] overflow-hidden">
                                <img src="logos/bitget-logo.png" alt="Bitget Logo" class="rounded-xl" style="width: 56px; height: 56px; object-fit: contain;" loading="lazy">
                            </div>
                            <div>
                                <h3 class="text-lg font-bold">Bitget</h3>
                                <p class="text-sm text-text-secondary">Exchange Global</p>
                            </div>
                        </div>
                        <div class="space-y-2 text-sm">
                            <div class="flex justify-between">
                                <span class="text-text-secondary">Estado:</span>
                                <span id="bitget-status-indicator" class="text-yellow-400">No conectado</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-text-secondary">Última sync:</span>
                                <span id="bitget-last-sync" class="text-text-secondary">Nunca</span>
                            </div>
                        </div>
                        <div class="mt-4 flex space-x-2">
                            <div class="flex-1 h-2 bg-surface rounded-full overflow-hidden">
                                <div id="bitget-progress-bar" class="h-full bg-primary transition-all duration-300" style="width: 0%"></div>
                            </div>
                        </div>
                        <div class="mt-4 flex justify-end space-x-2">
                            <button id="bitget-import-csv" class="bg-green-600 hover:bg-green-700 text-white text-xs px-3 py-1.5 rounded-md flex items-center space-x-1 transition-colors" title="Importar CSV de Bitget">
                                <i class="fas fa-file-csv text-xs"></i>
                                <span>CSV</span>
                            </button>
                            <button id="bitget-quick-sync" class="bg-green-600 hover:bg-green-700 text-white text-xs px-3 py-1.5 rounded-md flex items-center space-x-1 transition-colors" title="Sincronizar con Bitget">
                                <i class="fas fa-sync-alt text-xs"></i>
                                <span>API</span>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Binance -->
                <div class="platform-card cursor-pointer" data-platform="binance">
                    <div class="metric-card p-6 hover:bg-surface-light transition-all opacity-50">
                        <div class="flex items-center mb-4">
                            <div class="w-16 h-16 rounded-xl flex items-center justify-center mr-4 bg-[#F3BA2F] overflow-hidden">
                                <img src="logos/binance-logo.png" alt="Binance Logo" class="rounded-xl" style="width: 56px; height: 56px; object-fit: contain;" loading="lazy">
                            </div>
                            <div>
                                <h3 class="text-lg font-bold">Binance</h3>
                                <p class="text-sm text-text-secondary">Exchange Líder</p>
                            </div>
                        </div>
                        <div class="space-y-2 text-sm">
                            <div class="flex justify-between">
                                <span class="text-text-secondary">Estado:</span>
                                <span class="text-gray-500">Próximamente</span>
                            </div>
                        </div>
                        <div class="mt-4 text-center">
                            <span class="text-xs text-gray-500 bg-surface px-2 py-1 rounded">En desarrollo</span>
                        </div>
                    </div>
                </div>

                <!-- MEXC -->
                <div class="platform-card cursor-pointer" data-platform="mexc">
                    <div class="metric-card p-6 hover:bg-surface-light transition-all">
                        <div class="flex items-center mb-4">
                            <div class="w-16 h-16 rounded-xl flex items-center justify-center mr-4 bg-[#00C087] overflow-hidden">
                                <img src="logos/mexc-logo.png" alt="MEXC Logo" class="rounded-xl" style="width: 56px; height: 56px; object-fit: contain;" loading="lazy">
                            </div>
                            <div>
                                <h3 class="text-lg font-bold">MEXC</h3>
                                <p class="text-sm text-text-secondary">Exchange Global</p>
                            </div>
                        </div>
                        <div class="space-y-2 text-sm">
                            <div class="flex justify-between">
                                <span class="text-text-secondary">Estado:</span>
                                <span id="mexc-status-indicator" class="text-yellow-400">No conectado</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-text-secondary">Última sync:</span>
                                <span id="mexc-last-sync" class="text-text-secondary">Nunca</span>
                            </div>
                        </div>
                        <div class="mt-4 flex space-x-2">
                            <div class="flex-1 h-2 bg-surface rounded-full overflow-hidden">
                                <div id="mexc-progress-bar" class="h-full bg-primary transition-all duration-300" style="width: 0%"></div>
                            </div>
                        </div>
                        <div class="mt-4 flex justify-end space-x-2">
                            <button id="mexc-import-csv" class="bg-green-600 hover:bg-green-700 text-white text-xs px-3 py-1.5 rounded-md flex items-center space-x-1 transition-colors" title="Importar CSV de MEXC">
                                <i class="fas fa-file-csv text-xs"></i>
                                <span>CSV</span>
                            </button>
                            <button id="mexc-quick-sync" class="bg-green-600 hover:bg-green-700 text-white text-xs px-3 py-1.5 rounded-md flex items-center space-x-1 transition-colors" title="Sincronizar con MEXC">
                                <i class="fas fa-sync-alt text-xs"></i>
                                <span>API</span>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- TopStepX -->
                <div class="platform-card cursor-pointer" data-platform="topstepx">
                    <div class="metric-card p-6 hover:bg-surface-light transition-all">
                        <div class="flex items-center mb-4">
                            <div class="w-16 h-16 rounded-xl flex items-center justify-center mr-4 bg-[#1E40AF] overflow-hidden">
                                <img src="logos/topstepx-logo.png" alt="TopStepX Logo" class="rounded-xl" style="width: 56px; height: 56px; object-fit: contain;" loading="lazy">
                            </div>
                            <div>
                                <h3 class="text-lg font-bold">TopStepX</h3>
                                <p class="text-sm text-text-secondary">Prop Trading Firm</p>
                            </div>
                        </div>
                        <div class="space-y-2 text-sm">
                            <div class="flex justify-between">
                                <span class="text-text-secondary">Estado:</span>
                                <span id="topstepx-status-indicator" class="text-yellow-400">No conectado</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-text-secondary">Última sync:</span>
                                <span id="topstepx-last-sync" class="text-text-secondary">Nunca</span>
                            </div>
                        </div>
                        <div class="mt-4 flex space-x-2">
                            <div class="flex-1 h-2 bg-surface rounded-full overflow-hidden">
                                <div id="topstepx-progress-bar" class="h-full bg-primary transition-all duration-300" style="width: 0%"></div>
                            </div>
                        </div>
                        <div class="mt-4 flex justify-end space-x-2">
                            <button id="topstepx-import-csv" class="bg-green-600 hover:bg-green-700 text-white text-xs px-3 py-1.5 rounded-md flex items-center space-x-1 transition-colors" title="Importar CSV de TopStepX">
                                <i class="fas fa-file-csv text-xs"></i>
                                <span>CSV</span>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Bitunix -->
                <div class="platform-card cursor-pointer" data-platform="bitunix">
                    <div class="metric-card p-6 hover:bg-surface-light transition-all">
                        <div class="flex items-center mb-4">
                            <div class="w-16 h-16 rounded-xl flex items-center justify-center mr-4 bg-[#FF6B00] overflow-hidden">
                                <img src="logos/bitunix-logo.png" alt="Bitunix Logo" class="rounded-xl" style="width: 56px; height: 56px; object-fit: contain;" loading="lazy">
                            </div>
                            <div>
                                <h3 class="text-lg font-bold">Bitunix</h3>
                                <p class="text-sm text-text-secondary">Exchange Emergente</p>
                            </div>
                        </div>
                        <div class="space-y-2 text-sm">
                            <div class="flex justify-between">
                                <span class="text-text-secondary">Estado:</span>
                                <span id="bitunix-status-indicator" class="text-yellow-400">No conectado</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-text-secondary">Última sync:</span>
                                <span id="bitunix-last-sync" class="text-text-secondary">Nunca</span>
                            </div>
                        </div>
                        <div class="mt-4 flex space-x-2">
                            <div class="flex-1 h-2 bg-surface rounded-full overflow-hidden">
                                <div id="bitunix-progress-bar" class="h-full bg-primary transition-all duration-300" style="width: 0%"></div>
                            </div>
                        </div>
                        <div class="mt-4 flex justify-end space-x-2">
                            <button id="bitunix-import-csv" class="bg-green-600 hover:bg-green-700 text-white text-xs px-3 py-1.5 rounded-md flex items-center space-x-1 transition-colors" title="Importar CSV de Bitunix">
                                <i class="fas fa-file-csv text-xs"></i>
                                <span>CSV</span>
                            </button>
                            <button id="bitunix-quick-sync" class="bg-green-600 hover:bg-green-700 text-white text-xs px-3 py-1.5 rounded-md flex items-center space-x-1 transition-colors" title="Sincronizar con Bitunix">
                                <i class="fas fa-sync-alt text-xs"></i>
                                <span>API</span>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- LBank -->
                <div class="platform-card cursor-pointer" data-platform="lbank">
                    <div class="metric-card p-6 hover:bg-surface-light transition-all">
                        <div class="flex items-center mb-4">
                            <div class="w-16 h-16 rounded-xl flex items-center justify-center mr-4 bg-[#2E5BFF] overflow-hidden">
                                <img src="logos/lbank-logo.png" alt="LBank Logo" class="rounded-xl" style="width: 56px; height: 56px; object-fit: contain;" loading="lazy">
                            </div>
                            <div>
                                <h3 class="text-lg font-bold">LBank</h3>
                                <p class="text-sm text-text-secondary">Exchange Global</p>
                            </div>
                        </div>
                        <div class="space-y-2 text-sm">
                            <div class="flex justify-between">
                                <span class="text-text-secondary">Estado:</span>
                                <span id="lbank-status-indicator" class="text-yellow-400">No conectado</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-text-secondary">Última sync:</span>
                                <span id="lbank-last-sync" class="text-text-secondary">Nunca</span>
                            </div>
                        </div>
                        <div class="mt-4 flex space-x-2">
                            <div class="flex-1 h-2 bg-surface rounded-full overflow-hidden">
                                <div id="lbank-progress-bar" class="h-full bg-primary transition-all duration-300" style="width: 0%"></div>
                            </div>
                        </div>
                        <div class="mt-4 flex justify-end space-x-2">
                            <button id="lbank-import-csv" class="bg-green-600 hover:bg-green-700 text-white text-xs px-3 py-1.5 rounded-md flex items-center space-x-1 transition-colors" title="Importar CSV de LBank">
                                <i class="fas fa-file-csv text-xs"></i>
                                <span>CSV</span>
                            </button>
                            <button id="lbank-quick-sync" class="bg-green-600 hover:bg-green-700 text-white text-xs px-3 py-1.5 rounded-md flex items-center space-x-1 transition-colors" title="Sincronizar con LBank">
                                <i class="fas fa-sync-alt text-xs"></i>
                                <span>API</span>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- BloFin -->
                <div class="platform-card cursor-pointer" data-platform="blofin">
                    <div class="metric-card p-6 hover:bg-surface-light transition-all">
                        <div class="flex items-center mb-4">
                            <div class="w-16 h-16 rounded-xl flex items-center justify-center mr-4 bg-[#00C9A7] overflow-hidden">
                                <img src="logos/blofin-logo.png" alt="BloFin Logo" class="rounded-xl" style="width: 56px; height: 56px; object-fit: contain;" loading="lazy">
                            </div>
                            <div>
                                <h3 class="text-lg font-bold">BloFin</h3>
                                <p class="text-sm text-text-secondary">Exchange Global</p>
                            </div>
                        </div>
                        <div class="space-y-2 text-sm">
                            <div class="flex justify-between">
                                <span class="text-text-secondary">Estado:</span>
                                <span id="blofin-status-indicator" class="text-yellow-400">No conectado</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-text-secondary">Última sync:</span>
                                <span id="blofin-last-sync" class="text-text-secondary">Nunca</span>
                            </div>
                        </div>
                        <div class="mt-4 flex space-x-2">
                            <div class="flex-1 h-2 bg-surface rounded-full overflow-hidden">
                                <div id="blofin-progress-bar" class="h-full bg-primary transition-all duration-300" style="width: 0%"></div>
                            </div>
                        </div>
                        <div class="mt-4 flex justify-end space-x-2">
                            <button id="blofin-import-csv" class="bg-green-600 hover:bg-green-700 text-white text-xs px-3 py-1.5 rounded-md flex items-center space-x-1 transition-colors" title="Importar CSV de BloFin">
                                <i class="fas fa-file-csv text-xs"></i>
                                <span>CSV</span>
                            </button>
                            <button id="blofin-quick-sync" class="bg-green-600 hover:bg-green-700 text-white text-xs px-3 py-1.5 rounded-md flex items-center space-x-1 transition-colors" title="Sincronizar con BloFin">
                                <i class="fas fa-sync-alt text-xs"></i>
                                <span>API</span>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- PrimeXBT Crypto -->
                <div class="platform-card cursor-pointer" data-platform="primexbtcrypto">
                    <div class="metric-card p-6 hover:bg-surface-light transition-all">
                        <div class="flex items-center mb-4">
                            <div class="w-16 h-16 rounded-xl flex items-center justify-center mr-4 bg-[#FF6B35] overflow-hidden">
                                <img src="logos/primexbt-logo.png" alt="PrimeXBT Logo" class="rounded-xl" style="width: 56px; height: 56px; object-fit: contain;">
                            </div>
                            <div>
                                <h3 class="text-lg font-bold">PrimeXBT Crypto</h3>
                                <p class="text-sm text-text-secondary">Exchange Global</p>
                            </div>
                        </div>
                        <div class="space-y-2 text-sm">
                            <div class="flex justify-between">
                                <span class="text-text-secondary">Estado:</span>
                                <span class="text-yellow-400">Importación manual</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-text-secondary">Última sync:</span>
                                <span class="text-text-secondary">Manual</span>
                            </div>
                        </div>
                        <div class="mt-4 flex space-x-2">
                            <div class="flex-1 h-2 bg-surface rounded-full overflow-hidden">
                                <div class="h-full bg-primary transition-all duration-300" style="width: 0%"></div>
                            </div>
                        </div>
                        <div class="mt-4 flex justify-end space-x-2">
                            <button id="primexbt-crypto-import-csv" class="bg-green-600 hover:bg-green-700 text-white text-xs px-3 py-1.5 rounded-md flex items-center space-x-1 transition-colors" title="Importar CSV de PrimeXBT Crypto">
                                <i class="fas fa-file-csv text-xs"></i>
                                <span>CSV</span>
                            </button>
                            <button id="primexbt-crypto-import-interface" class="bg-yellow-600 hover:bg-yellow-700 text-white text-xs px-3 py-1.5 rounded-md flex items-center space-x-1 transition-colors" title="Importar desde Interfaz de PrimeXBT">
                                <i class="fas fa-paste text-xs"></i>
                                <span>Interfaz</span>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- PrimeXBT CFDs -->
                <div class="platform-card cursor-pointer" data-platform="primexbtcfds">
                    <div class="metric-card p-6 hover:bg-surface-light transition-all">
                        <div class="flex items-center mb-4">
                            <div class="w-16 h-16 rounded-xl flex items-center justify-center mr-4 bg-[#FF6B35] overflow-hidden">
                                <img src="logos/primexbt-logo.png" alt="PrimeXBT Logo" class="rounded-xl" style="width: 56px; height: 56px; object-fit: contain;">
                            </div>
                            <div>
                                <h3 class="text-lg font-bold">PrimeXBT CFDs</h3>
                                <p class="text-sm text-text-secondary">Plataforma Profesional</p>
                            </div>
                        </div>
                        <div class="space-y-2 text-sm">
                            <div class="flex justify-between">
                                <span class="text-text-secondary">Estado:</span>
                                <span class="text-yellow-400">Importación manual</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-text-secondary">Última sync:</span>
                                <span class="text-text-secondary">Manual</span>
                            </div>
                        </div>
                        <div class="mt-4 flex space-x-2">
                            <div class="flex-1 h-2 bg-surface rounded-full overflow-hidden">
                                <div class="h-full bg-primary transition-all duration-300" style="width: 0%"></div>
                            </div>
                        </div>
                        <div class="mt-4 flex justify-end space-x-2">
                            <button id="primexbt-cfds-import-csv" class="bg-green-600 hover:bg-green-700 text-white text-xs px-3 py-1.5 rounded-md flex items-center space-x-1 transition-colors" title="Importar CSV de PrimeXBT CFDs">
                                <i class="fas fa-file-csv text-xs"></i>
                                <span>CSV</span>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- MetaTrader 4 -->
                <div class="platform-card cursor-pointer" data-platform="metatrader4">
                    <div class="metric-card p-6 hover:bg-surface-light transition-all">
                        <div class="flex items-center mb-4">
                            <div class="w-16 h-16 rounded-xl flex items-center justify-center mr-4 bg-[#1B5E20] overflow-hidden">
                                <img src="logos/metatrader 4-logo.png" alt="MetaTrader 4 Logo" class="rounded-xl" style="width: 56px; height: 56px; object-fit: contain;">
                            </div>
                            <div>
                                <h3 class="text-lg font-bold">MetaTrader 4</h3>
                                <p class="text-sm text-text-secondary">Plataforma Clásica</p>
                            </div>
                        </div>
                        <div class="space-y-2 text-sm">
                            <div class="flex justify-between">
                                <span class="text-text-secondary">Estado:</span>
                                <span class="text-gray-500">Importación manual</span>
                            </div>
                        </div>
                        <div class="mt-4 flex justify-end space-x-2">
                            <button id="mt4-import-html" class="bg-green-600 hover:bg-green-700 text-white text-xs px-3 py-1.5 rounded-md flex items-center space-x-1 transition-colors" title="Importar Informe HTML de MT4">
                                <i class="fas fa-file-code text-xs"></i>
                                <span>HTML</span>
                            </button>
                            <button id="mt4-clean-operations" class="bg-red-600 hover:bg-red-700 text-white text-xs px-3 py-1.5 rounded-md flex items-center space-x-1 transition-colors" title="Limpiar operaciones con errores">
                                <i class="fas fa-broom text-xs"></i>
                                <span>Limpiar</span>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- MetaTrader 5 -->
                <div class="platform-card cursor-pointer" data-platform="metatrader5">
                    <div class="metric-card p-6 hover:bg-surface-light transition-all">
                        <div class="flex items-center mb-4">
                            <div class="w-16 h-16 rounded-xl flex items-center justify-center mr-4 bg-[#1B5E20] overflow-hidden">
                                <img src="logos/metatrader5-logo.png" alt="MetaTrader 5 Logo" class="rounded-xl" style="width: 56px; height: 56px; object-fit: contain;">
                            </div>
                            <div>
                                <h3 class="text-lg font-bold">MetaTrader 5</h3>
                                <p class="text-sm text-text-secondary">Plataforma Profesional</p>
                            </div>
                        </div>
                        <div class="space-y-2 text-sm">
                            <div class="flex justify-between">
                                <span class="text-text-secondary">Estado:</span>
                                <span class="text-gray-500">Importación manual</span>
                            </div>
                        </div>
                        <div class="mt-4 flex justify-end space-x-2">
                            <button id="mt5-import-html" class="bg-green-600 hover:bg-green-700 text-white text-xs px-3 py-1.5 rounded-md flex items-center space-x-1 transition-colors" title="Importar Informe HTML de MT5">
                                <i class="fas fa-file-code text-xs"></i>
                                <span>HTML</span>
                            </button>
                            <button id="mt5-clean-operations" class="bg-red-600 hover:bg-red-700 text-white text-xs px-3 py-1.5 rounded-md flex items-center space-x-1 transition-colors" title="Limpiar operaciones con errores">
                                <i class="fas fa-broom text-xs"></i>
                                <span>Limpiar</span>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- cTrader -->
                <div class="platform-card cursor-pointer" data-platform="ctrader">
                    <div class="metric-card p-6 hover:bg-surface-light transition-all">
                        <div class="flex items-center mb-4">
                            <div class="w-16 h-16 rounded-xl flex items-center justify-center mr-4 bg-[#00A8E1] overflow-hidden">
                                <img src="logos/ctrader-logo.png" alt="cTrader Logo" class="rounded-xl" style="width: 56px; height: 56px; object-fit: contain;">
                            </div>
                            <div>
                                <h3 class="text-lg font-bold">cTrader</h3>
                                <p class="text-sm text-text-secondary">Plataforma Avanzada</p>
                            </div>
                        </div>
                        <div class="space-y-2 text-sm">
                            <div class="flex justify-between">
                                <span class="text-text-secondary">Estado:</span>
                                <span class="text-gray-500">Importación manual</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-text-secondary">Formato:</span>
                                <span class="text-white">HTML Statement</span>
                            </div>
                        </div>
                        <div class="mt-4 flex justify-end space-x-2">
                            <button id="ctrader-import-html" class="bg-green-600 hover:bg-green-700 text-white text-xs px-3 py-1.5 rounded-md flex items-center space-x-1 transition-colors" title="Importar HTML Statement de cTrader">
                                <i class="fas fa-file-code text-xs"></i>
                                <span>HTML</span>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- TradingView -->
                <div class="platform-card cursor-pointer" data-platform="tradingview">
                    <div class="metric-card p-6 hover:bg-surface-light transition-all">
                        <div class="flex items-center mb-4">
                            <div class="w-16 h-16 rounded-xl flex items-center justify-center mr-4 bg-[#2962FF] overflow-hidden">
                                <img src="logos/tradingview-logo.png" alt="TradingView Logo" class="rounded-xl" style="width: 56px; height: 56px; object-fit: contain;">
                            </div>
                            <div>
                                <h3 class="text-lg font-bold">TradingView</h3>
                                <p class="text-sm text-text-secondary">Webhooks & Estrategias</p>
                            </div>
                        </div>
                        <div class="space-y-2 text-sm">
                            <div class="flex justify-between">
                                <span class="text-text-secondary">Estado:</span>
                                <span id="tradingview-status" class="text-yellow-500">⚠️ No configurado</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-text-secondary">Webhook:</span>
                                <span id="tradingview-webhook-status" class="text-xs text-text-secondary">Sin configurar</span>
                            </div>
                        </div>
                        <div class="mt-4 text-center">
                            <span class="text-xs text-green bg-green/10 px-2 py-1 rounded">✨ Configurar Webhooks</span>
                        </div>
                    </div>
                </div>

            </div>
        </section>

        <!-- PANTALLA DETALLADA DE TRADINGVIEW -->
        <section id="platform-tradingview" class="section-container" style="display: none;">
            <div class="platform-detail-container">
                <!-- Header -->
                <div class="platform-detail-header">
                    <div class="platform-detail-back" id="back-to-platforms-tradingview">
                        <i class="fas fa-arrow-left"></i>
                    </div>
                    <div class="platform-logo" style="background: #2962FF;">
                        <img src="logos/tradingview-logo.png" alt="TradingView Logo" style="width: 56px; height: 56px; object-fit: contain;">
                    </div>
                    <div>
                        <h2 class="text-2xl font-bold">TradingView</h2>
                        <p class="text-text-secondary">Webhooks & Auto-Import</p>
                    </div>
                </div>

                <!-- Status Card -->
                <div class="metric-card p-6 mb-6">
                    <div class="flex items-center justify-between">
                        <div>
                            <h3 class="text-lg font-bold mb-2">Estado del Webhook</h3>
                            <p id="tradingview-detail-status" class="text-sm text-text-secondary">Sin configurar</p>
                        </div>
                        <div id="tradingview-detail-indicator" class="w-4 h-4 rounded-full bg-gray-500"></div>
                    </div>
                </div>

                <!-- Configuración Webhook -->
                <div class="metric-card p-6 mb-6">
                    <h3 class="text-lg font-bold mb-4">⚙️ Configuración del Webhook</h3>
                    
                    <div class="space-y-4">
                        <!-- URL del Webhook -->
                        <div>
                            <label class="block text-sm font-medium mb-2">URL del Webhook</label>
                            <div class="flex gap-2">
                                <input type="text" id="tradingview-webhook-url" 
                                    value="http://localhost:8003/webhook/tradingview"
                                    class="flex-1 bg-surface text-text-primary px-4 py-3 rounded-lg border border-primary/20 focus:border-primary focus:outline-none"
                                    readonly>
                                <button id="copy-webhook-url" class="btn-primary px-4">
                                    <i class="fas fa-copy"></i>
                                </button>
                            </div>
                            <p class="text-xs text-text-secondary mt-2">
                                💡 Copia esta URL y úsala en las alertas de TradingView
                            </p>
                        </div>

                        <!-- Seleccionar Cuenta -->
                        <div>
                            <label class="block text-sm font-medium mb-2">Cuenta Destino</label>
                            <select id="tradingview-account-select" 
                                class="w-full bg-surface text-text-primary px-4 py-3 rounded-lg border border-primary/20 focus:border-primary focus:outline-none">
                                <option value="">Selecciona una cuenta...</option>
                            </select>
                            <p class="text-xs text-text-secondary mt-2">
                                Los trades del webhook se guardarán en esta cuenta
                            </p>
                        </div>

                        <!-- ID de Cuenta para TradingView -->
                        <div id="tradingview-account-id-section" style="display: none;">
                            <label class="block text-sm font-medium mb-2">Account ID para TradingView</label>
                            <div class="flex gap-2">
                                <input type="text" id="tradingview-account-id" 
                                    class="flex-1 bg-surface text-text-primary px-4 py-3 rounded-lg border border-primary/20 focus:border-primary focus:outline-none"
                                    readonly>
                                <button id="copy-account-id" class="btn-primary px-4">
                                    <i class="fas fa-copy"></i>
                                </button>
                            </div>
                            <p class="text-xs text-text-secondary mt-2">
                                ⚠️ Usa este ID en el campo <code class="bg-surface-light px-1 rounded">accountId</code> del mensaje JSON de tu alerta
                            </p>
                        </div>

                        <!-- Botones de Acción -->
                        <div class="flex gap-3 mt-6">
                            <button id="tradingview-test-webhook" class="btn-secondary flex-1">
                                <i class="fas fa-vial mr-2"></i>
                                Probar Webhook
                            </button>
                            <button id="tradingview-save-config" class="btn-primary flex-1">
                                <i class="fas fa-save mr-2"></i>
                                Guardar Configuración
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Instrucciones -->
                <div class="metric-card p-6 mb-6" style="background: #000; border: 2px solid #00ff88;">
                    <h3 class="text-lg font-bold mb-4" style="color: #fff;">
                        <i class="fas fa-book mr-2" style="color: #00ff88;"></i>
                        📚 Cómo Configurar Webhooks en TradingView
                    </h3>
                    
                    <div class="space-y-4 text-sm" style="color: #fff; line-height: 1.8;">
                        <div style="background: rgba(0,255,136,0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #00ff88;">
                            <p style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">💡 TradingView Webhooks</p>
                            <p>TradingView envía alertas automáticas a Trading Survivor mediante webhooks. Cada vez que tu estrategia ejecuta una orden, se registra automáticamente aquí.</p>
                        </div>

                        <div style="background: rgba(0,255,136,0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #00ff88;">
                            <p style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">📝 Paso 1: Selecciona la Cuenta Destino</p>
                            <p style="margin-bottom: 8px;">En la sección "Configuración del Webhook" arriba:</p>
                            <ol style="list-style: decimal; margin-left: 20px; line-height: 1.8;">
                                <li>Selecciona la <strong>cuenta destino</strong> donde se guardarán los trades</li>
                                <li>Copia el <strong>Account ID</strong> que aparece (lo necesitarás para el JSON)</li>
                                <li>Click en <strong>"Guardar Configuración"</strong></li>
                            </ol>
                        </div>

                        <div style="background: rgba(0,255,136,0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #00ff88;">
                            <p style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">🔗 Paso 2: Copia la URL del Webhook</p>
                            <p style="margin-bottom: 8px;">La URL del webhook es:</p>
                            <div style="background: rgba(0,0,0,0.5); padding: 12px; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 12px; overflow-x: auto;">
                                http://localhost:8003/webhook/tradingview
                            </div>
                            <p style="margin-top: 12px;">Click en el botón de <strong>copiar</strong> junto a la URL arriba.</p>
                        </div>

                        <div style="background: rgba(0,255,136,0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #00ff88;">
                            <p style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">🔔 Paso 3: Crea una Alerta en TradingView</p>
                            <ol style="list-style: decimal; margin-left: 20px; line-height: 1.8;">
                                <li>En tu gráfico de TradingView, agrega tu estrategia</li>
                                <li>Click derecho en el chart → <strong>"Add Alert"</strong></li>
                                <li>En "Condition" selecciona tu estrategia</li>
                                <li>En "Webhook URL" pega la URL que copiaste</li>
                            </ol>
                        </div>

                        <div style="background: rgba(0,255,136,0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #00ff88;">
                            <p style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">📋 Paso 4: Configura el Mensaje JSON</p>
                            <p style="margin-bottom: 8px;">En el campo "Message" de la alerta, pega este JSON:</p>
                            <pre style="background: rgba(0,0,0,0.7); padding: 12px; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 11px; overflow-x: auto; line-height: 1.6;">{
  "accountId": "<span style="color: #fbbf24;">TU_ACCOUNT_ID</span>",
  "symbol": "{{ticker}}",
  "action": "{{strategy.order.action}}",
  "contracts": {{strategy.order.contracts}},
  "price": {{strategy.order.price}},
  "orderType": "market",
  "timestamp": "{{timenow}}",
  "orderId": "{{strategy.order.id}}",
  "comment": "{{strategy.order.comment}}"
}</pre>
                            <p style="margin-top: 12px; color: #fbbf24;">⚠️ <strong>Importante:</strong> Reemplaza <code style="background: rgba(0,0,0,0.5); padding: 2px 6px; border-radius: 4px;">TU_ACCOUNT_ID</code> con el Account ID que copiaste en el Paso 1.</p>
                        </div>

                        <div style="background: rgba(0,255,136,0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #00ff88;">
                            <p style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">🚀 Paso 5: Activa la Alerta</p>
                            <ol style="list-style: decimal; margin-left: 20px; line-height: 1.8;">
                                <li>Asegúrate de marcar <strong>"Webhook URL"</strong> en "Notifications"</li>
                                <li>Click en <strong>"Create"</strong></li>
                                <li>¡Listo! Ahora cada orden se registrará automáticamente</li>
                            </ol>
                        </div>

                        <div style="background: rgba(234,179,8,0.1); padding: 12px; border-radius: 8px; margin-top: 16px; border-left: 4px solid #eab308;">
                            <p style="color: #fbbf24; font-weight: 600;">⚠️ Servidor Proxy Requerido</p>
                            <p style="margin-top: 6px;">Asegúrate de que el servidor proxy esté corriendo en puerto 8003 antes de operar. Ejecuta en terminal:</p>
                            <div style="background: rgba(0,0,0,0.5); padding: 8px; border-radius: 4px; font-family: 'Courier New', monospace; font-size: 12px; margin-top: 8px;">
                                node proxy-server.js
                            </div>
                        </div>

                        <div style="background: rgba(59,130,246,0.1); padding: 12px; border-radius: 8px; margin-top: 16px; border-left: 4px solid #60a5fa;">
                            <p style="color: #60a5fa; font-weight: 600;">💡 Consejo Pro</p>
                            <p style="margin-top: 6px;">TradingView Pro+ permite webhooks ilimitados. Con plan gratuito, puedes usar webhooks pero con límites. Los webhooks funcionan en tiempo real para registrar todas tus operaciones automáticamente.</p>
                        </div>
                    </div>
                </div>

                <!-- Últimos Webhooks Recibidos -->
                <div class="metric-card p-6">
                    <h3 class="text-lg font-bold mb-4">📥 Últimos Webhooks Recibidos</h3>
                    <div id="tradingview-webhook-log" class="space-y-2 max-h-64 overflow-y-auto">
                        <p class="text-sm text-text-secondary text-center py-8">No hay webhooks recibidos aún</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- PANTALLA DETALLADA DE TRADOVATE -->
        <section id="platform-tradovate" class="section-container" style="display: none;">
            <div class="platform-detail-container">
                <!-- Header -->
                <div class="platform-detail-header">
                    <div class="platform-detail-back" id="back-to-platforms-tradovate">
                        <i class="fas fa-arrow-left"></i>
                    </div>
                    <div class="platform-logo" style="background: #0066CC;">
                        <img src="logos/tradovate-logo.png" alt="Tradovate Logo">
                    </div>
                    <div class="platform-detail-title">
                        <h2>Tradovate</h2>
                        <p>Importar Trades desde CSV</p>
                    </div>
                </div>

                <!-- Estado -->
                <div class="metric-card p-6 mb-6">
                    <div class="flex items-center justify-between">
                        <div class="flex items-center">
                            <div id="tradovate-detail-indicator" class="w-3 h-3 rounded-full bg-yellow-500 mr-3"></div>
                            <div>
                                <div class="text-sm text-text-secondary">Estado de Configuración</div>
                                <div id="tradovate-detail-status" class="text-lg font-semibold">No configurado</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Configuración -->
                <div class="metric-card p-6 mb-6">
                    <h3 class="text-lg font-semibold mb-4 flex items-center">
                        <i class="fas fa-cog mr-2 text-primary"></i>
                        Configuración de Importación
                    </h3>

                    <div class="space-y-4">
                        <!-- Cuenta Destino -->
                        <div>
                            <label class="block text-sm font-medium mb-2">Selecciona la cuenta donde importar</label>
                            <select id="tradovate-account-select" class="w-full bg-surface border border-border rounded-lg px-4 py-2 focus:outline-none focus:border-primary">
                                <option value="">Selecciona una cuenta...</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Importar CSV -->
                <div class="metric-card p-6 mb-6">
                    <h3 class="text-lg font-semibold mb-4 flex items-center">
                        <i class="fas fa-file-csv mr-2 text-green-500"></i>
                        Importar Trades desde CSV
                    </h3>

                    <div class="space-y-4">
                        <div class="bg-surface-light p-4 rounded-lg border border-border">
                            <p class="text-sm mb-3">
                                <i class="fas fa-info-circle text-blue-400 mr-2"></i>
                                Exporta tus trades desde Tradovate en formato <strong>Performance.csv</strong>
                            </p>
                            <ol class="text-sm text-text-secondary space-y-1 ml-6 list-decimal">
                                <li>En TradingView → Panel de Tradovate → Pestaña "Performance"</li>
                                <li>Click en el botón de exportar (⋮ o icono descarga)</li>
                                <li>Selecciona "Performance" y descarga el CSV</li>
                                <li>Sube el archivo aquí abajo</li>
                            </ol>
                        </div>

                        <!-- File Input -->
                        <div class="border-2 border-dashed border-border rounded-lg p-8 text-center hover:border-primary transition-colors cursor-pointer" id="tradovate-csv-dropzone">
                            <input type="file" id="tradovate-csv-input" accept=".csv" class="hidden">
                            <i class="fas fa-cloud-upload-alt text-4xl text-text-secondary mb-3"></i>
                            <p class="text-sm font-medium mb-1">Click aquí o arrastra el archivo CSV</p>
                            <p class="text-xs text-text-secondary">Solo archivos Performance.csv de Tradovate</p>
                        </div>

                        <!-- File Info -->
                        <div id="tradovate-file-info" class="hidden bg-surface-light p-4 rounded-lg border border-green-500">
                            <div class="flex items-center justify-between">
                                <div class="flex items-center">
                                    <i class="fas fa-file-csv text-green-500 text-2xl mr-3"></i>
                                    <div>
                                        <p class="text-sm font-medium" id="tradovate-file-name">archivo.csv</p>
                                        <p class="text-xs text-text-secondary" id="tradovate-file-size">0 KB</p>
                                    </div>
                                </div>
                                <button id="tradovate-remove-file" class="text-red-500 hover:text-red-400">
                                    <i class="fas fa-times"></i>
                                </button>
                            </div>
                        </div>

                        <!-- Import Button -->
                        <button id="tradovate-import-btn" class="w-full bg-green-600 hover:bg-green-700 text-white py-3 rounded-lg font-semibold transition-colors disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                            <i class="fas fa-file-import mr-2"></i>
                            Importar Trades
                        </button>

                        <!-- Progress -->
                        <div id="tradovate-import-progress" class="hidden">
                            <div class="flex justify-between text-sm mb-2">
                                <span>Importando...</span>
                                <span id="tradovate-progress-text">0%</span>
                            </div>
                            <div class="h-2 bg-surface rounded-full overflow-hidden">
                                <div id="tradovate-progress-bar-import" class="h-full bg-green-500 transition-all" style="width: 0%"></div>
                            </div>
                        </div>

                        <!-- Results -->
                        <div id="tradovate-import-results" class="hidden bg-green-500/10 border border-green-500 rounded-lg p-4">
                            <p class="text-green-500 font-medium mb-2">
                                <i class="fas fa-check-circle mr-2"></i>
                                Importación completada
                            </p>
                            <div class="text-sm text-text-secondary space-y-1">
                                <p><strong id="tradovate-imported-count">0</strong> trades importados correctamente</p>
                                <p>Balance actualizado: <strong id="tradovate-final-balance">$0.00</strong></p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Instrucciones -->
                <div class="metric-card p-6" style="background: #000; border: 2px solid #00ff88;">
                    <h3 class="text-lg font-semibold mb-4 flex items-center" style="color: #fff;">
                        <i class="fas fa-book mr-2" style="color: #00ff88;"></i>
                        📚 Cómo Obtener el CSV de Tradovate
                    </h3>
                    <div class="space-y-4 text-sm" style="color: #fff; line-height: 1.8;">
                        <div style="background: rgba(0,255,136,0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #00ff88;">
                            <p style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">💡 Tradovate + TradingView</p>
                            <p>Tradovate funciona a través de TradingView. Exportarás el archivo CSV de rendimiento directamente desde el panel de Tradovate en TradingView.</p>
                        </div>

                        <div style="background: rgba(0,255,136,0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #00ff88;">
                            <p style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">📊 Paso 1: Abre TradingView con Tradovate</p>
                            <p>Inicia sesión en TradingView con tu cuenta de Tradovate conectada. Asegúrate de que el broker activo sea Tradovate.</p>
                        </div>

                        <div style="background: rgba(0,255,136,0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #00ff88;">
                            <p style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">📂 Paso 2: Abre el Panel de Tradovate</p>
                            <ol style="list-style: decimal; margin-left: 20px; line-height: 1.8;">
                                <li>En la parte inferior de TradingView, busca el panel <strong>"Tradovate"</strong></li>
                                <li>Si no lo ves, ve a <strong>Menú → Trading Panel</strong></li>
                            </ol>
                        </div>

                        <div style="background: rgba(0,255,136,0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #00ff88;">
                            <p style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">📈 Paso 3: Ve a la Pestaña "Performance"</p>
                            <p>Dentro del panel de Tradovate, haz click en la pestaña <strong>"Performance"</strong> (Rendimiento).</p>
                        </div>

                        <div style="background: rgba(0,255,136,0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #00ff88;">
                            <p style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">💾 Paso 4: Exporta el CSV</p>
                            <ol style="list-style: decimal; margin-left: 20px; line-height: 1.8;">
                                <li>Busca el botón de menú <strong>(⋮)</strong> o el icono de descarga</li>
                                <li>Click en <strong>"Exportar datos"</strong></li>
                                <li>Selecciona <strong>"Performance"</strong> como tipo de reporte</li>
                                <li>Descarga el archivo CSV a tu computadora</li>
                            </ol>
                        </div>

                        <div style="background: rgba(0,255,136,0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #00ff88;">
                            <p style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">📤 Paso 5: Importa en Trading Survivor</p>
                            <ol style="list-style: decimal; margin-left: 20px; line-height: 1.8;">
                                <li>Selecciona la cuenta destino arriba (donde se importarán los trades)</li>
                                <li>Arrastra el CSV al área de "Importar Trades desde CSV"</li>
                                <li>O haz click en el área y selecciona el archivo</li>
                                <li>Click en <strong>"Importar Trades"</strong></li>
                                <li>Espera a que termine la importación</li>
                            </ol>
                        </div>

                        <div style="background: rgba(59,130,246,0.1); padding: 12px; border-radius: 8px; margin-top: 16px; border-left: 4px solid #60a5fa;">
                            <p style="color: #60a5fa; font-weight: 600;">💡 Consejo Pro</p>
                            <p style="margin-top: 6px;">El CSV de Performance incluye todos tus trades con detalles completos: entrada, salida, P&L, comisiones, etc. Trading Survivor detecta automáticamente el formato de Tradovate.</p>
                        </div>

                        <div style="background: rgba(234,179,8,0.1); padding: 12px; border-radius: 8px; margin-top: 16px; border-left: 4px solid #eab308;">
                            <p style="color: #fbbf24; font-weight: 600;">⚠️ Importante</p>
                            <p style="margin-top: 6px;">Tradovate no ofrece API pública para sincronización automática. La importación manual con CSV es el método oficial recomendado.</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- PANTALLA DETALLADA DE NINJATRADER -->
        <section id="platform-ninjatrader" class="section-container" style="display: none;">
            <div class="platform-detail-container">
                <!-- Header -->
                <div class="platform-detail-header">
                    <div class="platform-detail-back" id="back-to-platforms-ninjatrader">
                        <i class="fas fa-arrow-left"></i>
                    </div>
                    <div class="platform-logo" style="background: #FF6600;">
                        <img src="logos/ninja-logo.png" alt="NinjaTrader" class="w-full h-full object-contain p-2" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                        <i class="fas fa-chart-bar text-4xl text-white" style="display:none;"></i>
                    </div>
                    <div class="platform-detail-title">
                        <h2>NinjaTrader 8</h2>
                        <p>Sincronización Automática de Archivos</p>
                    </div>
                </div>

                <!-- Estado -->
                <div class="metric-card p-6 mb-6">
                    <div class="flex items-center justify-between">
                        <div class="flex items-center">
                            <div id="ninjatrader-detail-indicator" class="w-3 h-3 rounded-full bg-yellow-500 mr-3"></div>
                            <div>
                                <div class="text-sm text-text-secondary">Estado</div>
                                <div id="ninjatrader-detail-status" class="text-lg font-semibold">No configurado</div>
                            </div>
                        </div>
                        <div class="text-right">
                            <div class="text-xs text-text-secondary">Última sincronización</div>
                            <div id="ninjatrader-last-sync-detail" class="text-sm font-medium">Nunca</div>
                        </div>
                    </div>
                </div>

                <!-- Botón Principal -->
                <div class="metric-card p-8 mb-6 text-center">
                    <div class="inline-flex items-center justify-center w-20 h-20 rounded-full bg-primary bg-opacity-20 mb-4">
                        <i class="fas fa-folder-open text-primary text-3xl"></i>
                    </div>
                    <h3 class="text-2xl font-bold mb-2">Sincronización Inteligente</h3>
                    <p class="text-text-secondary mb-6">Lee automáticamente tus trades desde los archivos de NinjaTrader</p>
                    
                    <button id="ninjatrader-sync-main" class="bg-primary hover:bg-primary-dark text-white px-8 py-4 rounded-lg font-bold text-lg transition-colors inline-flex items-center gap-3">
                        <i class="fas fa-sync-alt"></i>
                        <span>Sincronizar Ahora</span>
                    </button>

                    <div id="ninja-folder-selected" class="hidden mt-6 p-4 bg-green-500 bg-opacity-10 border border-green-500 rounded-lg">
                        <div class="flex items-center justify-center gap-2 text-green-500">
                            <i class="fas fa-check-circle"></i>
                            <span class="font-semibold">Carpeta configurada</span>
                        </div>
                        <p class="text-sm text-text-secondary mt-2">Las próximas sincronizaciones serán automáticas</p>
                    </div>
                </div>

                <!-- Cuentas Detectadas -->
                <div id="ninja-accounts-section" class="hidden metric-card p-6 mb-6">
                    <h3 class="text-lg font-semibold mb-4 flex items-center">
                        <i class="fas fa-users mr-2 text-accent"></i>
                        Cuentas Detectadas
                    </h3>
                    <div id="ninja-accounts-grid" class="grid grid-cols-2 gap-3">
                        <!-- Se llenará dinámicamente -->
                    </div>
                </div>

                <!-- Estadísticas Recientes -->
                <div id="ninja-stats-section" class="hidden metric-card p-6 mb-6">
                    <h3 class="text-lg font-semibold mb-4 flex items-center">
                        <i class="fas fa-chart-line mr-2 text-primary"></i>
                        Última Sincronización
                    </h3>
                    <div class="grid grid-cols-3 gap-4">
                        <div class="text-center p-4 bg-surface-light rounded-lg">
                            <div class="text-2xl font-bold text-primary" id="ninja-stat-trades">0</div>
                            <div class="text-xs text-text-secondary mt-1">Trades</div>
                        </div>
                        <div class="text-center p-4 bg-surface-light rounded-lg">
                            <div class="text-2xl font-bold text-accent" id="ninja-stat-accounts">0</div>
                            <div class="text-xs text-text-secondary mt-1">Cuentas</div>
                        </div>
                        <div class="text-center p-4 bg-surface-light rounded-lg">
                            <div class="text-2xl font-bold text-green-500" id="ninja-stat-files">0</div>
                            <div class="text-xs text-text-secondary mt-1">Archivos</div>
                        </div>
                    </div>
                </div>

                <!-- Instrucciones -->
                <div class="metric-card p-6" style="background: #000; border: 2px solid #00ff88;">
                    <h3 class="text-lg font-semibold mb-4 flex items-center" style="color: #fff;">
                        <i class="fas fa-book mr-2" style="color: #00ff88;"></i>
                        📚 Cómo Configurar NinjaTrader 8
                    </h3>
                    <div class="space-y-4 text-sm" style="color: #fff; line-height: 1.8;">
                        <div style="background: rgba(0,255,136,0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #00ff88;">
                            <p style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">💡 Sin Instalación - Sincronización Automática</p>
                            <p>NinjaTrader 8 no usa API. En su lugar, <strong>lee directamente tus archivos de ejecución</strong>. Solo selecciona la carpeta una vez y listo.</p>
                        </div>

                        <div style="background: rgba(0,255,136,0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #00ff88;">
                            <p style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">📂 Paso 1: Haz Click en "Sincronizar Ahora"</p>
                            <p>Haz click en el botón <strong>"Sincronizar Ahora"</strong> arriba. Se abrirá el explorador de archivos de Windows.</p>
                        </div>

                        <div style="background: rgba(0,255,136,0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #00ff88;">
                            <p style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">📁 Paso 2: Localiza la Carpeta de Ejecución</p>
                            <p style="margin-bottom: 8px;">Navega a la carpeta <strong>execution</strong> de NinjaTrader:</p>
                            <div style="background: rgba(0,0,0,0.5); padding: 12px; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 12px; overflow-x: auto;">
                                C:\Users\<span style="color: #fbbf24;">TuUsuario</span>\Documents\NinjaTrader 8\db\<span style="color: #00ff88;">execution</span>
                            </div>
                            <p style="margin-top: 12px; color: #60a5fa;">💡 <strong>Tip:</strong> Reemplaza "TuUsuario" con tu nombre de usuario de Windows.</p>
                        </div>

                        <div style="background: rgba(0,255,136,0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #00ff88;">
                            <p style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">✅ Paso 3: Selecciona la Carpeta</p>
                            <ul style="list-style: disc; margin-left: 20px; line-height: 1.8;">
                                <li>Haz click en la carpeta <strong>"execution"</strong></li>
                                <li>Presiona el botón <strong>"Seleccionar carpeta"</strong> del explorador</li>
                                <li>¡Listo! La sincronización comenzará automáticamente</li>
                            </ul>
                        </div>

                        <div style="background: rgba(0,255,136,0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #00ff88;">
                            <p style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">🔄 Paso 4: Asigna las Cuentas</p>
                            <p style="margin-bottom: 8px;">Después de la sincronización:</p>
                            <ul style="list-style: disc; margin-left: 20px; line-height: 1.8;">
                                <li>Se detectarán tus cuentas de NinjaTrader (Sim101, Live, Rithmic, etc.)</li>
                                <li>Asigna cada cuenta de NinjaTrader a una cuenta de Trading Survivor</li>
                                <li>Los trades se importarán automáticamente a las cuentas correspondientes</li>
                            </ul>
                        </div>

                        <div style="background: rgba(59,130,246,0.1); padding: 12px; border-radius: 8px; margin-top: 16px; border-left: 4px solid #60a5fa;">
                            <p style="color: #60a5fa; font-weight: 600;">💡 Multi-Cuenta Automático</p>
                            <p style="margin-top: 6px;">Si tienes varias cuentas en NinjaTrader (Sim, Live, Rithmic, etc.), todas se detectan y separan automáticamente. No necesitas configurar nada adicional.</p>
                        </div>

                        <div style="background: rgba(234,179,8,0.1); padding: 12px; border-radius: 8px; margin-top: 16px; border-left: 4px solid #eab308;">
                            <p style="color: #fbbf24; font-weight: 600;">⚠️ Importante</p>
                            <p style="margin-top: 6px;">La carpeta se guarda automáticamente. Las próximas sincronizaciones se harán con un solo click, sin necesidad de volver a seleccionar la carpeta.</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- PANTALLA DETALLADA DE BINGX -->
        <section id="platform-bingx" class="section-container" style="display: none;">
            <div class="platform-detail-container">
                <!-- Header -->
                <div class="platform-detail-header">
                    <div class="platform-detail-back" id="back-to-platforms-bingx">
                        <i class="fas fa-arrow-left"></i>
                    </div>
                    <div class="platform-logo" style="background: #006FFF;">
                        <img src="logos/bingx-logo.png" alt="BingX Logo">
                    </div>
                    <div class="platform-detail-title">
                        <h2>BingX Exchange</h2>
                        <p>Configuración y Sincronización</p>
                    </div>
                </div>

                <!-- Estado de Conexión -->
                <div id="bingx-connection-status" class="status-card status-card-warning mb-6">
                    <i class="fas fa-exclamation-triangle status-card-icon"></i>
                    <div>
                        <p class="font-semibold text-lg mb-1">No conectado</p>
                        <p class="text-sm opacity-90">Configure sus claves API para comenzar la sincronización automática.</p>
                    </div>
                </div>

                <!-- Tabs de Navegación -->
                <div class="platform-tabs">
                    <button class="platform-tab active" data-tab="api">
                        <i class="fas fa-key mr-2"></i>Conexión API
                    </button>
                    <button class="platform-tab" data-tab="csv">
                        <i class="fas fa-file-csv mr-2"></i>Importar CSV
                    </button>
                    <button class="platform-tab" data-tab="info">
                        <i class="fas fa-info-circle mr-2"></i>Información
                    </button>
                </div>

                <!-- Tab: Conexión API -->
                <div class="platform-tab-content active" id="bingx-tab-api">
                    <div class="metric-card mb-6">
                        <h3 class="text-xl font-semibold mb-6">Configuración de API</h3>

                        <div class="space-y-5">
                            <div>
                                <label class="block mb-2 font-semibold text-sm">
                                    <i class="fas fa-key mr-2 text-primary"></i>Clave API
                                </label>
                                <input type="password" id="bingx-api-key-detail" class="w-full" placeholder="Introduce tu clave API de BingX">
                                <p class="text-xs text-text-secondary mt-2">La clave API se almacena localmente y de forma segura</p>
                            </div>

                            <div>
                                <label class="block mb-2 font-semibold text-sm">
                                    <i class="fas fa-lock mr-2 text-primary"></i>Secret API
                                </label>
                                <input type="password" id="bingx-secret-key-detail" class="w-full" placeholder="Introduce tu secret de BingX">
                                <p class="text-xs text-text-secondary mt-2">El secret se encripta antes de almacenarse</p>
                            </div>

                            <div>
                                <label class="block mb-2 font-semibold text-sm">
                                    <i class="fas fa-wallet mr-2 text-primary"></i>Cuenta a sincronizar
                                </label>
                                <select id="bingx-account-detail" class="w-full">
                                    <option value="">Seleccionar cuenta...</option>
                                </select>
                                <p class="text-xs text-text-secondary mt-2">Selecciona la cuenta donde se guardarán las operaciones sincronizadas</p>
                            </div>
                        </div>

                        <div class="status-card status-card-warning mt-6">
                            <i class="fas fa-info-circle status-card-icon"></i>
                            <div class="text-sm">
                                <p class="font-semibold mb-1">¿Error de signature?</p>
                                <p>Las credenciales pueden ser incorrectas. Ve a <strong>BingX → Account → API Management</strong> y crea nuevas credenciales con permisos de <strong>Read + Trade</strong>.</p>
                            </div>
                        </div>

                        <!-- Botón principal de guardar configuración -->
                        <button id="save-bingx-credentials" class="primary w-full mt-6">
                            <i class="fas fa-save mr-2"></i>💾 Guardar Configuración
                        </button>

                        <div class="grid grid-cols-2 gap-3 mt-4">
                            <button id="test-bingx-connection-detail" class="secondary">
                                <i class="fas fa-plug mr-2"></i>Probar Conexión
                            </button>
                            <button id="sync-bingx-trades-detail" class="success">
                                <i class="fas fa-sync-alt mr-2"></i>Sincronizar Trades
                            </button>
                            <button id="disconnect-bingx-detail" class="danger">
                                <i class="fas fa-unlink mr-2"></i>Desconectar y Borrar Credenciales
                            </button>
                        </div>
                    </div>

                    <!-- Historial de Sincronización -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-4">Historial de Sincronización</h3>
                        <div id="bingx-sync-history" class="space-y-2">
                            <p class="text-text-secondary text-center py-8 text-sm">No hay sincronizaciones realizadas</p>
                        </div>
                    </div>
                </div>

                <!-- Tab: Importar CSV -->
                <div class="platform-tab-content" id="bingx-tab-csv">
                    <div class="metric-card">
                        <h3 class="text-xl font-semibold mb-6">Importar desde CSV</h3>
                        
                        <div class="space-y-5">
                            <div>
                                <label for="bingx-csv-file-input" class="block mb-3 font-semibold text-sm">
                                    <i class="fas fa-file-csv mr-2 text-primary"></i>Seleccionar archivo CSV
                                </label>
                                <input type="file" id="bingx-csv-file-input" accept=".csv" class="w-full">
                                <p class="text-xs text-text-secondary mt-3 leading-relaxed">
                                    <strong>Formato:</strong> Nombre Cuenta, <strong>ID (Agrupa parciales con el mismo ID)</strong>, Fecha (YYYY-MM-DD), Hora Entrada (HH:MM), Hora Salida (HH:MM), Instrumento, Tipo (buy/sell), Entrada, Salida, Volumen, P&L (opc), Divisa, Tarifa/Comisión (opc), Notas (opc)
                                </p>
                            </div>

                            <button id="bingx-import-csv-btn" class="primary w-full">
                                <i class="fas fa-upload mr-2"></i>Importar CSV
                            </button>

                            <div id="bingx-csv-import-status" class="text-sm"></div>
                        </div>
                    </div>
                </div>

                <!-- Tab: Información -->
                <div class="platform-tab-content" id="bingx-tab-info">
                    <div class="space-y-6">
                        <!-- Proxy Server Info -->


                        <!-- Important Notice -->
                        <div class="metric-card">
                            <h3 class="text-lg font-semibold mb-4">Importante</h3>
                            <div class="status-card status-card-info">
                                <i class="fas fa-info-circle status-card-icon"></i>
                                <div class="text-sm">
                                    <p class="font-semibold mb-2">Solo Cuenta Real</p>
                                    <p class="mb-2">BingX no permite APIs en modo demo/testnet. Solo funciona con cuentas reales.</p>
                                    <p class="mb-2"><strong>Para pruebas seguras:</strong> Puedes crear operaciones con volúmenes muy pequeños (0.01 lotes).</p>
                                    <p>La sincronización importará todas las operaciones reales de BingX.</p>
                                </div>
                            </div>
                        </div>

                        <!-- Platform Info -->
                        <div class="metric-card" style="background: #000; border: 2px solid #00ff88;">
                            <h3 class="text-lg font-semibold mb-4" style="color: #fff;">📚 Cómo Configurar API en BingX</h3>
                            <div class="space-y-4 text-sm" style="color: #fff; line-height: 1.8;">
                                <div style="background: rgba(0,255,136,0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #00ff88;">
                                    <p style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">🔐 Paso 1: Accede a API Management</p>
                                    <ol style="list-style: decimal; margin-left: 20px; line-height: 1.8;">
                                        <li>Inicia sesión en <strong>BingX.com</strong></li>
                                        <li>Ve a <strong>Account → API Management</strong></li>
                                        <li>Haz clic en <strong>Create API</strong></li>
                                        <li>Elige <strong>Standard API Key</strong> (recomendado)</li>
                                    </ol>
                                </div>

                                <div style="background: rgba(0,255,136,0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #00ff88;">
                                    <p style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">⚙️ Paso 2: Configura los Permisos</p>
                                    <ul style="list-style: disc; margin-left: 20px; line-height: 1.8;">
                                        <li><strong>Read:</strong> ✅ Activa (para leer posiciones)</li>
                                        <li><strong>Trade:</strong> ❌ NO activar (no necesario)</li>
                                        <li><strong>Withdraw:</strong> ❌ NO activar (seguridad)</li>
                                    </ul>
                                    <p style="margin-top: 12px; color: #fbbf24;">⚠️ Solo necesitas permisos de <strong>Read</strong> para sincronizar trades automáticamente.</p>
                                </div>

                                <div style="background: rgba(0,255,136,0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #00ff88;">
                                    <p style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">📝 Paso 3: Obtén las Credenciales</p>
                                    <p>BingX te proporcionará:</p>
                                    <ul style="list-style: disc; margin-left: 20px; line-height: 1.8; margin-top: 8px;">
                                        <li><strong>API Key:</strong> Tu identificador público</li>
                                        <li><strong>Secret Key:</strong> Tu clave privada (se muestra UNA VEZ)</li>
                                    </ul>
                                    <p style="margin-top: 12px; color: #ef4444;">🔒 <strong>IMPORTANTE:</strong> Copia el Secret Key inmediatamente. BingX solo lo muestra una vez al crear la API.</p>
                                </div>

                                <div style="background: rgba(0,255,136,0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #00ff88;">
                                    <p style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">🚀 Paso 4: Conecta en Trading Survivor</p>
                                    <ol style="list-style: decimal; margin-left: 20px; line-height: 1.8;">
                                        <li>Ve a la pestaña <strong>"Conexión API"</strong></li>
                                        <li>Pega tu <strong>API Key</strong></li>
                                        <li>Pega tu <strong>Secret Key</strong></li>
                                        <li>Selecciona la <strong>cuenta destino</strong></li>
                                        <li>Haz clic en <strong>"💾 Guardar Configuración"</strong></li>
                                        <li>Prueba con <strong>"Probar Conexión"</strong></li>
                                        <li>Usa <strong>"Sincronizar Ahora"</strong> para importar trades</li>
                                    </ol>
                                </div>

                                <div style="background: rgba(234,179,8,0.1); padding: 12px; border-radius: 8px; margin-top: 16px; border-left: 4px solid #eab308;">
                                    <p style="color: #fbbf24; font-weight: 600;">⚠️ Nota sobre Cuenta Demo</p>
                                    <p style="margin-top: 6px; color: #fff;">BingX <strong>NO permite crear APIs en cuentas demo/testnet</strong>. Solo funciona con cuentas reales. Para pruebas, usa volúmenes mínimos (0.01 lotes).</p>
                                </div>

                                <div style="background: rgba(59,130,246,0.1); padding: 12px; border-radius: 8px; margin-top: 16px;">
                                    <p style="color: #60a5fa; font-weight: 600;">💡 Consejo Pro</p>
                                    <p style="margin-top: 6px;">BingX ofrece trading de futuros perpetuos, spot y copy trading. La API sincroniza automáticamente todas tus operaciones cerradas.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- ============================================
             PANEL DE BITGET
             ============================================ -->
        <section id="platform-bitget" class="section-container" style="display: none;">
            <div class="platform-detail-container">
                <!-- Header -->
                <div class="platform-detail-header">
                    <div class="platform-detail-back" id="back-to-platforms-bitget">
                        <i class="fas fa-arrow-left"></i>
                    </div>
                    <div class="platform-logo" style="background: #54FDD5;">
                        <img src="logos/bitget-logo.png" alt="Bitget Logo">
                    </div>
                    <div class="platform-detail-title">
                        <h2>Bitget Exchange</h2>
                        <p>Configuración y Sincronización</p>
                    </div>
                </div>

                <!-- Estado de Conexión -->
                <div id="bitget-connection-status" class="status-card status-card-warning mb-6">
                    <i class="fas fa-exclamation-triangle status-card-icon"></i>
                    <div>
                        <p class="font-semibold text-lg mb-1">No conectado</p>
                        <p class="text-sm opacity-90">Configure sus claves API para comenzar la sincronización automática.</p>
                    </div>
                </div>

                <!-- Tabs de Navegación -->
                <div class="platform-tabs">
                    <button class="platform-tab active" data-tab="api">
                        <i class="fas fa-key mr-2"></i>Conexión API
                    </button>
                    <button class="platform-tab" data-tab="csv">
                        <i class="fas fa-file-csv mr-2"></i>Importar CSV
                    </button>
                    <button class="platform-tab" data-tab="info">
                        <i class="fas fa-info-circle mr-2"></i>Información
                    </button>
                </div>

                <!-- Tab: Conexión API -->
                <div class="platform-tab-content active" id="bitget-tab-api">
                    <div class="metric-card mb-6">
                        <h3 class="text-xl font-semibold mb-6">Configuración de API</h3>

                        <div class="space-y-5">
                            <div>
                                <label class="block mb-2 font-semibold text-sm">
                                    <i class="fas fa-key mr-2 text-primary"></i>Clave API
                                </label>
                                <input type="password" id="bitget-api-key-detail" class="w-full" placeholder="Introduce tu clave API de Bitget">
                                <p class="text-xs text-text-secondary mt-2">La clave API se almacena localmente y de forma segura</p>
                            </div>

                            <div>
                                <label class="block mb-2 font-semibold text-sm">
                                    <i class="fas fa-lock mr-2 text-primary"></i>Secret API
                                </label>
                                <input type="password" id="bitget-secret-key-detail" class="w-full" placeholder="Introduce tu secret de Bitget">
                                <p class="text-xs text-text-secondary mt-2">El secret se encripta antes de almacenarse</p>
                            </div>

                            <div>
                                <label class="block mb-2 font-semibold text-sm">
                                    <i class="fas fa-key mr-2 text-primary"></i>Passphrase
                                </label>
                                <input type="password" id="bitget-passphrase-detail" class="w-full" placeholder="Introduce tu passphrase de Bitget">
                                <p class="text-xs text-text-secondary mt-2">El passphrase es requerido para autenticación en Bitget</p>
                            </div>

                            <div>
                                <label class="block mb-2 font-semibold text-sm">
                                    <i class="fas fa-wallet mr-2 text-primary"></i>Cuenta a sincronizar
                                </label>
                                <select id="bitget-account-detail" class="w-full">
                                    <option value="">Seleccionar cuenta...</option>
                                </select>
                                <p class="text-xs text-text-secondary mt-2">Selecciona la cuenta donde se guardarán las operaciones sincronizadas</p>
                            </div>
                        </div>

                        <div class="status-card status-card-info mt-6">
                            <i class="fas fa-info-circle status-card-icon"></i>
                            <div class="text-sm">
                                <p class="font-semibold mb-1">Configurar API en Bitget</p>
                                <p>Ve a <strong>Perfil → API Management</strong> y crea nuevas credenciales con permisos de <strong>Read</strong>. Bitget requiere API Key, Secret y Passphrase para la autenticación.</p>
                            </div>
                        </div>

                        <!-- Botón principal de guardar configuración -->
                        <button id="save-bitget-credentials" class="primary w-full mt-6">
                            <i class="fas fa-save mr-2"></i>💾 Guardar Configuración
                        </button>

                        <div class="grid grid-cols-2 gap-3 mt-4">
                            <button id="test-bitget-connection-detail" class="secondary">
                                <i class="fas fa-plug mr-2"></i>Probar Conexión
                            </button>
                            <button id="sync-bitget-trades-detail" class="success">
                                <i class="fas fa-sync-alt mr-2"></i>Sincronizar Trades
                            </button>
                        </div>

                        <button id="disconnect-bitget-detail" class="secondary w-full mt-3 opacity-70 hover:opacity-100">
                            <i class="fas fa-unlink mr-2"></i>Desconectar y Borrar Credenciales
                        </button>
                    </div>

                    <!-- Historial de Sincronización -->
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-4">Historial de Sincronización</h3>
                        <div id="bitget-sync-history" class="space-y-2">
                            <p class="text-text-secondary text-center py-8 text-sm">No hay sincronizaciones realizadas</p>
                        </div>
                    </div>
                </div>

                <!-- Tab: Importar CSV -->
                <div class="platform-tab-content" id="bitget-tab-csv">
                    <div class="metric-card">
                        <h3 class="text-xl font-semibold mb-6">Importar desde CSV</h3>
                        
                        <div class="space-y-5">
                            <div>
                                <label for="bitget-csv-file-input" class="block mb-3 font-semibold text-sm">
                                    <i class="fas fa-file-csv mr-2 text-primary"></i>Seleccionar archivo CSV
                                </label>
                                <input type="file" id="bitget-csv-file-input" accept=".csv" class="w-full">
                                <p class="text-xs text-text-secondary mt-3 leading-relaxed">
                                    <strong>Formato:</strong> Nombre Cuenta, <strong>ID (Agrupa parciales con el mismo ID)</strong>, Fecha (YYYY-MM-DD), Hora Entrada (HH:MM), Hora Salida (HH:MM), Instrumento, Tipo (buy/sell), Entrada, Salida, Volumen, P&L (opc), Divisa, Tarifa/Comisión (opc), Notas (opc)
                                </p>
                            </div>

                            <button id="bitget-import-csv-btn" class="primary w-full">
                                <i class="fas fa-upload mr-2"></i>Importar CSV
                            </button>

                            <div id="bitget-csv-import-status" class="text-sm"></div>
                        </div>

                        <div class="mt-6 pt-6 border-t border-border">
                            <h4 class="text-lg font-semibold mb-4">
                                <i class="fas fa-copy mr-2 text-primary"></i>Importar desde Interfaz Web
                            </h4>
                            <p class="text-sm text-text-secondary mb-4 leading-relaxed">
                                Copia los datos directamente desde el <strong>Historial de Posición</strong> de Bitget y pégalos aquí para una importación rápida.
                            </p>
                            <button id="bitget-interface-import-btn" class="bg-green-600 hover:bg-green-700 text-white w-full py-2.5 rounded-lg font-semibold transition-colors">
                                <i class="fas fa-paste mr-2"></i>Abrir Importador de Interfaz
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Tab: Información -->
                <div class="platform-tab-content" id="bitget-tab-info">
                    <div class="metric-card" style="background: #000; border: 2px solid #00ff88;">
                        <h3 class="text-lg font-semibold mb-4" style="color: #fff;">📚 Cómo Configurar API en Bitget</h3>
                        <div class="space-y-4 text-sm" style="color: #fff; line-height: 1.8;">
                            <div style="background: rgba(0,255,136,0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #00ff88;">
                                <p style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">🔐 Paso 1: Accede a API Management</p>
                                <ol style="list-style: decimal; margin-left: 20px; line-height: 1.8;">
                                    <li>Inicia sesión en <strong>Bitget.com</strong></li>
                                    <li>Ve a <strong>Perfil → API Management</strong></li>
                                    <li>Haz clic en <strong>Create API</strong></li>
                                    <li>Selecciona <strong>System Generated</strong> (recomendado)</li>
                                </ol>
                            </div>

                            <div style="background: rgba(0,255,136,0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #00ff88;">
                                <p style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">⚙️ Paso 2: Configura los Permisos</p>
                                <ul style="list-style: disc; margin-left: 20px; line-height: 1.8;">
                                    <li><strong>Read:</strong> ✅ Activa esta opción</li>
                                    <li><strong>Trade:</strong> ❌ NO activar (no necesario)</li>
                                    <li><strong>Withdraw:</strong> ❌ NO activar (seguridad)</li>
                                    <li><strong>Transfer:</strong> ❌ NO activar (no necesario)</li>
                                </ul>
                                <p style="margin-top: 12px; color: #fbbf24;">⚠️ Solo necesitas permisos de <strong>lectura (Read)</strong> para sincronizar trades.</p>
                            </div>

                            <div style="background: rgba(0,255,136,0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #00ff88;">
                                <p style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">📝 Paso 3: Crea tu Passphrase</p>
                                <p style="margin-bottom: 8px;">Bitget requiere un <strong>passphrase</strong> (frase de seguridad):</p>
                                <ul style="list-style: disc; margin-left: 20px; line-height: 1.8;">
                                    <li>Crea una passphrase de <strong>8-32 caracteres</strong></li>
                                    <li>Debe incluir <strong>letras, números y símbolos</strong></li>
                                    <li>Ejemplos: <code style="background: rgba(0,0,0,0.5); padding: 2px 6px; border-radius: 4px;">MyPass123!</code> o <code style="background: rgba(0,0,0,0.5); padding: 2px 6px; border-radius: 4px;">TradingBot@2024</code></li>
                                </ul>
                                <p style="margin-top: 12px; color: #ef4444;">🔒 <strong>IMPORTANTE:</strong> Guarda el passphrase, lo necesitarás para conectar.</p>
                            </div>

                            <div style="background: rgba(0,255,136,0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #00ff88;">
                                <p style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">📋 Paso 4: Obtén las Credenciales</p>
                                <p>Bitget te proporcionará:</p>
                                <ul style="list-style: disc; margin-left: 20px; line-height: 1.8; margin-top: 8px;">
                                    <li><strong>API Key:</strong> Tu identificador público</li>
                                    <li><strong>Secret Key:</strong> Tu clave privada (solo se muestra UNA VEZ)</li>
                                    <li><strong>Passphrase:</strong> La que creaste en el paso anterior</li>
                                </ul>
                            </div>

                            <div style="background: rgba(0,255,136,0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #00ff88;">
                                <p style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">🚀 Paso 5: Conecta en Trading Survivor</p>
                                <ol style="list-style: decimal; margin-left: 20px; line-height: 1.8;">
                                    <li>Ve a la pestaña <strong>"Conexión API"</strong></li>
                                    <li>Pega tu <strong>API Key</strong></li>
                                    <li>Pega tu <strong>Secret Key</strong></li>
                                    <li>Pega tu <strong>Passphrase</strong></li>
                                    <li>Selecciona la <strong>cuenta destino</strong></li>
                                    <li>Haz clic en <strong>"💾 Guardar Configuración"</strong></li>
                                    <li>Prueba con <strong>"Probar Conexión"</strong></li>
                                </ol>
                            </div>

                            <div style="background: rgba(59,130,246,0.1); padding: 12px; border-radius: 8px; margin-top: 16px;">
                                <p style="color: #60a5fa; font-weight: 600;">💡 Consejo Pro</p>
                                <p style="margin-top: 6px;">Bitget usa HMAC SHA256 con passphrase para autenticación. La conexión es segura y la sincronización de trades es completamente automática.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- MEXC Platform Panel -->
        <section id="platform-mexc" class="section-container" style="display: none;">
            <div class="platform-detail-container">
                <!-- Header -->
                <div class="platform-detail-header">
                    <div class="platform-detail-back" id="back-to-platforms-mexc">
                        <i class="fas fa-arrow-left"></i>
                    </div>
                    <div class="platform-logo" style="background: #00C087;">
                        <img src="logos/mexc-logo.png" alt="MEXC Logo">
                    </div>
                    <div class="platform-detail-title">
                        <h2>MEXC Exchange</h2>
                        <p>Configuración y Sincronización</p>
                    </div>
                </div>

                <!-- Estado de Conexión -->
                <div id="mexc-connection-status" class="status-card status-card-warning mb-6">
                    <i class="fas fa-exclamation-triangle status-card-icon"></i>
                    <div>
                        <p class="font-semibold text-lg mb-1">No conectado</p>
                        <p class="text-sm opacity-90">Importa operaciones mediante archivo CSV o API.</p>
                    </div>
                </div>

                <!-- Tabs de Navegación -->
                <div class="platform-tabs">
                    <button class="platform-tab active" data-tab="api">
                        <i class="fas fa-key mr-2"></i>Conexión API
                    </button>
                    <button class="platform-tab" data-tab="csv">
                        <i class="fas fa-file-csv mr-2"></i>Importar CSV
                    </button>
                    <button class="platform-tab" data-tab="info">
                        <i class="fas fa-info-circle mr-2"></i>Información
                    </button>
                </div>

                <!-- Tab: Conexión API -->
                <div class="platform-tab-content active" id="mexc-tab-api">
                    <div class="metric-card mb-6">
                        <h3 class="text-xl font-semibold mb-6">Configuración de API</h3>

                        <div class="space-y-5">
                            <div>
                                <label class="block mb-2 font-semibold text-sm">
                                    <i class="fas fa-key mr-2 text-primary"></i>Clave API
                                </label>
                                <input type="password" id="mexc-api-key-detail" class="w-full" placeholder="Introduce tu clave API de MEXC">
                                <p class="text-xs text-text-secondary mt-2">La clave API se almacena localmente y de forma segura</p>
                            </div>

                            <div>
                                <label class="block mb-2 font-semibold text-sm">
                                    <i class="fas fa-lock mr-2 text-primary"></i>Secret API
                                </label>
                                <input type="password" id="mexc-secret-key-detail" class="w-full" placeholder="Introduce tu secret de MEXC">
                                <p class="text-xs text-text-secondary mt-2">El secret se encripta antes de almacenarse</p>
                            </div>

                            <div>
                                <label class="block mb-2 font-semibold text-sm">
                                    <i class="fas fa-wallet mr-2 text-primary"></i>Cuenta a sincronizar
                                </label>
                                <select id="mexc-account-detail" class="w-full">
                                    <option value="">Seleccionar cuenta...</option>
                                </select>
                                <p class="text-xs text-text-secondary mt-2">Selecciona la cuenta donde se guardarán las operaciones sincronizadas</p>
                            </div>
                        </div>

                        <div class="status-card status-card-info mt-6">
                            <i class="fas fa-info-circle status-card-icon"></i>
                            <div class="text-sm">
                                <p class="font-semibold mb-1">Configurar API en MEXC Futures</p>
                                <p>Ve a <strong>Account → API Management → Futures</strong> y crea nuevas credenciales con permisos de <strong>View Account Details</strong> y <strong>View Order Details</strong>. MEXC Futures requiere API Key y Secret para la autenticación.</p>
                            </div>
                        </div>

                        <!-- Botón principal de guardar configuración -->
                        <button id="save-mexc-credentials" class="primary w-full mt-6">
                            <i class="fas fa-save mr-2"></i>💾 Guardar Configuración
                        </button>

                        <div class="grid grid-cols-2 gap-3 mt-4">
                            <button id="test-mexc-connection-detail" class="secondary">
                                <i class="fas fa-plug mr-2"></i>Probar Conexión
                            </button>
                            <button id="sync-mexc-trades-detail" class="success">
                                <i class="fas fa-sync-alt mr-2"></i>Sincronizar Trades
                            </button>
                        </div>

                        <div class="mt-4">
                            <button id="disconnect-mexc-detail" class="w-full danger">
                                <i class="fas fa-unlink mr-2"></i>Desconectar y Borrar Credenciales
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Tab: Importar CSV -->
                <div class="platform-tab-content" id="mexc-tab-csv">
                    <div class="metric-card">
                        <h3 class="text-xl font-semibold mb-6">Importar desde CSV</h3>
                        
                        <div class="space-y-5">
                            <div>
                                <label for="mexc-csv-file-input" class="block mb-3 font-semibold text-sm">
                                    <i class="fas fa-file-csv mr-2 text-primary"></i>Seleccionar archivo CSV
                                </label>
                                <input type="file" id="mexc-csv-file-input" accept=".csv" class="w-full">
                                <p class="text-xs text-text-secondary mt-3 leading-relaxed">
                                    <strong>Formato:</strong> Nombre Cuenta, <strong>ID (Agrupa parciales con el mismo ID)</strong>, Fecha (YYYY-MM-DD), Hora Entrada (HH:MM), Hora Salida (HH:MM), Instrumento, Tipo (buy/sell), Entrada, Salida, Volumen, P&L (opc), Divisa, Tarifa/Comisión (opc), Notas (opc)
                                </p>
                            </div>

                            <div class="status-card status-card-info">
                                <i class="fas fa-lightbulb status-card-icon"></i>
                                <div class="text-sm">
                                    <p class="font-semibold mb-2">Ejemplo de CSV válido:</p>
                                    <pre class="text-xs mt-2 overflow-x-auto bg-black bg-opacity-30 p-2 rounded">Nombre Cuenta,Fecha,Hora Entrada,Hora Salida,Instrumento,Tipo,Entrada,Salida,Volumen,P&L,Divisa,Tarifa/Comision,Notas
Mi Cuenta MEXC,2024-10-15,09:30,10:45,BTCUSDT,buy,42500.00,43200.00,0.1,70.00,USDT,2.50,Trade exitoso</pre>
                                </div>
                            </div>

                            <button id="mexc-import-csv-btn" class="primary w-full">
                                <i class="fas fa-upload mr-2"></i>Importar CSV de MEXC
                            </button>

                            <div id="mexc-csv-import-status" class="text-sm"></div>
                        </div>
                    </div>

                    <!-- Historial de Importaciones -->
                    <div class="metric-card mt-6">
                        <h3 class="text-lg font-semibold mb-4">Historial de Importaciones</h3>
                        <div id="mexc-import-history" class="space-y-2">
                            <p class="text-text-secondary text-center py-8 text-sm">No hay importaciones realizadas</p>
                        </div>
                    </div>
                </div>

                <!-- Tab: Información -->
                <div class="platform-tab-content" id="mexc-tab-info">
                    <div class="metric-card" style="background: #000; border: 2px solid #00ff88;">
                        <h3 class="text-lg font-semibold mb-4" style="color: #fff;">📚 Cómo Configurar API en MEXC Futures</h3>
                        <div class="space-y-4 text-sm" style="color: #fff; line-height: 1.8;">
                            <div style="background: rgba(0,255,136,0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #00ff88;">
                                <p style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">🔐 Paso 1: Accede a API Management</p>
                                <ol style="list-style: decimal; margin-left: 20px; line-height: 1.8;">
                                    <li>Inicia sesión en <strong>MEXC.com</strong></li>
                                    <li>Ve a <strong>Account → API Management</strong></li>
                                    <li>Selecciona <strong>Futures API</strong> (NO Spot API)</li>
                                    <li>Haz clic en <strong>Create API</strong></li>
                                </ol>
                            </div>

                            <div style="background: rgba(0,255,136,0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #00ff88;">
                                <p style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">⚙️ Paso 2: Configura los Permisos</p>
                                <ul style="list-style: disc; margin-left: 20px; line-height: 1.8;">
                                    <li><strong>View Account Details:</strong> ✅ Activa</li>
                                    <li><strong>View Order Details:</strong> ✅ Activa</li>
                                    <li><strong>Trading:</strong> ❌ NO activar</li>
                                    <li><strong>Withdraw:</strong> ❌ NO activar</li>
                                </ul>
                                <p style="margin-top: 12px; color: #fbbf24;">⚠️ Solo necesitas permisos de lectura de cuenta y órdenes.</p>
                            </div>

                            <div style="background: rgba(0,255,136,0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #00ff88;">
                                <p style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">📝 Paso 3: Whitelist de IP (IMPORTANTE)</p>
                                <p style="margin-bottom: 8px;">MEXC requiere que agregues IPs autorizadas. Tienes 2 opciones:</p>
                                <ul style="list-style: disc; margin-left: 20px; line-height: 1.8;">
                                    <li><strong>Opción Fácil:</strong> Desmarca "Restrict access to trusted IPs only" (menos seguro)</li>
                                    <li><strong>Opción Segura:</strong> Agrega la IP de Vercel a la whitelist (Trading Survivor te la mostrará si hay error)</li>
                                </ul>
                                <p style="margin-top: 12px; color: #ef4444;">🔒 Si ves "IP not in whitelist", revisa el mensaje de error para obtener la IP correcta.</p>
                            </div>

                            <div style="background: rgba(0,255,136,0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #00ff88;">
                                <p style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">🚀 Paso 4: Conecta en Trading Survivor</p>
                                <ol style="list-style: decimal; margin-left: 20px; line-height: 1.8;">
                                    <li>MEXC te dará <strong>API Key</strong> y <strong>Secret Key</strong></li>
                                    <li>Ve a la pestaña <strong>"Conexión API"</strong></li>
                                    <li>Pega las credenciales en los campos correspondientes</li>
                                    <li>Selecciona tu <strong>cuenta destino</strong></li>
                                    <li>Haz clic en <strong>"💾 Guardar Configuración"</strong></li>
                                    <li>Prueba con <strong>"Probar Conexión"</strong></li>
                                </ol>
                            </div>

                            <div style="background: rgba(59,130,246,0.1); padding: 12px; border-radius: 8px; margin-top: 16px;">
                                <p style="color: #60a5fa; font-weight: 600;">💡 Nota Importante</p>
                                <p style="margin-top: 6px;">MEXC Futures API es diferente de Spot API. Asegúrate de crear una <strong>Futures API Key</strong>, no una Spot API Key.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- PANTALLA DETALLADA DE cTrader -->
        <section id="platform-ctrader" class="section-container" style="display: none;">
            <div class="platform-detail-container">
                <!-- Header -->
                <div class="platform-detail-header">
                    <div class="platform-detail-back" id="back-to-platforms-ctrader">
                        <i class="fas fa-arrow-left"></i>
                    </div>
                    <div class="platform-logo" style="background: #00A8E1;">
                        <img src="logos/ctrader-logo.png" alt="cTrader Logo">
                    </div>
                    <div class="platform-detail-title">
                        <h2>cTrader Platform</h2>
                        <p>Configuración y Sincronización</p>
                    </div>
                </div>

                <!-- Estado de Conexión -->
                <div id="ctrader-connection-status" class="status-card status-card-warning mb-6">
                    <i class="fas fa-exclamation-triangle status-card-icon"></i>
                    <div>
                        <p class="font-semibold text-lg mb-1">No conectado</p>
                        <p class="text-sm opacity-90">Importa operaciones mediante archivo HTML Statement.</p>
                    </div>
                </div>

                <!-- Tabs de Navegación -->
                <div class="platform-tabs">
                    <button class="platform-tab active" data-tab="html">
                        <i class="fas fa-file-code mr-2"></i>Importar HTML
                    </button>
                    <button class="platform-tab" data-tab="api">
                        <i class="fas fa-key mr-2"></i>Conexión API
                    </button>
                    <button class="platform-tab" data-tab="info">
                        <i class="fas fa-info-circle mr-2"></i>Información
                    </button>
                </div>

                <!-- Tab: Importar HTML -->
                <div class="platform-tab-content active" id="ctrader-tab-html">
                    <div class="metric-card">
                        <h3 class="text-xl font-semibold mb-6">
                            <i class="fas fa-file-code mr-2 text-primary"></i>Importar desde HTML Statement
                        </h3>
                        
                        <div class="space-y-5">
                            <div class="status-card status-card-info">
                                <i class="fas fa-lightbulb status-card-icon"></i>
                                <div class="text-sm">
                                    <p class="font-semibold mb-2">📋 ¿Cómo obtener el HTML Statement?</p>
                                    <ol class="list-decimal list-inside space-y-1 ml-2 mt-2">
                                        <li>Abre <strong>cTrader</strong> y ve a la pestaña <strong>History</strong></li>
                                        <li>Selecciona el rango de fechas que deseas importar</li>
                                        <li>Haz click derecho sobre la tabla → <strong>Export → HTML Statement</strong></li>
                                        <li>Guarda el archivo .html en tu computadora</li>
                                        <li>Súbelo aquí abajo 👇</li>
                                    </ol>
                                    <p class="mt-3 text-xs opacity-75">
                                        <strong>Ejemplo de nombre:</strong> cT_17015573_2025-11-12_15-03.htm
                                    </p>
                                </div>
                            </div>

                            <div>
                                <label class="block mb-2 font-semibold text-sm">
                                    <i class="fas fa-wallet mr-2 text-primary"></i>1. Selecciona la cuenta destino
                                </label>
                                <select id="ctrader-account-select" class="w-full">
                                    <option value="">Seleccionar cuenta...</option>
                                </select>
                                <p class="text-xs text-text-secondary mt-2">Las operaciones se importarán a esta cuenta</p>
                            </div>

                            <div>
                                <label for="ctrader-csv-file-input" class="block mb-3 font-semibold text-sm">
                                    <i class="fas fa-file-upload mr-2 text-primary"></i>2. Selecciona el archivo HTML Statement
                                </label>
                                <input type="file" id="ctrader-csv-file-input" accept=".html,.htm" class="w-full">
                                <p class="text-xs text-text-secondary mt-3 leading-relaxed">
                                    <strong>Solo archivos HTML</strong> (.html o .htm) exportados desde cTrader
                                </p>
                            </div>

                            <button id="ctrader-import-csv-btn" class="primary w-full" style="padding: 1rem; font-size: 1.1rem;">
                                <i class="fas fa-upload mr-2"></i>3. Importar Operaciones de cTrader
                            </button>

                            <div id="ctrader-csv-import-status" class="text-sm"></div>
                        </div>
                    </div>

                    <!-- Vista previa de operaciones -->
                    <div class="metric-card mt-6" id="ctrader-preview-container" style="display: none;">
                        <h3 class="text-lg font-semibold mb-4">
                            <i class="fas fa-eye mr-2 text-primary"></i>Vista previa de operaciones
                        </h3>
                        <p class="text-sm text-text-secondary mb-4">
                            Revisa las operaciones detectadas antes de importarlas
                        </p>
                        <div class="overflow-x-auto">
                            <table class="w-full text-sm">
                                <thead class="bg-surface-light">
                                    <tr>
                                        <th class="px-3 py-2 text-left">Símbolo</th>
                                        <th class="px-3 py-2 text-left">Tipo</th>
                                        <th class="px-3 py-2 text-left">Fecha</th>
                                        <th class="px-3 py-2 text-right">Entrada</th>
                                        <th class="px-3 py-2 text-right">Salida</th>
                                        <th class="px-3 py-2 text-right">Volumen</th>
                                        <th class="px-3 py-2 text-right">P&L</th>
                                    </tr>
                                </thead>
                                <tbody id="ctrader-preview-tbody">
                                </tbody>
                            </table>
                        </div>
                        <div class="mt-4 flex justify-between items-center">
                            <p class="text-sm text-text-secondary">
                                <span id="ctrader-preview-count">0</span> operaciones detectadas
                            </p>
                            <button id="ctrader-confirm-import-btn" class="success" style="padding: 0.75rem 1.5rem; font-size: 1rem;">
                                <i class="fas fa-check mr-2"></i>Confirmar Importación
                            </button>
                        </div>
                    </div>

                    <!-- Historial de Importaciones -->
                    <div class="metric-card mt-6">
                        <h3 class="text-lg font-semibold mb-4">
                            <i class="fas fa-history mr-2 text-primary"></i>Historial de Importaciones
                        </h3>
                        <div id="ctrader-import-history" class="space-y-2">
                            <p class="text-text-secondary text-center py-8 text-sm">No hay importaciones realizadas</p>
                        </div>
                    </div>
                </div>

                <!-- Tab: Conexión API -->
                <div class="platform-tab-content" id="ctrader-tab-api">
                    <div class="metric-card mb-6">
                        <h3 class="text-xl font-semibold mb-6">Configuración de API</h3>

                        <div class="status-card status-card-info">
                            <i class="fas fa-info-circle status-card-icon"></i>
                            <div class="text-sm">
                                <p class="font-semibold mb-1">API en desarrollo</p>
                                <p>La integración automática con cTrader Open API está en desarrollo. Por ahora, puedes importar tus operaciones mediante archivo HTML Statement.</p>
                            </div>
                        </div>

                        <div class="mt-6">
                            <p class="text-sm text-text-secondary">
                                <strong>Próximamente:</strong> Conexión directa con cTrader Open API para sincronización automática de operaciones, balances y posiciones en tiempo real.
                            </p>
                        </div>
                    </div>
                </div>

                <!-- Tab: Información -->
                <div class="platform-tab-content" id="ctrader-tab-info">
                    <div class="metric-card" style="background: #000; border: 2px solid #00ff88;">
                        <h3 class="text-lg font-semibold mb-4" style="color: #fff;">
                            <i class="fas fa-book mr-2" style="color: #00ff88;"></i>
                            📚 Cómo Importar desde cTrader
                        </h3>
                        <div class="space-y-4 text-sm" style="color: #fff; line-height: 1.8;">
                            <div style="background: rgba(0,255,136,0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #00ff88;">
                                <p style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">💡 cTrader HTML Statement</p>
                                <p>cTrader no tiene API pública para sincronización automática. En su lugar, exporta un <strong>HTML Statement</strong> con todo tu historial de operaciones, que Trading Survivor procesa automáticamente.</p>
                            </div>

                            <div style="background: rgba(0,255,136,0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #00ff88;">
                                <p style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">📊 Paso 1: Abre el Historial en cTrader</p>
                                <ol style="list-style: decimal; margin-left: 20px; line-height: 1.8;">
                                    <li>Abre tu plataforma <strong>cTrader</strong> (desktop o web)</li>
                                    <li>Ve a la pestaña <strong>"History"</strong> (Historial)</li>
                                    <li>Verás tu lista de operaciones cerradas</li>
                                </ol>
                            </div>

                            <div style="background: rgba(0,255,136,0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #00ff88;">
                                <p style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">📅 Paso 2: Selecciona el Rango de Fechas</p>
                                <p style="margin-bottom: 8px;">En la parte superior del panel de History:</p>
                                <ul style="list-style: disc; margin-left: 20px; line-height: 1.8;">
                                    <li>Elige las <strong>fechas de inicio y fin</strong> del período que quieres exportar</li>
                                    <li>Puedes exportar todo el historial o solo trades recientes</li>
                                </ul>
                            </div>

                            <div style="background: rgba(0,255,136,0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #00ff88;">
                                <p style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">💾 Paso 3: Exporta el HTML Statement</p>
                                <ol style="list-style: decimal; margin-left: 20px; line-height: 1.8;">
                                    <li>Haz <strong>click derecho</strong> sobre la tabla de operaciones</li>
                                    <li>Selecciona <strong>"Export"</strong> → <strong>"HTML Statement"</strong></li>
                                    <li>Elige dónde guardar el archivo .html (ej: Desktop)</li>
                                    <li>Se generará un archivo HTML completo con tu historial</li>
                                </ol>
                            </div>

                            <div style="background: rgba(0,255,136,0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #00ff88;">
                                <p style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">📤 Paso 4: Importa en Trading Survivor</p>
                                <ol style="list-style: decimal; margin-left: 20px; line-height: 1.8;">
                                    <li>Ve a la pestaña <strong>"Importar HTML"</strong> arriba</li>
                                    <li>Selecciona la <strong>cuenta destino</strong></li>
                                    <li>Arrastra el archivo .html o click para seleccionarlo</li>
                                    <li>Click en <strong>"Importar Trades"</strong></li>
                                    <li>Trading Survivor procesará automáticamente todas las operaciones</li>
                                </ol>
                            </div>

                            <div style="background: rgba(59,130,246,0.1); padding: 12px; border-radius: 8px; margin-top: 16px; border-left: 4px solid #60a5fa;">
                                <p style="color: #60a5fa; font-weight: 600;">💡 Lo que incluye el HTML Statement</p>
                                <p style="margin-top: 6px;">El archivo HTML contiene tablas con: <strong>Historial de operaciones, Posiciones abiertas, Órdenes pendientes y Transacciones</strong>. Trading Survivor extrae automáticamente las operaciones cerradas con todos sus detalles (entrada, salida, P&L, comisiones, swaps, etc.).</p>
                            </div>

                            <div style="background: rgba(234,179,8,0.1); padding: 12px; border-radius: 8px; margin-top: 16px; border-left: 4px solid #eab308;">
                                <p style="color: #fbbf24; font-weight: 600;">⚠️ Compatibilidad con Brokers</p>
                                <p style="margin-top: 6px;">cTrader funciona con múltiples brokers: <strong>IC Markets, Pepperstone, FxPro, Spotware, FTMO</strong> y muchos más. El formato HTML Statement es el mismo para todos.</p>
                            </div>

                            <div style="background: rgba(0,255,136,0.1); padding: 12px; border-radius: 8px; margin-top: 16px; border-left: 4px solid #00ff88;">
                                <p style="color: #00ff88; font-weight: 600;">🤖 API en Desarrollo</p>
                                <p style="margin-top: 6px;">cTrader tiene una Open API para desarrolladores, pero requiere OAuth y configuración compleja. Estamos trabajando en una integración automática. Por ahora, el HTML Statement es la forma más rápida y confiable.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- PANTALLA DETALLADA DE BITUNIX -->
        <section id="platform-bitunix" class="section-container" style="display: none;">
            <div class="platform-detail-container">
                <!-- Header -->
                <div class="platform-detail-header">
                    <div class="platform-detail-back" id="back-to-platforms-bitunix">
                        <i class="fas fa-arrow-left"></i>
                    </div>
                    <div class="platform-logo" style="background: #FF6B00;">
                        <img src="logos/bitunix-logo.png" alt="Bitunix Logo">
                    </div>
                    <div class="platform-detail-title">
                        <h2>Bitunix Exchange</h2>
                        <p>Configuración y Sincronización</p>
                    </div>
                </div>

                <!-- Estado de Conexión -->
                <div id="bitunix-connection-status" class="status-card status-card-warning mb-6">
                    <i class="fas fa-exclamation-triangle status-card-icon"></i>
                    <div>
                        <p class="font-semibold text-lg mb-1">No conectado</p>
                        <p class="text-sm opacity-90">Importa operaciones mediante archivo CSV o API.</p>
                    </div>
                </div>

                <!-- Tabs de Navegación -->
                <div class="platform-tabs">
                    <button class="platform-tab active" data-tab="api">
                        <i class="fas fa-key mr-2"></i>Conexión API
                    </button>
                    <button class="platform-tab" data-tab="csv">
                        <i class="fas fa-file-csv mr-2"></i>Importar CSV
                    </button>
                    <button class="platform-tab" data-tab="info">
                        <i class="fas fa-info-circle mr-2"></i>Información
                    </button>
                </div>

                <!-- Tab: Conexión API -->
                <div class="platform-tab-content active" id="bitunix-tab-api">
                    <div class="metric-card mb-6">
                        <h3 class="text-xl font-semibold mb-6">Configuración de API</h3>

                        <div class="space-y-5">
                            <div>
                                <label class="block mb-2 font-semibold text-sm">
                                    <i class="fas fa-key mr-2 text-primary"></i>Clave API
                                </label>
                                <input type="password" id="bitunix-api-key-detail" class="w-full" placeholder="Introduce tu clave API de Bitunix">
                                <p class="text-xs text-text-secondary mt-2">La clave API se almacena localmente y de forma segura</p>
                            </div>

                            <div>
                                <label class="block mb-2 font-semibold text-sm">
                                    <i class="fas fa-lock mr-2 text-primary"></i>Secret Key
                                </label>
                                <input type="password" id="bitunix-secret-key-detail" class="w-full" placeholder="Introduce tu secret de Bitunix">
                                <p class="text-xs text-text-secondary mt-2">El secret se encripta antes de almacenarse</p>
                            </div>

                            <div>
                                <label class="block mb-2 font-semibold text-sm">
                                    <i class="fas fa-wallet mr-2 text-primary"></i>Cuenta a sincronizar
                                </label>
                                <select id="bitunix-account-detail" class="w-full">
                                    <option value="">Seleccionar cuenta...</option>
                                </select>
                                <p class="text-xs text-text-secondary mt-2">Selecciona la cuenta donde se guardarán las operaciones sincronizadas</p>
                            </div>
                        </div>

                        <div class="status-card status-card-info mt-6">
                            <i class="fas fa-info-circle status-card-icon"></i>
                            <div class="text-sm">
                                <p class="font-semibold mb-1">Configurar API en Bitunix</p>
                                <p>Ve a <strong>Account → API Management</strong> y crea nuevas credenciales. Asegúrate de otorgar permisos de lectura para <strong>Account</strong> y <strong>Trading</strong>.</p>
                            </div>
                        </div>

                        <!-- Botón principal de guardar configuración -->
                        <button id="save-bitunix-credentials" class="primary w-full mt-6">
                            <i class="fas fa-save mr-2"></i>💾 Guardar Configuración
                        </button>

                        <div class="grid grid-cols-2 gap-3 mt-4">
                            <button id="test-bitunix-connection-detail" class="secondary">
                                <i class="fas fa-plug mr-2"></i>Probar Conexión
                            </button>
                            <button id="sync-bitunix-trades-detail" class="success">
                                <i class="fas fa-sync-alt mr-2"></i>Sincronizar Trades
                            </button>
                        </div>

                        <div class="mt-4">
                            <button id="disconnect-bitunix-detail" class="w-full danger">
                                <i class="fas fa-unlink mr-2"></i>Desconectar y Borrar Credenciales
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Tab: Importar CSV -->
                <div class="platform-tab-content" id="bitunix-tab-csv">
                    <div class="metric-card">
                        <h3 class="text-xl font-semibold mb-6">Importar desde CSV</h3>
                        
                        <div class="space-y-5">
                            <div>
                                <label for="bitunix-csv-file-input" class="block mb-3 font-semibold text-sm">
                                    <i class="fas fa-file-csv mr-2 text-primary"></i>Seleccionar archivo CSV
                                </label>
                                <input type="file" id="bitunix-csv-file-input" accept=".csv" class="w-full">
                                <p class="text-xs text-text-secondary mt-3 leading-relaxed">
                                    <strong>Formato:</strong> El CSV debe contener columnas como Fecha, Símbolo, Tipo (buy/sell), Precio Entrada, Precio Salida, Cantidad, P&L, etc.
                                </p>
                            </div>

                            <button id="bitunix-import-csv-btn-detail" class="primary w-full">
                                <i class="fas fa-upload mr-2"></i>Importar CSV de Bitunix
                            </button>

                            <div id="bitunix-csv-import-status" class="text-sm"></div>
                        </div>
                    </div>
                </div>

                <!-- Tab: Información -->
                <div class="platform-tab-content" id="bitunix-tab-info">
                    <div class="metric-card" style="background: #000; border: 2px solid #00ff88;">
                        <h3 class="text-lg font-semibold mb-4" style="color: #fff;">📚 Cómo Configurar API en Bitunix</h3>
                        <div class="space-y-4 text-sm" style="color: #fff; line-height: 1.8;">
                            <div style="background: rgba(0,255,136,0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #00ff88;">
                                <p style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">🔐 Paso 1: Accede a la Configuración de API</p>
                                <ol style="list-style: decimal; margin-left: 20px; line-height: 1.8;">
                                    <li>Inicia sesión en <strong>Bitunix.com</strong></li>
                                    <li>Ve a <strong>Account</strong> (esquina superior derecha)</li>
                                    <li>Selecciona <strong>API Management</strong></li>
                                    <li>Haz clic en <strong>Create API</strong></li>
                                </ol>
                            </div>

                            <div style="background: rgba(0,255,136,0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #00ff88;">
                                <p style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">⚙️ Paso 2: Configura los Permisos</p>
                                <ul style="list-style: disc; margin-left: 20px; line-height: 1.8;">
                                    <li><strong>Read Only:</strong> ✅ Activa esta opción</li>
                                    <li><strong>Trade:</strong> ❌ NO activar (no necesario)</li>
                                    <li><strong>Withdraw:</strong> ❌ NO activar (seguridad)</li>
                                </ul>
                                <p style="margin-top: 12px; color: #fbbf24;">⚠️ Solo necesitas permisos de <strong>lectura</strong> para sincronizar trades.</p>
                            </div>

                            <div style="background: rgba(0,255,136,0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #00ff88;">
                                <p style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">📝 Paso 3: Obtén las Credenciales</p>
                                <p>Bitunix te proporcionará:</p>
                                <ul style="list-style: disc; margin-left: 20px; line-height: 1.8; margin-top: 8px;">
                                    <li><strong>API Key:</strong> Una clave pública (ejemplo: <code style="background: rgba(0,0,0,0.5); padding: 2px 6px; border-radius: 4px;">BX-abc123...</code>)</li>
                                    <li><strong>Secret Key:</strong> Una clave privada (guárdala de forma segura)</li>
                                </ul>
                                <p style="margin-top: 12px; color: #ef4444;">🔒 <strong>IMPORTANTE:</strong> El Secret solo se muestra UNA VEZ. Guárdalo inmediatamente.</p>
                            </div>

                            <div style="background: rgba(0,255,136,0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #00ff88;">
                                <p style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">🚀 Paso 4: Conecta en Trading Survivor</p>
                                <ol style="list-style: decimal; margin-left: 20px; line-height: 1.8;">
                                    <li>Ve a la pestaña <strong>"Conexión API"</strong></li>
                                    <li>Pega tu <strong>API Key</strong> en el primer campo</li>
                                    <li>Pega tu <strong>Secret Key</strong> en el segundo campo</li>
                                    <li>Selecciona la <strong>cuenta destino</strong> donde guardar los trades</li>
                                    <li>Haz clic en <strong>"💾 Guardar Configuración"</strong></li>
                                    <li>Prueba la conexión con <strong>"Probar Conexión"</strong></li>
                                </ol>
                            </div>

                            <div style="background: rgba(59,130,246,0.1); padding: 12px; border-radius: 8px; margin-top: 16px;">
                                <p style="color: #60a5fa; font-weight: 600;">💡 Consejo Pro</p>
                                <p style="margin-top: 6px;">Una vez conectado, usa <strong>"Sincronizar Trades"</strong> para importar automáticamente todas tus operaciones. La sincronización es instantánea y no tiene límites.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- PANTALLA DETALLADA DE LBANK -->
        <section id="platform-lbank" class="section-container" style="display: none;">
            <div class="platform-detail-container">
                <!-- Header -->
                <div class="platform-detail-header">
                    <div class="platform-detail-back" id="back-to-platforms-lbank">
                        <i class="fas fa-arrow-left"></i>
                    </div>
                    <div class="platform-logo" style="background: #2E5BFF;">
                        <img src="logos/lbank-logo.png" alt="LBank Logo">
                    </div>
                    <div class="platform-detail-title">
                        <h2>LBank Exchange</h2>
                        <p>Configuración y Sincronización</p>
                    </div>
                </div>

                <!-- Estado de Conexión -->
                <div id="lbank-connection-status" class="status-card status-card-warning mb-6">
                    <i class="fas fa-exclamation-triangle status-card-icon"></i>
                    <div>
                        <p class="font-semibold text-lg mb-1">No conectado</p>
                        <p class="text-sm opacity-90">Importa operaciones mediante archivo CSV o API.</p>
                    </div>
                </div>

                <!-- Tabs de Navegación -->
                <div class="platform-tabs">
                    <button class="platform-tab active" data-tab="api">
                        <i class="fas fa-key mr-2"></i>Conexión API
                    </button>
                    <button class="platform-tab" data-tab="csv">
                        <i class="fas fa-file-csv mr-2"></i>Importar CSV
                    </button>
                    <button class="platform-tab" data-tab="info">
                        <i class="fas fa-info-circle mr-2"></i>Información
                    </button>
                </div>

                <!-- Tab: Conexión API -->
                <div class="platform-tab-content active" id="lbank-tab-api">
                    <div class="metric-card mb-6">
                        <h3 class="text-xl font-semibold mb-6">Configuración de API</h3>

                        <div class="space-y-5">
                            <div>
                                <label class="block mb-2 font-semibold text-sm">
                                    <i class="fas fa-key mr-2 text-primary"></i>Clave API
                                </label>
                                <input type="password" id="lbank-api-key-detail" class="w-full" placeholder="Introduce tu clave API de LBank">
                                <p class="text-xs text-text-secondary mt-2">La clave API se almacena localmente</p>
                            </div>

                            <div>
                                <label class="block mb-2 font-semibold text-sm">
                                    <i class="fas fa-lock mr-2 text-primary"></i>Private Key RSA (PEM formato)
                                </label>
                                <textarea id="lbank-private-key-detail" class="w-full font-mono text-xs" rows="8" placeholder="-----BEGIN PRIVATE KEY-----
MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQ...
-----END PRIVATE KEY-----"></textarea>
                                <p class="text-xs text-text-secondary mt-2">⚠️ LBank requiere firma RSA. Pega tu clave privada completa incluyendo los encabezados.</p>
                            </div>

                            <div>
                                <label class="block mb-2 font-semibold text-sm">
                                    <i class="fas fa-wallet mr-2 text-primary"></i>Cuenta a sincronizar
                                </label>
                                <select id="lbank-account-detail" class="w-full">
                                    <option value="">Seleccionar cuenta...</option>
                                </select>
                                <p class="text-xs text-text-secondary mt-2">Selecciona la cuenta donde se guardarán las operaciones sincronizadas</p>
                            </div>
                        </div>

                        <div class="status-card status-card-info mt-6">
                            <i class="fas fa-info-circle status-card-icon"></i>
                            <div class="text-sm">
                                <p class="font-semibold mb-1">Configurar API en LBank</p>
                                <p class="mb-2">Ve a <strong>API Management</strong> y crea nuevas credenciales. LBank soporta dos métodos de firma:</p>
                                <ul class="list-disc list-inside ml-4 space-y-1">
                                    <li><strong>RSA (Recomendado):</strong> Genera un par de claves RSA y sube la clave pública a LBank</li>
                                    <li><strong>HmacSHA256:</strong> Usa un secret key generado por LBank</li>
                                </ul>
                                <p class="mt-2">Trading Survivor usa el método <strong>RSA</strong> por mayor seguridad.</p>
                            </div>
                        </div>

                        <!-- Botón principal de guardar configuración -->
                        <button id="save-lbank-credentials" class="primary w-full mt-6">
                            <i class="fas fa-save mr-2"></i>💾 Guardar Configuración
                        </button>

                        <div class="grid grid-cols-2 gap-3 mt-4">
                            <button id="test-lbank-connection-detail" class="secondary">
                                <i class="fas fa-plug mr-2"></i>Probar Conexión
                            </button>
                            <button id="sync-lbank-trades-detail" class="success">
                                <i class="fas fa-sync-alt mr-2"></i>Sincronizar Trades
                            </button>
                        </div>

                        <div class="mt-4">
                            <button id="disconnect-lbank-detail" class="w-full danger">
                                <i class="fas fa-unlink mr-2"></i>Desconectar y Borrar Credenciales
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Tab: Importar CSV -->
                <div class="platform-tab-content" id="lbank-tab-csv">
                    <div class="metric-card">
                        <h3 class="text-xl font-semibold mb-6">Importar desde CSV</h3>
                        
                        <div class="space-y-5">
                            <div>
                                <label for="lbank-csv-file-input" class="block mb-3 font-semibold text-sm">
                                    <i class="fas fa-file-csv mr-2 text-primary"></i>Seleccionar archivo CSV
                                </label>
                                <input type="file" id="lbank-csv-file-input" accept=".csv" class="w-full">
                                <p class="text-xs text-text-secondary mt-3 leading-relaxed">
                                    <strong>Formato:</strong> El CSV debe contener columnas como Fecha, Par, Tipo (buy/sell), Precio, Cantidad, P&L, etc.
                                </p>
                            </div>

                            <button id="lbank-import-csv-btn-detail" class="primary w-full">
                                <i class="fas fa-upload mr-2"></i>Importar CSV de LBank
                            </button>

                            <div id="lbank-csv-import-status" class="text-sm"></div>
                        </div>
                    </div>
                </div>

                <!-- Tab: Información -->
                <div class="platform-tab-content" id="lbank-tab-info">
                    <div class="metric-card" style="background: #000; border: 2px solid #00ff88;">
                        <h3 class="text-lg font-semibold mb-4" style="color: #fff;">📚 Cómo Configurar API en LBank</h3>
                        <div class="space-y-4 text-sm" style="color: #fff; line-height: 1.8;">
                            <div style="background: rgba(0,255,136,0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #00ff88;">
                                <p style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">🔐 Paso 1: Genera un Par de Claves RSA</p>
                                <p>LBank usa autenticación RSA (más segura que HMAC). Necesitas generar claves RSA:</p>
                                <ol style="list-style: decimal; margin-left: 20px; line-height: 1.8; margin-top: 8px;">
                                    <li>Usa una herramienta como <code style="background: rgba(0,0,0,0.5); padding: 2px 6px; border-radius: 4px;">openssl</code> o un generador online</li>
                                    <li>Genera un par RSA de <strong>2048 bits</strong></li>
                                    <li>Guarda tanto la <strong>clave pública</strong> como la <strong>clave privada</strong></li>
                                </ol>
                                <pre style="background: rgba(0,0,0,0.7); padding: 12px; border-radius: 6px; margin-top: 12px; overflow-x: auto; font-size: 11px;">openssl genrsa -out private_key.pem 2048
openssl rsa -in private_key.pem -pubout -out public_key.pem</pre>
                            </div>

                            <div style="background: rgba(0,255,136,0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #00ff88;">
                                <p style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">⚙️ Paso 2: Registra la Clave Pública en LBank</p>
                                <ol style="list-style: decimal; margin-left: 20px; line-height: 1.8;">
                                    <li>Inicia sesión en <strong>LBank.com</strong></li>
                                    <li>Ve a <strong>Account → API Management</strong></li>
                                    <li>Haz clic en <strong>Create API Key</strong></li>
                                    <li>Pega tu <strong>clave pública RSA</strong> (contenido de <code>public_key.pem</code>)</li>
                                    <li>Selecciona permisos: <strong>Read Only</strong> ✅</li>
                                    <li>LBank te dará un <strong>API Key</strong></li>
                                </ol>
                            </div>

                            <div style="background: rgba(0,255,136,0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #00ff88;">
                                <p style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">📝 Paso 3: Obtén las Credenciales</p>
                                <p>LBank te proporcionará:</p>
                                <ul style="list-style: disc; margin-left: 20px; line-height: 1.8; margin-top: 8px;">
                                    <li><strong>API Key:</strong> Tu identificador público</li>
                                    <li><strong>RSA Private Key:</strong> Tu clave privada (del archivo <code>private_key.pem</code>)</li>
                                </ul>
                                <p style="margin-top: 12px; color: #ef4444;">🔒 <strong>IMPORTANTE:</strong> NUNCA compartastu clave privada RSA.</p>
                            </div>

                            <div style="background: rgba(0,255,136,0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #00ff88;">
                                <p style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">🚀 Paso 4: Conecta en Trading Survivor</p>
                                <ol style="list-style: decimal; margin-left: 20px; line-height: 1.8;">
                                    <li>Ve a la pestaña <strong>"Conexión API"</strong></li>
                                    <li>Pega tu <strong>API Key</strong> en el primer campo</li>
                                    <li>Pega tu <strong>clave privada RSA COMPLETA</strong> (incluyendo <code>-----BEGIN PRIVATE KEY-----</code>)</li>
                                    <li>Selecciona la <strong>cuenta destino</strong></li>
                                    <li>Haz clic en <strong>"💾 Guardar Configuración"</strong></li>
                                    <li>Prueba con <strong>"Probar Conexión"</strong></li>
                                </ol>
                            </div>

                            <div style="background: rgba(251,191,36,0.1); padding: 12px; border-radius: 8px; margin-top: 16px;">
                                <p style="color: #fbbf24; font-weight: 600;">⚠️ Nota Técnica</p>
                                <p style="margin-top: 6px;">LBank usa RSA-SHA256 + MD5 para firmar requests. Trading Survivor maneja esto automáticamente en el servidor proxy.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- PANTALLA DETALLADA DE BLOFIN -->
        <section id="platform-blofin" class="section-container" style="display: none;">
            <div class="platform-detail-container">
                <!-- Header -->
                <div class="platform-detail-header">
                    <div class="platform-detail-back" id="back-to-platforms-blofin">
                        <i class="fas fa-arrow-left"></i>
                    </div>
                    <div class="platform-logo" style="background: #00C9A7;">
                        <img src="logos/blofin-logo.png" alt="BloFin Logo">
                    </div>
                    <div class="platform-detail-title">
                        <h2>BloFin Exchange</h2>
                        <p>Configuración y Sincronización</p>
                    </div>
                </div>

                <!-- Estado de Conexión -->
                <div id="blofin-connection-status" class="status-card status-card-warning mb-6">
                    <i class="fas fa-exclamation-triangle status-card-icon"></i>
                    <div>
                        <p class="font-semibold text-lg mb-1">No conectado</p>
                        <p class="text-sm opacity-90">Importa operaciones mediante archivo CSV o API.</p>
                    </div>
                </div>

                <!-- Tabs de Navegación -->
                <div class="platform-tabs">
                    <button class="platform-tab active" data-tab="api">
                        <i class="fas fa-key mr-2"></i>Conexión API
                    </button>
                    <button class="platform-tab" data-tab="csv">
                        <i class="fas fa-file-csv mr-2"></i>Importar CSV
                    </button>
                    <button class="platform-tab" data-tab="info">
                        <i class="fas fa-info-circle mr-2"></i>Información
                    </button>
                </div>

                <!-- API Tab -->
                <div class="platform-tab-content active" id="blofin-tab-api">
                    <div class="metric-card mb-6">
                        <h3 class="text-xl font-semibold mb-6">
                            <i class="fas fa-key mr-2 text-primary"></i>Configuración de API
                        </h3>

                        <div class="space-y-5">
                            <!-- API Key Input -->
                            <div>
                                <label for="blofin-api-key-detail" class="block mb-2 font-semibold text-sm">
                                    <i class="fas fa-key mr-2 text-primary"></i>Clave API
                                </label>
                                <input 
                                    type="password" 
                                    id="blofin-api-key-detail" 
                                    class="w-full px-4 py-3 bg-background border border-border rounded-lg focus:outline-none focus:border-primary transition-colors" 
                                    placeholder="Introduce tu clave API de BloFin"
                                >
                            </div>

                            <!-- Secret Key Input -->
                            <div>
                                <label for="blofin-secret-key-detail" class="block mb-2 font-semibold text-sm">
                                    <i class="fas fa-lock mr-2 text-primary"></i>Secret Key
                                </label>
                                <input 
                                    type="password" 
                                    id="blofin-secret-key-detail" 
                                    class="w-full px-4 py-3 bg-background border border-border rounded-lg focus:outline-none focus:border-primary transition-colors" 
                                    placeholder="Introduce tu secret de BloFin"
                                >
                            </div>

                            <!-- Passphrase Input -->
                            <div>
                                <label for="blofin-passphrase-detail" class="block mb-2 font-semibold text-sm">
                                    <i class="fas fa-shield-alt mr-2 text-primary"></i>Passphrase
                                </label>
                                <input 
                                    type="password" 
                                    id="blofin-passphrase-detail" 
                                    class="w-full px-4 py-3 bg-background border border-border rounded-lg focus:outline-none focus:border-primary transition-colors" 
                                    placeholder="Introduce tu passphrase de BloFin"
                                >
                            </div>

                            <!-- Account Selector -->
                            <div>
                                <label for="blofin-account-detail" class="block mb-2 font-semibold text-sm">
                                    <i class="fas fa-wallet mr-2 text-primary"></i>Cuenta a sincronizar
                                </label>
                                <select 
                                    id="blofin-account-detail" 
                                    class="w-full px-4 py-3 bg-background border border-border rounded-lg focus:outline-none focus:border-primary transition-colors"
                                >
                                    <option value="">Seleccionar cuenta...</option>
                                </select>
                            </div>
                        </div>

                        <!-- Info Card -->
                        <div class="status-card status-card-info mt-6">
                            <i class="fas fa-info-circle status-card-icon"></i>
                            <div class="text-sm">
                                <p class="font-semibold mb-1">Configurar API en BloFin</p>
                                <p>Ve a Account → API Management y crea nuevas credenciales. Activa los permisos de <strong>Lectura</strong> y anota API Key, Secret Key y Passphrase.</p>
                            </div>
                        </div>

                        <!-- Action Buttons -->
                        <button 
                            id="save-blofin-credentials" 
                            class="w-full mt-6 px-6 py-3 bg-primary text-background font-semibold rounded-lg hover:bg-secondary transition-colors flex items-center justify-center"
                        >
                            <i class="fas fa-save mr-2"></i>💾 Guardar Configuración
                        </button>

                        <div class="grid grid-cols-2 gap-3 mt-4">
                            <button 
                                id="test-blofin-connection-detail" 
                                class="px-4 py-3 bg-surface border border-primary text-primary font-semibold rounded-lg hover:bg-primary hover:text-background transition-colors flex items-center justify-center"
                            >
                                <i class="fas fa-plug mr-2"></i>Probar Conexión
                            </button>
                            <button 
                                id="sync-blofin-trades-detail" 
                                class="px-4 py-3 bg-green-600 text-white font-semibold rounded-lg hover:bg-green-700 transition-colors flex items-center justify-center"
                            >
                                <i class="fas fa-sync-alt mr-2"></i>Sincronizar Trades
                            </button>
                        </div>

                        <div class="mt-4">
                            <button 
                                id="disconnect-blofin-detail" 
                                class="w-full px-4 py-3 bg-red-600 text-white font-semibold rounded-lg hover:bg-red-700 transition-colors flex items-center justify-center"
                            >
                                <i class="fas fa-unlink mr-2"></i>Desconectar y Borrar Credenciales
                            </button>
                        </div>
                    </div>
                </div>

                <!-- CSV Tab -->
                <div class="platform-tab-content" id="blofin-tab-csv">
                    <div class="metric-card">
                        <h3 class="text-xl font-semibold mb-6">
                            <i class="fas fa-file-csv mr-2 text-primary"></i>Importar desde CSV
                        </h3>
                        
                        <div class="space-y-5">
                            <div>
                                <label for="blofin-csv-file-input" class="block mb-3 font-semibold text-sm">
                                    <i class="fas fa-file-csv mr-2 text-primary"></i>Seleccionar archivo CSV
                                </label>
                                <input 
                                    type="file" 
                                    id="blofin-csv-file-input" 
                                    accept=".csv" 
                                    class="w-full px-4 py-3 bg-background border border-border rounded-lg focus:outline-none focus:border-primary transition-colors cursor-pointer"
                                >
                            </div>

                            <button 
                                id="blofin-import-csv-btn-detail" 
                                class="w-full px-6 py-3 bg-primary text-background font-semibold rounded-lg hover:bg-secondary transition-colors flex items-center justify-center"
                            >
                                <i class="fas fa-upload mr-2"></i>Importar CSV de BloFin
                            </button>

                            <div id="blofin-csv-import-status" class="text-sm text-center"></div>
                        </div>

                        <div class="status-card status-card-info mt-6">
                            <i class="fas fa-info-circle status-card-icon"></i>
                            <div class="text-sm">
                                <p class="font-semibold mb-1">Formato del CSV</p>
                                <p>Exporta tu historial de operaciones desde BloFin → Trade History y selecciona el archivo CSV resultante.</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Info Tab -->
                <div class="platform-tab-content" id="blofin-tab-info">
                    <div class="metric-card" style="background: #000; border: 2px solid #00ff88;">
                        <h3 class="text-lg font-semibold mb-4" style="color: #fff;">
                            📚 Cómo Configurar API en BloFin
                        </h3>
                        <div class="space-y-4 text-sm" style="color: #fff; line-height: 1.8;">
                            <div style="background: rgba(0,255,136,0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #00ff88;">
                                <p style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">🔐 Paso 1: Accede a la Configuración de API</p>
                                <ol style="list-style: decimal; margin-left: 20px; line-height: 1.8;">
                                    <li>Inicia sesión en <strong>BloFin.com</strong></li>
                                    <li>Ve a <strong>Account</strong> (esquina superior derecha)</li>
                                    <li>Selecciona <strong>API Management</strong></li>
                                    <li>Haz clic en <strong>Create New API</strong></li>
                                </ol>
                            </div>

                            <div style="background: rgba(0,255,136,0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #00ff88;">
                                <p style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">⚙️ Paso 2: Configura los Permisos</p>
                                <ul style="list-style: disc; margin-left: 20px; line-height: 1.8;">
                                    <li><strong>Read Only:</strong> ✅ Activa esta opción</li>
                                    <li><strong>Trade:</strong> ❌ NO activar (no necesario)</li>
                                    <li><strong>Withdraw:</strong> ❌ NO activar (mayor seguridad)</li>
                                </ul>
                                <p style="margin-top: 12px; color: #fbbf24;">⚠️ Solo necesitas permisos de <strong>lectura</strong> para sincronizar trades.</p>
                            </div>

                            <div style="background: rgba(0,255,136,0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #00ff88;">
                                <p style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">📝 Paso 3: Obtén las Credenciales</p>
                                <p>BloFin te proporcionará:</p>
                                <ul style="list-style: disc; margin-left: 20px; line-height: 1.8; margin-top: 8px;">
                                    <li><strong>API Key:</strong> Tu identificador público</li>
                                    <li><strong>Secret Key:</strong> Tu clave privada</li>
                                    <li><strong>Passphrase:</strong> Una frase de seguridad adicional (que TÚ defines al crear la API)</li>
                                </ul>
                                <p style="margin-top: 12px; color: #ef4444;">🔒 <strong>IMPORTANTE:</strong> El Secret y Passphrase solo se muestran UNA VEZ. Guárdalos inmediatamente.</p>
                            </div>

                            <div style="background: rgba(0,255,136,0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #00ff88;">
                                <p style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">🚀 Paso 4: Conecta en Trading Survivor</p>
                                <ol style="list-style: decimal; margin-left: 20px; line-height: 1.8;">
                                    <li>Ve a la pestaña <strong>"Conexión API"</strong></li>
                                    <li>Pega tu <strong>API Key</strong> en el primer campo</li>
                                    <li>Pega tu <strong>Secret Key</strong> en el segundo campo</li>
                                    <li>Pega tu <strong>Passphrase</strong> en el tercer campo</li>
                                    <li>Selecciona la <strong>cuenta destino</strong> donde guardar los trades</li>
                                    <li>Haz clic en <strong>"💾 Guardar Configuración"</strong></li>
                                    <li>Prueba la conexión con <strong>"Probar Conexión"</strong></li>
                                </ol>
                            </div>

                            <div style="background: rgba(59,130,246,0.1); padding: 12px; border-radius: 8px; margin-top: 16px;">
                                <p style="color: #60a5fa; font-weight: 600;">💡 Consejo Pro</p>
                                <p style="margin-top: 6px;">BloFin usa HMAC SHA256 con passphrase adicional para mayor seguridad. Una vez conectado, la sincronización de trades es automática e instantánea.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <div id="loading" class="loading" style="display: none;"><div class="spinner"></div></div>

        <div id="image-modal" class="image-modal">
            <span class="image-modal-fullscreen-btn" id="image-modal-fullscreen-btn" title="Pantalla completa">
                <i class="fas fa-expand"></i>
            </span>
            <span class="image-modal-close" id="image-modal-close-btn">&times;</span>
            <span class="image-modal-nav" id="image-modal-prev">&#10094;</span>
            <img class="image-modal-content" id="modal-image-content">
            <span class="image-modal-nav" id="image-modal-next">&#10095;</span>
            <div class="image-modal-counter" id="image-modal-counter">1 / 1</div>
        </div>

        <!-- Date Range Selector Modal -->
        <div id="date-range-modal" class="fixed inset-0 z-50 flex items-center justify-center p-4 hidden" style="background-color: rgba(0,0,0,0.95);">
            <div class="relative bg-surface border border-border rounded-lg shadow-lg p-6 w-full max-w-lg">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-xl font-semibold">Seleccionar Rango de Fechas</h3>
                    <button id="date-range-close-btn" class="p-2 -mr-2 rounded-full hover:bg-surface-light"><i class="fas fa-times"></i></button>
                </div>
                <div class="flex flex-col md:flex-row gap-6">
                    <!-- Predefined Ranges -->
                    <div class="w-full md:w-1/3 border-b md:border-b-0 md:border-r border-border pb-4 md:pb-0 md:pr-6">
                        <h4 class="text-sm font-semibold mb-3">Rangos Rápidos</h4>
                        <div class="space-y-2">
                            <button class="w-full text-left p-2 rounded hover:bg-surface-light date-range-preset" data-range="today">Hoy</button>
                            <button class="w-full text-left p-2 rounded hover:bg-surface-light date-range-preset" data-range="this_week">Esta Semana</button>
                            <button class="w-full text-left p-2 rounded hover:bg-surface-light date-range-preset" data-range="this_month">Este Mes</button>
                            <button class="w-full text-left p-2 rounded hover:bg-surface-light date-range-preset" data-range="last_7_days">Últimos 7 días</button>
                            <button class="w-full text-left p-2 rounded hover:bg-surface-light date-range-preset" data-range="last_30_days">Últimos 30 días</button>
                            <button class="w-full text-left p-2 rounded hover:bg-surface-light date-range-preset" data-range="this_year">Este Año</button>
                        </div>
                    </div>
                    <!-- Calendar -->
                    <div class="w-full md:w-2/3">
                        <div class="flex justify-between items-center mb-3">
                            <button id="calendar-prev-month" class="p-2 rounded-full hover:bg-surface-light"><i class="fas fa-chevron-left"></i></button>
                            <h4 id="calendar-month-year" class="font-semibold text-lg"></h4>
                            <button id="calendar-next-month" class="p-2 rounded-full hover:bg-surface-light"><i class="fas fa-chevron-right"></i></button>
                        </div>
                        <div class="grid grid-cols-7 gap-1 text-center text-sm mb-2 text-text-secondary">
                            <div>Do</div><div>Lu</div><div>Ma</div><div>Mi</div><div>Ju</div><div>Vi</div><div>Sá</div>
                        </div>
                        <div id="calendar-days" class="grid grid-cols-7 gap-1">
                            <!-- Calendar days will be generated here -->
                        </div>
                    </div>
                </div>
                <div class="mt-6 border-t border-border pt-4 flex justify-between items-center">
                    <div class="flex items-center gap-2 text-sm">
                        <input type="text" id="date-range-start-input" class="bg-surface-light p-2 rounded w-32 text-center" placeholder="Inicio">
                        <span>-</span>
                        <input type="text" id="date-range-end-input" class="bg-surface-light p-2 rounded w-32 text-center" placeholder="Fin">
                    </div>
                    <div class="space-x-2">
                        <button id="date-range-clear-btn" class="secondary">Limpiar</button>
                        <button id="date-range-apply-btn" class="primary">Aplicar</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="day-detail-modal" class="fixed inset-0 hidden items-center justify-center z-[1002] px-4 py-6"><div class="p-5 rounded-lg shadow-xl w-full max-w-3xl text-text relative flex flex-col max-h-[90vh]"><div class="flex justify-between items-center mb-4 pb-3 border-b border-surface-light"><h3 id="day-modal-title" class="text-xl font-semibold">Trades del DD/MM/YYYY</h3><button id="close-day-modal-icon" class="text-2xl text-text-secondary hover:text-text leading-none -mt-1">&times;</button></div><div class="mb-4 grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-x-4 gap-y-3 text-sm"><div>P&L Total: <span id="day-total-pl-header" class="font-semibold"></span></div><div>Trades Totales: <span id="day-total-trades-header" class="font-semibold"></span></div><div>Win Rate: <span id="day-win-rate-header" class="font-semibold"></span></div><div>Ganadores: <span id="day-winners-header" class="font-semibold"></span></div><div>Perdedores: <span id="day-losers-header" class="font-semibold"></span></div><div>Comisiones: <span id="day-fees-header" class="font-semibold text-red"></span></div><div>Volumen: <span id="day-volume-header" class="font-semibold"></span></div><div class="md:col-span-1">Profit Factor: <span id="day-profit-factor-header" class="font-semibold"></span></div><div class="md:col-span-2 border-t border-surface-light pt-2">P&L Neto (después fees): <span id="day-net-pl-header" class="font-bold"></span></div></div><div class="overflow-y-auto flex-grow mb-4 border border-surface-light rounded-md"><table class="w-full text-left text-sm"><thead class="sticky top-0 bg-surface z-10"><tr><th class="py-2 px-3">ID</th><th class="py-2 px-3"></th>Hora Entrada</th><th class="py-2 px-3">Símbolo</th><th class="py-2 px-3">Tipo</th><th class="py-2 px-3">P&L Neto</th><th class="py-2 px-3">Hora Salida</th></tr></thead><tbody id="day-modal-table-body" class="divide-y divide-surface"></tbody></table></div><div class="text-right pt-4 border-t border-surface-light"><button id="close-day-modal-btn" class="primary px-4 py-2">Cerrar</button></div></div></div>

        <!-- Modal de Importación desde Interfaz de Bitget -->
        <div id="bitget-interface-import-modal" class="fixed inset-0 z-50 hidden items-center justify-center p-4" style="background-color: rgba(0,0,0,0.95);">
            <div class="relative bg-surface border border-border rounded-lg shadow-lg p-6 w-full max-w-4xl max-h-[90vh] flex flex-col">
                <div class="flex justify-between items-center mb-4">
                    <div>
                        <h3 class="text-xl font-semibold">Importar desde Interfaz de Bitget</h3>
                        <p class="text-sm text-text-secondary mt-1">Copia y pega las operaciones desde el Historial de Posición</p>
                    </div>
                    <button id="bitget-interface-close-btn" class="p-2 -mr-2 rounded-full hover:bg-surface-light"><i class="fas fa-times"></i></button>
                </div>
                
                <div class="flex-1 flex flex-col gap-4 overflow-hidden">
                    <!-- Instrucciones -->
                    <div class="bg-blue-900 bg-opacity-20 border border-blue-700 rounded-lg p-4">
                        <h4 class="font-semibold mb-2 flex items-center gap-2">
                            <i class="fas fa-info-circle text-blue-400"></i>
                            Instrucciones
                        </h4>
                        <ol class="text-sm text-text-secondary space-y-1 ml-4 list-decimal">
                            <li>Ve a Bitget → <strong>Trading de Futuros</strong> → <strong>Historial de Posición</strong></li>
                            <li>Selecciona las operaciones que deseas importar</li>
                            <li>Copia toda la información (Ctrl+C o Cmd+C)</li>
                            <li>Pega los datos en el área de texto a continuación</li>
                            <li>Selecciona la cuenta donde deseas importar las operaciones</li>
                            <li>Haz clic en "Importar Operaciones"</li>
                        </ol>
                    </div>

                    <!-- Selector de cuenta -->
                    <div class="flex items-center gap-4">
                        <label for="bitget-interface-account" class="text-sm font-semibold whitespace-nowrap">
                            <i class="fas fa-wallet mr-2"></i>Cuenta destino:
                        </label>
                        <select id="bitget-interface-account" class="flex-1 bg-background border border-border rounded px-3 py-2 text-sm">
                            <option value="">Selecciona una cuenta...</option>
                        </select>
                    </div>

                    <!-- Área de texto para pegar datos -->
                    <div class="flex-1 flex flex-col overflow-hidden">
                        <label for="bitget-interface-data" class="text-sm font-semibold mb-2">
                            <i class="fas fa-paste mr-2"></i>Datos del Historial de Posición:
                        </label>
                        <textarea 
                            id="bitget-interface-data" 
                            class="flex-1 bg-background border border-border rounded p-3 text-sm font-mono resize-none"
                            placeholder="Pega aquí los datos copiados desde Bitget...&#10;&#10;Ejemplo:&#10;BTCUSDT&#10;Short · Aislado&#10;2025-08-23&#10;17:37:37&#10;114,818.1&#10;114,794.1&#10;0.5565 BTC&#10;0.5565 BTC&#10;-37.7531 USDT&#10;--&#10;2025-08-23&#10;17:58:12&#10;--"
                        ></textarea>
                    </div>

                    <!-- Mensaje de estado -->
                    <div id="bitget-interface-status" class="text-sm text-center"></div>
                </div>

                <div class="mt-4 pt-4 border-t border-border flex justify-end gap-3">
                    <button id="bitget-interface-cancel-btn" class="px-4 py-2 bg-surface-light border border-border rounded hover:bg-surface transition-colors">
                        Cancelar
                    </button>
                    <button id="bitget-interface-import-btn-modal" class="px-4 py-2 bg-primary text-background rounded hover:bg-secondary transition-colors font-semibold">
                        <i class="fas fa-upload mr-2"></i>Importar Operaciones
                    </button>
                </div>
            </div>
        </div>

        <!-- Modal de Importación desde Interfaz de Bitget -->
        <div id="bitget-interface-import-modal" class="fixed inset-0 z-50 hidden items-center justify-center p-4" style="background-color: rgba(0,0,0,0.95);">
            <div class="relative bg-surface border border-border rounded-lg shadow-lg p-6 w-full max-w-4xl max-h-[90vh] flex flex-col">
                <div class="flex justify-between items-center mb-4">
                    <div>
                        <h3 class="text-xl font-semibold">Importar desde Interfaz de Bitget</h3>
                        <p class="text-sm text-text-secondary mt-1">Copia y pega las operaciones desde el Historial de Posición</p>
                    </div>
                    <button id="bitget-interface-close-btn" class="p-2 -mr-2 rounded-full hover:bg-surface-light"><i class="fas fa-times"></i></button>
                </div>
                
                <div class="flex-1 flex flex-col gap-4 overflow-hidden">
                    <!-- Instrucciones -->
                    <div class="bg-blue-900 bg-opacity-20 border border-blue-700 rounded-lg p-4">
                        <h4 class="font-semibold mb-2 flex items-center gap-2">
                            <i class="fas fa-info-circle text-blue-400"></i>
                            Instrucciones
                        </h4>
                        <ol class="text-sm text-text-secondary space-y-1 ml-4 list-decimal">
                            <li>Ve a Bitget → <strong>Trading de Futuros</strong> → <strong>Historial de Posición</strong></li>
                            <li>Selecciona las operaciones que deseas importar</li>
                            <li>Copia toda la información (Ctrl+C o Cmd+C)</li>
                            <li>Pega los datos en el área de texto a continuación</li>
                            <li>Selecciona la cuenta donde deseas importar las operaciones</li>
                            <li>Haz clic en "Importar Operaciones"</li>
                        </ol>
                    </div>

                    <!-- Selector de cuenta -->
                    <div class="flex items-center gap-4">
                        <label for="bitget-interface-account" class="text-sm font-semibold whitespace-nowrap">
                            <i class="fas fa-wallet mr-2"></i>Cuenta destino:
                        </label>
                        <select id="bitget-interface-account" class="flex-1 bg-background border border-border rounded px-3 py-2 text-sm">
                            <option value="">Selecciona una cuenta...</option>
                        </select>
                    </div>

                    <!-- Área de texto para pegar datos -->
                    <div class="flex-1 flex flex-col overflow-hidden">
                        <label for="bitget-interface-data" class="text-sm font-semibold mb-2">
                            <i class="fas fa-paste mr-2"></i>Datos del Historial de Posición:
                        </label>
                        <textarea 
                            id="bitget-interface-data" 
                            class="flex-1 bg-background border border-border rounded p-3 text-sm font-mono resize-none"
                            placeholder="Pega aquí los datos copiados desde Bitget...&#10;&#10;Ejemplo:&#10;BTCUSDT&#10;Short · Aislado&#10;2025-08-23&#10;17:37:37&#10;114,818.1&#10;114,794.1&#10;0.5565 BTC&#10;0.5565 BTC&#10;-37.7531 USDT&#10;--&#10;2025-08-23&#10;17:58:12&#10;--"
                        ></textarea>
                    </div>

                    <!-- Mensaje de estado -->
                    <div id="bitget-interface-status" class="text-sm text-center"></div>
                </div>

                <div class="mt-4 pt-4 border-t border-border flex justify-end gap-3">
                    <button id="bitget-interface-cancel-btn" class="px-4 py-2 bg-surface-light border border-border rounded hover:bg-surface transition-colors">
                        Cancelar
                    </button>
                    <button id="bitget-interface-import-btn-modal" class="px-4 py-2 bg-primary text-background rounded hover:bg-secondary transition-colors font-semibold">
                        <i class="fas fa-upload mr-2"></i>Importar Operaciones
                    </button>
                </div>
            </div>
        </div>

        <!-- Modal de Importación desde Interfaz de PrimeXBT -->
        <div id="primexbt-interface-import-modal" class="fixed inset-0 z-50 hidden flex items-center justify-center p-4" style="background-color: rgba(0,0,0,0.95);">
            <div class="relative bg-surface border border-border rounded-lg shadow-lg p-6 w-full max-w-4xl max-h-[90vh] flex flex-col">
                <div class="flex justify-between items-center mb-4">
                    <div>
                        <h3 class="text-xl font-semibold">Importar desde Interfaz de PrimeXBT</h3>
                        <p class="text-sm text-text-secondary mt-1">Copia y pega las operaciones directamente desde la interfaz del broker</p>
                    </div>
                    <button id="primexbt-interface-close-btn" class="p-2 -mr-2 rounded-full hover:bg-surface-light"><i class="fas fa-times"></i></button>
                </div>
                
                <div class="flex-1 flex flex-col gap-4 overflow-hidden">
                    <!-- Instrucciones -->
                    <div class="bg-blue-900 bg-opacity-20 border border-blue-700 rounded-lg p-4">
                        <h4 class="font-semibold mb-2 flex items-center gap-2">
                            <i class="fas fa-info-circle text-blue-400"></i>
                            Instrucciones
                        </h4>
                        <ol class="text-sm text-text-secondary space-y-1 ml-4 list-decimal">
                            <li>Ve a tu historial de operaciones en PrimeXBT</li>
                            <li>Selecciona las operaciones que deseas importar</li>
                            <li>Copia toda la información (Ctrl+C o Cmd+C)</li>
                            <li>Pega los datos en el área de texto a continuación</li>
                            <li>Selecciona la cuenta donde deseas importar las operaciones</li>
                            <li>Haz clic en "Importar Operaciones"</li>
                        </ol>
                    </div>

                    <!-- Selector de cuenta -->
                    <div class="flex items-center gap-4">
                        <label for="primexbt-interface-account" class="text-sm font-semibold whitespace-nowrap">
                            <i class="fas fa-wallet mr-2"></i>Cuenta destino:
                        </label>
                        <select id="primexbt-interface-account" class="flex-1 bg-background border border-border rounded px-3 py-2 text-sm">
                            <option value="">Selecciona una cuenta...</option>
                        </select>
                    </div>

                    <!-- Área de texto para pegar datos -->
                    <div class="flex-1 flex flex-col overflow-hidden">
                        <label for="primexbt-interface-data" class="text-sm font-semibold mb-2">
                            <i class="fas fa-paste mr-2"></i>Datos de operaciones:
                        </label>
                        <textarea 
                            id="primexbt-interface-data" 
                            class="flex-1 bg-background border border-border rounded p-3 text-sm font-mono resize-none"
                            placeholder="Pega aquí los datos copiados desde PrimeXBT...&#10;&#10;Ejemplo:&#10;1132091056&#10;ETH/USDT&#10;Mercado&#10;Vender&#10;Ejecutado&#10;4,10&#10;−6,3714 USDT&#10;+66,0510 USDT&#10;+22,81 %&#10;—&#10;4,10&#10;3453,34&#10;08/11/25, 09:59:59"
                        ></textarea>
                    </div>

                    <!-- Mensaje de estado -->
                    <div id="primexbt-interface-status" class="text-sm text-center"></div>
                </div>

                <div class="mt-4 pt-4 border-t border-border flex justify-end gap-3">
                    <button id="primexbt-interface-cancel-btn" class="px-4 py-2 bg-surface-light border border-border rounded hover:bg-surface transition-colors">
                        Cancelar
                    </button>
                    <button id="primexbt-interface-import-btn" class="px-4 py-2 bg-primary text-background rounded hover:bg-secondary transition-colors font-semibold">
                        <i class="fas fa-upload mr-2"></i>Importar Operaciones
                    </button>
                </div>
            </div>
        </div>

        <!-- --- NUEVO: Modal para Detalles de Analytics --- -->
        <div id="analytics-detail-modal">
            <div class="analytics-detail-container">
                <div class="flex justify-between items-start mb-6">
                    <h2 id="analytics-detail-title" class="text-3xl font-bold text-primary">Análisis Detallado</h2>
                    <button id="analytics-detail-close-btn" class="text-3xl text-text-secondary hover:text-text leading-none">&times;</button>
                </div>

                <!-- Tabs de navegación (solo visible en análisis de día/mes) -->
                <div id="analytics-detail-tabs-container" style="display: none;" class="nav-tabs flex mb-6">
                    <div class="nav-tab analytics-detail-tab active" data-target="general">General</div>
                    <div class="nav-tab analytics-detail-tab" data-target="metricas-dia" id="analytics-metricas-tab">Métricas del Día</div>
                    <div class="nav-tab analytics-detail-tab" data-target="notas" id="analytics-notas-tab">Notas</div>
                </div>

                <!-- Métricas principales -->
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-6 gap-6 mb-8">
                    <div class="metric-card"><h3 class="text-sm font-medium text-text-secondary mb-1">P&L Bruto Total</h3><p id="analytics-detail-pl" class="text-3xl font-bold">$0.00</p></div>
                    <div class="metric-card"><h3 class="text-sm font-medium text-text-secondary mb-1">Win Rate</h3><p id="analytics-detail-winrate" class="text-3xl font-bold">0%</p></div>
                    <div class="metric-card"><h3 class="text-sm font-medium text-text-secondary mb-1">Profit Factor</h3><p id="analytics-detail-pf" class="text-3xl font-bold">0.00</p></div>
                    <div class="metric-card"><h3 class="text-sm font-medium text-text-secondary mb-1">Operaciones</h3><p id="analytics-detail-trades" class="text-3xl font-bold">0</p></div>
                    <div class="metric-card"><h3 class="text-sm font-medium text-text-secondary mb-1">Total Comisiones</h3><p id="analytics-detail-fees" class="text-3xl font-bold text-red">$0.00</p></div>
                    <div class="metric-card"><h3 class="text-sm font-medium text-text-secondary mb-1">R:R Promedio</h3><p id="analytics-detail-rr" class="text-3xl font-bold text-primary">0.00</p></div>
                </div>

                <!-- TAB: GENERAL -->
                <div id="analytics-detail-tab-general" class="analytics-detail-tab-content">
                    <!-- Gráficos y Métricas Avanzadas -->
                    <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-8">
                        <div class="metric-card lg:col-span-1">
                            <h3 class="text-lg font-semibold mb-3">Estadísticas Clave</h3>
                            <dl class="space-y-3 text-sm">
                                <div class="flex justify-between"><dt>Ganancia Promedio:</dt><dd id="analytics-detail-avg-win" class="font-semibold text-green">$0.00</dd></div>
                                <div class="flex justify-between"><dt>Pérdida Promedio:</dt><dd id="analytics-detail-avg-loss" class="font-semibold text-red">$0.00</dd></div>
                                <div class="flex justify-between"><dt>Comisión Promedio:</dt><dd id="analytics-detail-avg-fee" class="font-semibold text-yellow">$0.00</dd></div>
                                <div class="flex justify-between"><dt>Ratio G/P Promedio:</dt><dd id="analytics-detail-w-l-ratio" class="font-semibold">0.00</dd></div>
                                <div class="flex justify-between"><dt>Mayor Ganancia:</dt><dd id="analytics-detail-largest-win" class="font-semibold text-green">$0.00</dd></div>
                                <div class="flex justify-between"><dt>Mayor Pérdida:</dt><dd id="analytics-detail-largest-loss" class="font-semibold text-red">$0.00</dd></div>
                                <div class="flex justify-between"><dt>Drawdown Máximo:</dt><dd id="analytics-detail-drawdown" class="font-semibold text-red">$0.00</dd></div>
                                <div class="flex justify-between border-t border-surface-light pt-2 mt-2"><dt class="font-bold">P&L Neto Total:</dt><dd id="analytics-detail-net-pl" class="font-bold text-green">$0.00</dd></div>
                            </dl>
                        </div>
                        <div class="metric-card lg:col-span-2">
                            <h3 class="text-lg font-semibold mb-2">Puntuación de Rendimiento</h3>
                            <div class="chart-container" style="height: 250px;">
                                <canvas id="analytics-detail-radar-chart"></canvas>
                            </div>
                        </div>
                    </div>

                    <!-- Más Gráficos -->
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                        <div class="metric-card">
                            <h3 class="text-lg font-semibold mb-2">Rendimiento por Instrumento</h3>
                            <div class="chart-container" style="height: 280px;">
                                <canvas id="analytics-detail-instrument-chart"></canvas>
                            </div>
                        </div>
                        <div class="metric-card">
                            <h3 class="text-lg font-semibold mb-2">Rendimiento Long vs Short</h3>
                            <div class="chart-container" style="height: 280px;">
                                <canvas id="analytics-detail-long-short-chart"></canvas>
                            </div>
                        </div>
                    </div>

                    <!-- Gráfica de Evolución del P&L -->
                    <div class="metric-card mb-6">
                        <h3 class="text-lg font-semibold mb-4">Evolución del P&L</h3>
                        <div class="chart-container" style="height: 300px;">
                            <canvas id="analytics-detail-pnl-evolution-chart"></canvas>
                        </div>
                    </div>

                    <!-- Tabla de Operaciones -->
                    <div class="metric-card p-0">
                        <h3 class="text-lg font-semibold p-4">Operaciones del Período</h3>
                        <div class="overflow-y-auto max-h-96">
                            <table class="w-full text-sm">
                                <thead>
                                    <tr>
                                        <th>Fecha</th>
                                        <th>Instrumento</th>
                                        <th>Tipo</th>
                                        <th>Entrada</th>
                                        <th>Salida</th>
                                        <th>Volumen</th>
                                        <th>P&L</th>
                                    </tr>
                                </thead>
                                <tbody id="analytics-detail-table-body">
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>

                <!-- TAB: MÉTRICAS DEL DÍA -->
                <div id="analytics-detail-tab-metricas-dia" class="analytics-detail-tab-content" style="display: none;">
                    <!-- Métricas numéricas del día -->
                    <div class="grid grid-cols-2 md:grid-cols-4 gap-4 bg-surface p-4 rounded-lg border border-surface-light mb-8">
                        <div>
                            <p class="text-xs text-text-secondary mb-1">Eficiencia</p>
                            <p id="day-metric-efficiency" class="text-lg font-bold text-primary">0%</p>
                        </div>
                        <div>
                            <p class="text-xs text-text-secondary mb-1">Duración Total</p>
                            <p id="day-metric-duration" class="text-lg font-bold">0h 0m</p>
                        </div>
                        <div>
                            <p class="text-xs text-text-secondary mb-1">Mejor Hora</p>
                            <p id="day-metric-best-hour" class="text-lg font-bold text-green">--:--</p>
                        </div>
                        <div>
                            <p class="text-xs text-text-secondary mb-1">Peor Hora</p>
                            <p id="day-metric-worst-hour" class="text-lg font-bold text-red">--:--</p>
                        </div>
                    </div>

                    <!-- Gráficas de barra (solo para análisis de día) -->
                    <div id="day-specific-charts-metrics" class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                        <div class="metric-card">
                            <h3 class="text-lg font-semibold mb-2">Comparativa: Hoy vs Promedio</h3>
                            <div class="chart-container" style="height: 280px;">
                                <canvas id="analytics-detail-comparison-chart"></canvas>
                            </div>
                        </div>
                        <div class="metric-card">
                            <h3 class="text-lg font-semibold mb-2">P/L por Sesión de Mercado</h3>
                            <div class="chart-container" style="height: 280px;">
                                <canvas id="analytics-detail-session-chart"></canvas>
                            </div>
                        </div>
                    </div>

                    <!-- ======= GRÁFICAS PARA ANÁLISIS DEL DÍA ======= -->
                    <div id="day-charts-container" style="display: none;">
                        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                            <div class="metric-card">
                                <h3 class="text-lg font-semibold mb-2">Performance por Momento del Día</h3>
                                <div class="chart-container" style="height: 280px;">
                                    <canvas id="analytics-detail-timeofday-chart"></canvas>
                                </div>
                            </div>
                            <div class="metric-card">
                                <h3 class="text-lg font-semibold mb-2">Distribución de Resultados</h3>
                                <div class="chart-container" style="height: 280px;">
                                    <canvas id="analytics-detail-distribution-chart"></canvas>
                                </div>
                            </div>
                        </div>

                        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                            <div class="metric-card">
                                <h3 class="text-lg font-semibold mb-2">Win Rate por Hora</h3>
                                <div class="chart-container" style="height: 280px;">
                                    <canvas id="analytics-detail-winrate-hour-chart"></canvas>
                                </div>
                            </div>
                            <div class="metric-card">
                                <h3 class="text-lg font-semibold mb-2">P/L por Instrumento</h3>
                                <div class="chart-container" style="height: 280px;">
                                    <canvas id="analytics-detail-instrument-pl-chart"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- ======= GRÁFICAS PARA ANÁLISIS DEL MES ======= -->
                    <div id="month-charts-container" style="display: none;">
                        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                            <div class="metric-card">
                                <h3 class="text-lg font-semibold mb-2">P/L por Semana del Mes</h3>
                                <div class="chart-container" style="height: 280px;">
                                    <canvas id="month-weekly-pl-chart"></canvas>
                                </div>
                            </div>
                            <div class="metric-card">
                                <h3 class="text-lg font-semibold mb-2">Win Rate por Semana</h3>
                                <div class="chart-container" style="height: 280px;">
                                    <canvas id="month-weekly-winrate-chart"></canvas>
                                </div>
                            </div>
                        </div>

                        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                            <div class="metric-card">
                                <h3 class="text-lg font-semibold mb-2">P/L por Día de la Semana</h3>
                                <div class="chart-container" style="height: 280px;">
                                    <canvas id="month-weekday-pl-chart"></canvas>
                                </div>
                            </div>
                            <div class="metric-card">
                                <h3 class="text-lg font-semibold mb-2">Top 10 Instrumentos del Mes</h3>
                                <div class="chart-container" style="height: 280px;">
                                    <canvas id="month-top-instruments-chart"></canvas>
                                </div>
                            </div>
                        </div>

                        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                            <div class="metric-card">
                                <h3 class="text-lg font-semibold mb-2">Operaciones por Semana</h3>
                                <div class="chart-container" style="height: 280px;">
                                    <canvas id="month-operations-chart"></canvas>
                                </div>
                            </div>
                            <div class="metric-card">
                                <h3 class="text-lg font-semibold mb-2">Distribución de Resultados</h3>
                                <div class="chart-container" style="height: 280px;">
                                    <canvas id="month-distribution-chart"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- ======= GRÁFICAS PARA ANÁLISIS DE LA SEMANA ======= -->
                    <div id="week-charts-container" style="display: none;">
                        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                            <div class="metric-card">
                                <h3 class="text-lg font-semibold mb-2">P/L por Día de la Semana</h3>
                                <div class="chart-container" style="height: 280px;">
                                    <canvas id="week-daily-pl-chart"></canvas>
                                </div>
                            </div>
                            <div class="metric-card">
                                <h3 class="text-lg font-semibold mb-2">Win Rate por Día</h3>
                                <div class="chart-container" style="height: 280px;">
                                    <canvas id="week-daily-winrate-chart"></canvas>
                                </div>
                            </div>
                        </div>

                        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                            <div class="metric-card">
                                <h3 class="text-lg font-semibold mb-2">Comparativa con Semanas Anteriores</h3>
                                <div class="chart-container" style="height: 280px;">
                                    <canvas id="week-comparison-chart"></canvas>
                                </div>
                            </div>
                            <div class="metric-card">
                                <h3 class="text-lg font-semibold mb-2">P/L por Sesión de Mercado</h3>
                                <div class="chart-container" style="height: 280px;">
                                    <canvas id="week-session-chart"></canvas>
                                </div>
                            </div>
                        </div>

                        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                            <div class="metric-card">
                                <h3 class="text-lg font-semibold mb-2">Top 10 Instrumentos de la Semana</h3>
                                <div class="chart-container" style="height: 280px;">
                                    <canvas id="week-top-instruments-chart"></canvas>
                                </div>
                            </div>
                            <div class="metric-card">
                                <h3 class="text-lg font-semibold mb-2">P/L por Hora del Día</h3>
                                <div class="chart-container" style="height: 280px;">
                                    <canvas id="week-hourly-pl-chart"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- ======= GRÁFICAS PARA ANÁLISIS DEL TRIMESTRE ======= -->
                    <div id="quarter-charts-container" style="display: none;">
                        <!-- Métricas numéricas adicionales del trimestre -->
                        <div class="grid grid-cols-2 md:grid-cols-5 gap-4 bg-surface p-4 rounded-lg border border-surface-light mb-8">
                            <div>
                                <p class="text-xs text-text-secondary mb-1">Días Operados</p>
                                <p id="quarter-metric-days-traded" class="text-lg font-bold text-primary">0</p>
                            </div>
                            <div>
                                <p class="text-xs text-text-secondary mb-1">Racha Máxima Win</p>
                                <p id="quarter-metric-max-streak" class="text-lg font-bold text-green">0</p>
                            </div>
                            <div>
                                <p class="text-xs text-text-secondary mb-1">Racha Máxima Loss</p>
                                <p id="quarter-metric-max-loss-streak" class="text-lg font-bold text-red">0</p>
                            </div>
                            <div>
                                <p class="text-xs text-text-secondary mb-1">Promedio por Día</p>
                                <p id="quarter-metric-avg-per-day" class="text-lg font-bold">$0.00</p>
                            </div>
                            <div>
                                <p class="text-xs text-text-secondary mb-1">Factor Recuperación</p>
                                <p id="quarter-metric-recovery-factor" class="text-lg font-bold text-primary">0.00</p>
                            </div>
                        </div>

                        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                            <div class="metric-card">
                                <h3 class="text-lg font-semibold mb-2">P/L por Mes del Trimestre</h3>
                                <div class="chart-container" style="height: 280px;">
                                    <canvas id="quarter-monthly-pl-chart"></canvas>
                                </div>
                            </div>
                            <div class="metric-card">
                                <h3 class="text-lg font-semibold mb-2">Win Rate por Mes</h3>
                                <div class="chart-container" style="height: 280px;">
                                    <canvas id="quarter-monthly-winrate-chart"></canvas>
                                </div>
                            </div>
                        </div>

                        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                            <div class="metric-card">
                                <h3 class="text-lg font-semibold mb-2">Volumen de Operaciones por Mes</h3>
                                <div class="chart-container" style="height: 280px;">
                                    <canvas id="quarter-operations-volume-chart"></canvas>
                                </div>
                            </div>
                            <div class="metric-card">
                                <h3 class="text-lg font-semibold mb-2">Top 5 Mejores Instrumentos</h3>
                                <div class="chart-container" style="height: 280px;">
                                    <canvas id="quarter-top-instruments-chart"></canvas>
                                </div>
                            </div>
                        </div>

                        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                            <div class="metric-card">
                                <h3 class="text-lg font-semibold mb-2">Performance por Sesión de Mercado</h3>
                                <div class="chart-container" style="height: 280px;">
                                    <canvas id="quarter-session-performance-chart"></canvas>
                                </div>
                            </div>
                            <div class="metric-card">
                                <h3 class="text-lg font-semibold mb-2">Distribución Wins vs Losses</h3>
                                <div class="chart-container" style="height: 280px;">
                                    <canvas id="quarter-win-loss-distribution-chart"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- TAB: NOTAS -->
                <div id="analytics-detail-tab-notas" class="analytics-detail-tab-content" style="display: none;">
                    <!-- Métricas Avanzadas -->
                    <div class="metric-card mb-6">
                        <h3 class="text-lg font-semibold mb-4">Métricas Avanzadas</h3>
                        <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                            <div class="p-4 bg-surface rounded border border-surface-light">
                                <p class="text-sm text-text-secondary mb-1">Velocidad de Ejecución</p>
                                <p id="day-metric-execution-speed" class="text-2xl font-bold text-primary">0 op/h</p>
                            </div>
                            <div class="p-4 bg-surface rounded border border-surface-light">
                                <p class="text-sm text-text-secondary mb-1">Peor Trade</p>
                                <p id="day-metric-worst-trade" class="text-2xl font-bold text-red">$0.00</p>
                            </div>
                            <div class="p-4 bg-surface rounded border border-surface-light">
                                <p class="text-sm text-text-secondary mb-1">Drawdown Intradía</p>
                                <p id="day-metric-intraday-dd" class="text-2xl font-bold text-red">$0.00</p>
                            </div>
                            <div class="p-4 bg-surface rounded border border-surface-light">
                                <p class="text-sm text-text-secondary mb-1">Expectativa</p>
                                <p id="day-metric-expectancy" class="text-2xl font-bold">$0.00</p>
                            </div>
                        </div>
                    </div>

                    <!-- Notas del Día -->
                    <div class="metric-card">
                        <div class="flex justify-between items-center mb-4 pb-3 border-b border-border">
                            <h3 class="text-lg font-semibold">Notas del Día</h3>
                            <button id="analytics-detail-images-btn" class="btn-secondary text-sm">
                                <i class="fas fa-images mr-2"></i>Imágenes Adjuntas
                            </button>
                        </div>
                        
                        <!-- Toolbar de Formato -->
                        <div class="flex flex-wrap items-center gap-1 p-3 border-b border-border bg-surface-light overflow-x-auto">
                            <!-- Formato de texto -->
                            <button onclick="formatTextAnalytics('bold')" class="p-2 hover:bg-surface rounded" title="Negrita">
                                <i class="fas fa-bold"></i>
                            </button>
                            <button onclick="formatTextAnalytics('italic')" class="p-2 hover:bg-surface rounded" title="Cursiva">
                                <i class="fas fa-italic"></i>
                            </button>
                            <button onclick="formatTextAnalytics('underline')" class="p-2 hover:bg-surface rounded" title="Subrayado">
                                <i class="fas fa-underline"></i>
                            </button>
                            <button onclick="formatTextAnalytics('strikeThrough')" class="p-2 hover:bg-surface rounded" title="Tachado">
                                <i class="fas fa-strikethrough"></i>
                            </button>
                            
                            <div class="w-px h-6 bg-border mx-1"></div>

                            <!-- Alineación -->
                            <button onclick="formatTextAnalytics('justifyLeft')" class="p-2 hover:bg-surface rounded" title="Alinear izquierda">
                                <i class="fas fa-align-left"></i>
                            </button>
                            <button onclick="formatTextAnalytics('justifyCenter')" class="p-2 hover:bg-surface rounded" title="Centrar">
                                <i class="fas fa-align-center"></i>
                            </button>
                            <button onclick="formatTextAnalytics('justifyRight')" class="p-2 hover:bg-surface rounded" title="Alinear derecha">
                                <i class="fas fa-align-right"></i>
                            </button>
                            <button onclick="formatTextAnalytics('justifyFull')" class="p-2 hover:bg-surface rounded" title="Justificar">
                                <i class="fas fa-align-justify"></i>
                            </button>

                            <div class="w-px h-6 bg-border mx-1"></div>

                            <!-- Listas -->
                            <button onclick="formatTextAnalytics('insertUnorderedList')" class="p-2 hover:bg-surface rounded" title="Lista con viñetas">
                                <i class="fas fa-list-ul"></i>
                            </button>
                            <button onclick="formatTextAnalytics('insertOrderedList')" class="p-2 hover:bg-surface rounded" title="Lista numerada">
                                <i class="fas fa-list-ol"></i>
                            </button>
                            <button onclick="formatTextAnalytics('indent')" class="p-2 hover:bg-surface rounded" title="Aumentar sangría">
                                <i class="fas fa-indent"></i>
                            </button>
                            <button onclick="formatTextAnalytics('outdent')" class="p-2 hover:bg-surface rounded" title="Disminuir sangría">
                                <i class="fas fa-outdent"></i>
                            </button>

                            <div class="w-px h-6 bg-border mx-1"></div>

                            <!-- Estilo de texto -->
                            <select id="analytics-format-block" onchange="formatTextAnalytics('formatBlock', this.value); this.selectedIndex=0;" class="px-2 py-1 bg-surface border border-border rounded text-sm">
                                <option value="" selected>Normal</option>
                                <option value="h1">Título 1</option>
                                <option value="h2">Título 2</option>
                                <option value="h3">Título 3</option>
                                <option value="p">Párrafo</option>
                            </select>

                            <div class="w-px h-6 bg-border mx-1"></div>

                            <!-- Colores -->
                            <input type="color" id="analytics-text-color" onchange="formatTextAnalytics('foreColor', this.value)" class="w-8 h-8 rounded cursor-pointer" value="#ffffff" title="Color de texto">
                            <input type="color" id="analytics-bg-color" onchange="formatTextAnalytics('hiliteColor', this.value)" class="w-8 h-8 rounded cursor-pointer" value="#ffeb3b" title="Color de fondo">

                            <div class="w-px h-6 bg-border mx-1"></div>

                            <!-- Insertar -->
                            <button onclick="insertImageAnalytics()" class="p-2 hover:bg-surface rounded" title="Insertar imagen">
                                <i class="fas fa-image"></i>
                            </button>
                            <button onclick="insertLinkAnalytics()" class="p-2 hover:bg-surface rounded" title="Insertar enlace">
                                <i class="fas fa-link"></i>
                            </button>
                            <button onclick="formatTextAnalytics('removeFormat')" class="p-2 hover:bg-surface rounded text-red" title="Limpiar formato">
                                <i class="fas fa-eraser"></i>
                            </button>
                        </div>

                        <!-- Input oculto para imágenes -->
                        <input type="file" id="analytics-notes-image-input" accept="image/*" style="display: none;">

                        <!-- Área de Edición -->
                        <div class="overflow-y-auto p-4" style="max-height: none;">
                            <div 
                                id="analytics-detail-notes-editor" 
                                contenteditable="true"
                                class="w-full p-4 bg-background border border-border rounded-lg focus:border-primary focus:outline-none text-base"
                                style="min-height: 800px;"
                                placeholder="Escribe las notas del día..."
                            ></div>
                        </div>

                        <!-- Footer con Acciones -->
                        <div class="flex items-center justify-between p-4 border-t border-border gap-4">
                            <div class="flex items-center gap-2">
                                <!-- Nota de Voz -->
                                <button id="analytics-voice-note-btn" class="flex items-center gap-2 px-4 py-2 bg-surface-light border border-border rounded hover:border-primary transition-all">
                                    <i class="fas fa-microphone"></i>
                                    <span>Nota de Voz</span>
                                </button>
                                <button id="analytics-download-note-btn" class="p-2 bg-surface-light border border-border rounded hover:border-primary transition-all" title="Descargar nota">
                                    <i class="fas fa-download"></i>
                                </button>
                            </div>

                            <div class="flex items-center gap-2">
                                <span class="text-xs text-text-secondary" id="analytics-editor-char-count">0 caracteres</span>
                                <button id="analytics-detail-save-notes-btn" class="btn-primary px-4 py-2">
                                    <i class="fas fa-save mr-2"></i>Guardar Notas
                                </button>
                                <button id="analytics-detail-goto-notebook-btn" class="btn-secondary px-4 py-2" title="Ver en Notebook">
                                    <i class="fas fa-book mr-2"></i>Ver en Notebook
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <!-- Modal de Configuración de PDF Report Profesional -->
    <div id="pdf-report-modal" class="modal" style="display: none;">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
                <h3 class="text-2xl font-semibold">Generar Reporte PDF Profesional</h3>
                <button id="close-pdf-report-modal" class="text-3xl">&times;</button>
            </div>

            <div class="modal-body">
                <!-- Cuenta seleccionada (pre-filled desde Analytics) -->
                <div class="mb-4">
                    <label class="block mb-2 text-sm font-medium">
                        <i class="fas fa-wallet mr-2"></i>Cuenta
                    </label>
                    <select id="pdf-account-select" class="w-full">
                        <!-- Se llenará dinámicamente -->
                    </select>
                </div>

                <!-- Período -->
                <div class="mb-4">
                    <label class="block mb-2 text-sm font-medium">
                        <i class="fas fa-calendar-alt mr-2"></i>Período
                    </label>
                    <select id="pdf-period-select" class="w-full mb-2">
                        <option value="current-month">Este mes (Feb 2026)</option>
                        <option value="last-month">Último mes (Ene 2026)</option>
                        <option value="current-quarter">Trimestre actual (Q1 2026)</option>
                        <option value="current-year">Año completo (2026)</option>
                        <option value="all-time">Todo el tiempo</option>
                        <option value="custom">Personalizado...</option>
                    </select>
                    
                    <!-- Campos de fecha personalizada (ocultos por defecto) -->
                    <div id="pdf-custom-dates" style="display: none;" class="grid grid-cols-2 gap-2">
                        <input type="date" id="pdf-start-date" class="w-full">
                        <input type="date" id="pdf-end-date" class="w-full">
                    </div>
                </div>

                <!-- Tipo de Reporte -->
                <div class="mb-4">
                    <label class="block mb-3 text-sm font-medium">
                        <i class="fas fa-file-alt mr-2"></i>Tipo de Reporte
                    </label>
                    <div class="grid grid-cols-3 gap-3">
                        <div class="pdf-report-option" data-value="summary" style="cursor: pointer; padding: 16px; border: 2px solid var(--border); border-radius: 8px; text-align: center; transition: all 0.2s;">
                            <i class="fas fa-bolt" style="font-size: 24px; color: var(--primary); margin-bottom: 8px;"></i>
                            <div style="font-weight: 600; font-size: 14px; margin-bottom: 4px;">Summary</div>
                            <div style="font-size: 11px; color: var(--text-secondary);">2 páginas</div>
                        </div>
                        <div class="pdf-report-option active" data-value="full" style="cursor: pointer; padding: 16px; border: 2px solid var(--primary); border-radius: 8px; text-align: center; transition: all 0.2s; background: rgba(57, 255, 20, 0.05);">
                            <i class="fas fa-file-invoice" style="font-size: 24px; color: var(--primary); margin-bottom: 8px;"></i>
                            <div style="font-weight: 600; font-size: 14px; margin-bottom: 4px;">Professional</div>
                            <div style="font-size: 11px; color: var(--text-secondary);">8-12 páginas</div>
                        </div>
                        <div class="pdf-report-option" data-value="detailed" style="cursor: pointer; padding: 16px; border: 2px solid var(--border); border-radius: 8px; text-align: center; transition: all 0.2s;">
                            <i class="fas fa-list-alt" style="font-size: 24px; color: var(--primary); margin-bottom: 8px;"></i>
                            <div style="font-weight: 600; font-size: 14px; margin-bottom: 4px;">Detailed</div>
                            <div style="font-size: 11px; color: var(--text-secondary);">Completo</div>
                        </div>
                    </div>
                    <input type="hidden" id="pdf-report-type-value" value="full">
                </div>

                <!-- Opciones Avanzadas -->
                <div class="mb-6">
                    <label class="block mb-2 text-sm font-medium">
                        <i class="fas fa-cog mr-2"></i>Opciones Avanzadas
                    </label>
                    <div class="space-y-2 text-sm">
                        <label class="flex items-center">
                            <input type="checkbox" id="pdf-include-charts" checked class="mr-2">
                            Incluir gráficos y visualizaciones
                        </label>
                        <label class="flex items-center">
                            <input type="checkbox" id="pdf-include-insights" checked class="mr-2">
                            Incluir análisis IA y recomendaciones
                        </label>
                        <label class="flex items-center">
                            <input type="checkbox" id="pdf-include-heatmap" checked class="mr-2">
                            Incluir heatmap horario
                        </label>
                        <label class="flex items-center">
                            <input type="checkbox" id="pdf-public-mode" class="mr-2">
                            Modo público (ocultar balances sensibles)
                        </label>
                    </div>
                </div>

                <!-- Botones -->
                <div class="flex gap-3 justify-end">
                    <button id="cancel-pdf-report" class="btn-outline">
                        <i class="fas fa-times mr-2"></i>Cancelar
                    </button>
                    <button id="generate-pdf-report" class="primary">
                        <i class="fas fa-file-pdf mr-2"></i>Generar PDF
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal de Pantalla Completa para Gráficos -->
    <div id="fullscreen-chart-modal" onclick="if(event.target.id==='fullscreen-chart-modal')window.closeFullscreenChart()" style="display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0,0,0,0.98); z-index: 10000; padding: 0; margin: 0;">
        <div style="position: relative; width: 100%; height: 100%; display: flex; flex-direction: column; padding: 15px; box-sizing: border-box;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-shrink: 0;">
                <h2 id="fullscreen-chart-title" style="color: #39FF14; font-size: 28px; font-weight: bold; margin: 0; text-shadow: 0 0 10px rgba(57,255,20,0.5);"></h2>
                <button onclick="window.closeFullscreenChart()" style="background: #FF0000; color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-size: 18px; font-weight: bold; box-shadow: 0 0 15px rgba(255,0,0,0.5); transition: all 0.3s;">
                    <i class="fas fa-times"></i> Cerrar
                </button>
            </div>
            <div style="flex: 1; background: #0f0f0f; border-radius: 12px; padding: 25px; position: relative; border: 2px solid #39FF14; box-shadow: 0 0 20px rgba(57,255,20,0.3); min-height: 0;">
                <canvas id="fullscreen-chart-canvas"></canvas>
            </div>
        </div>
    </div>

    <script>
        // Variables globales para autenticación
        let currentUser = null;
        let isSyncing = false;

        const dexieDB = new Dexie('TradingSurvivorDB');

        // Versión 7: Esquema original
        dexieDB.version(7).stores({
            accounts: 'id,name,currency,platform',
            operations: 'id,date,accountId,instrument,result,currency',
            finances: '++id,date',
            generalData: 'key',
            apiKeys: 'id'
        });

        // Versión 8: Asegurar que apiKeys existe con el esquema correcto
        dexieDB.version(8).stores({
            accounts: 'id,name,currency,platform',
            operations: 'id,date,accountId,instrument,result,currency',
            finances: '++id,date',
            generalData: 'key',
            apiKeys: 'id,platform,key,secret'
        });

        // Versión 9: Añadir parentId para parciales
        dexieDB.version(9).stores({
            operations: 'id,date,accountId,instrument,result,currency,parentId' // Añadir parentId
        });

        dexieDB.version(10).stores({
            setups: 'id,category,rating,createdAt' // Nueva tabla para Playbook
        });

        dexieDB.version(11).stores({
            fundedAccounts: 'id,company,type,status,activationDate' // Tabla para Funded Accounts
        });

        dexieDB.version(12).stores({
            fundedHistory: 'id,accountId,date,timestamp,action' // Historial de cuentas funded (borradas/suspendidas)
        });

        dexieDB.version(13).stores({
            notebookFolders: 'id,user_id,name,created_at', // Carpetas del Notebook
            notebookNotes: 'id,user_id,folder_id,updated_at', // Notas del Notebook
            notebookAttachments: 'id,note_id,type,created_at' // Archivos adjuntos (imágenes, audio)
        });

        // Exportar dexieDB globalmente
        window.dexieDB = dexieDB;

        // Hacer DB global para acceso desde otros scripts
        window.DB = {
            accounts: [],
            operations: [],
            finances: [],
            fundedAccounts: [], // Nueva tabla para cuentas funded
            fundedHistory: [], // Historial de cuentas funded
            settings: { showTooltips: true, defaultCurrency: 'USD' },
            apiKeys: { ctrader: {}, bingx: {}, bitget: {}, mexc: {} },
            setups: [], // Nueva tabla para Playbook
            notebookFolders: [], // Carpetas del Notebook
            notebookNotes: [], // Notas del Notebook
            notebookAttachments: [], // Archivos adjuntos
            chartbookImages: [], // Imágenes de gráficos en Chartbook
            journalEntries: [] // Entradas del Daily Journal
        };
        
        // Alias local para compatibilidad
        const DB = window.DB;

        let globalDateFilter = { type: 'all', startDate: null, endDate: null, display: 'Sin filtro de fecha' };
        let globalSelectedAccount = 'all'; // Nueva variable global para sincronizar cuentas
        let popupCalendarStateDate = new Date();
        const monthNamesShort = ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'];
        let currentEditingOpImages = [];
        let modalImageList = [];
        let modalImageIndex = 0;
        // NUEVO: Estado para el ordenamiento de la tabla de operaciones
        let operationSortState = { column: 'date', order: 'desc' };
        let informeFilters = { symbol: '', type: 'all', result: 'all', plMin: null, plMax: null, day: 'all' };

        // ===== FUNCIONES DE SINCRONIZACIÓN DE CUENTA =====
        function syncAccountSelection(accountId) {
            console.log('🔄 Sincronizando cuenta a:', accountId);
            globalSelectedAccount = accountId;
            
            // Actualizar todos los selectores de cuenta principales
            const selectors = [
                'dashboard-account-select',
                'new-dashboard-account-select',
                'analytics-account-select',
                'informe-account-select',
                'daily-journal-account-select',
                'calendar-account-select',
                'equity-account-select',
                'filter-account',
                'chartbook-account-select'
            ];
            
            selectors.forEach(selectorId => {
                const selectElement = document.getElementById(selectorId);
                if (selectElement && selectElement.value !== accountId) {
                    selectElement.value = accountId;
                    updateSelectorLogo(selectorId);
                }
            });
            
            // Actualizar el multi-selector del header también
            const mainSelect = document.getElementById('main-account-select');
            if (mainSelect && mainSelect.value !== accountId) {
                mainSelect.value = accountId;
            }
            
            // Refrescar la sección activa después de sincronizar
            refreshCurrentSection();
            
            console.log('✅ Cuenta sincronizada en todas las secciones con logos');
        }

        function refreshCurrentSection() {
            const activeSection = document.querySelector('.section-container.active');
            if (!activeSection) return;
            
            const sectionId = activeSection.id;
            console.log('🔄 Refrescando sección activa:', sectionId);
            
            switch(sectionId) {
                case 'dashboard':
                    if (typeof refreshNewDashboard === 'function') {
                        refreshNewDashboard();
                    }
                    break;
                case 'analytics':
                    if (typeof refreshAnalytics === 'function') {
                        refreshAnalytics();
                    }
                    break;
                case 'equity-graph':
                    if (typeof refreshEquityGraph === 'function') {
                        refreshEquityGraph();
                    }
                    break;
                case 'daily-journal':
                    if (typeof refreshDailyJournal === 'function') {
                        refreshDailyJournal();
                    }
                    break;
                case 'informe':
                    if (typeof refreshInforme === 'function') {
                        refreshInforme();
                    }
                    break;
                case 'operations':
                    if (typeof refreshOperationsTable === 'function') {
                        refreshOperationsTable();
                    }
                    break;
                case 'finances':
                    // Detectar qué vista de finanzas está activa
                    const activeFinanceTab = document.querySelector('.finances-tab.active');
                    if (activeFinanceTab) {
                        const viewId = activeFinanceTab.id.replace('-tab-', '-view-');
                        console.log('🔄 Refrescando vista de finanzas:', viewId);
                        if (typeof updateFinancesView === 'function') {
                            updateFinancesView(viewId);
                        }
                    } else if (typeof refreshFinancesView === 'function') {
                        refreshFinancesView();
                    }
                    break;
                case 'calendar':
                    if (typeof updateCalendar === 'function') {
                        setTimeout(() => updateCalendar(), 50);
                    }
                    break;
                case 'chartbook':
                    if (typeof window.refreshChartbook === 'function') {
                        setTimeout(() => window.refreshChartbook(), 50);
                    }
                    break;
                case 'playbook':
                    if (typeof window.refreshPlaybook === 'function') {
                        setTimeout(() => window.refreshPlaybook(), 50);
                    }
                    break;
                case 'notebook':
                    if (typeof initializeNotebook === 'function') {
                        initializeNotebook();
                    }
                    break;
                case 'accounts':
                    if (typeof refreshAccountsView === 'function') {
                        refreshAccountsView();
                    }
                    break;
            }
        }

        // ===== SIDEBAR FUNCTIONALITY =====
        function initSidebar() {
            const sidebar = document.getElementById('sidebar');
            const sidebarToggle = document.getElementById('sidebarToggle');
            const navItems = document.querySelectorAll('.sidebar .nav-item');
            const pageTitle = document.getElementById('pageTitle');
            
            // Toggle sidebar collapse
            if (sidebarToggle) {
                sidebarToggle.addEventListener('click', () => {
                    sidebar.classList.toggle('collapsed');
                    const icon = sidebarToggle.querySelector('i');
                    const span = sidebarToggle.querySelector('span');
                    
                    if (sidebar.classList.contains('collapsed')) {
                        icon.classList.remove('fa-bars');
                        icon.classList.add('fa-arrow-right');
                        if (span) span.textContent = 'Expandir';
                    } else {
                        icon.classList.remove('fa-arrow-right');
                        icon.classList.add('fa-bars');
                        if (span) span.textContent = 'Contraer';
                    }
                    
                    // Save state in localStorage
                    localStorage.setItem('sidebarCollapsed', sidebar.classList.contains('collapsed'));
                });
            }
            
            // Restore sidebar state
            const sidebarCollapsed = localStorage.getItem('sidebarCollapsed') === 'true';
            if (sidebarCollapsed && sidebar) {
                sidebar.classList.add('collapsed');
                const icon = sidebarToggle.querySelector('i');
                const span = sidebarToggle.querySelector('span');
                if (icon) {
                    icon.classList.remove('fa-bars');
                    icon.classList.add('fa-arrow-right');
                }
                if (span) span.textContent = 'Expandir';
            }
            
            // Navigation items click
            navItems.forEach(item => {
                item.addEventListener('click', () => {
                    const target = item.dataset.target;
                    
                    if (!target) return;
                    
                    // Show section
                    showSection(target);
                    updatePageTitle(getSectionTitle(target));
                    
                    // Update active state
                    updateActiveNavItem(target);
                });
            });
            
            // Footer items
            const footerItems = document.querySelectorAll('.footer-item');
            footerItems.forEach(item => {
                item.addEventListener('click', () => {
                    const target = item.dataset.target;
                    if (target) {
                        showSection(target);
                        updateActiveNavItem(target);
                        updatePageTitle(getSectionTitle(target));
                    }
                });
            });
            
            // Dark mode toggle (placeholder for future implementation)
            const darkModeToggle = document.getElementById('darkModeToggle');
            if (darkModeToggle) {
                darkModeToggle.addEventListener('click', () => {
                    alert('Modo oscuro se implementará próximamente');
                });
            }
            
            // Support button
            const supportBtn = document.getElementById('supportBtn');
            if (supportBtn) {
                supportBtn.addEventListener('click', () => {
                    window.open('mailto:support@tradingsurvivor.com', '_blank');
                });
            }
        }
        
        function updateActiveNavItem(target) {
            const navItems = document.querySelectorAll('.sidebar .nav-item');
            navItems.forEach(item => {
                if (item.dataset.target === target) {
                    item.classList.add('active');
                } else {
                    item.classList.remove('active');
                }
            });
        }
        
        function updatePageTitle(title) {
            const pageTitle = document.getElementById('pageTitle');
            if (pageTitle) {
                pageTitle.textContent = title;
            }
        }
        
        function getSectionTitle(section) {
            const titles = {
                'dashboard': 'Dashboard',
                'analytics': 'Analytics',
                'equity-graph': 'Equity Graph',
                'informe': 'Informe',
                'calendar': 'Calendario',
                'operations': 'Operaciones',
                'chartbook': 'Chartbook',
                'playbook': 'Playbook',
                'accounts': 'Cuentas',
                'finances': 'Finanzas',
                'platforms': 'Plataformas',
                'news': 'Noticias',
                'market-scanner': 'Market Scanner',
                'config': 'Configuración'
            };
            return titles[section] || section.charAt(0).toUpperCase() + section.slice(1);
        }
        
        // ===== CONFIGURATION SECTION NAVIGATION =====
        function initConfigNavigation() {
            const configNavItems = document.querySelectorAll('.config-nav-item');
            const configSections = document.querySelectorAll('.config-section');
            
            configNavItems.forEach(item => {
                item.addEventListener('click', () => {
                    const sectionId = item.dataset.configSection;
                    
                    // Update active nav item
                    configNavItems.forEach(nav => nav.classList.remove('active'));
                    item.classList.add('active');
                    
                    // Show corresponding section
                    configSections.forEach(section => {
                        if (section.id === 'config-' + sectionId) {
                            section.classList.add('active');
                        } else {
                            section.classList.remove('active');
                        }
                    });
                });
            });

            // Connect old auth buttons to new config sections
            const showAuthModalBtnOld = document.getElementById('show-auth-modal-btn');
            const configShowAuthModalBtn = document.getElementById('config-show-auth-modal-btn');
            const logoutBtnConfigOld = document.getElementById('logout-btn-config');
            const configLogoutBtn = document.getElementById('config-logout-btn');

            if (configShowAuthModalBtn) {
                configShowAuthModalBtn.addEventListener('click', () => {
                    if (typeof showAuth === 'function') showAuth();
                });
            }

            if (configLogoutBtn) {
                configLogoutBtn.addEventListener('click', async () => {
                    if (confirm('¿Estás seguro de que deseas cerrar sesión?')) {
                        await supabase.auth.signOut();
                        // Redirigir a landing page después de logout
                        window.location.href = '/';
                    }
                });
            }

            // Save user info
            const saveUserInfoBtn = document.getElementById('save-user-info');
            if (saveUserInfoBtn) {
                saveUserInfoBtn.addEventListener('click', async () => {
                    const username = document.getElementById('config-username').value;
                    
                    // Guardar en localStorage (cache local)
                    localStorage.setItem('username', username);
                    
                    // Guardar en Supabase para persistencia
                    try {
                        const { data: { user } } = await supabase.auth.getUser();
                        if (user) {
                            const { error } = await supabase
                                .from('user_settings')
                                .upsert({
                                    user_id: user.id,
                                    username: username,
                                    updated_at: new Date().toISOString()
                                }, {
                                    onConflict: 'user_id'
                                });
                            
                            if (error) {
                                console.error('❌ Error guardando username en Supabase:', error);
                                showMessage('Error al guardar el nombre de usuario', 'error');
                                return;
                            } else {
                                console.log('✅ Username guardado en Supabase');
                            }
                        }
                    } catch (err) {
                        console.error('❌ Error al guardar username:', err);
                        showMessage('Error al guardar el nombre de usuario', 'error');
                        return;
                    }
                    
                    // Actualizar en Audición
                    loadAudicionUserInfo();
                    
                    // Guardar configuración de perfil público
                    if (typeof saveUserPublicSettings === 'function') {
                        await saveUserPublicSettings();
                    }
                    
                    showMessage('Información guardada correctamente', 'success');
                });
            }
            
            // Toggle de perfil público - actualizar label
            const publicProfileToggle = document.getElementById('config-public-profile');
            const publicProfileLabel = document.getElementById('config-public-profile-label');
            if (publicProfileToggle && publicProfileLabel) {
                publicProfileToggle.addEventListener('change', function() {
                    if (this.checked) {
                        publicProfileLabel.textContent = 'Perfil Público';
                        publicProfileLabel.style.color = '#10B981'; // Verde
                    } else {
                        publicProfileLabel.textContent = 'Perfil Privado';
                        publicProfileLabel.style.color = '#6B7280'; // Gris
                    }
                });
            }

            // Change password
            const changePasswordBtn = document.getElementById('change-password-btn');
            if (changePasswordBtn) {
                changePasswordBtn.addEventListener('click', async () => {
                    const newPassword = document.getElementById('new-password').value;
                    const confirmPassword = document.getElementById('confirm-password').value;

                    if (!newPassword || newPassword.length < 6) {
                        showMessage('La contraseña debe tener al menos 6 caracteres', 'error');
                        return;
                    }

                    if (newPassword !== confirmPassword) {
                        showMessage('Las contraseñas no coinciden', 'error');
                        return;
                    }

                    try {
                        const { error } = await supabase.auth.updateUser({ password: newPassword });
                        if (error) throw error;
                        showMessage('Contraseña actualizada correctamente', 'success');
                        document.getElementById('current-password').value = '';
                        document.getElementById('new-password').value = '';
                        document.getElementById('confirm-password').value = '';
                    } catch (error) {
                        showMessage('Error al cambiar la contraseña: ' + error.message, 'error');
                    }
                });
            }

            // CSV Import (config version)
            const configImportCsvBtn = document.getElementById('config-import-csv-btn');
            const configCsvFileInput = document.getElementById('config-csv-file-input');
            
            if (configImportCsvBtn && configCsvFileInput) {
                configImportCsvBtn.addEventListener('click', () => {
                    const file = configCsvFileInput.files[0];
                    if (!file) {
                        showMessage('Por favor selecciona un archivo CSV', 'error');
                        return;
                    }
                    // Trigger original CSV import logic
                    if (typeof procesarCSV === 'function') {
                        const reader = new FileReader();
                        reader.onload = (e) => procesarCSV(e.target.result);
                        reader.readAsText(file);
                    }
                });
            }

            // Export buttons (config version)
            const configExportJson = document.getElementById('config-export-json');
            const configExportCsv = document.getElementById('config-export-csv');
            const configExportPdf = document.getElementById('config-export-pdf');
            const configImportJson = document.getElementById('config-import-json');
            const configClearData = document.getElementById('config-clear-data');

            console.log('🔧 Inicializando botones de exportar/importar');

            if (configExportJson) {
                configExportJson.addEventListener('click', async () => {
                    console.log('📤 Exportando JSON...');
                    try {
                        const exportData = {
                            version: '2.0',
                            exportDate: new Date().toISOString(),
                            operations: DB.operations || [],
                            accounts: DB.accounts || [],
                            finances: DB.finances || [],
                            settings: {
                                username: localStorage.getItem('username') || '',
                                theme: localStorage.getItem('theme') || 'dark'
                            }
                        };

                        const jsonString = JSON.stringify(exportData, null, 2);
                        const blob = new Blob([jsonString], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `trader-survivor-backup-${new Date().toISOString().split('T')[0]}.json`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);

                        alert('✅ Respaldo JSON exportado correctamente');
                        console.log('✅ JSON exportado con éxito');
                    } catch (error) {
                        console.error('❌ Error exportando JSON:', error);
                        alert('❌ Error al exportar JSON');
                    }
                });
                console.log('✅ Botón Export JSON configurado');
            }

            if (configExportCsv) {
                configExportCsv.addEventListener('click', async () => {
                    console.log('📤 Exportando CSV...');
                    try {
                        const operations = DB.operations || [];
                        if (operations.length === 0) {
                            alert('⚠️ No hay operaciones para exportar');
                            return;
                        }
                        
                        const csvContent = convertToCSV(operations);
                        const blob = new Blob([csvContent], { type: 'text/csv' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `operaciones-${new Date().toISOString().split('T')[0]}.csv`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);

                        alert('✅ CSV exportado correctamente');
                        console.log('✅ CSV exportado con éxito');
                    } catch (error) {
                        console.error('❌ Error exportando CSV:', error);
                        alert('❌ Error al exportar CSV');
                    }
                });
                console.log('✅ Botón Export CSV configurado');
            }

            if (configExportPdf) {
                configExportPdf.addEventListener('click', async () => {
                    console.log('📤 Exportando PDF...');
                    alert('⚠️ Función de exportar PDF en desarrollo.\nUsa Imprimir (Ctrl+P) desde la sección Informe para generar PDFs.');
                });
                console.log('✅ Botón Export PDF configurado');
            }

            if (configImportJson) {
                configImportJson.addEventListener('change', async (e) => {
                    console.log('📥 Importando JSON...');
                    const file = e.target.files[0];
                    if (!file) return;

                    try {
                        const reader = new FileReader();
                        reader.onload = async (event) => {
                            try {
                                const importData = JSON.parse(event.target.result);
                                
                                if (!confirm('⚠️ ADVERTENCIA: Esto reemplazará todos tus datos actuales.\n¿Estás seguro de que deseas continuar?')) {
                                    return;
                                }

                                // Importar operaciones
                                if (importData.operations && Array.isArray(importData.operations)) {
                                    DB.operations = importData.operations;
                                    console.log(`✅ ${importData.operations.length} operaciones importadas`);
                                }

                                // Importar cuentas
                                if (importData.accounts && Array.isArray(importData.accounts)) {
                                    DB.accounts = importData.accounts;
                                    console.log(`✅ ${importData.accounts.length} cuentas importadas`);
                                }

                                // Importar finanzas
                                if (importData.finances && Array.isArray(importData.finances)) {
                                    DB.finances = importData.finances;
                                    console.log(`✅ ${importData.finances.length} finanzas importadas`);
                                }

                                // Guardar todo en localStorage
                                saveToLocalStorage();

                                alert('✅ Respaldo importado correctamente.\nLa página se recargará.');
                                location.reload();
                            } catch (error) {
                                console.error('❌ Error parseando JSON:', error);
                                alert('❌ Error: El archivo no es un JSON válido');
                            }
                        };
                        reader.readAsText(file);
                    } catch (error) {
                        console.error('❌ Error importando JSON:', error);
                        alert('❌ Error al importar archivo');
                    }

                    // Reset input
                    e.target.value = '';
                });
                console.log('✅ Botón Import JSON configurado');
            }

            if (configClearData) {
                configClearData.addEventListener('click', async () => {
                    console.log('🗑️ Borrar datos...');
                    if (!confirm('⚠️ ADVERTENCIA: Esto borrará TODOS tus datos.\n¿Estás seguro de que deseas continuar?')) {
                        return;
                    }

                    if (!confirm('⚠️ ÚLTIMA ADVERTENCIA: Esta acción NO se puede deshacer.\n¿Realmente deseas borrar todos los datos?')) {
                        return;
                    }

                    try {
                        DB.operations = [];
                        DB.accounts = [];
                        DB.finances = [];
                        saveToLocalStorage();
                        
                        alert('✅ Todos los datos han sido borrados.\nLa página se recargará.');
                        location.reload();
                    } catch (error) {
                        console.error('❌ Error borrando datos:', error);
                        alert('❌ Error al borrar datos');
                    }
                });
                console.log('✅ Botón Clear Data configurado');
            }

            // Update stats in billing section
            updateConfigStats();
        }

        async function updateConfigStats() {
            try {
                const totalTrades = await dexieDB.operations.count();
                const totalAccounts = await dexieDB.accounts.count();
                
                const tradesCountEl = document.getElementById('total-trades-count');
                const accountsCountEl = document.getElementById('total-accounts-count');
                
                if (tradesCountEl) tradesCountEl.textContent = totalTrades;
                if (accountsCountEl) accountsCountEl.textContent = totalAccounts;
            } catch (error) {
                console.warn('⚠️ Error actualizando estadísticas de configuración:', error);
            }
        }

        function updateConfigUserInfo(user) {
            if (!user) return;
            
            const configUserEmail = document.getElementById('config-user-email');
            const configCurrentUserEmail = document.getElementById('config-current-user-email');
            const configUserAvatar = document.getElementById('config-user-avatar');
            const configAuthLoggedOut = document.getElementById('config-auth-status-logged-out');
            const configAuthLoggedIn = document.getElementById('config-auth-status-logged-in');
            
            if (configUserEmail) configUserEmail.value = user.email;
            if (configCurrentUserEmail) configCurrentUserEmail.textContent = user.email;
            if (configUserAvatar) configUserAvatar.textContent = user.email.charAt(0).toUpperCase();
            
            if (configAuthLoggedOut) configAuthLoggedOut.style.display = 'none';
            if (configAuthLoggedIn) configAuthLoggedIn.style.display = 'flex';

            // Load username from localStorage
            const username = localStorage.getItem('username') || '';
            const configUsername = document.getElementById('config-username');
            if (configUsername) configUsername.value = username;
            
            // Load profile image from localStorage
            const profileImage = localStorage.getItem('profile-image');
            if (profileImage) {
                const configAvatar = document.getElementById('config-user-avatar');
                if (configAvatar) {
                    configAvatar.innerHTML = `<img src="${profileImage}" alt="Profile" class="w-full h-full object-cover rounded-full">`;
                }
                
                const preview = document.getElementById('config-profile-preview');
                if (preview) {
                    preview.innerHTML = `<img src="${profileImage}" alt="Profile" class="w-full h-full object-cover">`;
                    const removeBtn = document.getElementById('config-remove-profile-image');
                    if (removeBtn) removeBtn.style.display = 'block';
                }
            }
        }

        function convertToCSV(operations) {
            const headers = ['Cuenta', 'ID', 'Fecha', 'Hora Entrada', 'Hora Salida', 'Instrumento', 'Tipo', 'Entrada', 'Salida', 'Volumen', 'P&L', 'Divisa', 'Comision', 'Notas'];
            const rows = operations.map(op => [
                op.accountName || '',
                op.id || '',
                op.date || '',
                op.entryTime || '',
                op.exitTime || '',
                op.symbol || '',
                op.type || '',
                op.entry || '',
                op.exit || '',
                op.volume || '',
                op.pl || '',
                op.currency || 'USD',
                op.commission || '',
                op.notes || ''
            ]);
            
            const csvContent = [headers, ...rows].map(row => row.join(',')).join('\n');
            return csvContent;
        }

        function downloadFile(content, filename, type) {
            const blob = new Blob([content], { type });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        function showMessage(message, type = 'info') {
            // Create toast notification
            const toast = document.createElement('div');
            toast.className = `alert alert-${type} toast-notification`;
            toast.innerHTML = `
                <i class="fas fa-${type === 'success' ? 'check-circle' : type === 'error' ? 'exclamation-circle' : 'info-circle'}"></i>
                <p>${message}</p>
            `;
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                z-index: 10000;
                min-width: 300px;
                animation: slideIn 0.3s ease;
            `;
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        function applyInformeFilters(operations) {
            let filteredOps = [...operations];

            // Symbol filter
            if (informeFilters.symbol) {
                filteredOps = filteredOps.filter(op => op.instrument.toUpperCase().includes(informeFilters.symbol));
            }
            // Type filter
            if (informeFilters.type !== 'all') {
                filteredOps = filteredOps.filter(op => op.type === informeFilters.type);
            }
            // Result filter
            if (informeFilters.result !== 'all') {
                filteredOps = filteredOps.filter(op => op.result === informeFilters.result);
            }
            // P/L Min filter
            if (informeFilters.plMin !== null) {
                filteredOps = filteredOps.filter(op => op.pl >= informeFilters.plMin);
            }
            // P/L Max filter
            if (informeFilters.plMax !== null) {
                filteredOps = filteredOps.filter(op => op.pl <= informeFilters.plMax);
            }
            // Day of week filter
            if (informeFilters.day !== 'all') {
                filteredOps = filteredOps.filter(op => new Date(op.date + 'T00:00:00').getUTCDay() == informeFilters.day);
            }

            return filteredOps;
        }


        async function loadData() {
            console.log('📦 loadData() - INICIANDO carga de datos...');
            showLoading(true);
            try {
                console.log('📦 loadData() - Cargando desde DexieDB...');
                const [accounts, operations, finances, storedSettings, storedApiKeys, setups, fundedAccounts, fundedHistory] = await Promise.all([
                    dexieDB.accounts.toArray(),
                    dexieDB.operations.toArray(),
                    dexieDB.finances.toArray(),
                    dexieDB.generalData.get('settings').then(result => result?.value),
                    dexieDB.generalData.get('apiKeys').then(result => result?.value),
                    dexieDB.setups.toArray(),
                    dexieDB.fundedAccounts.toArray(),
                    dexieDB.fundedHistory.toArray()
                ]);

                console.log('📦 loadData() - Datos cargados, asignando a DB...');
                DB.accounts = accounts || [];
                DB.operations = operations || [];
                DB.finances = finances || [];
                DB.setups = setups || [];
                DB.fundedAccounts = fundedAccounts || [];
                DB.fundedHistory = fundedHistory || [];
                console.log('📦 loadData() - DB actualizado:', {
                    accounts: DB.accounts.length,
                    operations: DB.operations.length,
                    finances: DB.finances.length
                });

                if (storedSettings) {
                    DB.settings = { ...{ darkMode: true, showTooltips: true, autoRefresh: false, defaultCurrency: 'USD' }, ...storedSettings };
                } else {
                    await dexieDB.generalData.put({ key: 'settings', value: DB.settings });
                }

                // Verificar localStorage primero antes de cargar desde DB
                const localBingXApiKey = localStorage.getItem('bingx-api-key');
                const localBingXSecretKey = localStorage.getItem('bingx-secret-key');
                const localBingXAccountId = localStorage.getItem('bingx-account-id');

                if (storedApiKeys) {
                    DB.apiKeys = {
                        ...{
                            ctrader: { key: '', secret: '', accountId: '' },
                            bingx: { key: '', secret: '', accountId: '' },
                            bitget: { key: '', secret: '', passphrase: '', accountId: '' }
                        },
                        ...storedApiKeys
                    };

                    // Si hay credenciales en localStorage, priorizarlas sobre las de DB
                    if (localBingXApiKey && localBingXSecretKey) {
                        DB.apiKeys.bingx = {
                            key: localBingXApiKey,
                            secret: localBingXSecretKey,
                            accountId: localBingXAccountId || 'main',
                            mode: 'real'
                        };
                        // Actualizar DB con las credenciales de localStorage
                        await dexieDB.generalData.put({ key: 'apiKeys', value: DB.apiKeys });
                    }
                } else {
                    // Si no hay datos en DB, verificar localStorage
                    if (localBingXApiKey && localBingXSecretKey) {
                        DB.apiKeys.bingx = {
                            key: localBingXApiKey,
                            secret: localBingXSecretKey,
                            accountId: localBingXAccountId || 'main',
                            mode: 'real'
                        };
                    }
                    await dexieDB.generalData.put({ key: 'apiKeys', value: DB.apiKeys });
                }


                let operationsToUpdateInDB = [];
                DB.operations.forEach(op => {
                    let changes = {};
                    let hasChanged = false;

                    if (op.date && op.date.includes('/')) {
                        const parts = op.date.split('/');
                        if (parts.length === 3) {
                            op.date = `${parts[2]}-${parts[1].padStart(2, '0')}-${parts[0].padStart(2, '0')}`;
                            changes.date = op.date;
                            hasChanged = true;
                        }
                    }
                    if (typeof op.imageData !== 'undefined' && op.imageData !== null) {
                        if (typeof op.imageDatas === 'undefined' || !Array.isArray(op.imageDatas) || op.imageDatas.length === 0) {
                            op.imageDatas = [op.imageData];
                            changes.imageDatas = op.imageDatas;
                            changes.imageData = Dexie.delete; // Eliminar la propiedad antigua
                            hasChanged = true;
                        }
                        delete op.imageData;
                    } else if (typeof op.imageDatas === 'undefined' || !Array.isArray(op.imageDatas)) {
                         op.imageDatas = [];
                         changes.imageDatas = [];
                         if (typeof op.imageData !== 'undefined') {
                            changes.imageData = Dexie.delete;
                            delete op.imageData;
                         }
                         hasChanged = true;
                    }

                    if (typeof op.manualPL === 'undefined') {op.manualPL = null; changes.manualPL = null; hasChanged = true;}
                    if (typeof op.entryTime === 'undefined') {op.entryTime = null; changes.entryTime = null; hasChanged = true;}
                    if (typeof op.exitTime === 'undefined') {op.exitTime = null; changes.exitTime = null; hasChanged = true;}
                    // Añadir migración para el nuevo campo 'session'
                    if (typeof op.session === 'undefined') {op.session = null; changes.session = null; hasChanged = true;}

                    if(hasChanged) {
                        operationsToUpdateInDB.push({key: op.id, changes: changes});
                    }
                });

                if (operationsToUpdateInDB.length > 0) {
                    // bulkUpdate no existe en Dexie, usar bulkPut con objetos completos
                    const opsToUpdate = operationsToUpdateInDB.map(item => {
                        const op = DB.operations.find(o => o.id === item.key);
                        return {...op, ...item.changes};
                    });
                    await dexieDB.operations.bulkPut(opsToUpdate);
                }


            } catch (e) {
                console.error('❌ Error loading data from DexieDB:', e);
            } finally {
                console.log('📦 loadData() - COMPLETADO');
                showLoading(false);
            }
        }



        function updateAccountBalances() {
            DB.accounts.forEach(account => {
                account.balance = account.initialBalance;
                const accountOps = DB.operations.filter(op => op.accountId === account.id);
                accountOps.forEach(operation => {
                    let pl = operation.pl;
                    if (operation.currency !== account.currency) {
                        pl = convertCurrency(pl, operation.currency, account.currency);
                    }
                    account.balance += pl;
                });
                account.balance = Math.round(account.balance * 100) / 100;
            });
        }

        // Función global para guardar setups en Dexie
        window.saveDB = async function() {
            try {
                console.log('💾 Guardando setups en base de datos...');
                await dexieDB.setups.clear();
                if (DB.setups && DB.setups.length > 0) {
                    await dexieDB.setups.bulkAdd(DB.setups);
                    console.log(`✅ ${DB.setups.length} setups guardados`);
                } else {
                    console.log('ℹ️ No hay setups para guardar');
                }
            } catch (error) {
                console.error('❌ Error guardando setups:', error);
            }
        };

        // Función para guardar las preferencias del usuario
        async function savePreferences() {
            try {
                console.log('💾 Guardando preferencias...');
                
                // Recopilar valores de los campos de configuración
                const preferences = {
                    showTooltips: document.getElementById('config-show-tooltips')?.checked ?? true,
                    animations: document.getElementById('config-animations')?.checked ?? true,
                    timezone: document.getElementById('config-timezone')?.value ?? 'UTC+1',
                    dateFormat: document.getElementById('config-date-format')?.value ?? 'DD/MM/YYYY',
                    defaultCurrency: document.getElementById('config-currency')?.value ?? 'USD',
                    // Notificaciones
                    notifWeeklySummary: document.getElementById('notif-weekly-summary')?.checked ?? true,
                    notifGoals: document.getElementById('notif-goals')?.checked ?? false,
                    notifUpdates: document.getElementById('notif-updates')?.checked ?? true,
                };
                
                // Actualizar DB.settings
                DB.settings = { ...DB.settings, ...preferences };
                
                // Guardar en Dexie
                await dexieDB.generalData.put({ key: 'settings', value: DB.settings });
                
                console.log('✅ Preferencias guardadas:', preferences);
                
                // Mostrar indicador de guardado exitoso
                showPreferencesSaveIndicator();
                
                return true;
            } catch (error) {
                console.error('❌ Error guardando preferencias:', error);
                showNotification('Error al guardar preferencias', 'error');
                return false;
            }
        }

        // Función para cargar las preferencias del usuario
        async function loadPreferences() {
            try {
                console.log('📥 Cargando preferencias...');
                
                if (!DB.settings) {
                    console.log('⚠️ No hay configuraciones guardadas, usando valores por defecto');
                    return;
                }
                
                // Cargar valores en los campos de configuración
                const tooltipsCheckbox = document.getElementById('config-show-tooltips');
                if (tooltipsCheckbox) tooltipsCheckbox.checked = DB.settings.showTooltips ?? true;
                
                const animationsCheckbox = document.getElementById('config-animations');
                if (animationsCheckbox) animationsCheckbox.checked = DB.settings.animations ?? true;
                
                const timezoneSelect = document.getElementById('config-timezone');
                if (timezoneSelect) timezoneSelect.value = DB.settings.timezone ?? 'UTC+1';
                
                const dateFormatSelect = document.getElementById('config-date-format');
                if (dateFormatSelect) dateFormatSelect.value = DB.settings.dateFormat ?? 'DD/MM/YYYY';
                
                const currencySelect = document.getElementById('config-currency');
                if (currencySelect) currencySelect.value = DB.settings.defaultCurrency ?? 'USD';
                
                // Notificaciones
                const notifWeekly = document.getElementById('notif-weekly-summary');
                if (notifWeekly) notifWeekly.checked = DB.settings.notifWeeklySummary ?? true;
                
                const notifGoals = document.getElementById('notif-goals');
                if (notifGoals) notifGoals.checked = DB.settings.notifGoals ?? false;
                
                const notifUpdates = document.getElementById('notif-updates');
                if (notifUpdates) notifUpdates.checked = DB.settings.notifUpdates ?? true;
                
                console.log('✅ Preferencias cargadas correctamente');
            } catch (error) {
                console.error('❌ Error cargando preferencias:', error);
            }
        }

        // Función para mostrar indicador de guardado exitoso
        function showPreferencesSaveIndicator() {
            const indicator = document.getElementById('preferences-save-indicator');
            if (indicator) {
                indicator.style.display = 'block';
                setTimeout(() => {
                    indicator.style.display = 'none';
                }, 3000);
            }
        }


        function convertCurrency(amount, fromCurrency, toCurrency) {
            // Mapeo de monedas comunes a sus equivalentes principales
            const currencyMapping = {
                'USDT': 'USD',
                'USDC': 'USD',
                'DAI': 'USD',
                'BUSD': 'USD',
                'TUSD': 'USD'
            };

            const rates = {
                'USD_EUR': 0.92,
                'EUR_USD': 1.09,
                'USD_USDT': 1.0,
                'USDT_USD': 1.0,
                'USD_USDC': 1.0,
                'USDC_USD': 1.0
            };

            // Validar y limpiar parámetros
            if (!fromCurrency || !toCurrency || typeof fromCurrency !== 'string' || typeof toCurrency !== 'string') {
                return amount || 0;
            }

            // Normalizar monedas
            const normalizedFrom = currencyMapping[fromCurrency.toUpperCase()] || fromCurrency.toUpperCase();
            const normalizedTo = currencyMapping[toCurrency.toUpperCase()] || toCurrency.toUpperCase();

            if (normalizedFrom === normalizedTo) return amount || 0;

            const rateKey = `${normalizedFrom}_${normalizedTo}`;
            if (rates[rateKey]) return (amount || 0) * rates[rateKey];

            // Solo mostrar warning si las monedas no son equivalentes conocidas
            if (!currencyMapping[fromCurrency] && !currencyMapping[toCurrency]) {
                console.warn(`Tasa de conversión no encontrada para ${fromCurrency} a ${toCurrency}. Usando 1:1.`);
            }

            return amount || 0;
        }

        // Función para validar datos de operaciones
        function isValidOperation(op) {
            if (!op) return false;
            if (!op.instrument || typeof op.instrument !== 'string') return false;
            if (!op.currency || typeof op.currency !== 'string') return false;
            if (typeof op.pl !== 'number' || isNaN(op.pl)) return false;
            if (!op.date) return false;
            return true;
        }

        // Función para mostrar notificaciones de sincronización
        function showSyncNotification(message, type = 'success') {
            const notification = document.createElement('div');
            const bgColor = type === 'success' ? '#10b981' : type === 'warning' ? '#f59e0b' : '#ef4444';
            const icon = type === 'success' ? 'check-circle' : type === 'warning' ? 'exclamation-triangle' : 'times-circle';

            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${bgColor};
                color: white;
                padding: 12px 16px;
                border-radius: 8px;
                z-index: 9999;
                font-size: 14px;
                font-weight: 500;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                max-width: 350px;
                animation: slideInRight 0.3s ease-out;
            `;

            notification.innerHTML = `<i class="fas fa-${icon} mr-2"></i>${message}`;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.style.animation = 'slideOutRight 0.3s ease-in';
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }

        function formatCurrency(amount, baseCurrency = null, displayCurrency = null) {
            let currencyToDisplay = displayCurrency;
            if (!currencyToDisplay) {
                // Intentar obtener el selector de moneda de la sección activa
                const activeTab = document.querySelector('.nav-tab.active')?.dataset.target;
                let currencySelect = null;
                if (activeTab === 'dashboard') currencySelect = document.getElementById('dashboard-currency-select');
                else if (activeTab === 'analytics') currencySelect = document.getElementById('analytics-currency-select');
                else if (activeTab === 'informe') currencySelect = document.getElementById('informe-currency-select');
                else if (activeTab === 'calendar') currencySelect = document.getElementById('calendar-currency-select');
                currencyToDisplay = currencySelect ? currencySelect.value : 'USD';
            }

            if (amount === 0 || typeof amount === 'undefined' || amount === null) {
                return currencyToDisplay === '%' ? '0.00%' : currencyToDisplay === 'EUR' ? '€0.00' : '$0.00';
            }
            const amountActualCurrency = baseCurrency || DB.settings.defaultCurrency;

            if (currencyToDisplay === '%') {
                const activeTab = document.querySelector('.nav-tab.active')?.dataset.target;
                let accountSelectId;
                if (activeTab === 'dashboard') accountSelectId = 'dashboard-account-select';
                else if (activeTab === 'analytics') accountSelectId = 'analytics-account-select';
                else if (activeTab === 'calendar') accountSelectId = 'calendar-account-select';

                if (!accountSelectId) return (amount > 0 ? '+' : '') + amount.toFixed(2);

                const selectedAccountFilterInput = document.getElementById(accountSelectId);
                const selectedAccountFilter = selectedAccountFilterInput ? selectedAccountFilterInput.value : 'all';

                let initialBalanceInDefault = 0;
                if (selectedAccountFilter === 'all') {
                    initialBalanceInDefault = DB.accounts.reduce((sum, acc) => {
                        let balance = acc.initialBalance;
                        if (acc.currency !== DB.settings.defaultCurrency) {
                            balance = convertCurrency(balance, acc.currency, DB.settings.defaultCurrency);
                        }
                        return sum + balance;
                    }, 0);
                } else {
                    const foundAccount = DB.accounts.find(a => a.id === selectedAccountFilter);
                    if (foundAccount) {
                        initialBalanceInDefault = foundAccount.initialBalance;
                        if (foundAccount.currency !== DB.settings.defaultCurrency) {
                            initialBalanceInDefault = convertCurrency(initialBalanceInDefault, foundAccount.currency, DB.settings.defaultCurrency);
                        }
                    }
                }
                if (initialBalanceInDefault === 0) return '0.00%';

                let amountInDefault = amount;
                if (amountActualCurrency !== DB.settings.defaultCurrency) {
                    amountInDefault = convertCurrency(amount, amountActualCurrency, DB.settings.defaultCurrency);
                }
                const percentage = (amountInDefault / initialBalanceInDefault) * 100;
                return percentage.toFixed(2) + '%';
            }

            let displayAmount = amount;
            if (amountActualCurrency !== currencyToDisplay) {
                displayAmount = convertCurrency(amount, amountActualCurrency, currencyToDisplay);
            }
            const options = { minimumFractionDigits: 2, maximumFractionDigits: 2 };
            if (currencyToDisplay === 'EUR') {
                return '€' + displayAmount.toLocaleString('es-ES', options);
            } else {
                return '$' + displayAmount.toLocaleString('en-US', options);
            }
        }


        function generateId() {
            // Usar sistema de IDs secuenciales simples
            return getNextOperationId();
        }

        /**
         * Detecta automáticamente la sesión de trading basada en la hora de entrada
         * Horario base: UTC+1 (Madrid)
         * - Londres: 9:00 - 15:30
         * - New York: 15:30 - 23:00
         * - Asia: 23:00 - 9:00
         */
        function detectTradingSession(entryTime) {
            if (!entryTime) return '';
            
            try {
                // Extraer hora y minutos del formato HH:MM o HH:MM:SS
                const timeParts = entryTime.split(':');
                const hour = parseInt(timeParts[0], 10);
                const minute = parseInt(timeParts[1], 10) || 0;
                
                if (isNaN(hour) || hour < 0 || hour > 23) return '';
                
                // Convertir a minutos totales para comparación más precisa
                const totalMinutes = hour * 60 + minute;
                
                // Londres: 9:00 (540 min) - 15:30 (930 min)
                if (totalMinutes >= 540 && totalMinutes < 930) {
                    return 'Londres';
                }
                // New York: 15:30 (930 min) - 23:00 (1380 min)
                else if (totalMinutes >= 930 && totalMinutes < 1380) {
                    return 'New York';
                }
                // Asia: 23:00 (1380 min) - 9:00 (540 min) del día siguiente
                else {
                    return 'Asia';
                }
            } catch (e) {
                console.warn('Error detectando sesión:', e);
                return '';
            }
        }

        function formatDate(dateString) {
            if (!dateString) return '';
            try {
                // Crear la fecha como fecha local en lugar de UTC
                const date = dateString.includes('T') ? new Date(dateString) : new Date(dateString + 'T00:00:00');
                if (isNaN(date.getTime())) return dateString;

                // Usar métodos locales en lugar de UTC
                const day = String(date.getDate()).padStart(2, '0');
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const year = date.getFullYear();
                return `${day}/${month}/${year}`;
            } catch (e) {
                console.warn("Error formatting date:", dateString, e);
                return dateString;
            }
        }

        function formatPlatformName(platformValue) {
            const names = {
                'meta-trader-4': 'Meta Trader 4',
                'meta-trader-5': 'Meta Trader 5',
                'ninjatrader': 'NinjaTrader 8',
                'ctrader': 'cTrader',
                'tradingview': 'TradingView',
                'tradovate': 'Tradovate',
                'topstepx': 'TopStepX',
                'bingx': 'BingX',
                'bitget': 'Bitget',
                'mexc': 'MEXC',
                'lbank': 'LBank',
                'blofin': 'BloFin',
                'primexbt': 'PrimeXBT',
                'primexbt-crypto': 'PrimeXBT Crypto',
                'primexbt-cfds': 'PrimeXBT CFDs',
                'bitunix': 'Bitunix',
                'binance': 'Binance',
                'other': 'Otra'
            };
            return names[platformValue] || platformValue;
        }

        function getPlatformLogo(platformValue) {
            const logos = {
                'bingx': {
                    file: 'logos/bingx-logo.png',
                    color: '#1E90FF',
                    initials: 'BX'
                },
                'bitget': {
                    file: 'logos/bitget-logo.png',
                    color: '#00F0FF',
                    initials: 'BG'
                },
                'primexbt': {
                    'id': ['order id', 'trade id', 'position id'],
                    file: 'logos/primexbt-logo.png',
                    color: '#0066FF',
                    initials: 'PX'
                },
                'primexbt-crypto': {
                    file: 'logos/primexbt-logo.png',
                    color: '#0066FF',
                    initials: 'PX'
                },
                'primexbt-cfds': {
                    file: 'logos/primexbt-logo.png',
                    color: '#0066FF',
                    initials: 'PX'
                },
                'bitunix': {
                    file: 'logos/bitunix-logo.png',
                    color: '#FF6B00',
                    initials: 'BU'
                },
                'mexc': {
                    file: 'logos/mexc-logo.png',
                    color: '#00D4AA',
                    initials: 'MX'
                },
                'lbank': {
                    file: 'logos/lbank-logo.png',
                    color: '#2E5BFF',
                    initials: 'LB'
                },
                'blofin': {
                    file: 'logos/blofin-logo.png',
                    color: '#00C9A7',
                    initials: 'BF'
                },
                'binance': {
                    file: 'logos/binance-logo.png',
                    color: '#F3BA2F',
                    initials: 'BN'
                },
                'meta-trader-5': {
                    file: 'logos/metatrader5-logo.png',
                    color: '#1B5E20',
                    initials: 'MT5'
                },
                'meta-trader-4': {
                    file: 'logos/metatrader 4-logo.png',
                    color: '#1B5E20',
                    initials: 'MT4'
                },
                'ctrader': {
                    file: 'logos/ctrader-logo.png',
                    color: '#00A8E1',
                    initials: 'CT'
                },
                'tradingview': {
                    file: 'logos/tradingview-logo.png',
                    color: '#2962FF',
                    initials: 'TV'
                },
                'ninjatrader': {
                    file: 'logos/ninja-logo.png',
                    color: '#FF6600',
                    initials: 'NT'
                },
                'tradovate': {
                    file: 'logos/tradovate-logo.png',
                    color: '#0066CC',
                    initials: 'TD'
                },
                'topstepx': {
                    file: 'logos/topstepx-logo.png',
                    color: '#FF5722',
                    initials: 'TSX'
                },
                'other': {
                    file: '',
                    color: '#808080',
                    initials: '?'
                }
            };

            return logos[platformValue] || { file: '', color: '#808080', initials: '?' };
        }


        function getStartDateForRange(range) {
            const endDate = new Date();
            let startDate = new Date();
            switch (range) {
                case '1W': startDate.setDate(endDate.getDate() - 7); break;
                case '1M': startDate.setMonth(endDate.getMonth() - 1); break;
                case '3M': startDate.setMonth(endDate.getMonth() - 3); break;
                case '6M': startDate.setMonth(endDate.getMonth() - 6); break;
                case '1Y': startDate.setFullYear(endDate.getFullYear() - 1); break;
                case 'ALL': default: return null;
            }
            return getLocalDateString(startDate);
        }

        window.applyDateFilterToData = function(dataArray) {
            console.log(`[applyDateFilterToData] Applying filter:`, JSON.stringify(globalDateFilter));
            console.log(`[applyDateFilterToData] Input array size: ${dataArray.length}`);

            if (globalDateFilter.type === 'all' || !globalDateFilter.startDate || !globalDateFilter.endDate) {
                console.log(`[applyDateFilterToData] No filter applied. Returning original array.`);
                return dataArray;
            }
            
            const filteredArray = dataArray.filter(item => {
                const itemDate = item.date;
                const isInRange = itemDate >= globalDateFilter.startDate && itemDate <= globalDateFilter.endDate;
                
                // Log para debug (solo primeros 3 items)
                if (dataArray.indexOf(item) < 3) {
                    console.log(`[Filter Debug] Item date: "${itemDate}", Range: "${globalDateFilter.startDate}" to "${globalDateFilter.endDate}", Match: ${isInRange}`);
                }
                
                return isInRange;
            });

            console.log(`[applyDateFilterToData] Output array size: ${filteredArray.length}`);
            console.log(`[applyDateFilterToData] Sample filtered dates:`, filteredArray.slice(0, 3).map(op => op.date));
            return filteredArray;
        }

        // Helper para filtrar operaciones por múltiples cuentas seleccionadas
        function filterBySelectedAccounts(operations, selectedAccountValue) {
            // Si es 'all' o está en selectedAccounts array, retornar todo
            if (selectedAccountValue === 'all' || selectedAccounts.includes('all')) {
                return operations;
            }
            
            // Si solo hay una cuenta seleccionada
            if (!Array.isArray(selectedAccounts) || selectedAccounts.length === 0) {
                if (selectedAccountValue !== 'all') {
                    return operations.filter(op => op.accountId === selectedAccountValue);
                }
                return operations;
            }
            
            // Filtrar por múltiples cuentas
            return operations.filter(op => selectedAccounts.includes(op.accountId));
        }


        // Función para descargar sección como PDF con screenshot
        // ========== FUNCIONES DE PDF REPORT PROFESIONAL ==========
        
        function openPDFReportModal() {
            const modal = document.getElementById('pdf-report-modal');
            if (!modal) return;
            
            // Pre-llenar con la cuenta seleccionada en Analytics
            const analyticsAccountSelect = document.getElementById('analytics-account-select');
            const pdfAccountSelect = document.getElementById('pdf-account-select');
            
            if (pdfAccountSelect && analyticsAccountSelect) {
                // Copiar opciones
                pdfAccountSelect.innerHTML = analyticsAccountSelect.innerHTML;
                pdfAccountSelect.value = analyticsAccountSelect.value;
            }
            
            // Establecer fecha actual para período personalizado
            const today = new Date().toISOString().split('T')[0];
            document.getElementById('pdf-end-date').value = today;
            
            const firstDayOfMonth = new Date();
            firstDayOfMonth.setDate(1);
            document.getElementById('pdf-start-date').value = firstDayOfMonth.toISOString().split('T')[0];
            
            modal.style.display = 'flex';
        }
        
        function closePDFReportModal() {
            const modal = document.getElementById('pdf-report-modal');
            if (modal) modal.style.display = 'none';
        }

        async function generateProfessionalPDF() {
            // Obtener configuración
            const accountId = document.getElementById('pdf-account-select').value;
            const period = document.getElementById('pdf-period-select').value;
            const reportType = document.getElementById('pdf-report-type-value').value;
            const includeCharts = document.getElementById('pdf-include-charts').checked;
            const includeInsights = document.getElementById('pdf-include-insights').checked;
            const includeHeatmap = document.getElementById('pdf-include-heatmap').checked;
            const publicMode = document.getElementById('pdf-public-mode').checked;
            
            // Determinar rango de fechas
            let startDate, endDate;
            if (period === 'custom') {
                startDate = document.getElementById('pdf-start-date').value;
                endDate = document.getElementById('pdf-end-date').value;
                
                // Validar fechas
                if (!startDate || !endDate) {
                    showMessage('⚠️ Por favor selecciona fechas de inicio y fin', 'warning');
                    return;
                }
            } else {
                const dates = calculatePeriodDates(period);
                startDate = dates.start;
                endDate = dates.end;
            }
            
            closePDFReportModal();
            
            // Mensaje personalizado según tipo de reporte
            const reportNames = {
                'summary': 'Summary (2 páginas)',
                'full': 'Professional (8-12 páginas)',
                'professional': 'Professional (8-12 páginas)',
                'detailed': 'Detailed (Completo)'
            };
            
            const reportName = reportNames[reportType] || 'PDF';
            showMessage(`📊 Generando reporte ${reportName}...`, 'info');
            
            try {
                // Obtener datos filtrados
                const operations = await getFilteredOperationsForPDF(accountId, startDate, endDate);
                
                if (operations.length === 0) {
                    showMessage('⚠️ No hay operaciones en el período seleccionado', 'warning');
                    return;
                }
                
                console.log(`📊 Generando PDF con ${operations.length} operaciones`);
                console.log(`⚙️ Opciones: Charts=${includeCharts}, Insights=${includeInsights}, Heatmap=${includeHeatmap}, Public=${publicMode}`);
                
                // Calcular métricas
                const metrics = calculateAllMetricsForPDF(operations, accountId);
                
                // Generar HTML del reporte
                await buildProfessionalReportHTML({
                    accountId,
                    startDate,
                    endDate,
                    reportType,
                    operations,
                    metrics,
                    includeCharts,
                    includeInsights,
                    includeHeatmap,
                    publicMode
                });
                
                showMessage(`✅ Reporte ${reportName} generado exitosamente`, 'success');
            } catch (error) {
                console.error('❌ Error generando PDF:', error);
                showMessage('❌ Error al generar reporte PDF: ' + error.message, 'error');
            }
        }
        
        function calculatePeriodDates(period) {
            const today = new Date();
            let start, end = today;
            
            switch(period) {
                case 'current-month':
                    start = new Date(today.getFullYear(), today.getMonth(), 1);
                    break;
                case 'last-month':
                    start = new Date(today.getFullYear(), today.getMonth() - 1, 1);
                    end = new Date(today.getFullYear(), today.getMonth(), 0);
                    break;
                case 'current-quarter':
                    const quarter = Math.floor(today.getMonth() / 3);
                    start = new Date(today.getFullYear(), quarter * 3, 1);
                    break;
                case 'current-year':
                    start = new Date(today.getFullYear(), 0, 1);
                    break;
                case 'all-time':
                default:
                    start = new Date('2020-01-01');
                    break;
            }
            
            return {
                start: start.toISOString().split('T')[0],
                end: end.toISOString().split('T')[0]
            };
        }
        
        async function getFilteredOperationsForPDF(accountId, startDate, endDate) {
            let operations = [...DB.operations];
            
            // Filtrar por cuenta
            if (accountId !== 'all') {
                operations = operations.filter(op => op.accountId === accountId);
            }
            
            // Filtrar por fechas
            operations = operations.filter(op => {
                return op.date >= startDate && op.date <= endDate;
            });
            
            return operations.sort((a, b) => new Date(a.date) - new Date(b.date));
        }
        
        function calculateAllMetricsForPDF(operations, accountId) {
            const basic = calculateMetrics(operations, accountId);
            const advanced = calculateAdvancedMetrics(operations, accountId);
            const professional = calculateProfessionalMetrics(operations, accountId);
            const time = calculateTimeMetrics(operations);
            
            return { ...basic, ...advanced, ...professional, ...time };
        }
        
        async function buildProfessionalReportHTML(config) {
            console.log('🔄 Generando reporte PDF personalizado...', config);
            
            // Guardar estado actual de Analytics
            const analyticsSection = document.getElementById('analytics');
            const originalDisplay = analyticsSection.style.display;
            const originalAccountSelect = document.getElementById('analytics-account-select').value;
            const originalGlobalDateFilter = {...globalDateFilter};
            
            try {
                // 1. Cambiar temporalmente a la cuenta/período del reporte
                document.getElementById('analytics-account-select').value = config.accountId;
                
                // 2. Establecer filtro de fechas temporal
                globalDateFilter = {
                    enabled: true,
                    startDate: config.startDate,
                    endDate: config.endDate
                };
                
                // 3. Forzar actualización de Analytics con filtros temporales
                refreshAnalytics();
                
                // 4. Aplicar opciones de visualización según tipo de reporte
                applyReportDisplayOptions(config);
                
                // 5. Esperar a que se rendericen los gráficos
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // 6. Generar PDF
                const fileName = `TradingSurvivor_${config.reportType}_${config.startDate}_${config.endDate}`;
                await downloadSectionPDF('analytics', fileName);
                
                // 7. Restaurar estado original
                globalDateFilter = originalGlobalDateFilter;
                restoreAnalyticsState(originalAccountSelect);
                
                return true;
            } catch (error) {
                console.error('Error generando reporte:', error);
                // Restaurar estado en caso de error
                globalDateFilter = originalGlobalDateFilter;
                restoreAnalyticsState(originalAccountSelect);
                throw error;
            }
        }
        
        function applyReportDisplayOptions(config) {
            const analyticsContent = document.getElementById('analytics');
            if (!analyticsContent) return;
            
            // Guardar estados originales antes de modificar
            const saveOriginalState = (element) => {
                if (!element.hasAttribute('data-original-display')) {
                    element.setAttribute('data-original-display', element.style.display || '');
                }
            };
            
            // Aplicar modo según tipo de reporte
            switch(config.reportType) {
                case 'summary':
                    // Summary: Solo dashboard principal y métricas clave (primeras 6-8 cards)
                    hideAdvancedSections(analyticsContent, saveOriginalState);
                    break;
                    
                case 'full':
                case 'professional':
                    // Professional: Todo visible, aplicar solo las opciones del usuario
                    // (ya está todo visible por defecto)
                    break;
                    
                case 'detailed':
                    // Detailed: Absolutamente todo forzado a visible
                    showAllSections(analyticsContent);
                    break;
            }
            
            // Aplicar opciones avanzadas del usuario
            if (!config.includeCharts) {
                hideCharts(analyticsContent, saveOriginalState);
            }
            
            if (!config.includeHeatmap) {
                hideHeatmaps(analyticsContent, saveOriginalState);
            }
            
            // Modo público: ocultar balances sensibles
            if (config.publicMode) {
                applyPublicMode(analyticsContent);
            }
            
            console.log(`✅ Opciones de reporte aplicadas: ${config.reportType}, charts=${config.includeCharts}, heatmap=${config.includeHeatmap}, public=${config.publicMode}`);
        }
        
        function hideAdvancedSections(container, saveState) {
            // Para Summary: ocultar gráficos detallados y tablas extensas
            const advancedSelectors = [
                '.chart-container:not(:nth-of-type(1)):not(:nth-of-type(2))', // Mantener solo primeros 2 gráficos
                'table',
                '[id*="detail"]',
                '[id*="advanced"]'
            ];
            
            advancedSelectors.forEach(selector => {
                container.querySelectorAll(selector).forEach(el => {
                    saveState(el);
                    el.style.display = 'none';
                });
            });
        }
        
        function hideCharts(container, saveState) {
            container.querySelectorAll('.chart-container, canvas').forEach(el => {
                saveState(el);
                el.style.display = 'none';
            });
        }
        
        function hideHeatmaps(container, saveState) {
            container.querySelectorAll('[id*="heatmap"], [class*="heatmap"]').forEach(el => {
                saveState(el);
                el.style.display = 'none';
            });
        }
        
        function applyPublicMode(container) {
            // Ocultar elementos sensibles con blur
            const sensitiveSelectors = [
                '[class*="hide-amount"]',
                '[id*="balance"]',
                '[id*="total-pl"]',
                '[id*="net-pl"]'
            ];
            
            sensitiveSelectors.forEach(selector => {
                container.querySelectorAll(selector).forEach(el => {
                    if (!el.hasAttribute('data-original-text')) {
                        el.setAttribute('data-original-text', el.textContent);
                        el.textContent = '•••••';
                        el.style.filter = 'blur(5px)';
                    }
                });
            });
        }
        
        function showAllSections(container) {
            // Mostrar todo forzadamente
            container.querySelectorAll('[style*="display: none"]').forEach(el => {
                el.style.display = '';
            });
        }
        
        function restoreAnalyticsState(originalAccountSelect) {
            // Restaurar selección de cuenta
            document.getElementById('analytics-account-select').value = originalAccountSelect;
            
            // Restaurar todos los elementos ocultos/modificados
            const analyticsContent = document.getElementById('analytics');
            
            // Restaurar displays
            analyticsContent.querySelectorAll('[data-original-display]').forEach(el => {
                el.style.display = el.getAttribute('data-original-display');
                el.removeAttribute('data-original-display');
            });
            
            // Restaurar balances en modo público
            analyticsContent.querySelectorAll('[data-original-text]').forEach(el => {
                el.textContent = el.getAttribute('data-original-text');
                el.style.filter = '';
                el.removeAttribute('data-original-text');
            });
            
            // Recargar Analytics con la cuenta original
            refreshAnalytics();
        }
        
        async function convertReportToPDF(html, reportType, accountId, startDate, endDate) {
            // Ya no es necesario, buildProfessionalReportHTML hace todo
            console.log('✅ PDF generado correctamente');
        }

        async function downloadSectionPDF(sectionId, sectionName) {
            const section = document.getElementById(sectionId);
            if (!section) {
                console.error('Sección no encontrada:', sectionId);
                alert('Error: No se encontró la sección para exportar.');
                return;
            }

            try {
                // Mostrar loading
                showLoading(true);

                // Crear overlay para ocultar el proceso visualmente
                const overlay = document.createElement('div');
                overlay.style.position = 'fixed';
                overlay.style.top = '0';
                overlay.style.left = '0';
                overlay.style.width = '100%';
                overlay.style.height = '100%';
                overlay.style.background = 'rgba(0, 0, 0, 0.9)';
                overlay.style.zIndex = '99999';
                overlay.style.display = 'flex';
                overlay.style.alignItems = 'center';
                overlay.style.justifyContent = 'center';
                overlay.innerHTML = '<div style="color: #39ff14; font-size: 20px; font-weight: bold;">Generando PDF...</div>';
                document.body.appendChild(overlay);

                // Scroll to top of section
                section.scrollIntoView({ behavior: 'instant', block: 'start' });
                
                // Esperar que el scroll se complete y los gráficos se rendericen
                await new Promise(resolve => setTimeout(resolve, 500));

                // Capturar la sección original directamente (no clonar)
                const canvas = await html2canvas(section, {
                    backgroundColor: '#0a0a0a',
                    scale: 2,
                    logging: false,
                    useCORS: true,
                    allowTaint: true,
                    foreignObjectRendering: false,
                    imageTimeout: 0,
                    windowWidth: section.scrollWidth,
                    windowHeight: section.scrollHeight,
                    onclone: (clonedDoc) => {
                        // Asegurar que los canvas de Chart.js se copien correctamente
                        const originalCanvases = section.querySelectorAll('canvas');
                        const clonedCanvases = clonedDoc.querySelectorAll('canvas');
                        
                        originalCanvases.forEach((originalCanvas, index) => {
                            if (clonedCanvases[index]) {
                                const ctx = clonedCanvases[index].getContext('2d');
                                clonedCanvases[index].width = originalCanvas.width;
                                clonedCanvases[index].height = originalCanvas.height;
                                ctx.drawImage(originalCanvas, 0, 0);
                            }
                        });
                    }
                });

                // Verificar que el canvas tenga contenido
                if (canvas.width === 0 || canvas.height === 0) {
                    throw new Error('El canvas generado está vacío');
                }

                // Remover overlay
                document.body.removeChild(overlay);

                // Crear PDF con jsPDF
                const { jsPDF } = window.jspdf;
                const imgWidth = 210; // A4 width in mm
                const pageHeight = 297; // A4 height in mm
                const imgHeight = (canvas.height * imgWidth) / canvas.width;
                
                const pdf = new jsPDF('p', 'mm', 'a4');
                
                // Agregar header en primera página
                pdf.setFillColor(10, 10, 10);
                pdf.rect(0, 0, 210, 297, 'F');
                
                pdf.setTextColor(57, 255, 20);
                pdf.setFontSize(24);
                pdf.setFont(undefined, 'bold');
                pdf.text('TRADING SURVIVOR', 105, 20, { align: 'center' });
                
                pdf.setFontSize(14);
                pdf.setFont(undefined, 'normal');
                pdf.setTextColor(160, 160, 160);
                pdf.text(sectionName, 105, 30, { align: 'center' });
                pdf.text(new Date().toLocaleDateString('es-ES', { year: 'numeric', month: 'long', day: 'numeric' }), 105, 37, { align: 'center' });
                
                // Línea separadora
                pdf.setDrawColor(57, 255, 20);
                pdf.setLineWidth(0.5);
                pdf.line(20, 40, 190, 40);
                
                // Agregar la imagen capturada
                const imgData = canvas.toDataURL('image/png', 1.0);
                
                let heightLeft = imgHeight;
                let position = 45;
                
                // Primera página - agregar imagen debajo del header
                const firstPageHeight = Math.min(imgHeight, pageHeight - position);
                pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
                heightLeft -= (pageHeight - position);
                
                // Páginas adicionales si es necesario
                while (heightLeft > 0) {
                    position = heightLeft - imgHeight;
                    pdf.addPage();
                    pdf.setFillColor(10, 10, 10);
                    pdf.rect(0, 0, 210, 297, 'F');
                    pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
                    heightLeft -= pageHeight;
                }

                // Descargar PDF
                const fileName = `TradingSurvivor_${sectionName}_${new Date().toISOString().split('T')[0]}.pdf`;
                pdf.save(fileName);
                
                showLoading(false);
                
                // Mostrar mensaje de éxito
                showMessage('✅ PDF descargado correctamente', 'success');
                
            } catch (error) {
                console.error('Error al generar PDF:', error);
                showLoading(false);
                // Limpiar en caso de error
                const overlay = document.querySelector('div[style*="z-index: 99999"]');
                if (overlay && overlay.parentNode) {
                    document.body.removeChild(overlay);
                }
                alert('Error al generar el PDF: ' + error.message + '\n\nPor favor, intenta nuevamente o usa Ctrl+P para imprimir la página.');
            }
        }

        // ========== CONTROL DEL SIDEBAR DE FILTROS ==========
        let currentFilterSection = 'dashboard'; // Rastrear qué sección está usando los filtros
        
        function toggleFiltersSidebar() {
            const sidebar = document.getElementById('filters-sidebar');
            const overlay = document.getElementById('filters-overlay');
            
            sidebar.classList.toggle('active');
            overlay.classList.toggle('active');
        }

        function toggleFilterSection(sectionId) {
            const section = document.getElementById(sectionId + '-content').parentElement;
            section.classList.toggle('expanded');
        }

        // Variable global para almacenar filtros de Dashboard
        let dashboardFilters = { symbol: '', type: 'all', result: 'all', plMin: null, plMax: null, day: 'all', duration: 'all', session: 'all', showWins: true, showLosses: true, showBreakeven: true };
        let analyticsFilters = { symbol: '', type: 'all', result: 'all', plMin: null, plMax: null, day: 'all', duration: 'all', session: 'all', showWins: true, showLosses: true, showBreakeven: true };
        let dailyJournalFilters = { symbol: '', type: 'all', result: 'all', plMin: null, plMax: null, day: 'all', duration: 'all', session: 'all', showWins: true, showLosses: true, showBreakeven: true };
        let operationsFilters = { symbol: '', type: 'all', result: 'all', plMin: null, plMax: null, day: 'all', duration: 'all', session: 'all', showWins: true, showLosses: true, showBreakeven: true };
        let calendarFilters = { symbol: '', type: 'all', result: 'all', plMin: null, plMax: null, day: 'all', duration: 'all', session: 'all', showWins: true, showLosses: true, showBreakeven: true };

        function applyCalendarFilters(operations) {
            return operations.filter(op => {
                if (calendarFilters.symbol && !op.instrument.toUpperCase().includes(calendarFilters.symbol)) return false;
                if (calendarFilters.type !== 'all' && op.type !== calendarFilters.type) return false;
                if (op.pl > 0 && !calendarFilters.showWins) return false;
                if (op.pl < 0 && !calendarFilters.showLosses) return false;
                if (op.pl === 0 && !calendarFilters.showBreakeven) return false;
                if (calendarFilters.result !== 'all') {
                    if (calendarFilters.result === 'win' && op.pl <= 0) return false;
                    if (calendarFilters.result === 'loss' && op.pl >= 0) return false;
                }
                if (calendarFilters.plMin !== null && op.pl < calendarFilters.plMin) return false;
                if (calendarFilters.plMax !== null && op.pl > calendarFilters.plMax) return false;
                if (calendarFilters.day !== 'all') {
                    const opDate = new Date(op.date + 'T00:00:00Z');
                    const dayOfWeek = opDate.getUTCDay();
                    if (parseInt(calendarFilters.day) !== dayOfWeek) return false;
                }
                if (calendarFilters.duration !== 'all') {
                    if (!op.entry_time || !op.exit_time) return false;
                    const duration = calculateDuration(op.entry_time, op.exit_time);
                    if (calendarFilters.duration === 'scalp' && duration > 5) return false;
                    if (calendarFilters.duration === 'intraday' && (duration <= 5 || duration >= 1440)) return false;
                    if (calendarFilters.duration === 'swing' && duration < 1440) return false;
                }
                if (calendarFilters.session !== 'all') {
                    const opSession = getTradingSession(op.entry_time);
                    if (opSession !== calendarFilters.session) return false;
                }
                return true;
            });
        }

        function applyDashboardFilters(operations) {
            console.log('🔍 applyDashboardFilters - Entrada:', operations.length, 'operaciones');
            console.log('🔍 Filtros activos:', JSON.stringify(dashboardFilters, null, 2));
            
            const filtered = operations.filter(op => {
                // Filtro por símbolo/instrumento
                if (dashboardFilters.symbol && !op.instrument.toUpperCase().includes(dashboardFilters.symbol)) {
                    return false;
                }
                
                // Filtro por tipo
                if (dashboardFilters.type !== 'all' && op.type !== dashboardFilters.type) {
                    return false;
                }
                
                // Filtro por resultado con checkboxes
                if (op.pl > 0 && !dashboardFilters.showWins) return false;
                if (op.pl < 0 && !dashboardFilters.showLosses) return false;
                if (op.pl === 0 && !dashboardFilters.showBreakeven) return false;
                
                // Filtro adicional por resultado (dropdown)
                if (dashboardFilters.result !== 'all') {
                    if (dashboardFilters.result === 'win' && op.pl <= 0) return false;
                    if (dashboardFilters.result === 'loss' && op.pl >= 0) return false;
                    if (dashboardFilters.result === 'breakeven' && op.pl !== 0) return false;
                }
                
                // Filtro por P/L
                if (dashboardFilters.plMin !== null && op.pl < dashboardFilters.plMin) return false;
                if (dashboardFilters.plMax !== null && op.pl > dashboardFilters.plMax) return false;
                
                // Filtro por día de la semana
                if (dashboardFilters.day !== 'all') {
                    const dayOfWeek = new Date(op.date + 'T00:00:00Z').getUTCDay();
                    if (dayOfWeek.toString() !== dashboardFilters.day) return false;
                }
                
                // Filtro por duración
                if (op.entryTime && op.exitTime && dashboardFilters.duration !== 'all') {
                    const duration = calculateTradeDuration(op.entryTime, op.exitTime);
                    if (dashboardFilters.duration === 'scalping' && duration >= 5) return false;
                    if (dashboardFilters.duration === 'intraday' && (duration < 5 || duration > 60)) return false;
                    if (dashboardFilters.duration === 'swing' && duration <= 60) return false;
                }
                
                // Filtro por sesión de trading
                if (dashboardFilters.session !== 'all' && op.entryTime) {
                    const hour = parseInt(op.entryTime.split(':')[0]);
                    if (dashboardFilters.session === 'asian' && (hour < 0 || hour >= 8)) return false;
                    if (dashboardFilters.session === 'london' && (hour < 8 || hour >= 16)) return false;
                    if (dashboardFilters.session === 'newyork' && (hour < 13 || hour >= 22)) return false;
                }
                
                return true;
            });
            
            console.log('🔍 applyDashboardFilters - Salida:', filtered.length, 'operaciones');
            if (filtered.length > 0 && filtered.length < 5) {
                console.log('🔍 Operaciones filtradas (muestra):', filtered.map(op => ({
                    symbol: op.symbol,
                    type: op.type,
                    pl: op.pl,
                    date: op.date
                })));
            }
            
            return filtered;
        }

        function applyAnalyticsFilters(operations) {
            console.log('🔍 applyAnalyticsFilters - Entrada:', operations.length, 'operaciones');
            console.log('🔍 Filtros Analytics activos:', JSON.stringify(analyticsFilters, null, 2));
            
            const filtered = operations.filter(op => {
                // Filtro por símbolo/instrumento
                if (analyticsFilters.symbol && !op.instrument.toUpperCase().includes(analyticsFilters.symbol)) {
                    return false;
                }
                
                // Filtro por tipo
                if (analyticsFilters.type !== 'all' && op.type !== analyticsFilters.type) {
                    return false;
                }
                
                // Filtro por resultado con checkboxes
                if (op.pl > 0 && !analyticsFilters.showWins) return false;
                if (op.pl < 0 && !analyticsFilters.showLosses) return false;
                if (op.pl === 0 && !analyticsFilters.showBreakeven) return false;
                
                // Filtro adicional por resultado (dropdown)
                if (analyticsFilters.result !== 'all') {
                    if (analyticsFilters.result === 'win' && op.pl <= 0) return false;
                    if (analyticsFilters.result === 'loss' && op.pl >= 0) return false;
                    if (analyticsFilters.result === 'breakeven' && op.pl !== 0) return false;
                }
                
                // Filtro por P/L
                if (analyticsFilters.plMin !== null && op.pl < analyticsFilters.plMin) return false;
                if (analyticsFilters.plMax !== null && op.pl > analyticsFilters.plMax) return false;
                
                // Filtro por día de la semana
                if (analyticsFilters.day !== 'all') {
                    const dayOfWeek = new Date(op.date + 'T00:00:00Z').getUTCDay();
                    if (dayOfWeek.toString() !== analyticsFilters.day) return false;
                }
                
                // Filtro por duración
                if (op.entryTime && op.exitTime && analyticsFilters.duration !== 'all') {
                    const duration = calculateTradeDuration(op.entryTime, op.exitTime);
                    if (analyticsFilters.duration === 'scalping' && duration >= 5) return false;
                    if (analyticsFilters.duration === 'intraday' && (duration < 5 || duration > 60)) return false;
                    if (analyticsFilters.duration === 'swing' && duration <= 60) return false;
                }
                
                // Filtro por sesión de trading
                if (analyticsFilters.session !== 'all' && op.entryTime) {
                    const hour = parseInt(op.entryTime.split(':')[0]);
                    if (analyticsFilters.session === 'asian' && (hour < 0 || hour >= 8)) return false;
                    if (analyticsFilters.session === 'london' && (hour < 8 || hour >= 16)) return false;
                    if (analyticsFilters.session === 'newyork' && (hour < 13 || hour >= 22)) return false;
                }
                
                return true;
            });
            
            console.log('🔍 applyAnalyticsFilters - Salida:', filtered.length, 'operaciones');
            return filtered;
        }

        function applyDailyJournalFilters(operations) {
            console.log('🔍 applyDailyJournalFilters - Entrada:', operations.length, 'operaciones');
            
            const filtered = operations.filter(op => {
                // Filtro por símbolo/instrumento
                if (dailyJournalFilters.symbol && !op.instrument.toUpperCase().includes(dailyJournalFilters.symbol)) {
                    return false;
                }
                
                // Filtro por tipo
                if (dailyJournalFilters.type !== 'all' && op.type !== dailyJournalFilters.type) {
                    return false;
                }
                
                // Filtro por resultado con checkboxes
                if (op.pl > 0 && !dailyJournalFilters.showWins) return false;
                if (op.pl < 0 && !dailyJournalFilters.showLosses) return false;
                if (op.pl === 0 && !dailyJournalFilters.showBreakeven) return false;
                
                // Filtro adicional por resultado (dropdown)
                if (dailyJournalFilters.result !== 'all') {
                    if (dailyJournalFilters.result === 'win' && op.pl <= 0) return false;
                    if (dailyJournalFilters.result === 'loss' && op.pl >= 0) return false;
                    if (dailyJournalFilters.result === 'breakeven' && op.pl !== 0) return false;
                }
                
                // Filtro por P/L
                if (dailyJournalFilters.plMin !== null && op.pl < dailyJournalFilters.plMin) return false;
                if (dailyJournalFilters.plMax !== null && op.pl > dailyJournalFilters.plMax) return false;
                
                // Filtro por día de la semana
                if (dailyJournalFilters.day !== 'all') {
                    const dayOfWeek = new Date(op.date + 'T00:00:00Z').getUTCDay();
                    if (dayOfWeek.toString() !== dailyJournalFilters.day) return false;
                }
                
                // Filtro por duración
                if (op.entryTime && op.exitTime && dailyJournalFilters.duration !== 'all') {
                    const duration = calculateTradeDuration(op.entryTime, op.exitTime);
                    if (dailyJournalFilters.duration === 'scalping' && duration >= 5) return false;
                    if (dailyJournalFilters.duration === 'intraday' && (duration < 5 || duration > 60)) return false;
                    if (dailyJournalFilters.duration === 'swing' && duration <= 60) return false;
                }
                
                // Filtro por sesión de trading
                if (dailyJournalFilters.session !== 'all' && op.entryTime) {
                    const hour = parseInt(op.entryTime.split(':')[0]);
                    if (dailyJournalFilters.session === 'asian' && (hour < 0 || hour >= 8)) return false;
                    if (dailyJournalFilters.session === 'london' && (hour < 8 || hour >= 16)) return false;
                    if (dailyJournalFilters.session === 'newyork' && (hour < 13 || hour >= 22)) return false;
                }
                
                return true;
            });
            
            console.log('🔍 applyDailyJournalFilters - Salida:', filtered.length, 'operaciones');
            return filtered;
        }

        window.applyOperationsFilters = function(operations) {
            console.log('🔍 applyOperationsFilters - Entrada:', operations.length, 'operaciones');
            console.log('🔍 Filtros Operations activos:', JSON.stringify(operationsFilters, null, 2));
            
            const filtered = operations.filter(op => {
                // Filtro por símbolo/instrumento
                if (operationsFilters.symbol && !op.instrument.toUpperCase().includes(operationsFilters.symbol)) {
                    return false;
                }
                
                // Filtro por tipo
                if (operationsFilters.type !== 'all' && op.type !== operationsFilters.type) {
                    return false;
                }
                
                // Filtro por resultado con checkboxes
                if (op.pl > 0 && !operationsFilters.showWins) return false;
                if (op.pl < 0 && !operationsFilters.showLosses) return false;
                if (op.pl === 0 && !operationsFilters.showBreakeven) return false;
                
                // Filtro adicional por resultado (dropdown)
                if (operationsFilters.result !== 'all') {
                    if (operationsFilters.result === 'win' && op.pl <= 0) return false;
                    if (operationsFilters.result === 'loss' && op.pl >= 0) return false;
                    if (operationsFilters.result === 'breakeven' && op.pl !== 0) return false;
                }
                
                // Filtro por P/L
                if (operationsFilters.plMin !== null && op.pl < operationsFilters.plMin) return false;
                if (operationsFilters.plMax !== null && op.pl > operationsFilters.plMax) return false;
                
                // Filtro por día de la semana
                if (operationsFilters.day !== 'all') {
                    const dayOfWeek = new Date(op.date + 'T00:00:00Z').getUTCDay();
                    if (dayOfWeek.toString() !== operationsFilters.day) return false;
                }
                
                // Filtro por duración
                if (op.entryTime && op.exitTime && operationsFilters.duration !== 'all') {
                    const duration = calculateTradeDuration(op.entryTime, op.exitTime);
                    if (operationsFilters.duration === 'scalping' && duration >= 5) return false;
                    if (operationsFilters.duration === 'intraday' && (duration < 5 || duration > 60)) return false;
                    if (operationsFilters.duration === 'swing' && duration <= 60) return false;
                }
                
                // Filtro por sesión de trading
                if (operationsFilters.session !== 'all' && op.entryTime) {
                    const hour = parseInt(op.entryTime.split(':')[0]);
                    if (operationsFilters.session === 'asian' && (hour < 0 || hour >= 8)) return false;
                    if (operationsFilters.session === 'london' && (hour < 8 || hour >= 16)) return false;
                    if (operationsFilters.session === 'newyork' && (hour < 13 || hour >= 22)) return false;
                }
                
                return true;
            });
            
            console.log('🔍 applyOperationsFilters - Salida:', filtered.length, 'operaciones');
            return filtered;
        }

        // Wrapper functions para refresh con filtros
        function renderDailyJournal() {
            refreshDailyJournal();
        }

        function renderOperations() {
            updateOperationsMetrics();
            refreshOperationsTable();
        }

        // ===== OPERATIONS VIEW SWITCHING =====
        window.switchOperationsView = function(viewName) {
            // Ocultar todas las vistas
            document.querySelectorAll('.operations-view-content').forEach(view => {
                view.style.display = 'none';
            });
            
            // Remover clase active de todos los tabs
            document.querySelectorAll('.operations-view-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Mostrar vista seleccionada
            const selectedView = document.getElementById(`operations-view-${viewName}`);
            if (selectedView) {
                selectedView.style.display = 'block';
            }
            
            // Activar tab correspondiente
            const activeTab = document.querySelector(`.operations-view-tab[data-view="${viewName}"]`);
            if (activeTab) {
                activeTab.classList.add('active');
            }
            
            // Renderizar contenido según la vista
            if (viewName === 'heatmap') {
                window.renderHeatmap();
            } else if (viewName === 'instrument') {
                window.renderInstrumentView();
            } else if (viewName === 'setup') {
                window.renderSetupView();
            }
        }
        
        // ===== HELPER FUNCTION: SAFE DATE PARSING =====
        window.parseOperationDateTime = function(op, useExitTime = true) {
            const dateStr = op.date;
            const timeStr = useExitTime ? (op.exitTime || '12:00:00') : (op.entryTime || '00:00:00');
            
            // Si la fecha ya incluye timestamp (formato ISO)
            if (dateStr && dateStr.includes('T')) {
                return new Date(dateStr);
            }
            
            // Formato simple, agregar tiempo
            if (dateStr) {
                return new Date(dateStr + 'T' + timeStr);
            }
            
            // Fallback
            return new Date();
        };

        // ===== HEATMAP VIEW =====
        window.renderHeatmap = function() {
            // Obtener operaciones con el mismo patrón que refreshOperationsTable
            const accountFilter = document.getElementById('filter-account')?.value || 'all';
            const instrumentFilter = document.getElementById('filter-instrument')?.value.toLowerCase().trim() || '';
            
            let operations = window.applyDateFilterToData(DB.operations);
            
            // Aplicar filtros básicos
            operations = operations.filter(op =>
                (accountFilter === 'all' || op.accountId === accountFilter) &&
                (!instrumentFilter || op.instrument.toLowerCase().includes(instrumentFilter))
            );
            
            // Aplicar filtros del sidebar
            operations = window.applyOperationsFilters(operations);
            
            const metric = document.getElementById('heatmap-metric')?.value || 'pl';
            const period = parseInt(document.getElementById('heatmap-period')?.value) || 0;
            
            // Filtrar por período si es necesario
            let filteredOps = operations;
            if (period > 0) {
                const cutoffDate = new Date();
                cutoffDate.setDate(cutoffDate.getDate() - period);
                filteredOps = operations.filter(op => new Date(op.date) >= cutoffDate);
            }
            
            // Crear matriz 24x7 (horas x días)
            const heatmapData = {};
            const zones = []; // Para tracking de todas las celdas con datos
            
            for (let hour = 0; hour < 24; hour++) {
                heatmapData[hour] = {};
                for (let day = 0; day < 7; day++) {
                    heatmapData[hour][day] = { pl: 0, wins: 0, losses: 0, trades: 0, dates: [], operations: [] };
                }
            }
            
            // Agregar datos
            filteredOps.forEach(op => {
                const exitDateTime = window.parseOperationDateTime(op, true);
                const hour = exitDateTime.getHours();
                const day = exitDateTime.getDay();
                
                // Validar que la fecha sea válida
                if (isNaN(hour) || isNaN(day)) {
                    console.warn('⚠️ Fecha inválida en operación:', op.id, 'fecha:', op.date);
                    return; // Saltar esta operación
                }
                
                heatmapData[hour][day].trades++;
                heatmapData[hour][day].pl += parseFloat(op.pl) || 0;
                heatmapData[hour][day].operations.push(op);
                if (!heatmapData[hour][day].dates.includes(op.date)) {
                    heatmapData[hour][day].dates.push(op.date);
                }
                if (parseFloat(op.pl) > 0) {
                    heatmapData[hour][day].wins++;
                } else {
                    heatmapData[hour][day].losses++;
                }
            });
            
            // Calcular estadísticas de zonas y métricas
            const plValues = [];
            const winrates = [];
            let totalPL = 0;
            
            for (let hour = 0; hour < 24; hour++) {
                for (let day = 0; day < 7; day++) {
                    const cellData = heatmapData[hour][day];
                    if (cellData.trades > 0) {
                        const dayNames = ['Dom', 'Lun', 'Mar', 'Mié', 'Jue', 'Vie', 'Sáb'];
                        const label = `${dayNames[day]} ${hour.toString().padStart(2, '0')}:00`;
                        const winrate = (cellData.wins / cellData.trades) * 100;
                        
                        zones.push({
                            label,
                            hour,
                            day,
                            pl: cellData.pl,
                            trades: cellData.trades,
                            winrate
                        });
                        
                        plValues.push(cellData.pl);
                        winrates.push(winrate);
                        totalPL += cellData.pl;
                    }
                }
            }
            
            // Ordenar zonas por PL
            zones.sort((a, b) => b.pl - a.pl);
            
            // Calcular consistency score (0-100)
            const consistencyScore = zones.length > 0 ? 
                Math.min(100, Math.max(0, 100 - (window.calculateStandardDeviation(plValues) / Math.abs(totalPL / zones.length)) * 20)) : 0;
            
            // Calcular concentración (% de ganancias en top 20%)
            const top20Count = Math.ceil(zones.length * 0.2);
            const top20PL = zones.slice(0, top20Count).reduce((sum, z) => sum + (z.pl > 0 ? z.pl : 0), 0);
            const totalPositivePL = zones.reduce((sum, z) => sum + (z.pl > 0 ? z.pl : 0), 0);
            const concentration = totalPositivePL > 0 ? ((top20PL / totalPositivePL) * 100).toFixed(0) : 0;
            
            // Actualizar panel de métricas clave
            document.getElementById('hm-consistency').textContent = consistencyScore.toFixed(0);
            document.getElementById('hm-consistency-trend').innerHTML = 
                consistencyScore >= 70 ? '<span class="comparison-indicator up arrow-up">Excelente</span>' :
                consistencyScore >= 50 ? '<span class="comparison-indicator neutral arrow-neutral">Aceptable</span>' :
                '<span class="comparison-indicator down arrow-down">Mejorar</span>';
            
            if (zones.length > 0) {
                document.getElementById('hm-best-zone').textContent = zones[0].label;
                document.getElementById('hm-best-zone-pl').innerHTML = 
                    `<span style="color: var(--green)">$${zones[0].pl.toFixed(2)}</span>`;
                
                document.getElementById('hm-worst-zone').textContent = zones[zones.length - 1].label;
                document.getElementById('hm-worst-zone-pl').innerHTML = 
                    `<span style="color: var(--red)">$${zones[zones.length - 1].pl.toFixed(2)}</span>`;
            } else {
                document.getElementById('hm-best-zone').textContent = '--';
                document.getElementById('hm-best-zone-pl').textContent = '--';
                document.getElementById('hm-worst-zone').textContent = '--';
                document.getElementById('hm-worst-zone-pl').textContent = '--';
            }
            
            document.getElementById('hm-concentration').textContent = concentration + '%';
            
            // Generar Insight Cards
            const insightsContainer = document.getElementById('heatmap-insights');
            let insightsHTML = '';
            
            if (zones.length >= 3) {
                // Insight 1: Mejor oportunidad
                const bestZone = zones[0];
                if (bestZone.pl > 0 && bestZone.trades >= 3) {
                    insightsHTML += `
                        <div class="insight-card success">
                            <div class="insight-title">Tu Mejor Ventana de Trading</div>
                            <div class="insight-content">
                                Operar en <strong>${bestZone.label}</strong> ha generado <strong>$${bestZone.pl.toFixed(2)}</strong> 
                                con ${bestZone.trades} operaciones (${bestZone.winrate.toFixed(0)}% win rate). 
                                ${bestZone.trades < 10 ? 'Incrementa tu frecuencia en esta zona.' : 'Mantén tu enfoque aquí.'}
                            </div>
                        </div>
                    `;
                }
                
                // Insight 2: Zona problemática
                const worstZone = zones[zones.length - 1];
                if (worstZone.pl < -100 && worstZone.trades >= 3) {
                    insightsHTML += `
                        <div class="insight-card danger">
                            <div class="insight-title">Zona de Alto Riesgo</div>
                            <div class="insight-content">
                                Evita operar en <strong>${worstZone.label}</strong>. Has perdido <strong>$${Math.abs(worstZone.pl).toFixed(2)}</strong> 
                                en ${worstZone.trades} intentos (${worstZone.winrate.toFixed(0)}% win rate). 
                                Considera eliminar esta ventana de tu estrategia.
                            </div>
                        </div>
                    `;
                }
                
                // Insight 3: Concentración
                if (concentration > 70) {
                    insightsHTML += `
                        <div class="insight-card warning">
                            <div class="insight-title">Alta Concentración Detectada</div>
                            <div class="insight-content">
                                El ${concentration}% de tus ganancias proviene de solo el 20% de tus ventanas de trading. 
                                Optimiza tu tiempo enfocándote en las zonas más rentables y reduciendo exposición en las demás.
                            </div>
                        </div>
                    `;
                }
            }
            
            insightsContainer.innerHTML = insightsHTML;
            
            // Calcular min/max para escala de colores
            let minValue = 0, maxValue = 0;
            for (let hour = 0; hour < 24; hour++) {
                for (let day = 0; day < 7; day++) {
                    const cellData = heatmapData[hour][day];
                    let value = 0;
                    if (metric === 'pl') value = cellData.pl;
                    else if (metric === 'winrate') value = cellData.trades > 0 ? (cellData.wins / cellData.trades) * 100 : 0;
                    else if (metric === 'trades') value = cellData.trades;
                    
                    minValue = Math.min(minValue, value);
                    maxValue = Math.max(maxValue, value);
                }
            }
            
            // Renderizar tabla
            const tbody = document.getElementById('heatmap-tbody');
            if (!tbody) return;
            
            let html = '';
            
            for (let hour = 0; hour < 24; hour++) {
                html += `<tr>`;
                html += `<td style="font-weight: 600; background: var(--surface);">${hour.toString().padStart(2, '0')}:00</td>`;
                
                for (let day = 0; day < 7; day++) {
                    const cellData = heatmapData[hour][day];
                    let value = 0;
                    let displayValue = '';
                    
                    if (metric === 'pl') {
                        value = cellData.pl;
                        displayValue = '$' + value.toFixed(0);
                    } else if (metric === 'winrate') {
                        value = cellData.trades > 0 ? (cellData.wins / cellData.trades) * 100 : 0;
                        displayValue = value.toFixed(0) + '%';
                    } else if (metric === 'trades') {
                        value = cellData.trades;
                        displayValue = value.toString();
                    }
                    
                    // Calcular color
                    const color = window.getHeatmapColor(value, minValue, maxValue, metric);
                    
                    // Preparar datos para onclick
                    const dayNames = ['Domingo', 'Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sábado'];
                    const cellTitle = cellData.trades > 0 ? `${cellData.trades} operaciones en ${dayNames[day]} ${hour}:00-${hour+1}:00. Click para ver detalles.` : 'Sin operaciones';
                    const clickable = cellData.trades > 0 ? `onclick="navigateToHeatmapDay(${hour}, ${day})" style="cursor: pointer;"` : '';
                    
                    html += `<td style="background: ${color};" title="${cellTitle}" ${clickable}>`;
                    if (cellData.trades > 0) {
                        html += `<div class="heatmap-cell-data">`;
                        html += `<span class="heatmap-value">${displayValue}</span>`;
                        html += `<span class="heatmap-count">${cellData.trades} ops</span>`;
                        html += `</div>`;
                    } else {
                        html += `<span style="opacity: 0.3;">-</span>`;
                    }
                    html += `</td>`;
                }
                
                html += `</tr>`;
            }
            
            tbody.innerHTML = html;
            
            // Actualizar top 3 y weak 3 zonas
            for (let i = 0; i < 3; i++) {
                if (zones[i]) {
                    document.getElementById(`hm-top${i+1}`).textContent = zones[i].label.split(' ')[0];
                    document.getElementById(`hm-top${i+1}-val`).textContent = `$${zones[i].pl.toFixed(0)} (${zones[i].trades}T)`;
                } else {
                    document.getElementById(`hm-top${i+1}`).textContent = '--';
                    document.getElementById(`hm-top${i+1}-val`).textContent = '--';
                }
                
                const weakIndex = zones.length - 1 - i;
                if (weakIndex >= 0 && zones[weakIndex]) {
                    document.getElementById(`hm-weak${i+1}`).textContent = zones[weakIndex].label.split(' ')[0];
                    document.getElementById(`hm-weak${i+1}-val`).textContent = `$${zones[weakIndex].pl.toFixed(0)} (${zones[weakIndex].trades}T)`;
                } else {
                    document.getElementById(`hm-weak${i+1}`).textContent = '--';
                    document.getElementById(`hm-weak${i+1}-val`).textContent = '--';
                }
            }
            
            // Guardar datos globalmente para uso posterior
            window.heatmapData = heatmapData;
        }

        window.calculateStandardDeviation = function(values) {
            if (values.length === 0) return 0;
            const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
            const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
            return Math.sqrt(variance);
        }

        window.getHeatmapColor = function(value, min, max, metric) {
            if (value === 0 || min === max) return 'var(--surface)';
            
            // Normalizar valor entre -1 y 1
            let normalized;
            if (metric === 'trades') {
                // Para trades, solo escala positiva
                normalized = (value - min) / (max - min);
                const intensity = Math.floor(normalized * 4);
                const greenShades = ['#0a0a0a', '#052e16', '#14532d', '#166534', '#15803d'];
                return greenShades[intensity];
            } else {
                // Para P&L y winrate, escala de negativo a positivo
                if (value < 0) {
                    normalized = value / Math.abs(min);
                    const intensity = Math.floor(normalized * 2);
                    const redShades = ['#7f1d1d', '#450a0a'];
                    return redShades[Math.abs(intensity)];
                } else {
                    normalized = value / max;
                    const intensity = Math.floor(normalized * 4);
                    const greenShades = ['#0a0a0a', '#052e16', '#14532d', '#166534', '#15803d'];
                    return greenShades[intensity];
                }
            }
        }

        // ===== INSTRUMENT VIEW =====
        window.renderInstrumentView = function() {
            // Obtener operaciones con el mismo patrón
            const accountFilter = document.getElementById('filter-account')?.value || 'all';
            const instrumentFilter = document.getElementById('filter-instrument')?.value.toLowerCase().trim() || '';
            
            let operations = window.applyDateFilterToData(DB.operations);
            
            // Aplicar filtros básicos
            operations = operations.filter(op =>
                (accountFilter === 'all' || op.accountId === accountFilter) &&
                (!instrumentFilter || op.instrument.toLowerCase().includes(instrumentFilter))
            );
            
            // Aplicar filtros del sidebar
            operations = window.applyOperationsFilters(operations);
            
            const sortBy = document.getElementById('instrument-sort')?.value || 'pl';
            const searchTerm = document.getElementById('instrument-search')?.value.toLowerCase() || '';
            
            // Agrupar por instrumento
            const instruments = {};
            let totalRMultiple = 0;
            let rMultipleCount = 0;
            let globalExpectancy = 0;
            
            operations.forEach(op => {
                const symbol = op.instrument || 'N/A';
                if (!instruments[symbol]) {
                    instruments[symbol] = {
                        symbol: symbol,
                        operations: [],
                        pl: 0,
                        wins: 0,
                        losses: 0,
                        totalVolume: 0,
                        grossProfit: 0,
                        grossLoss: 0,
                        plValues: []
                    };
                }
                
                instruments[symbol].operations.push(op);
                const plValue = parseFloat(op.pl) || 0;
                instruments[symbol].pl += plValue;
                instruments[symbol].plValues.push(plValue);
                instruments[symbol].totalVolume += parseFloat(op.volume) || 0;
                
                if (plValue > 0) {
                    instruments[symbol].wins++;
                    instruments[symbol].grossProfit += plValue;
                } else if (plValue < 0) {
                    instruments[symbol].losses++;
                    instruments[symbol].grossLoss += Math.abs(plValue);
                }
            });
            
            // Calcular métricas por instrumento
            Object.values(instruments).forEach(inst => {
                // R-Multiple promedio (aproximado como PL promedio / PL promedio de pérdidas)
                const avgLoss = inst.losses > 0 ? inst.grossLoss / inst.losses : 1;
                const avgWin = inst.wins > 0 ? inst.grossProfit / inst.wins : 0;
                inst.rMultiple = avgLoss > 0 ? avgWin / avgLoss : 0;
                totalRMultiple += inst.rMultiple;
                rMultipleCount++;
                
                // Expectancy
                const winRate = inst.operations.length > 0 ? inst.wins / inst.operations.length : 0;
                inst.expectancy = (avgWin * winRate) - (avgLoss * (1 - winRate));
                globalExpectancy += inst.expectancy * inst.operations.length;
                
                // Consistency Score (0-100)
                const stdDev = calculateStandardDeviation(inst.plValues);
                const avgPL = inst.operations.length > 0 ? inst.pl / inst.operations.length : 0;
                inst.consistency = avgPL !== 0 ? Math.min(100, Math.max(0, 100 - (stdDev / Math.abs(avgPL)) * 15)) : 0;
                
                // Mejor momento del día (hora con más beneficio)
                const hourlyPL = {};
                inst.operations.forEach(op => {
                    const exitDateTime = window.parseOperationDateTime(op, true);
                    const hour = exitDateTime.getHours();
                    if (isNaN(hour)) return; // Saltar si la fecha es inválida
                    if (!hourlyPL[hour]) hourlyPL[hour] = 0;
                    hourlyPL[hour] += parseFloat(op.pl);
                });
                let bestHour = 0;
                let bestHourPL = -Infinity;
                Object.entries(hourlyPL).forEach(([hour, pl]) => {
                    if (pl > bestHourPL) {
                        bestHourPL = pl;
                        bestHour = hour;
                    }
                });
                inst.bestHour = `${bestHour.toString().padStart(2, '0')}:00`;
                inst.bestHourPL = bestHourPL;
            });
            
            // Calcular promedios globales
            const averageRMultiple = rMultipleCount > 0 ? totalRMultiple / rMultipleCount : 0;
            const avgExpectancy = operations.length > 0 ? globalExpectancy / operations.length : 0;
            const avgConsistency = Object.values(instruments).reduce((sum, inst) => sum + inst.consistency, 0) / Object.keys(instruments).length || 0;
            
            // Contar instrumentos que superan promedios
            const aboveAverageCount = Object.values(instruments).filter(inst => 
                inst.pl > 0 && inst.expectancy > avgExpectancy
            ).length;
            
            // Actualizar panel de métricas clave
            document.getElementById('inst-rmultiple').textContent = averageRMultiple.toFixed(2) + 'R';
            document.getElementById('inst-rmultiple-trend').innerHTML = 
                averageRMultiple >= 2 ? '<span class="comparison-indicator up arrow-up">Excelente</span>' :
                averageRMultiple >= 1 ? '<span class="comparison-indicator neutral arrow-neutral">Aceptable</span>' :
                '<span class="comparison-indicator down arrow-down">Bajo</span>';
                
            document.getElementById('inst-expectancy').textContent = '$' + avgExpectancy.toFixed(2);
            document.getElementById('inst-best-count').textContent = aboveAverageCount;
            document.getElementById('inst-consistency').textContent = avgConsistency.toFixed(0);
            document.getElementById('inst-consistency-trend').innerHTML = 
                avgConsistency >= 70 ? '<span class="comparison-indicator up arrow-up">Alta</span>' :
                avgConsistency >= 50 ? '<span class="comparison-indicator neutral arrow-neutral">Media</span>' :
                '<span class="comparison-indicator down arrow-down">Baja</span>';
            
            // Generar Insight Cards
            const insightsContainer = document.getElementById('instrument-insights');
            let insightsHTML = '';
            
            const instrumentsArray = Object.values(instruments);
            instrumentsArray.sort((a, b) => b.expectancy - a.expectancy);
            
            if (instrumentsArray.length >= 2) {
                // Insight 1: Mejor instrumento
                const bestInst = instrumentsArray[0];
                if (bestInst.expectancy > 50 && bestInst.operations.length >= 3) {
                    insightsHTML += `
                        <div class="insight-card success">
                            <div class="insight-title">Instrumento Estrella</div>
                            <div class="insight-content">
                                <strong>${bestInst.symbol}</strong> tiene una expectativa de <strong>$${bestInst.expectancy.toFixed(2)}</strong> por trade 
                                con ${bestInst.operations.length} operaciones. Mejor hora: ${bestInst.bestHour}. 
                                ${bestInst.operations.length < 10 ? 'Aumenta volumen en este activo.' : 'Mantén tu exposición.'}
                            </div>
                        </div>
                    `;
                }
                
                // Insight 2: Instrumento problemático
                const worstInst = instrumentsArray[instrumentsArray.length - 1];
                if (worstInst.expectancy < -30 && worstInst.operations.length >= 3) {
                    insightsHTML += `
                        <div class="insight-card danger">
                            <div class="insight-title">Instrumento de Alto Riesgo</div>
                            <div class="insight-content">
                                <strong>${worstInst.symbol}</strong> tiene expectativa negativa de <strong>$${worstInst.expectancy.toFixed(2)}</strong> por trade. 
                                Has perdido $${Math.abs(worstInst.pl).toFixed(2)} en ${worstInst.operations.length} intentos. 
                                Considera eliminar este activo de tu watchlist.
                            </div>
                        </div>
                    `;
                }
                
                // Insight 3: Diversificación
                if (instrumentsArray.length >= 5) {
                    const topThreePL = instrumentsArray.slice(0, 3).reduce((sum, inst) => sum + inst.pl, 0);
                    const totalPL = instrumentsArray.reduce((sum, inst) => sum + inst.pl, 0);
                    const concentration = totalPL > 0 ? (topThreePL / totalPL * 100).toFixed(0) : 0;
                    
                    if (concentration > 75) {
                        insightsHTML += `
                            <div class="insight-card warning">
                                <div class="insight-title">Concentración Detectada</div>
                                <div class="insight-content">
                                    El ${concentration}% de tus ganancias proviene de solo 3 instrumentos. 
                                    Considera diversificar para reducir dependencia y riesgo.
                                </div>
                            </div>
                        `;
                    }
                }
            }
            
            insightsContainer.innerHTML = insightsHTML;
            
            // Convertir a array y filtrar por búsqueda
            let filteredInstruments = Object.values(instruments);
            if (searchTerm) {
                filteredInstruments = filteredInstruments.filter(inst => 
                    inst.symbol.toLowerCase().includes(searchTerm)
                );
            }
            
            // Ordenar
            filteredInstruments.sort((a, b) => {
                if (sortBy === 'pl') return b.pl - a.pl;
                if (sortBy === 'trades') return b.operations.length - a.operations.length;
                if (sortBy === 'winrate') {
                    const wrA = a.operations.length > 0 ? a.wins / a.operations.length : 0;
                    const wrB = b.operations.length > 0 ? b.wins / b.operations.length : 0;
                    return wrB - wrA;
                }
                if (sortBy === 'expectancy') return b.expectancy - a.expectancy;
                if (sortBy === 'consistency') return b.consistency - a.consistency;
                if (sortBy === 'name') return a.symbol.localeCompare(b.symbol);
                return 0;
            });
            
            // Renderizar
            const container = document.getElementById('instruments-container');
            if (!container) return;
            
            let html = '';
            filteredInstruments.forEach(inst => {
                const winRate = inst.operations.length > 0 ? (inst.wins / inst.operations.length * 100).toFixed(1) : '0.0';
                const avgPL = inst.operations.length > 0 ? (inst.pl / inst.operations.length).toFixed(2) : '0.00';
                const profitFactor = inst.grossLoss > 0 ? (inst.grossProfit / inst.grossLoss).toFixed(2) : 'N/A';
                
                // Determinar badge
                let badge = '';
                if (inst.expectancy > avgExpectancy && inst.pl > 0) {
                    badge = '<span class="badge badge-success">Supera Promedio</span>';
                } else if (inst.expectancy < 0) {
                    badge = '<span class="badge badge-danger">Bajo Expectancy</span>';
                } else {
                    badge = '<span class="badge badge-neutral">Promedio</span>';
                }
                
                html += `<div class="group-item" data-instrument="${inst.symbol}">`;
                html += `  <div class="group-header" onclick="toggleGroupItem(this)">`;
                html += `    <div class="group-header-left">`;
                html += `      <div class="group-info">`;
                html += `        <h4>${inst.symbol} ${badge}</h4>`;
                html += `        <span class="group-subtitle">${inst.operations.length} operaciones • Mejor hora: ${inst.bestHour}</span>`;
                html += `      </div>`;
                html += `    </div>`;
                html += `    <div class="group-stats">`;
                html += `      <div class="group-stat">`;
                html += `        <span class="group-stat-label">P&L</span>`;
                html += `        <span class="group-stat-value" style="color: ${inst.pl >= 0 ? 'var(--green)' : 'var(--red)'}">$${inst.pl.toFixed(2)}</span>`;
                html += `      </div>`;
                html += `      <div class="group-stat">`;
                html += `        <span class="group-stat-label">Expectancy</span>`;
                html += `        <span class="group-stat-value" style="color: ${inst.expectancy >= 0 ? 'var(--green)' : 'var(--red)'}">$${inst.expectancy.toFixed(2)}</span>`;
                html += `      </div>`;
                html += `      <div class="group-stat">`;
                html += `        <span class="group-stat-label">Consistency</span>`;
                html += `        <span class="group-stat-value">${inst.consistency.toFixed(0)}</span>`;
                html += `      </div>`;
                html += `      <span class="group-expand-icon">▼</span>`;
                html += `    </div>`;
                html += `  </div>`;
                html += `  <div class="group-content">`;
                html += `    <div class="group-details">`;
                
                // Métricas mejoradas con progress bars
                html += `      <div class="group-metrics">`;
                html += `        <div class="group-metric-card">`;
                html += `          <div class="group-metric-label">Win Rate</div>`;
                html += `          <div class="group-metric-value">${winRate}%</div>`;
                html += `          <div class="progress-bar-container">`;
                html += `            <div class="progress-bar-fill ${parseFloat(winRate) >= 50 ? 'progress-bar-success' : 'progress-bar-danger'}" style="width: ${winRate}%"></div>`;
                html += `          </div>`;
                html += `        </div>`;
                html += `        <div class="group-metric-card">`;
                html += `          <div class="group-metric-label">R-Multiple</div>`;
                html += `          <div class="group-metric-value" style="color: ${inst.rMultiple >= 1 ? 'var(--green)' : 'var(--red)' }">${inst.rMultiple.toFixed(2)}R</div>`;
                html += `        </div>`;
                html += `        <div class="group-metric-card">`;
                html += `          <div class="group-metric-label">P&L Promedio</div>`;
                html += `          <div class="group-metric-value" style="color: ${parseFloat(avgPL) >= 0 ? 'var(--green)' : 'var(--red)'}">$${avgPL}</div>`;
                html += `        </div>`;
                html += `        <div class="group-metric-card">`;
                html += `          <div class="group-metric-label">Profit Factor</div>`;
                html += `          <div class="group-metric-value">${profitFactor}</div>`;
                html += `        </div>`;
                html += `        <div class="group-metric-card">`;
                html += `          <div class="group-metric-label">Mejor Hora</div>`;
                html += `          <div class="group-metric-value" style="font-size: 1.25rem">${inst.bestHour}</div>`;
                html += `          <div class="stat-subvalue">$${inst.bestHourPL.toFixed(0)}</div>`;
                html += `        </div>`;
                html += `        <div class="group-metric-card">`;
                html += `          <div class="group-metric-label">Volumen Total</div>`;
                html += `          <div class="group-metric-value">${inst.totalVolume.toFixed(2)}</div>`;
                html += `        </div>`;
                html += `      </div>`;
                
                // Lista de operaciones
                html += `      <div class="group-trades-list">`;
                html += `        <div class="group-trades-header">Últimas operaciones</div>`;
                inst.operations.slice(0, 10).forEach(op => {
                    html += `        <div class="mini-trade-row" style="cursor: pointer;" onclick="showOperationDetailPage('${op.id}')" title="Click para ver detalles">`;
                    html += `          <span>${op.date || 'N/A'}</span>`;
                    html += `          <span>${op.type || 'N/A'}</span>`;
                    html += `          <span>${op.setupId || 'Sin setup'}</span>`;
                    html += `          <span style="color: ${parseFloat(op.pl) >= 0 ? 'var(--green)' : 'var(--red)'}">$${parseFloat(op.pl).toFixed(2)}</span>`;
                    html += `          <span>${op.volume || 'N/A'}</span>`;
                    html += `        </div>`;
                });
                if (inst.operations.length > 10) {
                    html += `        <div style="text-align: center; padding: 0.5rem; color: var(--text-secondary); font-size: 0.875rem;">`;
                    html += `          +${inst.operations.length - 10} operaciones más`;
                    html += `        </div>`;
                }
                html += `      </div>`;
                
                html += `    </div>`;
                html += `  </div>`;
                html += `</div>`;
            });
            
            if (filteredInstruments.length === 0) {
                html = `<div class="text-center py-8 text-text-secondary">No se encontraron instrumentos</div>`;
            }
            
            container.innerHTML = html;
        }

        // ===== SETUP VIEW =====
        window.renderSetupView = function() {
            // Obtener operaciones con el mismo patrón
            const accountFilter = document.getElementById('filter-account')?.value || 'all';
            const instrumentFilter = document.getElementById('filter-instrument')?.value.toLowerCase().trim() || '';
            
            let operations = window.applyDateFilterToData(DB.operations);
            
            // Aplicar filtros básicos
            operations = operations.filter(op =>
                (accountFilter === 'all' || op.accountId === accountFilter) &&
                (!instrumentFilter || op.instrument.toLowerCase().includes(instrumentFilter))
            );
            
            // Aplicar filtros del sidebar
            operations = window.applyOperationsFilters(operations);
            
            const sortBy = document.getElementById('setup-sort')?.value || 'pl';
            
            // Agrupar por setup
            const setups = {};
            let totalPL = 0;
            let totalEdgeScore = 0;
            
            operations.forEach(op => {
                const setupName = op.setupId || op.setupUsed || 'Sin setup';
                if (!setups[setupName]) {
                    setups[setupName] = {
                        name: setupName,
                        operations: [],
                        pl: 0,
                        wins: 0,
                        losses: 0,
                        grossProfit: 0,
                        grossLoss: 0,
                        plValues: [],
                        durations: []
                    };
                }
                
                setups[setupName].operations.push(op);
                const plValue = parseFloat(op.pl) || 0;
                setups[setupName].pl += plValue;
                setups[setupName].plValues.push(plValue);
                totalPL += plValue;
                
                // Calcular duración si hay datos de tiempo
                if (op.entryTime && op.exitTime) {
                    try {
                        const entry = window.parseOperationDateTime(op, false); // usar entryTime
                        const exit = window.parseOperationDateTime(op, true);   // usar exitTime
                        const durationMin = (exit - entry) / (1000 * 60); // minutos
                        setups[setupName].durations.push(durationMin);
                    } catch (e) {}
                }
                
                if (plValue > 0) {
                    setups[setupName].wins++;
                    setups[setupName].grossProfit += plValue;
                } else if (plValue < 0) {
                    setups[setupName].losses++;
                    setups[setupName].grossLoss += Math.abs(plValue);
                }
            });
            
            // Calcular métricas por setup
            Object.values(setups).forEach(setup => {
                // Win Rate
                const winRate = setup.operations.length > 0 ? (setup.wins / setup.operations.length) * 100 : 0;
                
                // Profit Factor
                const profitFactor = setup.grossLoss > 0 ? setup.grossProfit / setup.grossLoss : 0;
                
                // Consistency Score (usando desviación estándar)
                const stdDev = calculateStandardDeviation(setup.plValues);
                const avgPL = setup.operations.length > 0 ? setup.pl / setup.operations.length : 0;
                const consistency = avgPL !== 0 ? Math.min(100, Math.max(0, 100 - (stdDev / Math.abs(avgPL)) * 15)) : 0;
                
                // Edge Score (0-100): WinRate * 0.4 + (ProfitFactor/3) * 30 + Consistency * 0.3
                const pfNormalized = Math.min(100, (profitFactor / 3) * 100); // Normalizar PF a 0-100
                setup.edgeScore = Math.min(100, Math.max(0, 
                    (winRate * 0.4) + (pfNormalized * 0.3) + (consistency * 0.3)
                ));
                totalEdgeScore += setup.edgeScore;
                
                // Expectancy
                const avgWin = setup.wins > 0 ? setup.grossProfit / setup.wins : 0;
                const avgLoss = setup.losses > 0 ? setup.grossLoss / setup.losses : 0;
                setup.expectancy = (avgWin * (winRate / 100)) - (avgLoss * (1 - winRate / 100));
                
                // Duración promedio en minutos
                setup.avgDuration = setup.durations.length > 0 ?
                    setup.durations.reduce((sum, d) => sum + d, 0) / setup.durations.length : 0;
                
                // Mejor sesión (AM/PM)
                let amPL = 0, pmPL = 0, amCount = 0, pmCount = 0;
                setup.operations.forEach(op => {
                    const exitDateTime = window.parseOperationDateTime(op, true);
                    const hour = exitDateTime.getHours();
                    if (isNaN(hour)) return; // Saltar si la fecha es inválida
                    const plVal = parseFloat(op.pl) || 0;
                    if (hour < 12) {
                        amPL += plVal;
                        amCount++;
                    } else {
                        pmPL += plVal;
                        pmCount++;
                    }
                });
                setup.bestSession = amPL > pmPL ? 'AM' : 'PM';
                setup.bestSessionPL = Math.max(amPL, pmPL);
                
                // Mejor hora
                const hourlyPL = {};
                setup.operations.forEach(op => {
                    const exitDateTime = window.parseOperationDateTime(op, true);
                    const hour = exitDateTime.getHours();
                    if (isNaN(hour)) return; // Saltar si la fecha es inválida
                    if (!hourlyPL[hour]) hourlyPL[hour] = 0;
                    hourlyPL[hour] += parseFloat(op.pl) || 0;
                });
                let bestHour = 0;
                let bestHourPL = -Infinity;
                Object.entries(hourlyPL).forEach(([hour, pl]) => {
                    if (pl > bestHourPL) {
                        bestHourPL = pl;
                        bestHour = hour;
                    }
                });
                setup.bestHour = `${bestHour.toString().padStart(2, '0')}:00`;
                setup.bestHourPL = bestHourPL;
                
                // Máximo drawdown
                let peak = 0;
                let maxDD = 0;
                let running = 0;
                setup.operations.forEach(op => {
                    running += parseFloat(op.pl) || 0;
                    if (running > peak) peak = running;
                    const currentDD = peak - running;
                    if (currentDD > maxDD) maxDD = currentDD;
                });
                setup.maxDrawdown = maxDD;
                
                // What-If Analysis: Si solo tradearas este setup, cuánto tendrías
                setup.whatIfPL = setup.pl;
                setup.whatIfTotal = operations.length > 0 ? 
                    (setup.operations.length / operations.length * 100).toFixed(1) : '0';
            });
            
            // Calcular promedios globales
            const avgEdgeScore = Object.keys(setups).length > 0 ? 
                totalEdgeScore / Object.keys(setups).length : 0;
            
            // Encontrar mejor setup
            const setupsArray = Object.values(setups);
            setupsArray.sort((a, b) => b.edgeScore - a.edgeScore);
            const bestSetup = setupsArray[0];
            
            // Calcular oportunidad perdida (si solo tradearas el mejor)
            const opportunityLost = totalPL - (bestSetup ? bestSetup.pl : 0);
            
            //Actualizar panel de métricas clave
            document.getElementById('setup-edge-avg').textContent = avgEdgeScore.toFixed(0);
            document.getElementById('setup-edge-trend').innerHTML = 
                avgEdgeScore >= 70 ? '<span class="comparison-indicator up arrow-up">Superior</span>' :
                avgEdgeScore >= 50 ? '<span class="comparison-indicator neutral arrow-neutral">Aceptable</span>' :
                '<span class="comparison-indicator down arrow-down">Débil</span>';
                
            const avgExpectancy = setupsArray.reduce((sum, s) => sum + s.expectancy, 0) / setupsArray.length || 0;
            document.getElementById('setup-expectancy-avg').textContent = '$' + avgExpectancy.toFixed(2);
            
            document.getElementById('setup-best-name').textContent = bestSetup ? bestSetup.name : 'N/A';
            document.getElementById('setup-best-score').textContent = bestSetup ? bestSetup.edgeScore.toFixed(0) : '0';
            
            document.getElementById('setup-opportunity').textContent = '$' + Math.abs(opportunityLost).toFixed(2);
            document.getElementById('setup-opportunity-trend').innerHTML = 
                opportunityLost < 0 ? '<span class="comparison-indicator down arrow-down">Pérdida evitada</span>' :
                opportunityLost > 1000 ? '<span class="comparison-indicator up arrow-up">Alto costo</span>' :
                '<span class="comparison-indicator neutral arrow-neutral">Bajo impacto</span>';
            
            // Generar Insight Cards
            const insightsContainer = document.getElementById('setup-insights');
            let insightsHTML = '';
            
            if (setupsArray.length >= 2) {
                // Insight 1: Mejor Setup (Edge Score alto)
                if (bestSetup && bestSetup.edgeScore >= 65 && bestSetup.operations.length >= 5) {
                    insightsHTML += `
                        <div class="insight-card success">
                            <div class="insight-title">Setup con Edge Comprobado</div>
                            <div class="insight-content">
                                <strong>${bestSetup.name}</strong> tiene un Edge Score de <strong>${bestSetup.edgeScore.toFixed(0)}</strong> 
                                con ${bestSetup.operations.length} operaciones (${bestSetup.whatIfTotal}% de tus trades). 
                                Mejor momento: ${bestSetup.bestSession} ${bestSetup.bestHour}. 
                                ${bestSetup.operations.length < 20 ? 'Aumenta volumen en este setup.' : 'Mantén consistencia.'}
                            </div>
                        </div>
                    `;
                }
                
                // Insight 2: Setup problemático (Edge Score bajo)
                const worstSetup = setupsArray[setupsArray.length - 1];
                if (worstSetup && worstSetup.edgeScore < 40 && worstSetup.operations.length >= 3) {
                    insightsHTML += `
                        <div class="insight-card danger">
                            <div class="insight-title">Setup Sin Edge Detectado</div>
                            <div class="insight-content">
                                <strong>${worstSetup.name}</strong> tiene Edge Score de solo <strong>${worstSetup.edgeScore.toFixed(0)}</strong>. 
                                Has perdido $${Math.abs(worstSetup.pl).toFixed(2)} en ${worstSetup.operations.length} intentos. 
                                Considera eliminar este setup de tu playbook o refinar las reglas de entrada.
                            </div>
                        </div>
                    `;
                }
                
                // Insight 3: What-If Analysis
                if (bestSetup && opportunityLost > 500) {
                    insightsHTML += `
                        <div class="insight-card warning">
                            <div class="insight-title">Análisis What-If</div>
                            <div class="insight-content">
                                Si solo hubieras operado <strong>${bestSetup.name}</strong>, habrías hecho 
                                <strong>$${bestSetup.whatIfPL.toFixed(2)}</strong> (vs. $${totalPL.toFixed(2)} actual). 
                                Oportunidad perdida: <strong>$${Math.abs(opportunityLost).toFixed(2)}</strong>. 
                                Considera concentrar esfuerzos en setups con edge probado.
                            </div>
                        </div>
                    `;
                }
            }
            
            insightsContainer.innerHTML = insightsHTML;
            
            // Ordenar según criterio seleccionado
            setupsArray.sort((a, b) => {
                if (sortBy === 'pl') return b.pl - a.pl;
                if (sortBy === 'trades') return b.operations.length - a.operations.length;
                if (sortBy === 'winrate') {
                    const wrA = a.operations.length > 0 ? a.wins / a.operations.length : 0;
                    const wrB = b.operations.length > 0 ? b.wins / b.operations.length : 0;
                    return wrB - wrA;
                }
                if (sortBy === 'profitfactor') {
                    const pfA = a.grossLoss > 0 ? a.grossProfit / a.grossLoss : 0;
                    const pfB = b.grossLoss > 0 ? b.grossProfit / b.grossLoss : 0;
                    return pfB - pfA;
                }
                if (sortBy === 'edgescore') return b.edgeScore - a.edgeScore;
                if (sortBy === 'expectancy') return b.expectancy - a.expectancy;
                return 0;
            });
            
            // Renderizar
            const container = document.getElementById('setups-container');
            if (!container) return;
            
            let html = '';
            setupsArray.forEach(setup => {
                const winRate = setup.operations.length > 0 ? (setup.wins / setup.operations.length * 100).toFixed(1) : '0.0';
                const avgPL = setup.operations.length > 0 ? (setup.pl / setup.operations.length).toFixed(2) : '0.00';
                const profitFactor = setup.grossLoss > 0 ? (setup.grossProfit / setup.grossLoss).toFixed(2) : 'N/A';
                
                // Determinar badge basado en Edge Score
                let badge = '';
                if (setup.edgeScore >= 70) {
                    badge = '<span class="badge badge-success">Edge Superior</span>';
                } else if (setup.edgeScore >= 50) {
                    badge = '<span class="badge badge-warning">Edge Aceptable</span>';
                } else {
                    badge = '<span class="badge badge-danger">Sin Edge</span>';
                }
                
                html += `<div class="group-item" data-setup="${setup.name}">`;
                html += `  <div class="group-header" onclick="toggleGroupItem(this)">`;
                html += `    <div class="group-header-left">`;
                html += `      <div class="group-info">`;
                html += `        <h4>${setup.name} ${badge}</h4>`;
                html += `        <span class="group-subtitle">${setup.operations.length} operaciones • ${setup.whatIfTotal}% de tu actividad</span>`;
                html += `      </div>`;
                html += `    </div>`;
                html += `    <div class="group-stats">`;
                html += `      <div class="group-stat">`;
                html += `        <span class="group-stat-label">Edge Score</span>`;
                html += `        <div class="score-circle score-${setup.edgeScore >= 70 ? 'success' : setup.edgeScore >= 50 ? 'warning' : 'danger'}" style="width: 50px; height: 50px; font-size: 0.875rem;">`;
                html += `          ${setup.edgeScore.toFixed(0)}`;
                html += `        </div>`;
                html += `      </div>`;
                html += `      <div class="group-stat">`;
                html += `        <span class="group-stat-label">P&L</span>`;
                html += `        <span class="group-stat-value" style="color: ${setup.pl >= 0 ? 'var(--green)' : 'var(--red)'}">$${setup.pl.toFixed(2)}</span>`;
                html += `      </div>`;
                html += `      <div class="group-stat">`;
                html += `        <span class="group-stat-label">Expectancy</span>`;
                html += `        <span class="group-stat-value" style="color: ${setup.expectancy >= 0 ? 'var(--green)' : 'var(--red)'}">$${setup.expectancy.toFixed(2)}</span>`;
                html += `      </div>`;
                html += `      <span class="group-expand-icon">▼</span>`;
                html += `    </div>`;
                html += `  </div>`;
                html += `  <div class="group-content">`;
                html += `    <div class="group-details">`;
                
                // Métricas mejoradas con progress bars
                html += `      <div class="group-metrics">`;
                html += `        <div class="group-metric-card">`;
                html += `          <div class="group-metric-label">Win Rate</div>`;
                html += `          <div class="group-metric-value">${winRate}%</div>`;
                html += `          <div class="progress-bar-container">`;
                html += `            <div class="progress-bar-fill ${parseFloat(winRate) >= 50 ? 'progress-bar-success' : 'progress-bar-danger'}" style="width: ${winRate}%"></div>`;
                html += `          </div>`;
                html += `        </div>`;
                html += `        <div class="group-metric-card">`;
                html += `          <div class="group-metric-label">Profit Factor</div>`;
                html += `          <div class="group-metric-value">${profitFactor}</div>`;
                html += `          <div class="progress-bar-container">`;
                const pfWidth = Math.min(100, (parseFloat(profitFactor) / 3) * 100);
                html += `            <div class="progress-bar-fill ${parseFloat(profitFactor) >= 1.5 ? 'progress-bar-success' : 'progress-bar-danger'}" style="width: ${pfWidth}%"></div>`;
                html += `          </div>`;
                html += `        </div>`;
                html += `        <div class="group-metric-card">`;
                html += `          <div class="group-metric-label">P&L Promedio</div>`;
                html += `          <div class="group-metric-value" style="color: ${parseFloat(avgPL) >= 0 ? 'var(--green)' : 'var(--red)'}">$${avgPL}</div>`;
                html += `        </div>`;
                html += `        <div class="group-metric-card">`;
                html += `          <div class="group-metric-label">Max Drawdown</div>`;
                html += `          <div class="group-metric-value" style="color: var(--red)">$${setup.maxDrawdown.toFixed(2)}</div>`;
                html += `        </div>`;
                html += `        <div class="group-metric-card">`;
                html += `          <div class="group-metric-label">Mejor Sesión</div>`;
                html += `          <div class="group-metric-value" style="font-size: 1.25rem">${setup.bestSession}</div>`;
                html += `          <div class="stat-subvalue">$${setup.bestSessionPL.toFixed(0)}</div>`;
                html += `        </div>`;
                html += `        <div class="group-metric-card">`;
                html += `          <div class="group-metric-label">Mejor Hora</div>`;
                html += `          <div class="group-metric-value" style="font-size: 1.25rem">${setup.bestHour}</div>`;
                html += `          <div class="stat-subvalue">$${setup.bestHourPL.toFixed(0)}</div>`;
                html += `        </div>`;
                if (setup.avgDuration > 0) {
                    html += `        <div class="group-metric-card">`;
                    html += `          <div class="group-metric-label">Duración Avg</div>`;
                    html += `          <div class="group-metric-value">${setup.avgDuration.toFixed(0)} min</div>`;
                    html += `        </div>`;
                }
                html += `        <div class="group-metric-card">`;
                html += `          <div class="group-metric-label">What-If P&L</div>`;
                html += `          <div class="group-metric-value" style="color: ${setup.whatIfPL >= 0 ? 'var(--green)' : 'var(--red)'}">$${setup.whatIfPL.toFixed(2)}</div>`;
                html += `          <div class="stat-subvalue">${setup.whatIfTotal}% actividad</div>`;
                html += `        </div>`;
                html += `      </div>`;
                
                // Lista de operaciones
                html += `      <div class="group-trades-list">`;
                html += `        <div class="group-trades-header">Últimas operaciones</div>`;
                setup.operations.slice(0, 10).forEach(op => {
                    html += `        <div class="mini-trade-row" style="cursor: pointer;" onclick="showOperationDetailPage('${op.id}')" title="Click para ver detalles">`;
                    html += `          <span>${op.date || 'N/A'}</span>`;
                    html += `          <span>${op.instrument || 'N/A'}</span>`;
                    html += `          <span>${op.type || 'N/A'}</span>`;
                    html += `          <span style="color: ${parseFloat(op.pl) >= 0 ? 'var(--green)' : 'var(--red)'}">$${parseFloat(op.pl).toFixed(2)}</span>`;
                    html += `          <span>${op.volume || 'N/A'}</span>`;
                    html += `        </div>`;
                });
                if (setup.operations.length > 10) {
                    html += `        <div style="text-align: center; padding: 0.5rem; color: var(--text-secondary); font-size: 0.875rem;">`;
                    html += `          +${setup.operations.length - 10} operaciones más`;
                    html += `        </div>`;
                }
                html += `      </div>`;
                
                html += `    </div>`;
                html += `  </div>`;
                html += `</div>`;
            });
            
            if (setupsArray.length === 0) {
                html = `<div class="text-center py-8 text-text-secondary">No se encontraron setups</div>`;
            }
            
            container.innerHTML = html;
        }

        // Toggle de grupos expandibles
        window.toggleGroupItem = function(header) {
            const groupItem = header.closest('.group-item');
            groupItem.classList.toggle('expanded');
        }

        // Función para navegar al Daily Journal desde el heatmap
        window.navigateToHeatmapDay = function(hour, dayOfWeek) {
            // Obtener operaciones del filtro actual
            const accountFilter = document.getElementById('filter-account')?.value || 'all';
            const instrumentFilter = document.getElementById('filter-instrument')?.value.toLowerCase().trim() || '';
            
            let operations = window.applyDateFilterToData(DB.operations);
            
            // Aplicar filtros
            operations = operations.filter(op =>
                (accountFilter === 'all' || op.accountId === accountFilter) &&
                (!instrumentFilter || op.instrument.toLowerCase().includes(instrumentFilter))
            );
            operations = window.applyOperationsFilters(operations);
            
            // Filtrar operaciones de ese día de la semana y hora específicos
            const matchingOps = operations.filter(op => {
                const exitDateTime = window.parseOperationDateTime(op, true);
                const opHour = exitDateTime.getHours();
                const opDay = exitDateTime.getDay();
                // Validar que las fechas sean válidas
                if (isNaN(opHour) || isNaN(opDay)) return false;
                return opHour === hour && opDay === dayOfWeek;
            });
            
            if (matchingOps.length === 0) {
                alert('No hay operaciones para mostrar en este horario.');
                return;
            }
            
            // Obtener la fecha más reciente de las operaciones coincidentes
            const sortedDates = matchingOps.map(op => op.date).sort((a, b) => new Date(b) - new Date(a));
            const targetDate = sortedDates[0];
            
            // Navegar al Daily Journal
            showSection('daily-journal');
            
            // Esperar a que se renderice y luego hacer scroll a la fecha
            setTimeout(() => {
                if (typeof refreshDailyJournal === 'function') {
                    refreshDailyJournal();
                    
                    // Hacer scroll al día específico
                    setTimeout(() => {
                        const dayCard = document.querySelector(`[data-journal-date="${targetDate}"]`);
                        if (dayCard) {
                            dayCard.scrollIntoView({ behavior: 'smooth', block: 'start' });
                            dayCard.style.border = '2px solid var(--primary)';
                            dayCard.style.boxShadow = '0 0 20px rgba(57, 255, 20, 0.3)';
                            setTimeout(() => {
                                dayCard.style.border = '';
                                dayCard.style.boxShadow = '';
                            }, 3000);
                        }
                    }, 300);
                }
            }, 100);
        };

        function calculateTradeDuration(entryTime, exitTime) {
            try {
                // Validar que los tiempos existen
                if (!entryTime || !exitTime) {
                    return 0;
                }
                
                const [eh, em] = entryTime.split(':').map(Number);
                const [xh, xm] = exitTime.split(':').map(Number);
                
                // Validar que los valores son números válidos
                if (isNaN(eh) || isNaN(em) || isNaN(xh) || isNaN(xm)) {
                    console.warn('⚠️ Tiempos inválidos:', { entryTime, exitTime });
                    return 0;
                }
                
                let duration = (xh * 60 + xm) - (eh * 60 + em);
                
                // Si la duración es negativa, puede ser overnight
                if (duration < 0) {
                    duration += 24 * 60; // Agregar 24 horas
                }
                
                return duration;
            } catch (e) {
                console.warn('⚠️ Error en calculateTradeDuration:', e, { entryTime, exitTime });
                return 0;
            }
        }

        function initDashboard() {
            updateAccountSelect('dashboard-account-select');
            refreshDashboard();
            
            const accountSelect = document.getElementById('dashboard-account-select');
            if (accountSelect) {
                accountSelect.addEventListener('change', function() {
                    const selectedAccount = this.value;
                    syncAccountSelection(selectedAccount); // Sincronizar con todas las secciones
                    updateSelectorLogo('dashboard-account-select');
                    refreshDashboard();
                });
            }
            
            // Selector de moneda Dashboard
            const currencySelect = document.getElementById('dashboard-currency-select');
            if (currencySelect) {
                currencySelect.addEventListener('change', refreshDashboard);
            }

            // Selectores de tipo de gráfico y métrica (nuevo)
            const chartTypeSelect = document.getElementById('dashboard-chart-type');
            if (chartTypeSelect) {
                chartTypeSelect.addEventListener('change', refreshDashboard);
            }

            const metricSelect = document.getElementById('dashboard-metric');
            if (metricSelect) {
                metricSelect.addEventListener('change', refreshDashboard);
            }

            // Abrir sidebar de filtros
            const filtersBtn = document.getElementById('dashboard-filters-btn');
            if (filtersBtn) {
                filtersBtn.addEventListener('click', () => {
                    currentFilterSection = 'dashboard';
                    toggleFiltersSidebar();
                });
            }

            // Cerrar sidebar
            const closeFiltersBtn = document.getElementById('close-filters-btn');
            const overlay = document.getElementById('filters-overlay');
            if (closeFiltersBtn) {
                closeFiltersBtn.addEventListener('click', toggleFiltersSidebar);
            }
            if (overlay) {
                overlay.addEventListener('click', toggleFiltersSidebar);
            }

            // Aplicar filtros del sidebar
            const sidebarApplyBtn = document.getElementById('sidebar-apply-filters-btn');
            if (sidebarApplyBtn) {
                sidebarApplyBtn.addEventListener('click', () => {
                    console.log('🎯 Aplicando filtros del sidebar...');
                    
                    // Leer valores del sidebar
                    const symbol = document.getElementById('sidebar-filter-symbol').value.toUpperCase();
                    const type = document.getElementById('sidebar-filter-type').value;
                    const result = document.getElementById('sidebar-filter-result').value;
                    const duration = document.getElementById('sidebar-filter-duration').value;
                    const day = document.getElementById('sidebar-filter-day').value;
                    const session = document.getElementById('sidebar-filter-session').value;
                    const plMin = document.getElementById('sidebar-filter-pl-min').value;
                    const plMax = document.getElementById('sidebar-filter-pl-max').value;
                    const showWins = document.getElementById('sidebar-show-wins').checked;
                    const showLosses = document.getElementById('sidebar-show-losses').checked;
                    const showBreakeven = document.getElementById('sidebar-show-breakeven').checked;
                    
                    console.log('📊 Filtros leídos:', { symbol, type, result, duration, day, session, plMin, plMax, showWins, showLosses, showBreakeven });
                    
                    // Aplicar filtros según la sección activa
                    if (currentFilterSection === 'dashboard') {
                        console.log('🔄 Aplicando filtros a Dashboard');
                        dashboardFilters.symbol = symbol;
                        dashboardFilters.type = type;
                        dashboardFilters.result = result;
                        dashboardFilters.duration = duration;
                        dashboardFilters.day = day;
                        dashboardFilters.session = session;
                        dashboardFilters.plMin = plMin === '' ? null : parseFloat(plMin);
                        dashboardFilters.plMax = plMax === '' ? null : parseFloat(plMax);
                        dashboardFilters.showWins = showWins;
                        dashboardFilters.showLosses = showLosses;
                        dashboardFilters.showBreakeven = showBreakeven;
                        
                        // Cerrar sidebar primero
                        toggleFiltersSidebar();
                        
                        // Refresh con delay para asegurar que se ejecuta
                        setTimeout(() => {
                            console.log('✅ Ejecutando refreshDashboard...');
                            refreshDashboard();
                        }, 100);
                        
                    } else if (currentFilterSection === 'informe') {
                        console.log('🔄 Aplicando filtros a Informe');
                        informeFilters.symbol = symbol;
                        informeFilters.type = type;
                        informeFilters.result = result;
                        informeFilters.day = day;
                        informeFilters.plMin = plMin === '' ? null : parseFloat(plMin);
                        informeFilters.plMax = plMax === '' ? null : parseFloat(plMax);
                        
                        // Cerrar sidebar primero
                        toggleFiltersSidebar();
                        
                        // Refresh con delay
                        setTimeout(() => {
                            console.log('✅ Ejecutando refreshActiveInformeSubTab...');
                            refreshActiveInformeSubTab();
                        }, 100);
                        
                    } else if (currentFilterSection === 'analytics') {
                        console.log('🔄 Aplicando filtros a Analytics');
                        analyticsFilters.symbol = symbol;
                        analyticsFilters.type = type;
                        analyticsFilters.result = result;
                        analyticsFilters.duration = duration;
                        analyticsFilters.day = day;
                        analyticsFilters.session = session;
                        analyticsFilters.plMin = plMin === '' ? null : parseFloat(plMin);
                        analyticsFilters.plMax = plMax === '' ? null : parseFloat(plMax);
                        analyticsFilters.showWins = showWins;
                        analyticsFilters.showLosses = showLosses;
                        analyticsFilters.showBreakeven = showBreakeven;
                        
                        toggleFiltersSidebar();
                        setTimeout(() => {
                            console.log('✅ Ejecutando refreshAnalytics...');
                            refreshAnalytics();
                        }, 100);
                    } else if (currentFilterSection === 'calendar') {
                        console.log('🔄 Aplicando filtros a Calendario');
                        // Aquí puedes agregar lógica para Calendario si es necesario
                        toggleFiltersSidebar();
                        setTimeout(() => {
                            updateCalendar();
                        }, 100);
                    }
                });
            }

            // Limpiar filtros del sidebar
            const sidebarClearBtn = document.getElementById('sidebar-clear-filters-btn');
            if (sidebarClearBtn) {
                sidebarClearBtn.addEventListener('click', () => {
                    console.log('🧹 Limpiando filtros del sidebar...');
                    
                    document.getElementById('sidebar-filter-symbol').value = '';
                    document.getElementById('sidebar-filter-type').value = 'all';
                    document.getElementById('sidebar-filter-result').value = 'all';
                    document.getElementById('sidebar-filter-duration').value = 'all';
                    document.getElementById('sidebar-filter-day').value = 'all';
                    document.getElementById('sidebar-filter-session').value = 'all';
                    document.getElementById('sidebar-filter-pl-min').value = '';
                    document.getElementById('sidebar-filter-pl-max').value = '';
                    document.getElementById('sidebar-show-wins').checked = true;
                    document.getElementById('sidebar-show-losses').checked = true;
                    document.getElementById('sidebar-show-breakeven').checked = true;
                    
                    // Resetear filtros según la sección
                    if (currentFilterSection === 'dashboard') {
                        dashboardFilters = { symbol: '', type: 'all', result: 'all', plMin: null, plMax: null, day: 'all', duration: 'all', session: 'all', showWins: true, showLosses: true, showBreakeven: true };
                        toggleFiltersSidebar();
                        setTimeout(() => {
                            console.log('✅ Limpiando Dashboard...');
                            refreshDashboard();
                        }, 100);
                    } else if (currentFilterSection === 'informe') {
                        informeFilters = { symbol: '', type: 'all', result: 'all', plMin: null, plMax: null, day: 'all' };
                        toggleFiltersSidebar();
                        setTimeout(() => {
                            console.log('✅ Limpiando Informe...');
                            refreshActiveInformeSubTab();
                        }, 100);
                    } else if (currentFilterSection === 'analytics') {
                        analyticsFilters = { symbol: '', type: 'all', result: 'all', plMin: null, plMax: null, day: 'all', duration: 'all', session: 'all', showWins: true, showLosses: true, showBreakeven: true };
                        toggleFiltersSidebar();
                        setTimeout(() => {
                            console.log('✅ Limpiando Analytics...');
                            refreshAnalytics();
                        }, 100);
                    } else {
                        toggleFiltersSidebar();
                        setTimeout(() => {
                            refreshCurrentSection();
                        }, 100);
                    }
                });
            }

            // Botón de descarga PDF
            const downloadBtn = document.getElementById('dashboard-download-btn');
            if (downloadBtn) {
                downloadBtn.addEventListener('click', () => downloadSectionPDF('dashboard', 'Dashboard'));
            }

            // ===== DAILY JOURNAL FILTERS & DOWNLOAD =====
            const djFiltersBtn = document.getElementById('daily-journal-filters-btn');
            if (djFiltersBtn) {
                djFiltersBtn.addEventListener('click', () => {
                    document.getElementById('daily-journal-filters-sidebar').classList.add('active');
                    document.getElementById('filters-overlay').classList.add('active');
                });
            }

            const closeDJFiltersBtn = document.getElementById('close-daily-journal-filters-btn');
            if (closeDJFiltersBtn) {
                closeDJFiltersBtn.addEventListener('click', () => {
                    document.getElementById('daily-journal-filters-sidebar').classList.remove('active');
                    document.getElementById('filters-overlay').classList.remove('active');
                });
            }

            const djApplyBtn = document.getElementById('dj-sidebar-apply-filters-btn');
            if (djApplyBtn) {
                djApplyBtn.addEventListener('click', () => {
                    dailyJournalFilters.symbol = document.getElementById('dj-sidebar-filter-symbol').value.toUpperCase();
                    dailyJournalFilters.type = document.getElementById('dj-sidebar-filter-type').value;
                    dailyJournalFilters.result = document.getElementById('dj-sidebar-filter-result').value;
                    dailyJournalFilters.duration = document.getElementById('dj-sidebar-filter-duration').value;
                    dailyJournalFilters.day = document.getElementById('dj-sidebar-filter-day').value;
                    dailyJournalFilters.session = document.getElementById('dj-sidebar-filter-session').value;
                    dailyJournalFilters.plMin = document.getElementById('dj-sidebar-filter-pl-min').value === '' ? null : parseFloat(document.getElementById('dj-sidebar-filter-pl-min').value);
                    dailyJournalFilters.plMax = document.getElementById('dj-sidebar-filter-pl-max').value === '' ? null : parseFloat(document.getElementById('dj-sidebar-filter-pl-max').value);
                    dailyJournalFilters.showWins = document.getElementById('dj-sidebar-show-wins').checked;
                    dailyJournalFilters.showLosses = document.getElementById('dj-sidebar-show-losses').checked;
                    dailyJournalFilters.showBreakeven = document.getElementById('dj-sidebar-show-breakeven').checked;
                    
                    document.getElementById('daily-journal-filters-sidebar').classList.remove('active');
                    document.getElementById('filters-overlay').classList.remove('active');
                    renderDailyJournal();
                });
            }

            const djClearBtn = document.getElementById('dj-sidebar-clear-filters-btn');
            if (djClearBtn) {
                djClearBtn.addEventListener('click', () => {
                    document.getElementById('dj-sidebar-filter-symbol').value = '';
                    document.getElementById('dj-sidebar-filter-type').value = 'all';
                    document.getElementById('dj-sidebar-filter-result').value = 'all';
                    document.getElementById('dj-sidebar-filter-duration').value = 'all';
                    document.getElementById('dj-sidebar-filter-day').value = 'all';
                    document.getElementById('dj-sidebar-filter-session').value = 'all';
                    document.getElementById('dj-sidebar-filter-pl-min').value = '';
                    document.getElementById('dj-sidebar-filter-pl-max').value = '';
                    document.getElementById('dj-sidebar-show-wins').checked = true;
                    document.getElementById('dj-sidebar-show-losses').checked = true;
                    document.getElementById('dj-sidebar-show-breakeven').checked = true;
                    
                    dailyJournalFilters = { symbol: '', type: 'all', result: 'all', plMin: null, plMax: null, day: 'all', duration: 'all', session: 'all', showWins: true, showLosses: true, showBreakeven: true };
                    document.getElementById('daily-journal-filters-sidebar').classList.remove('active');
                    document.getElementById('filters-overlay').classList.remove('active');
                    renderDailyJournal();
                });
            }

            const djDownloadBtn = document.getElementById('daily-journal-download-btn');
            if (djDownloadBtn) {
                djDownloadBtn.addEventListener('click', () => downloadSectionPDF('daily-journal', 'Daily Journal'));
            }

            // ===== OPERATIONS FILTERS & DOWNLOAD =====
            const opsFiltersBtn = document.getElementById('operations-filters-btn');
            if (opsFiltersBtn) {
                opsFiltersBtn.addEventListener('click', () => {
                    document.getElementById('operations-filters-sidebar').classList.add('active');
                    document.getElementById('filters-overlay').classList.add('active');
                });
            }

            const closeOpsFiltersBtn = document.getElementById('close-operations-filters-btn');
            if (closeOpsFiltersBtn) {
                closeOpsFiltersBtn.addEventListener('click', () => {
                    document.getElementById('operations-filters-sidebar').classList.remove('active');
                    document.getElementById('filters-overlay').classList.remove('active');
                });
            }

            const opsApplyBtn = document.getElementById('ops-sidebar-apply-filters-btn');
            if (opsApplyBtn) {
                opsApplyBtn.addEventListener('click', () => {
                    operationsFilters.symbol = document.getElementById('ops-sidebar-filter-symbol').value.toUpperCase();
                    operationsFilters.type = document.getElementById('ops-sidebar-filter-type').value;
                    operationsFilters.result = document.getElementById('ops-sidebar-filter-result').value;
                    operationsFilters.duration = document.getElementById('ops-sidebar-filter-duration').value;
                    operationsFilters.day = document.getElementById('ops-sidebar-filter-day').value;
                    operationsFilters.session = document.getElementById('ops-sidebar-filter-session').value;
                    operationsFilters.plMin = document.getElementById('ops-sidebar-filter-pl-min').value === '' ? null : parseFloat(document.getElementById('ops-sidebar-filter-pl-min').value);
                    operationsFilters.plMax = document.getElementById('ops-sidebar-filter-pl-max').value === '' ? null : parseFloat(document.getElementById('ops-sidebar-filter-pl-max').value);
                    operationsFilters.showWins = document.getElementById('ops-sidebar-show-wins').checked;
                    operationsFilters.showLosses = document.getElementById('ops-sidebar-show-losses').checked;
                    operationsFilters.showBreakeven = document.getElementById('ops-sidebar-show-breakeven').checked;
                    
                    // Aplicar los mismos filtros a calendario
                    calendarFilters.symbol = operationsFilters.symbol;
                    calendarFilters.type = operationsFilters.type;
                    calendarFilters.result = operationsFilters.result;
                    calendarFilters.duration = operationsFilters.duration;
                    calendarFilters.day = operationsFilters.day;
                    calendarFilters.session = operationsFilters.session;
                    calendarFilters.plMin = operationsFilters.plMin;
                    calendarFilters.plMax = operationsFilters.plMax;
                    calendarFilters.showWins = operationsFilters.showWins;
                    calendarFilters.showLosses = operationsFilters.showLosses;
                    calendarFilters.showBreakeven = operationsFilters.showBreakeven;
                    
                    document.getElementById('operations-filters-sidebar').classList.remove('active');
                    document.getElementById('filters-overlay').classList.remove('active');
                    
                    // Detectar qué sección está activa y refrescarla
                    if (document.getElementById('operations').classList.contains('active')) {
                        renderOperations();
                    }
                    if (document.getElementById('calendar').classList.contains('active')) {
                        updateCalendar();
                    }
                });
            }

            const opsClearBtn = document.getElementById('ops-sidebar-clear-filters-btn');
            if (opsClearBtn) {
                opsClearBtn.addEventListener('click', () => {
                    document.getElementById('ops-sidebar-filter-symbol').value = '';
                    document.getElementById('ops-sidebar-filter-type').value = 'all';
                    document.getElementById('ops-sidebar-filter-result').value = 'all';
                    document.getElementById('ops-sidebar-filter-duration').value = 'all';
                    document.getElementById('ops-sidebar-filter-day').value = 'all';
                    document.getElementById('ops-sidebar-filter-session').value = 'all';
                    document.getElementById('ops-sidebar-filter-pl-min').value = '';
                    document.getElementById('ops-sidebar-filter-pl-max').value = '';
                    document.getElementById('ops-sidebar-show-wins').checked = true;
                    document.getElementById('ops-sidebar-show-losses').checked = true;
                    document.getElementById('ops-sidebar-show-breakeven').checked = true;
                    
                    operationsFilters = { symbol: '', type: 'all', result: 'all', plMin: null, plMax: null, day: 'all', duration: 'all', session: 'all', showWins: true, showLosses: true, showBreakeven: true };
                    calendarFilters = { symbol: '', type: 'all', result: 'all', plMin: null, plMax: null, day: 'all', duration: 'all', session: 'all', showWins: true, showLosses: true, showBreakeven: true };
                    document.getElementById('operations-filters-sidebar').classList.remove('active');
                    document.getElementById('filters-overlay').classList.remove('active');
                    
                    // Detectar qué sección está activa y refrescarla
                    if (document.getElementById('operations').classList.contains('active')) {
                        renderOperations();
                    }
                    if (document.getElementById('calendar').classList.contains('active')) {
                        updateCalendar();
                    }
                });
            }

            const opsDownloadBtn = document.getElementById('operations-download-btn');
            if (opsDownloadBtn) {
                opsDownloadBtn.addEventListener('click', () => downloadSectionPDF('operations', 'Operaciones'));
            }

            // Cerrar todos los sidebars con overlay
            const filtersOverlay = document.getElementById('filters-overlay');
            if (filtersOverlay) {
                filtersOverlay.addEventListener('click', () => {
                    document.getElementById('filters-sidebar').classList.remove('active');
                    document.getElementById('daily-journal-filters-sidebar').classList.remove('active');
                    document.getElementById('operations-filters-sidebar').classList.remove('active');
                    filtersOverlay.classList.remove('active');
                });
            }
        }
        
        // Inicializar NUEVO Dashboard
        function initNewDashboard() {
            updateAccountSelect('new-dashboard-account-select');
            refreshNewDashboard();
        }
        
        // Debounce timer para evitar múltiples refreshes
        let refreshDashboardTimer = null;

        function refreshDashboard() {
            // Cancelar refresh anterior si existe
            if (refreshDashboardTimer) {
                clearTimeout(refreshDashboardTimer);
            }
            
            // Programar nuevo refresh después de un pequeño delay
            refreshDashboardTimer = setTimeout(() => {
                _refreshDashboardNow();
                refreshDashboardTimer = null;
            }, 100);
        }
        
        function _refreshDashboardNow() {
            console.log('🔄 refreshDashboard() iniciado');
            
            if (!document.getElementById('dashboard').classList.contains('active')) {
                console.log('⚠️ Dashboard no está activo, cancelando refresh');
                return;
            }
            
            const accountSelect = document.getElementById('dashboard-account-select');
            const currencySelect = document.getElementById('dashboard-currency-select');
            
            if (!accountSelect || !currencySelect) {
                console.log('⚠️ Selectores no encontrados');
                return;
            }
            
            const selectedAccount = accountSelect.value;
            const displayCurrency = currencySelect.value;

            console.log('📊 Dashboard - Cuenta seleccionada:', selectedAccount);
            console.log('📅 Dashboard - Filtro de fecha:', globalDateFilter);
            console.log('🎯 Dashboard - Filtros personalizados:', dashboardFilters);

            let operationsForMetrics = applyDateFilterToData(DB.operations);
            console.log('📅 Después de filtro de fecha:', operationsForMetrics.length, 'operaciones');

            if (selectedAccount !== 'all') {
                operationsForMetrics = operationsForMetrics.filter(op => op.accountId === selectedAccount);
                console.log('👤 Después de filtro de cuenta:', operationsForMetrics.length, 'operaciones');
            }

            // Aplicar filtros de Dashboard
            operationsForMetrics = applyDashboardFilters(operationsForMetrics);
            console.log('🎯 Después de filtros personalizados:', operationsForMetrics.length, 'operaciones');

            const metrics = calculateMetrics(operationsForMetrics, selectedAccount);
            const advancedMetrics = calculateAdvancedMetrics(operationsForMetrics, selectedAccount);
            const grossPL = metrics.totalWin + metrics.totalLoss;
            const netPL = grossPL - metrics.totalFees;
            
            console.log('✅ Dashboard actualizado con', operationsForMetrics.length, 'operaciones');
            console.log('💰 P/L Bruto:', grossPL, '| P/L Neto:', netPL, '| Comisiones:', metrics.totalFees);

            const balanceEl = document.getElementById('current-balance');
            if (balanceEl) {
                balanceEl.textContent = formatCurrency(netPL, DB.settings.defaultCurrency, displayCurrency);
                balanceEl.className = `text-3xl font-bold ${netPL >= 0 ? 'text-green' : 'text-negative'}`;
            }

            const winRateEl = document.getElementById('win-rate');
            if (winRateEl) winRateEl.textContent = metrics.winRate.toFixed(0) + '%';
            
            const profitFactorEl = document.getElementById('profit-factor');
            if (profitFactorEl) profitFactorEl.textContent = isFinite(metrics.profitFactor) ? metrics.profitFactor.toFixed(2) : "∞";
            
            const totalTradesEl = document.getElementById('total-trades');
            if (totalTradesEl) totalTradesEl.textContent = metrics.totalTrades;

            // P&L Metrics - Nuevos elementos
            const plGrossEl = document.getElementById('dashboard-pl-gross');
            if (plGrossEl) {
                plGrossEl.textContent = formatCurrency(grossPL, DB.settings.defaultCurrency, displayCurrency);
                plGrossEl.className = `text-2xl font-bold hide-amount ${grossPL >= 0 ? 'text-green' : 'text-negative'}`;
            }
            
            const totalFeesEl = document.getElementById('dashboard-total-fees');
            if (totalFeesEl) {
                totalFeesEl.textContent = formatCurrency(metrics.totalFees, DB.settings.defaultCurrency, displayCurrency);
            }
            
            const plNetEl = document.getElementById('dashboard-pl-net');
            if (plNetEl) {
                plNetEl.textContent = formatCurrency(netPL, DB.settings.defaultCurrency, displayCurrency);
                plNetEl.className = `text-2xl font-bold hide-amount ${netPL >= 0 ? 'text-green' : 'text-negative'}`;
            }
            
            const totalOpsEl = document.getElementById('dashboard-total-operations');
            if (totalOpsEl) {
                totalOpsEl.textContent = metrics.totalTrades;
            }

            // Totals
            const totalWinEl = document.getElementById('dashboard-total-win');
            if (totalWinEl) totalWinEl.textContent = formatCurrency(metrics.totalWin, DB.settings.defaultCurrency, displayCurrency);
            const totalLossEl = document.getElementById('dashboard-total-loss');
            if (totalLossEl) totalLossEl.textContent = formatCurrency(metrics.totalLoss, DB.settings.defaultCurrency, displayCurrency);

            // Advanced metrics
            const avgWinEl = document.getElementById('dashboard-avg-win');
            if (avgWinEl) avgWinEl.textContent = formatCurrency(advancedMetrics.avgWin, DB.settings.defaultCurrency, displayCurrency);

            const avgLossEl = document.getElementById('dashboard-avg-loss');
            if (avgLossEl) avgLossEl.textContent = formatCurrency(advancedMetrics.avgLoss, DB.settings.defaultCurrency, displayCurrency);

            const avgPlEl = document.getElementById('dashboard-avg-pl');
            if (avgPlEl) {
                avgPlEl.textContent = formatCurrency(advancedMetrics.avgPLPerTrade, DB.settings.defaultCurrency, displayCurrency);
                avgPlEl.className = `text-2xl font-bold ${advancedMetrics.avgPLPerTrade >= 0 ? 'text-white' : 'text-negative'}`;
            }
            
            // Win Rate Display (NUEVO)
            const winRateDisplayEl = document.getElementById('dashboard-win-rate-display');
            if (winRateDisplayEl) {
                winRateDisplayEl.textContent = `${metrics.winRate.toFixed(2)}%`;
            }

            const activeRangeButton = document.querySelector('#dashboard .time-range-btn.active');
            const timeRange = activeRangeButton ? activeRangeButton.dataset.range : 'ALL';

            let opsForEvolutionChart = applyDateFilterToData(DB.operations);
            if (selectedAccount !== 'all') {
                opsForEvolutionChart = opsForEvolutionChart.filter(op => op.accountId === selectedAccount);
            }
            updateAccountEvolutionChart(opsForEvolutionChart, selectedAccount, timeRange);

            updateDashboardRadarChart(operationsForMetrics, selectedAccount);
            updateInstrumentPerformanceChart(operationsForMetrics, 'instrument-performance-chart');
            updateDayPerformanceChart(operationsForMetrics, 'day-performance-chart');
            updateTypePerformanceChart(operationsForMetrics, 'type-performance-chart');

            // Update dashboard mini visuals solo si existen los elementos
            const sparklineChart = document.getElementById('dashboard-sparkline-chart');
            if (sparklineChart) updateDashboardSparkline(operationsForMetrics);
            
            const pfGauge = document.getElementById('dashboard-pf-gauge');
            if (pfGauge) updateDashboardPFGauge(metrics.profitFactor);
            
            const winCircle = document.getElementById('dashboard-win-circle');
            if (winCircle) updateDashboardWinDonut(metrics.winRate, metrics.winningTrades, metrics.losingTrades);
            
            const latestOpsTable = document.getElementById('latest-operations-table');
            if (latestOpsTable) updateLatestOperationsTable(operationsForMetrics);

            // Actualizar nuevos módulos
            updateLast7DaysCalendar(operationsForMetrics);
            updateRecentOperationsList(operationsForMetrics);

            // ROI - solo actualizar si el elemento existe
            const initialBalance = metrics.initialBalance || 0;
            const roiEl = document.getElementById('dashboard-roi');
            if (roiEl) {
                const roi = initialBalance > 0 ? (totalPL / initialBalance) * 100 : 0;
                roiEl.textContent = roi.toFixed(2) + '%';
                roiEl.className = roi >= 0 ? 'text-sm font-semibold text-success' : 'text-sm font-semibold text-danger';
            }
        }

        function updateLatestOperationsTable(operations) {
            const tableBody = document.getElementById('latest-operations-table');
            if (!tableBody) return;

            tableBody.innerHTML = '';

            const latestOps = [...operations].sort((a, b) => new Date(b.date) - new Date(a.date)).slice(0, 6);

            if (latestOps.length === 0) {
                tableBody.innerHTML = '<tr><td colspan="4" class="text-center text-text-secondary py-4">No hay operaciones recientes.</td></tr>';
                return;
            }

            latestOps.forEach(op => {
                const row = document.createElement('tr');
                row.className = 'cursor-pointer';
                row.dataset.id = op.id;

                const plClass = op.pl >= 0 ? 'text-positive' : 'text-negative';
                const typeClass = op.type === 'buy' ? 'text-positive' : 'text-negative';

                row.innerHTML = `
                    <td class="text-left font-semibold">${op.instrument}</td>
                    <td class="${plClass} text-right">${formatCurrency(op.pl, op.currency, op.currency)}</td>
                    <td class="${typeClass} text-center">${op.type === 'buy' ? 'Long' : 'Short'}</td>
                    <td class="text-right text-text-secondary">${formatDate(op.date)}</td>
                `;

                row.addEventListener('click', () => {
                    showOperationDetailPage(op.id);
                });

                tableBody.appendChild(row);
            });
        }

        // Función para el calendario de últimos 7 días - diseño exacto según imagen
        window.updateLast7DaysCalendar = function updateLast7DaysCalendar(operations) {
            const container = document.getElementById('last-7-days-calendar');
            if (!container) return;

            try {
                container.innerHTML = '';

                // Obtener los últimos 7 días
                const today = new Date();
                const days = [];
                
                for (let i = 6; i >= 0; i--) {
                    const date = new Date(today);
                    date.setDate(date.getDate() - i);
                    days.push(date);
                }

                days.forEach(date => {
                    const dateStr = date.toISOString().split('T')[0];
                    const dayOperations = operations.filter(op => op.date === dateStr);
                    const totalPL = dayOperations.reduce((sum, op) => sum + (op.pl || 0), 0);
                    const operationsCount = dayOperations.length;

                    const dayNames = ['Dom', 'Lun', 'Mar', 'Mié', 'Jue', 'Vie', 'Sáb'];
                    const dayName = dayNames[date.getDay()];
                    const dayNumber = date.getDate();

                    const dayCard = document.createElement('div');
                    dayCard.className = 'bg-surface border border-border rounded-lg p-4 text-center cursor-pointer transition-all duration-200 hover:border-gray-500';
                    
                    if (operationsCount > 0) {
                        if (totalPL > 0) {
                            dayCard.className += ' border-success hover:border-success';
                        } else {
                            dayCard.className += ' border-danger hover:border-danger';
                        }
                    }

                    const formattedPL = operationsCount > 0 ? `$${totalPL.toFixed(2)}` : '$0';
                    
                    dayCard.innerHTML = `
                        <div class="text-xs text-text-secondary mb-1">${dayName}</div>
                        <div class="text-2xl font-bold text-white mb-2">${dayNumber}</div>
                        <div class="text-sm ${totalPL > 0 ? 'text-positive' : totalPL < 0 ? 'text-negative' : 'text-text-secondary'} font-bold mb-1">
                            ${formattedPL}
                        </div>
                        <div class="text-xs text-text-secondary">${operationsCount} comercio${operationsCount === 1 ? '' : 's'}</div>
                    `;

                    if (operationsCount > 0) {
                        dayCard.addEventListener('click', () => {
                            try {
                                // Mostrar análisis del día usando el modal existente
                                const dateStr = date.toISOString().split('T')[0]; // Formato YYYY-MM-DD
                                const dayName = date.toLocaleDateString('es-ES', { weekday: 'long', day: 'numeric', month: 'long' });
                                openAnalyticsDetailModal('date', dateStr, `Día: ${dayName}`);
                            } catch (e) {
                                console.log('Error al mostrar análisis del día:', e);
                            }
                        });
                    }

                    container.appendChild(dayCard);
                });
            } catch (error) {
                console.log('Error en updateLast7DaysCalendar:', error);
                container.innerHTML = '<div class="text-center text-gray-400 p-4">Error al cargar el calendario</div>';
            }
        }

        // Función para operaciones recientes - diseño exacto según imagen
        window.updateRecentOperationsList = function updateRecentOperationsList(operations) {
            const container = document.getElementById('recent-operations-list');
            if (!container) return;

            try {
                const recentOps = [...operations]
                    .sort((a, b) => new Date(b.date + ' ' + (b.entryTime || '00:00')) - new Date(a.date + ' ' + (a.entryTime || '00:00')))
                    .slice(0, 3);

                if (recentOps.length === 0) {
                    container.innerHTML = `
                        <div class="col-span-3 text-center py-8 text-gray-400">
                            <div class="text-2xl mb-2">📊</div>
                            <div>No hay operaciones recientes detectadas</div>
                        </div>
                    `;
                    return;
                }

                container.innerHTML = recentOps.map((op, index) => {
                    const date = new Date(op.date);
                    const dayNames = ['Viernes', 'Martes', 'Lunes']; 
                    const dayName = dayNames[index] || date.toLocaleDateString('es-ES', { weekday: 'long' });
                    const formattedPL = `$${(op.pl || 0).toFixed(2)}`;
                    const chartId = `mini-chart-${op.id}`;
                    
                    return `
                        <div class="metric-card cursor-pointer transition-all duration-200 hover:bg-surface-light" onclick="try { showOperationDetailPage('${op.id}'); } catch(e) { console.log('Error:', e); }">
                            <div class="flex items-center justify-between mb-3">
                                <div class="text-white font-bold text-xl">${op.instrument || 'N/A'}</div>
                            </div>
                            <div class="mb-3">
                                <div class="text-xs text-text-secondary mb-1">${dayName} ${date.getDate()} de ${date.toLocaleDateString('es-ES', { month: 'long' })} de ${date.getFullYear()}</div>
                            </div>
                            <div class="h-20 mb-3 bg-surface rounded border border-border flex items-center justify-center">
                                <canvas id="${chartId}" width="200" height="80" class="w-full h-full"></canvas>
                            </div>
                            <div class="text-right">
                                <div class="${(op.pl || 0) >= 0 ? 'text-positive' : 'text-negative'} font-bold text-lg">
                                    ${formattedPL}
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');

                // Generar mini gráficos después de insertar HTML
                setTimeout(() => {
                    recentOps.forEach(op => {
                        generateMiniChartGreen(`mini-chart-${op.id}`, op);
                    });
                }, 50);

            } catch (error) {
                console.log('Error en updateRecentOperationsList:', error);
                container.innerHTML = '<div class="col-span-3 text-center text-gray-400 p-4">Error al cargar operaciones</div>';
            }
        }

        // Función para generar mini gráfico con P/L real y escala de 0 al P/L final
        function generateMiniChartGreen(canvasId, operation) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            // Limpiar canvas
            ctx.clearRect(0, 0, width, height);

            // Configurar datos del gráfico con P/L real
            const finalPL = operation.pl || 0;
            const points = 40;
            const data = [];
            
            // Generar progresión de P/L desde 0 hasta el valor final
            for (let i = 0; i < points; i++) {
                const progress = i / (points - 1);
                // Crear una progresión más realista con fluctuaciones menores
                const baseProgress = progress * finalPL;
                const volatility = Math.sin(i * 0.5) * (Math.abs(finalPL) * 0.08);
                data.push(baseProgress + volatility);
            }

            // Asegurar que el último punto sea exactamente el P/L final
            data[data.length - 1] = finalPL;

            // Determinar colores según P/L
            const lineColor = finalPL >= 0 ? '#39ff14' : '#ef4444'; // Verde fluorescente o rojo
            const fillColor = finalPL >= 0 ? 'rgba(57, 255, 20, 0.2)' : 'rgba(239, 68, 68, 0.2)';

            // Calcular escala desde 0 hasta el P/L (o desde P/L hasta 0 si es negativo)
            const maxValue = Math.max(0, finalPL, ...data);
            const minValue = Math.min(0, finalPL, ...data);
            const range = maxValue - minValue || 1;

            // Dibujar línea del gráfico
            ctx.strokeStyle = lineColor;
            ctx.lineWidth = 2.5;
            ctx.beginPath();

            data.forEach((value, index) => {
                const x = (index / (points - 1)) * width;
                const y = height - ((value - minValue) / range) * height;
                
                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });

            ctx.stroke();

            // Rellenar área bajo/sobre la línea base
            const zeroY = height - ((0 - minValue) / range) * height;
            ctx.fillStyle = fillColor;
            ctx.beginPath();
            
            // Recrear la línea para el relleno
            data.forEach((value, index) => {
                const x = (index / (points - 1)) * width;
                const y = height - ((value - minValue) / range) * height;
                
                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            
            // Completar el área hacia la línea base (0)
            ctx.lineTo(width, zeroY);
            ctx.lineTo(0, zeroY);
            ctx.closePath();
            ctx.fill();

            // Dibujar línea base en 0
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, zeroY);
            ctx.lineTo(width, zeroY);
            ctx.stroke();
        }

        // Función para generar mini gráfico de cada operación
        function generateMiniChart(canvasId, operation) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            // Limpiar canvas
            ctx.clearRect(0, 0, width, height);

            // Generar datos simulados para el mini gráfico (precio simulado)
            const points = 20;
            const basePrice = operation.entry || 1.0;
            const data = [];
            
            for (let i = 0; i < points; i++) {
                const variation = (Math.random() - 0.5) * 0.02; // ±1% de variación
                const price = basePrice * (1 + variation * (i / points));
                data.push(price);
            }

            // Dibujar línea del gráfico
            const color = operation.pl >= 0 ? '#39ff14' : '#EF4444'; // Verde fluorescente o rojo
            
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();

            const minPrice = Math.min(...data);
            const maxPrice = Math.max(...data);
            const priceRange = maxPrice - minPrice || 1;

            data.forEach((price, index) => {
                const x = (index / (points - 1)) * width;
                const y = height - ((price - minPrice) / priceRange) * height;
                
                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });

            ctx.stroke();

            // Rellenar área bajo la curva con gradiente
            const gradient = ctx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, color + '40'); // 25% opacity
            gradient.addColorStop(1, color + '00'); // 0% opacity
            
            ctx.fillStyle = gradient;
            ctx.lineTo(width, height);
            ctx.lineTo(0, height);
            ctx.closePath();
            ctx.fill();
        }



        let dashboardSparklineChart = null;
        function updateDashboardSparkline(operations) {
            const canvas = document.getElementById('dashboard-sparkline-chart');
            if (!canvas) return;
            if (typeof Chart === 'undefined') return;

            const sorted = [...operations].sort((a,b) => new Date(a.date) - new Date(b.date));
            let cumulative = 0;
            const labels = [];
            const data = [];
            sorted.forEach(op => {
                const rawPL = op.manualPL ?? op.pl ?? 0;
                const plInDefault = op.currency && op.currency !== DB.settings.defaultCurrency ? convertCurrency(rawPL, op.currency, DB.settings.defaultCurrency) : rawPL;
                cumulative += plInDefault;
                labels.push(op.date);
                data.push(cumulative);
            });
            if (data.length === 0) { labels.push(new Date().toISOString().split('T')[0]); data.push(0); }

            if (dashboardSparklineChart) dashboardSparklineChart.destroy();

            const ctx = canvas.getContext('2d');
            dashboardSparklineChart = new Chart(ctx, {
                type: 'line',
                data: { labels, datasets: [{ data, borderColor: '#00FF00', backgroundColor: '#00FF00', borderWidth: 0, fill: true, pointRadius: 0, tension: 0.3 }] },
                options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } }, scales: { x: { display: false }, y: { display: false } }, elements: { line: { tension: 0.3 } } }
            });
        }

        function updateDashboardPFGauge(pf) {
            const gaugeEl = document.getElementById('dashboard-pf-gauge');
            const pfEl = document.getElementById('profit-factor');
            if (gaugeEl) {
                let percentage = 0;
                if (pf >= 3) percentage = 100;
                else if (pf >= 2) percentage = 66 + (pf - 2) * 34;
                else if (pf >= 1) percentage = 33 + (pf - 1) * 33;
                else percentage = pf * 33;
                gaugeEl.style.width = Math.min(100, Math.max(0, percentage)) + '%';
            }
            if (pfEl) pfEl.textContent = isFinite(pf) ? pf.toFixed(2) : '∞';
        }

        function updateDashboardWinDonut(winRate, wins, losses) {
            const circleEl = document.getElementById('dashboard-win-circle');
            const textEl = document.getElementById('dashboard-win-text');
            const winsEl = document.getElementById('dashboard-wins');
            const lossesEl = document.getElementById('dashboard-losses');
            if (circleEl) {
                const dash = `${winRate.toFixed(0)}, 100`;
                circleEl.setAttribute('stroke-dasharray', dash);
                let color = '#ef4444';
                if (winRate >= 60) color = '#22c55e';
                else if (winRate >= 40) color = '#eab308';
                circleEl.setAttribute('stroke', color);
            }
            if (textEl) textEl.textContent = Math.round(winRate) + '%';
            if (winsEl) winsEl.textContent = wins;
            if (lossesEl) lossesEl.textContent = losses;
        }
        function calculateMetrics(operations, accountId = 'all') {
            console.log(`[calculateMetrics] Calculando métricas para ${operations.length} operaciones`);
            
            // Debug: Verificar qué campos de comisiones tienen las primeras 5 operaciones
            if (operations.length > 0) {
                console.log('[DEBUG] Campos de comisiones en primeras 5 ops:');
                operations.slice(0, 5).forEach(op => {
                    console.log(`  Op ${op.id}: fee=${op.fee}, fees=${op.fees}, commission=${op.commission}`);
                });
            }
            
            let currentBalance = 0;
            let initialBalance = 0;
            let accountCurrency = DB.settings.defaultCurrency;
            let totalWin = 0;
            let totalLoss = 0;
            let winningTrades = 0;
            let losingTrades = 0;
            let breakevenTrades = 0;

            if (accountId !== 'all') {
                const account = DB.accounts.find(a => a.id === accountId);
                if (account) {
                    currentBalance = account.balance;
                    initialBalance = account.initialBalance;
                    accountCurrency = account.currency;
                }
            } else {
                DB.accounts.forEach(account => {
                    let accBalance = account.balance;
                    let accInitialBalance = account.initialBalance;
                    if (account.currency !== DB.settings.defaultCurrency) {
                        accBalance = convertCurrency(accBalance, account.currency, DB.settings.defaultCurrency);
                        accInitialBalance = convertCurrency(accInitialBalance, account.currency, DB.settings.defaultCurrency);
                    }
                    currentBalance += accBalance;
                    initialBalance += accInitialBalance;
                });
                accountCurrency = DB.settings.defaultCurrency;
            }

            // AGRUPAR por ID para contar trades correctamente
            // pero SUMAR todo el P&L (parciales + únicos)
            const groupedOps = {};
            
            operations.forEach(op => {
                const opId = op.id;
                
                // Crear grupo si no existe
                if (!groupedOps[opId]) {
                    groupedOps[opId] = {
                        id: opId,
                        totalPL: 0,
                        totalFees: 0,
                        currency: op.currency
                    };
                }
                
                // SUMAR el P&L de cada operación (parciales incluidas)
                groupedOps[opId].totalPL += (op.pl || 0);
                // Soportar fee, fees, y commission
                groupedOps[opId].totalFees += (op.fee || op.fees || op.commission || 0);
            });

            const uniqueTradeGroups = Object.values(groupedOps);
            
            console.log(`[calculateMetrics] Agrupadas en ${uniqueTradeGroups.length} trades únicos`);
            console.log(`[calculateMetrics] Muestra de IDs:`, uniqueTradeGroups.slice(0, 5).map(g => ({ id: g.id, pl: g.totalPL, fees: g.totalFees })));
            console.log(`[calculateMetrics] Fees totales por trade:`, uniqueTradeGroups.map(g => g.totalFees));

            // Ahora calcular métricas por TRADE COMPLETO
            // IMPORTANTE: Devolvemos P/L BRUTO (sin restar fees) para consistencia
            uniqueTradeGroups.forEach(group => {
                let plInDefaultCurrency = group.totalPL;
                
                if (group.currency !== DB.settings.defaultCurrency) {
                    plInDefaultCurrency = convertCurrency(group.totalPL, group.currency, DB.settings.defaultCurrency);
                }
                
                // Determinar resultado basado en P/L BRUTO del trade
                if (plInDefaultCurrency > 0) {
                    totalWin += plInDefaultCurrency;
                    winningTrades++;
                } else if (plInDefaultCurrency < 0) {
                    totalLoss += plInDefaultCurrency;
                    losingTrades++;
                } else {
                    breakevenTrades++;
                }
            });

            const totalTrades = uniqueTradeGroups.length;
            const relevantTradesForWinRate = winningTrades + losingTrades;
            const winRate = relevantTradesForWinRate > 0 ? (winningTrades / relevantTradesForWinRate) * 100 : 0;
            const profitFactor = Math.abs(totalLoss) > 0 ? Math.abs(totalWin / totalLoss) : (totalWin > 0 ? Infinity : 0);
            
            // Calcular total de fees en moneda por defecto
            let totalFeesInDefaultCurrency = 0;
            uniqueTradeGroups.forEach(group => {
                let feesConverted = group.totalFees;
                if (group.currency !== DB.settings.defaultCurrency) {
                    feesConverted = convertCurrency(group.totalFees, group.currency, DB.settings.defaultCurrency);
                }
                totalFeesInDefaultCurrency += feesConverted;
            });

            console.log(`[calculateMetrics] Resultados:`);
            console.log(`   - P/L Bruto: ${totalWin + totalLoss}`);
            console.log(`   - Total Fees: ${totalFeesInDefaultCurrency}`);
            console.log(`   - P/L Neto: ${(totalWin + totalLoss) - totalFeesInDefaultCurrency}`);
            console.log(`   - Trades: ${totalTrades} (${winningTrades}W / ${losingTrades}L)`);
            
            const plBruto = totalWin + totalLoss;
            const plNeto = plBruto - totalFeesInDefaultCurrency;

            // Calcular avgPL (promedio de P/L por trade)
            const avgPL = totalTrades > 0 ? plBruto / totalTrades : 0;

            // Calcular desviación estándar de P/L
            let stdDev = 0;
            if (totalTrades > 1) {
                const plValues = uniqueTradeGroups.map(group => {
                    let plInDefaultCurrency = group.totalPL;
                    if (group.currency !== DB.settings.defaultCurrency) {
                        plInDefaultCurrency = convertCurrency(group.totalPL, group.currency, DB.settings.defaultCurrency);
                    }
                    return plInDefaultCurrency;
                });

                const variance = plValues.reduce((sum, pl) => sum + Math.pow(pl - avgPL, 2), 0) / totalTrades;
                stdDev = Math.sqrt(variance);
            }

            // Calcular avgWin y avgLoss
            const avgWin = winningTrades > 0 ? totalWin / winningTrades : 0;
            const avgLoss = losingTrades > 0 ? Math.abs(totalLoss / losingTrades) : 0;

            return {
                currentBalance, initialBalance, accountCurrency,
                totalWin,
                totalLoss,
                totalFees: totalFeesInDefaultCurrency,
                plBruto,
                plNeto,
                winningTrades, losingTrades, breakevenTrades, totalTrades,
                winRate, profitFactor,
                avgPL,
                stdDev,
                avgWin,
                avgLoss
            };
        }

        // Función para calcular estadísticas de días ganadores/perdedores
        function calculateDayWinStats(operations) {
            const dayTotals = {};
            
            operations.forEach(op => {
                const date = op.date;
                if (!dayTotals[date]) {
                    dayTotals[date] = 0;
                }
                dayTotals[date] += op.pl || 0;
            });

            const days = Object.values(dayTotals);
            const winningDays = days.filter(pl => pl > 0).length;
            const losingDays = days.filter(pl => pl < 0).length;
            const breakevenDays = days.filter(pl => pl === 0).length;
            const totalDays = days.length;

            const dayWinRate = totalDays > 0 ? (winningDays / totalDays) * 100 : 0;

            return {
                winningDays,
                losingDays,
                breakevenDays,
                totalDays,
                dayWinRate
            };
        }

        let accountEvolutionChart = null;
        function updateAccountEvolutionChart(allAccountOps, accountId, timeRange = 'ALL') {
            const canvas = document.getElementById('account-evolution-chart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            if (accountEvolutionChart) {
                accountEvolutionChart.destroy();
                accountEvolutionChart = null;
            }

            // Obtener configuración de tipo de gráfico y métrica
            const chartTypeSelect = document.getElementById('dashboard-chart-type');
            const metricSelect = document.getElementById('dashboard-metric');
            const chartType = chartTypeSelect ? chartTypeSelect.value : 'area';
            const metric = metricSelect ? metricSelect.value : 'balance';

            // Filtrar operaciones según la cuenta seleccionada
            let operations = [];
            if (accountId === 'all') {
                operations = [...DB.operations];
            } else {
                operations = DB.operations.filter(op => op.accountId === accountId);
            }

            // Ordenar por fecha
            operations.sort((a, b) => new Date(a.date) - new Date(b.date));

            if (operations.length === 0) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.font = '14px Arial';
                ctx.fillStyle = '#8b949e';
                ctx.textAlign = 'center';
                ctx.fillText('No hay operaciones para mostrar', canvas.width / 2, canvas.height / 2);
                return;
            }

            // Calcular balance inicial
            let initialBalance = 0;
            if (accountId === 'all') {
                initialBalance = DB.accounts.reduce((sum, acc) => {
                    return sum + convertCurrency(acc.initialBalance, acc.currency, DB.settings.defaultCurrency);
                }, 0);
            } else {
                const account = DB.accounts.find(a => a.id === accountId);
                if (account) {
                    initialBalance = convertCurrency(account.initialBalance, account.currency, DB.settings.defaultCurrency);
                }
            }

            // Preparar datos según la métrica seleccionada
            let cumulativePL = 0;
            const chartData = operations.map((op, idx) => {
                const pl = convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency);
                cumulativePL += pl;
                
                let yValue;
                if (metric === 'balance') {
                    yValue = initialBalance + cumulativePL;
                } else if (metric === 'return') {
                    yValue = cumulativePL;
                } else if (metric === 'return-pct') {
                    yValue = initialBalance > 0 ? (cumulativePL / initialBalance) * 100 : 0;
                }
                
                return {
                    x: new Date(op.date).getTime(),
                    y: yValue
                };
            });

            // Agregar punto inicial
            chartData.unshift({
                x: chartData.length > 0 ? chartData[0].x - 86400000 : new Date().getTime(),
                y: metric === 'balance' ? initialBalance : 0
            });

            // Configurar el tipo de gráfico
            const validChartType = (chartType === 'area' || chartType === 'line') ? 'line' : 'bar';

            // Configurar label y callback del eje Y según la métrica
            let yAxisLabel = 'Balance ($)';
            let yAxisCallback = v => '$' + v.toFixed(0);
            let tooltipCallback = (item) => `Balance: $${item.parsed.y.toFixed(2)}`;

            if (metric === 'return') {
                yAxisLabel = 'Return ($)';
                tooltipCallback = (item) => `Return: $${item.parsed.y.toFixed(2)}`;
            } else if (metric === 'return-pct') {
                yAxisLabel = 'Return (%)';
                yAxisCallback = v => v.toFixed(1) + '%';
                tooltipCallback = (item) => `Return: ${item.parsed.y.toFixed(2)}%`;
            }

            accountEvolutionChart = new Chart(ctx, {
                type: validChartType,
                data: {
                    datasets: [{
                        label: yAxisLabel,
                        data: chartData,
                        borderColor: '#39FF14',
                        backgroundColor: chartType === 'area' ? 'rgba(57, 255, 20, 0.2)' : '#39FF14',
                        borderWidth: chartType === 'bar' ? 0 : 2,
                        fill: chartType === 'area',
                        tension: 0.4,
                        pointRadius: 0,
                        pointHoverRadius: 6,
                        pointBackgroundColor: '#39FF14',
                        pointBorderColor: '#fff',
                        pointBorderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleColor: '#fff',
                            bodyColor: '#fff',
                            borderColor: '#39FF14',
                            borderWidth: 1,
                            callbacks: {
                                label: tooltipCallback,
                                title: (items) => {
                                    if (items[0]?.parsed?.x) {
                                        const date = new Date(items[0].parsed.x);
                                        return date.toLocaleDateString('es-ES', { 
                                            year: 'numeric', 
                                            month: 'short', 
                                            day: 'numeric' 
                                        });
                                    }
                                    return '';
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'day',
                                displayFormats: {
                                    day: 'MMM dd',
                                    week: 'MMM dd',
                                    month: 'MMM yyyy'
                                }
                            },
                            title: { display: true, text: 'Fecha', color: '#FFF' },
                            grid: { color: '#2a2a2a' },
                            ticks: { 
                                color: '#FFF',
                                maxRotation: 45,
                                minRotation: 0
                            }
                        },
                        y: {
                            title: { display: true, text: yAxisLabel, color: '#FFF' },
                            grid: { color: '#2a2a2a' },
                            ticks: { 
                                color: '#FFF',
                                callback: yAxisCallback
                            }
                        }
                    }
                }
            });
        }

        let dashboardRadarChart = null;
        function updateDashboardRadarChart(operations, accountId, chartId = 'dashboard-radar-chart') {
            console.log('🎯 [RADAR-ADV] Actualizando chart:', chartId, 'con', operations.length, 'operaciones');
            
            const ctx = document.getElementById(chartId)?.getContext('2d');
            if (!ctx) {
                console.error('❌ [RADAR-ADV] Context no encontrado para:', chartId);
                return;
            }
            
            // SIEMPRE destruir el gráfico existente
            if (chartId === 'dashboard-radar-chart' && dashboardRadarChart) {
                console.log('🔄 [RADAR-ADV] Destruyendo dashboard-radar-chart...');
                try {
                    dashboardRadarChart.destroy();
                } catch (e) {
                    console.warn('⚠️ [RADAR-ADV] Error al destruir:', e);
                }
                dashboardRadarChart = null;
            } else if (chartId === 'analytics-detail-radar-chart' && window.analyticsDetailRadarChart) {
                console.log('🔄 [RADAR-ADV] Destruyendo analytics-detail-radar-chart...');
                try {
                    window.analyticsDetailRadarChart.destroy();
                } catch (e) {
                    console.warn('⚠️ [RADAR-ADV] Error al destruir:', e);
                }
                window.analyticsDetailRadarChart = null;
            }

            const basicMetrics = calculateMetrics(operations, accountId);
            const advancedMetrics = calculateAdvancedMetrics(operations, accountId);

            let maxDrawdownPercentage = 0;
            if (operations.length > 0) {
                const sortedOps = [...operations].sort((a, b) => new Date(a.date + 'T' + (a.entryTime || '00:00')) - new Date(b.date + 'T' + (b.entryTime || '00:00')));
                let accountInitialBalance = 0;
                let accountCurrency = DB.settings.defaultCurrency;

                if (accountId !== 'all') {
                    const account = DB.accounts.find(a => a.id === accountId);
                    if (account) {
                        accountInitialBalance = account.initialBalance;
                        accountCurrency = account.currency;
                    }
                } else {
                    accountInitialBalance = DB.accounts.reduce((sum, acc) => sum + convertCurrency(acc.initialBalance, acc.currency, DB.settings.defaultCurrency), 0);
                }

                if (accountInitialBalance > 0) {
                    let peakBalance = accountInitialBalance;
                    let maxDrawdownValue = 0;
                    let currentBalance = accountInitialBalance;
                    sortedOps.forEach(op => {
                        let pl = convertCurrency(op.pl, op.currency, accountCurrency);
                        currentBalance += pl;
                        if (currentBalance > peakBalance) peakBalance = currentBalance;
                        const drawdown = peakBalance - currentBalance;
                        if (drawdown > maxDrawdownValue) maxDrawdownValue = drawdown;
                    });
                    maxDrawdownPercentage = (maxDrawdownValue / accountInitialBalance) * 100;
                }
            }


            const winRateScore = basicMetrics.winRate || 0;
            const profitFactorScore = Math.min(basicMetrics.profitFactor / 3, 1) * 100; // PF of 3.0 is 100%
            const avgWLRatio = advancedMetrics.avgWin && advancedMetrics.avgLoss ? Math.abs(advancedMetrics.avgWin / advancedMetrics.avgLoss) : 0;
            const avgWLRatioScore = Math.min(avgWLRatio / 3, 1) * 100; // Ratio of 3.0 is 100%
            const drawdownScore = Math.max(0, (1 - Math.min(maxDrawdownPercentage / 20, 1)) * 100); // 20% DD is 0 score

            let consistencyScore = 0;
            if (operations.length > 1) {
                console.log('📊 [CONSISTENCY-ADV] Calculando para', operations.length, 'operaciones');
                const dailyPL = {};
                operations.forEach(op => {
                    if (!dailyPL[op.date]) dailyPL[op.date] = 0;
                    const plValue = op.pl ?? op.pnl ?? 0;
                    const feeValue = op.fee ?? op.fees ?? 0;
                    const plInDefaultCurrency = convertCurrency(plValue, op.currency, DB.settings.defaultCurrency);
                    const feesInDefaultCurrency = convertCurrency(feeValue, op.currency, DB.settings.defaultCurrency);
                    dailyPL[op.date] += plInDefaultCurrency - feesInDefaultCurrency;
                });
                
                const dailyValues = Object.values(dailyPL);
                console.log('📊 [CONSISTENCY-ADV] Días únicos:', dailyValues.length);
                
                if (dailyValues.length >= 2) {
                    const avg = dailyValues.reduce((sum, v) => sum + v, 0) / dailyValues.length;
                    const variance = dailyValues.reduce((sum, v) => sum + Math.pow(v - avg, 2), 0) / dailyValues.length;
                    const stdDev = Math.sqrt(variance);
                    
                    console.log('📊 [CONSISTENCY-ADV] Avg:', avg.toFixed(2), 'StdDev:', stdDev.toFixed(2));
                    
                    if (Math.abs(avg) > 0.01) {
                        const coefficientOfVariation = stdDev / Math.abs(avg);
                        console.log('📊 [CONSISTENCY-ADV] CV:', coefficientOfVariation.toFixed(2));
                        
                        if (coefficientOfVariation < 0.3) {
                            consistencyScore = 95 + (0.3 - coefficientOfVariation) * 16.67;
                        } else if (coefficientOfVariation < 0.8) {
                            consistencyScore = 80 + (0.8 - coefficientOfVariation) * 30;
                        } else if (coefficientOfVariation < 1.5) {
                            consistencyScore = 60 + (1.5 - coefficientOfVariation) * 28.57;
                        } else if (coefficientOfVariation < 2.5) {
                            consistencyScore = 35 + (2.5 - coefficientOfVariation) * 25;
                        } else if (coefficientOfVariation < 4.0) {
                            consistencyScore = 10 + (4.0 - coefficientOfVariation) * 16.67;
                        } else {
                            consistencyScore = Math.max(0, 10 - (coefficientOfVariation - 4.0) * 2.5);
                        }
                        
                        consistencyScore = Math.max(0, Math.min(100, consistencyScore));
                    } else {
                        // Si avg es ~0, usar win rate diario
                        const winningDays = dailyValues.filter(pl => pl > 0).length;
                        consistencyScore = (winningDays / dailyValues.length) * 100;
                        console.log('📊 [CONSISTENCY-ADV] Avg ~0, usando winrate diario');
                    }
                    
                    console.log('✅ [CONSISTENCY-ADV] Score final:', consistencyScore.toFixed(1) + '%');
                }
            }
            
            console.log('🎯 [RADAR-ADV] Creando chart con scores:', [
                winRateScore, profitFactorScore, avgWLRatioScore, drawdownScore, consistencyScore
            ]);

            const radarChart = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: ['Win %', 'Profit Factor', 'Avg Win/Loss', 'Drawdown Ctrl', 'Consistencia'],
                    datasets: [{
                        label: 'Puntuación',
                        data: [winRateScore, profitFactorScore, avgWLRatioScore, drawdownScore, consistencyScore],
                        fill: true,
                        backgroundColor: 'rgba(57, 255, 20, 0.2)',
                        borderColor: 'rgba(57, 255, 20, 0.8)',
                        pointBackgroundColor: 'var(--primary)',
                        pointBorderColor: '#0a0a0a',
                        pointHoverBackgroundColor: '#FFFFFF',
                        pointHoverBorderColor: 'var(--primary)'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        r: {
                            min: 0,
                            max: 100,
                            angleLines: { color: '#2a2a2a' },
                            grid: { color: '#2a2a2a' },
                            pointLabels: { color: '#FFFFFF', font: { size: 11 } },
                            ticks: { display: false, stepSize: 20 }
                        }
                    },
                    plugins: { legend: { display: false } }
                }
            });

            // Asignar la nueva instancia de gráfico a la variable correcta
            if (chartId === 'dashboard-radar-chart') {
                dashboardRadarChart = radarChart;
                console.log('✅ [RADAR-ADV] dashboard-radar-chart creado con datos:', radarChart.data.datasets[0].data);
            } else if (chartId === 'analytics-detail-radar-chart') {
                window.analyticsDetailRadarChart = radarChart;
                console.log('✅ [RADAR-ADV] analytics-detail-radar-chart creado con datos:', radarChart.data.datasets[0].data);
            }
        }

        let instrumentPerformanceChart = null;
        let analyticsInstrumentPerformanceChart = null;
        let newDashInstrumentChart = null; // Nuevo chart para Dashboard
        
        function updateInstrumentPerformanceChart(operations, chartId) {
            const ctx = document.getElementById(chartId)?.getContext('2d');
            if (!ctx) return;
            if (chartId === 'instrument-performance-chart' && instrumentPerformanceChart) instrumentPerformanceChart.destroy();
            if (chartId === 'analytics-instrument-performance-chart' && analyticsInstrumentPerformanceChart) analyticsInstrumentPerformanceChart.destroy();
            if (chartId === 'analytics-detail-instrument-chart' && window.analyticsDetailInstrumentChart) window.analyticsDetailInstrumentChart.destroy();
            if (chartId === 'new-dash-instrument-chart' && newDashInstrumentChart) newDashInstrumentChart.destroy();

            const performance = {};
            operations.forEach(op => {
                // Validar que el instrumento existe
                if (!op.instrument || typeof op.instrument !== 'string') {
                    console.warn('Operación con instrumento inválido encontrada:', op);
                    return;
                }
                const instrumentKey = op.instrument.toUpperCase();
                if (!performance[instrumentKey]) performance[instrumentKey] = { total: 0 };
                const plInDefaultCurrency = convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency);
                const feesInDefaultCurrency = convertCurrency(op.fee || op.fees || 0, op.currency, DB.settings.defaultCurrency);
                performance[instrumentKey].total += plInDefaultCurrency - feesInDefaultCurrency;
            });
            const sorted = Object.entries(performance).sort((a, b) => b[1].total - a[1].total).slice(0, 10);
            const chart = new Chart(ctx, { type: 'bar', data: { labels: sorted.map(item => item[0]), datasets: [{ data: sorted.map(item => item[1].total), backgroundColor: sorted.map(item => item[1].total >= 0 ? '#00FF00' : '#FF0000') }] }, options: { indexAxis: 'y', responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } }, scales: { x: { grid: { color: '#2a2a2a' }, ticks: { color: '#FFFFFF' } }, y: { grid: { display: false }, ticks: { color: '#FFFFFF' } } } } });

            if (chartId === 'instrument-performance-chart') instrumentPerformanceChart = chart;
            else if (chartId === 'analytics-instrument-performance-chart') analyticsInstrumentPerformanceChart = chart;
            else if (chartId === 'analytics-detail-instrument-chart') window.analyticsDetailInstrumentChart = chart;
            else if (chartId === 'new-dash-instrument-chart') newDashInstrumentChart = chart;

        }

        let dayPerformanceChart = null;
        let newDashDayChart = null; // Nuevo chart para Dashboard
        
        function updateDayPerformanceChart(operations, chartId) {
            const ctx = document.getElementById(chartId)?.getContext('2d');
            if (!ctx) return;
            if (chartId === 'day-performance-chart' && dayPerformanceChart) dayPerformanceChart.destroy();
            if (chartId === 'new-dash-day-chart' && newDashDayChart) newDashDayChart.destroy();
            
            const days = ['Domingo', 'Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sábado'];
            const performance = Array(7).fill(0);
            operations.forEach(op => {
                if (!isValidOperation(op)) return;
                const day = new Date(op.date + 'T00:00:00').getUTCDay();
                const plInDefaultCurrency = convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency);
                const feesInDefaultCurrency = convertCurrency(op.fee || op.fees || 0, op.currency, DB.settings.defaultCurrency);
                performance[day] += plInDefaultCurrency - feesInDefaultCurrency;
            });
            
            const chart = new Chart(ctx, { type: 'bar', data: { labels: days, datasets: [{ data: performance, backgroundColor: performance.map(v => v >= 0 ? '#00FF00' : '#FF0000'), borderWidth: 0 }] }, options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } }, scales: { x: { grid: { display: false }, ticks: { color: '#FFFFFF' } }, y: { grid: { color: '#2a2a2a' }, ticks: { color: '#FFFFFF' } } } } });
            
            if (chartId === 'day-performance-chart') dayPerformanceChart = chart;
            else if (chartId === 'new-dash-day-chart') newDashDayChart = chart;
        }

        let typePerformanceChart = null;
        function updateTypePerformanceChart(operations, chartId) {
            const ctx = document.getElementById(chartId)?.getContext('2d');
            if (!ctx) return;
            if (chartId === 'type-performance-chart' && typePerformanceChart) typePerformanceChart.destroy();
            if (chartId === 'analytics-detail-long-short-chart' && window.analyticsDetailLongShortChart) window.analyticsDetailLongShortChart.destroy();


            const calcPL = (type, result) => operations
                .filter(op => op.type === type && op.result === result)
                .reduce((sum, op) => sum + convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency), 0);

            const buyWin = calcPL('buy', 'win');
            const buyLoss = calcPL('buy', 'loss');
            const sellWin = calcPL('sell', 'win');
            const sellLoss = calcPL('sell', 'loss');

            const chart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['Compra (Long)', 'Venta (Short)'],
                    datasets: [
                        {
                            label: 'Ganancias',
                            data: [buyWin, sellWin],
                            backgroundColor: '#00FF00'
                        },
                        {
                            label: 'Pérdidas',
                            data: [buyLoss, sellLoss],
                            backgroundColor: '#FF0000'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { labels: { color: '#a0a0a0' } } },
                    scales: {
                        x: { stacked: true, grid: { display: false }, ticks: { color: '#FFFFFF' } },
                        y: { stacked: true, grid: { color: '#2a2a2a' }, ticks: { color: '#FFFFFF' } }
                    }
                }
            });

            if (chartId === 'type-performance-chart') typePerformanceChart = chart;
            else if (chartId === 'analytics-detail-long-short-chart') window.analyticsDetailLongShortChart = chart;

        }

        let financesEvolutionChart = null;
        function updateFinancesEvolutionChart(entries) {
            const ctx = document.getElementById('finances-evolution-chart').getContext('2d');
            if (financesEvolutionChart) financesEvolutionChart.destroy();

            const sortedEntries = [...entries].sort((a, b) => new Date(a.date) - new Date(b.date));
            const chartTargetCurrency = DB.settings.defaultCurrency;

            const labels = ['Inicio'];
            const dataPoints = [0];
            let currentBalance = 0;

            sortedEntries.forEach(entry => {
                let amountInTargetCurrency = entry.amount;
                if (entry.currency !== chartTargetCurrency) {
                    amountInTargetCurrency = convertCurrency(entry.amount, entry.currency, chartTargetCurrency);
                }
                currentBalance += amountInTargetCurrency;
                dataPoints.push(currentBalance);
                labels.push(formatDate(entry.date));
            });

            const yAxisFormatter = (val) => formatCurrency(val, chartTargetCurrency, chartTargetCurrency);

            financesEvolutionChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: `Balance en ${chartTargetCurrency}`,
                        data: dataPoints,
                        borderColor: '#FFFFFF',
                        backgroundColor: 'rgba(255, 255, 255, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.1,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true, maintainAspectRatio: false, interaction: { mode: 'index', intersect: false },
                    plugins: { legend: { display: false }, tooltip: { callbacks: { label: (ctx) => `Balance: ${yAxisFormatter(ctx.raw)}` } } },
                    scales: {
                        x: { grid: { display: false }, ticks: { color: '#FFFFFF' } },
                        y: { grid: { color: '#2a2a2a' }, ticks: { color: '#FFFFFF', callback: yAxisFormatter } }
                    }
                }
            });
        }

        // Gráfica de Flujo de Caja Mensual
        let financesCashflowChart = null;
        function updateFinancesCashflowChart(financeEntries, tradeOperations) {
            const canvas = document.getElementById('finances-cashflow-chart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            if (financesCashflowChart) financesCashflowChart.destroy();

            const targetCurrency = DB.settings.defaultCurrency;
            
            // Agrupar por mes
            const monthlyData = {};
            
            // Procesar movimientos financieros manuales
            financeEntries.forEach(entry => {
                const date = new Date(entry.date);
                const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                
                if (!monthlyData[monthKey]) {
                    monthlyData[monthKey] = { income: 0, expenses: 0, trading: 0 };
                }
                
                const amount = convertCurrency(entry.amount, entry.currency, targetCurrency);
                if (amount > 0) {
                    monthlyData[monthKey].income += amount;
                } else {
                    monthlyData[monthKey].expenses += Math.abs(amount);
                }
            });
            
            // Procesar operaciones de trading
            tradeOperations.forEach(op => {
                const date = new Date(op.date);
                const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                
                if (!monthlyData[monthKey]) {
                    monthlyData[monthKey] = { income: 0, expenses: 0, trading: 0 };
                }
                
                const pl = convertCurrency(op.pl, op.currency, targetCurrency);
                monthlyData[monthKey].trading += pl;
            });
            
            // Ordenar por fecha
            const sortedMonths = Object.keys(monthlyData).sort();
            const labels = sortedMonths.map(key => {
                const [year, month] = key.split('-');
                const monthNames = ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'];
                return `${monthNames[parseInt(month) - 1]} ${year}`;
            });
            
            const incomeData = sortedMonths.map(key => monthlyData[key].income);
            const expensesData = sortedMonths.map(key => monthlyData[key].expenses);
            const tradingData = sortedMonths.map(key => monthlyData[key].trading);
            
            financesCashflowChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels,
                    datasets: [
                        {
                            label: 'Trading P&L',
                            data: tradingData,
                            backgroundColor: 'rgba(41, 98, 255, 0.7)',
                            borderColor: '#2962ff',
                            borderWidth: 1
                        },
                        {
                            label: 'Ingresos Manuales',
                            data: incomeData,
                            backgroundColor: '#00FF00',
                            borderColor: '#39ff14',
                            borderWidth: 1
                        },
                        {
                            label: 'Gastos',
                            data: expensesData,
                            backgroundColor: '#FF0000',
                            borderColor: '#ff4136',
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: { color: '#a0a0a0', font: { size: 11 } }
                        },
                        tooltip: {
                            callbacks: {
                                label: (ctx) => `${ctx.dataset.label}: ${formatCurrency(ctx.raw, targetCurrency, targetCurrency)}`
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: { display: false },
                            ticks: { color: '#a0a0a0' }
                        },
                        y: {
                            grid: { color: '#2a2a2a' },
                            ticks: {
                                color: '#a0a0a0',
                                callback: (val) => formatCurrency(val, targetCurrency, targetCurrency)
                            }
                        }
                    }
                }
            });
        }

        // Gráfica de Profit vs Expenses
        let financesProfitExpensesChart = null;
        function updateFinancesProfitExpensesChart(financeEntries, tradeOperations) {
            const canvas = document.getElementById('finances-profit-expenses-chart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            if (financesProfitExpensesChart) financesProfitExpensesChart.destroy();

            const targetCurrency = DB.settings.defaultCurrency;
            
            // Calcular totales
            const tradingMetrics = calculateMetrics(tradeOperations, 'all');
            const tradingProfit = tradingMetrics.totalWin + tradingMetrics.totalLoss;
            
            let manualIncome = 0;
            let totalExpenses = 0;
            
            financeEntries.forEach(entry => {
                const amount = convertCurrency(entry.amount, entry.currency, targetCurrency);
                if (amount > 0) {
                    manualIncome += amount;
                } else {
                    totalExpenses += Math.abs(amount);
                }
            });
            
            const totalProfit = tradingProfit + manualIncome;
            const netBalance = totalProfit - totalExpenses;
            
            financesProfitExpensesChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['Trading P&L', 'Ingresos Manuales', 'Gastos Totales', 'Balance Neto'],
                    datasets: [{
                        data: [tradingProfit, manualIncome, totalExpenses, netBalance],
                        backgroundColor: [
                            tradingProfit >= 0 ? '#00FF00' : '#FF0000',
                            '#00FF00',
                            '#FF0000',
                            netBalance >= 0 ? '#00FF00' : '#FF0000'
                        ],
                        borderColor: [
                            tradingProfit >= 0 ? '#39ff14' : '#ff4136',
                            '#39ff14',
                            '#ff4136',
                            netBalance >= 0 ? '#39ff14' : '#ff4136'
                        ],
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (ctx) => formatCurrency(ctx.raw, targetCurrency, targetCurrency)
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: { display: false },
                            ticks: { 
                                color: '#a0a0a0',
                                font: { size: 10 }
                            }
                        },
                        y: {
                            grid: { color: '#2a2a2a' },
                            ticks: {
                                color: '#a0a0a0',
                                callback: (val) => formatCurrency(val, targetCurrency, targetCurrency)
                            }
                        }
                    }
                }
            });
        }

        // ===== FUNCIONES PARA NUEVAS SECCIONES DE FINANZAS =====
        
        // Función principal para actualizar vistas de finanzas según pestaña activa
        function updateFinancesView(viewId) {
            console.log('🔄 updateFinancesView llamada para:', viewId);
            
            // Auto-detectar y vincular cuentas funded ANTES de cualquier cálculo
            if (typeof autoDetectFundedAccounts === 'function') {
                const updated = autoDetectFundedAccounts();
                if (updated) {
                    console.log('🔗 Cuentas funded auto-vinculadas');
                }
            }
            
            const allFinances = DB.finances || [];
            const allOperations = DB.operations || [];
            console.log('📊 Finanzas disponibles:', allFinances.length);
            console.log('📊 Operaciones disponibles:', allOperations.length);
            
            // Destruir todos los gráficos antes de actualizar
            destroyAllFinanceCharts();
            
            switch(viewId) {
                case 'finances-view-dashboard':
                    updateDashboardView(allFinances, allOperations);
                    break;
                case 'finances-view-capital-propio':
                    updateCapitalPropioView(allFinances, allOperations);
                    break;
                case 'finances-view-funded':
                    updateFundedView(allFinances, allOperations);
                    break;
                case 'finances-view-movements':
                    refreshFinancesView();
                    break;
                case 'finances-view-calendar':
                    renderFinancialCalendar(allFinances, allOperations);
                    break;
                case 'finances-view-trackerbank':
                    updateTrackerBankView(allFinances, allOperations);
                    break;
            }
        }

        // Variables globales para los gráficos
        let dashboardCapitalDistChart = null;
        let dashboardIncomeDistChart = null;
        let dashboardTop3IncomeChart = null;
        let dashboardMonthlyEvolutionChart = null;
        let dashboardCapitalVsFundedChart = null;
        let dashboardTotalEvolutionChart = null;

        // Variables globales para TrackerBank
        let trackerbankEvolutionChart = null;
        let trackerbankVolumeChart = null;
        let trackerbankDistributionChart = null;
        let trackerbankExpensesCategoryChart = null;

        // Función para destruir todos los gráficos de finanzas
        function destroyAllFinanceCharts() {
            // Dashboard
            if (dashboardCapitalDistChart) { dashboardCapitalDistChart.destroy(); dashboardCapitalDistChart = null; }
            if (dashboardIncomeDistChart) { dashboardIncomeDistChart.destroy(); dashboardIncomeDistChart = null; }
            if (dashboardTop3IncomeChart) { dashboardTop3IncomeChart.destroy(); dashboardTop3IncomeChart = null; }
            if (dashboardMonthlyEvolutionChart) { dashboardMonthlyEvolutionChart.destroy(); dashboardMonthlyEvolutionChart = null; }
            if (dashboardCapitalVsFundedChart) { dashboardCapitalVsFundedChart.destroy(); dashboardCapitalVsFundedChart = null; }
            if (dashboardTotalEvolutionChart) { dashboardTotalEvolutionChart.destroy(); dashboardTotalEvolutionChart = null; }
            
            // Capital Propio
            if (capitalEvolutionChart) { capitalEvolutionChart.destroy(); capitalEvolutionChart = null; }
            if (capitalIncomeExpensesDonut) { capitalIncomeExpensesDonut.destroy(); capitalIncomeExpensesDonut = null; }
            if (capitalMonthlyPerformanceChart) { capitalMonthlyPerformanceChart.destroy(); capitalMonthlyPerformanceChart = null; }
            if (capitalTop3MovementsChart) { capitalTop3MovementsChart.destroy(); capitalTop3MovementsChart = null; }
            if (capitalWeeklyTrendChart) { capitalWeeklyTrendChart.destroy(); capitalWeeklyTrendChart = null; }
            
            // Funded
            if (fundedEvolutionChart) { fundedEvolutionChart.destroy(); fundedEvolutionChart = null; }
            if (fundedExpensesDonut) { fundedExpensesDonut.destroy(); fundedExpensesDonut = null; }
            if (fundedProfitExpensesChart) { fundedProfitExpensesChart.destroy(); fundedProfitExpensesChart = null; }
            if (fundedAccountPerformanceChart) { fundedAccountPerformanceChart.destroy(); fundedAccountPerformanceChart = null; }
            if (fundedMonthlyTrendChart) { fundedMonthlyTrendChart.destroy(); fundedMonthlyTrendChart = null; }
            
            // TrackerBank
            if (trackerbankEvolutionChart) { trackerbankEvolutionChart.destroy(); trackerbankEvolutionChart = null; }
            if (trackerbankVolumeChart) { trackerbankVolumeChart.destroy(); trackerbankVolumeChart = null; }
            if (trackerbankDistributionChart) { trackerbankDistributionChart.destroy(); trackerbankDistributionChart = null; }
            if (trackerbankExpensesCategoryChart) { trackerbankExpensesCategoryChart.destroy(); trackerbankExpensesCategoryChart = null; }
            if (trackerbankCashflowChart) { trackerbankCashflowChart.destroy(); trackerbankCashflowChart = null; }
            if (trackerbankBankEvolutionChart) { trackerbankBankEvolutionChart.destroy(); trackerbankBankEvolutionChart = null; }
        }

        // Actualizar Dashboard Principal
        function updateDashboardView(finances, operations) {
            console.log('📊 updateDashboardView - Finanzas recibidas:', finances.length);
            const targetCurrency = DB.settings.defaultCurrency;
            
            // Asegurarse de que finances es un array
            if (!Array.isArray(finances)) {
                console.error('❌ finances no es un array:', finances);
                finances = [];
            }
            
            // DEBUG: Mostrar tipo de cuentas
            console.log('🔍 DEBUG Dashboard - Tipos de cuenta:');
            DB.accounts.forEach(acc => {
                console.log(`  - ${acc.name}: type="${acc.accountType || 'undefined'}"`);
            });
            
            // ===== CALCULAR CAPITAL PROPIO =====
            // Son todas las cuentas que NO son 'funded'
            const capitalAccounts = DB.accounts.filter(acc => 
                !acc.accountType || acc.accountType !== 'funded'
            );
            
            console.log(`💰 Capital Propio: ${capitalAccounts.length} cuentas`);
            capitalAccounts.forEach(acc => console.log(`  - ${acc.name}`));
            
            let capitalBalance = 0;
            let capitalInitialBalance = 0;
            let capitalPL = 0;
            let capitalFees = 0;
            
            capitalAccounts.forEach(account => {
                const initialBalance = parseFloat(account.initialBalance) || 0;
                capitalInitialBalance += convertCurrency(initialBalance, account.currency, targetCurrency);
                
                const accountOps = operations.filter(op => op.accountId === account.id);
                accountOps.forEach(op => {
                    capitalPL += convertCurrency(op.pl || 0, op.currency, targetCurrency);
                    capitalFees += convertCurrency(op.fees || 0, op.currency, targetCurrency);
                });
            });
            
            capitalBalance = capitalInitialBalance + capitalPL - capitalFees;
            
            // ===== CALCULAR FUNDED =====
            const fundedAccounts = DB.fundedAccounts || [];
            console.log(`🏆 Funded: ${fundedAccounts.length} cuentas en DB.fundedAccounts`);
            
            let fundedBalance = 0;
            let fundedPL = 0;
            let fundedFees = 0;
            
            fundedAccounts.forEach(account => {
                fundedPL += parseFloat(account.earnings) || 0;
                fundedFees += parseFloat(account.fee) || 0;
            });
            
            fundedBalance = fundedPL - fundedFees;
            
            // ===== TOTALES =====
            const totalBalance = capitalBalance + fundedBalance;
            const totalIncome = capitalPL + fundedPL;
            const totalExpenses = capitalFees + fundedFees;
            const netProfit = totalIncome - totalExpenses;
            
            console.log('💰 Dashboard Métricas:');
            console.log('   - Capital Propio:', capitalBalance);
            console.log('   - Funded:', fundedBalance);
            console.log('   - Total Balance:', totalBalance);
            console.log('   - Total Income:', totalIncome);
            console.log('   - Total Expenses:', totalExpenses);
            
            // Actualizar métricas en el HTML
            const totalBalanceEl = document.getElementById('dashboard-total-balance');
            const capitalBalanceEl = document.getElementById('dashboard-capital-balance');
            const fundedBalanceEl = document.getElementById('dashboard-funded-balance');
            const totalIncomeEl = document.getElementById('dashboard-total-income');
            const totalExpensesEl = document.getElementById('dashboard-total-expenses');
            
            if (totalBalanceEl) totalBalanceEl.textContent = formatCurrency(totalBalance, targetCurrency, targetCurrency);
            if (capitalBalanceEl) capitalBalanceEl.textContent = formatCurrency(capitalBalance, targetCurrency, targetCurrency);
            if (fundedBalanceEl) fundedBalanceEl.textContent = formatCurrency(fundedBalance, targetCurrency, targetCurrency);
            if (totalIncomeEl) totalIncomeEl.textContent = formatCurrency(totalIncome, targetCurrency, targetCurrency);
            if (totalExpensesEl) totalExpensesEl.textContent = formatCurrency(totalExpenses, targetCurrency, targetCurrency);
            
            // Actualizar gráficos con datos de cuentas
            updateDashboardCapitalDistribution(capitalBalance, fundedBalance, targetCurrency);
            updateDashboardIncomeDistribution(capitalAccounts, fundedAccounts, operations, targetCurrency);
            updateDashboardCapitalVsFunded(capitalAccounts, fundedAccounts, operations, targetCurrency);
            updateDashboardTop3Income(finances, targetCurrency);
            updateDashboardMonthlyEvolution(finances, targetCurrency);
            updateDashboardTotalEvolution(finances, targetCurrency);
        }

        // Gráfico Donut: Distribución de Capital
        function updateDashboardCapitalDistribution(capitalBalance, fundedBalance, currency) {
            const canvas = document.getElementById('dashboard-capital-distribution-chart');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            
            if (dashboardCapitalDistChart) dashboardCapitalDistChart.destroy();
            
            // Calcular balance total de cuentas live activas
            const liveAccountsBalance = (DB.fundedAccounts || [])
                .filter(a => a.type === 'live' && a.status === 'active')
                .reduce((sum, a) => sum + (parseFloat(a.balance) || 0), 0);
            
            // Añadir el balance de las cuentas live al total de funded
            const totalFundedWithBalance = Math.abs(fundedBalance) + liveAccountsBalance;
            
            dashboardCapitalDistChart = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: ['Capital Propio', 'Funded (Ganancias)', 'Funded (Balance Live)'],
                    datasets: [{
                        data: [Math.abs(capitalBalance), Math.abs(fundedBalance), liveAccountsBalance],
                        backgroundColor: [
                            '#00FF00', 
                            'rgba(16, 185, 129, 0.7)',
                            'rgba(147, 51, 234, 0.7)'
                        ],
                        borderColor: ['#39ff14', '#10b981', '#9333ea'],
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { 
                            display: true,
                            position: 'bottom',
                            labels: { color: '#ffffff', padding: 15 }
                        },
                        tooltip: {
                            callbacks: {
                                label: (ctx) => `${ctx.label}: ${formatCurrency(ctx.raw, currency, currency)}`
                            }
                        }
                    }
                }
            });
        }

        // Gráfico Donut: Distribución de Ganancias
        function updateDashboardIncomeDistribution(capitalAccounts, fundedAccounts, operations, currency) {
            const canvas = document.getElementById('dashboard-income-distribution-chart');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            
            if (dashboardIncomeDistChart) dashboardIncomeDistChart.destroy();
            
            // Calcular ingresos de Capital Propio
            let capitalIncome = 0;
            capitalAccounts.forEach(account => {
                const accountOps = operations.filter(op => op.accountId === account.id && (op.pl || 0) > 0);
                accountOps.forEach(op => {
                    capitalIncome += convertCurrency(op.pl || 0, op.currency, currency);
                });
            });
            
            // Calcular ingresos de Funded
            let fundedIncome = 0;
            fundedAccounts.forEach(account => {
                fundedIncome += parseFloat(account.earnings) || 0;
            });
            
            dashboardIncomeDistChart = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: ['Capital Propio', 'Funded'],
                    datasets: [{
                        data: [capitalIncome, fundedIncome],
                        backgroundColor: ['#00FF00', 'rgba(16, 185, 129, 0.7)'],
                        borderColor: ['#39ff14', '#10b981'],
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { 
                            display: true,
                            position: 'bottom',
                            labels: { color: '#ffffff', padding: 15 }
                        },
                        tooltip: {
                            callbacks: {
                                label: (ctx) => `${ctx.label}: ${formatCurrency(ctx.raw, currency, currency)}`
                            }
                        }
                    }
                }
            });
        }

        // Gráfico de Barras: Top 3 Fuentes de Ingreso
        function updateDashboardTop3Income(finances, currency) {
            const canvas = document.getElementById('dashboard-top3-income-chart');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            
            if (dashboardTop3IncomeChart) dashboardTop3IncomeChart.destroy();
            
            const incomes = finances.filter(f => f.amount > 0)
                .map(f => ({
                    description: f.notes || 'Sin descripción',
                    amount: convertCurrency(f.amount, f.currency, currency)
                }))
                .sort((a, b) => b.amount - a.amount)
                .slice(0, 3);
            
            dashboardTop3IncomeChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: incomes.map((_, i) => `#${i + 1}`),
                    datasets: [{
                        label: 'Ingreso',
                        data: incomes.map(i => i.amount),
                        backgroundColor: '#00FF00',
                        borderColor: '#39ff14',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                title: (ctx) => incomes[ctx[0].dataIndex]?.description || '',
                                label: (ctx) => formatCurrency(ctx.raw, currency, currency)
                            }
                        }
                    },
                    scales: {
                        x: { grid: { display: false }, ticks: { color: '#a0a0a0' } },
                        y: { 
                            grid: { color: '#2a2a2a' },
                            ticks: { 
                                color: '#a0a0a0',
                                callback: (val) => formatCurrency(val, currency, currency)
                            }
                        }
                    }
                }
            });
        }

        // Gráfico de Barras: Evolución Últimos 5 Meses
        function updateDashboardMonthlyEvolution(finances, currency) {
            const canvas = document.getElementById('dashboard-monthly-evolution-chart');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            
            if (dashboardMonthlyEvolutionChart) dashboardMonthlyEvolutionChart.destroy();
            
            const monthlyData = {};
            finances.forEach(f => {
                const date = new Date(f.date);
                const key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                if (!monthlyData[key]) monthlyData[key] = 0;
                monthlyData[key] += convertCurrency(f.amount, f.currency, currency);
            });
            
            const sortedMonths = Object.keys(monthlyData).sort().slice(-5);
            const labels = sortedMonths.map(m => {
                const [year, month] = m.split('-');
                const monthNames = ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'];
                return `${monthNames[parseInt(month) - 1]}`;
            });
            const data = sortedMonths.map(m => monthlyData[m]);
            
            dashboardMonthlyEvolutionChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Balance Neto',
                        data: data,
                        backgroundColor: data.map(v => v >= 0 ? '#00FF00' : '#FF0000'),
                        borderColor: data.map(v => v >= 0 ? '#39ff14' : '#ff4136'),
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (ctx) => formatCurrency(ctx.raw, currency, currency)
                            }
                        }
                    },
                    scales: {
                        x: { grid: { display: false }, ticks: { color: '#a0a0a0' } },
                        y: { 
                            grid: { color: '#2a2a2a' },
                            ticks: { 
                                color: '#a0a0a0',
                                callback: (val) => formatCurrency(val, currency, currency)
                            }
                        }
                    }
                }
            });
        }

        // Gráfico de Barras: Capital vs Funded (Comparativa)
        function updateDashboardCapitalVsFunded(capitalAccounts, fundedAccounts, operations, currency) {
            const canvas = document.getElementById('dashboard-capital-vs-funded-chart');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            
            if (dashboardCapitalVsFundedChart) dashboardCapitalVsFundedChart.destroy();
            
            // Calcular balance de Capital Propio
            let capitalBalance = 0;
            capitalAccounts.forEach(account => {
                const initialBalance = parseFloat(account.initialBalance) || 0;
                capitalBalance += convertCurrency(initialBalance, account.currency, currency);
                
                const accountOps = operations.filter(op => op.accountId === account.id);
                accountOps.forEach(op => {
                    capitalBalance += convertCurrency(op.pl || 0, op.currency, currency);
                    capitalBalance -= convertCurrency(op.fees || 0, op.currency, currency);
                });
            });
            
            // Calcular balance de Funded
            let fundedBalance = 0;
            fundedAccounts.forEach(account => {
                fundedBalance += (parseFloat(account.earnings) || 0) - (parseFloat(account.fee) || 0);
            });
            
            dashboardCapitalVsFundedChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['Capital Propio', 'Funded'],
                    datasets: [{
                        label: 'Rendimiento',
                        data: [capitalBalance, fundedBalance],
                        backgroundColor: ['#00FF00', 'rgba(16, 185, 129, 0.7)'],
                        borderColor: ['#39ff14', '#10b981'],
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (ctx) => formatCurrency(ctx.raw, currency, currency)
                            }
                        }
                    },
                    scales: {
                        x: { grid: { display: false }, ticks: { color: '#a0a0a0' } },
                        y: { 
                            grid: { color: '#2a2a2a' },
                            ticks: { 
                                color: '#a0a0a0',
                                callback: (val) => formatCurrency(val, currency, currency)
                            }
                        }
                    }
                }
            });
        }

        // Gráfico de Línea: Evolución del Balance Total
        function updateDashboardTotalEvolution(finances, currency) {
            const canvas = document.getElementById('dashboard-total-evolution-chart');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            
            if (dashboardTotalEvolutionChart) dashboardTotalEvolutionChart.destroy();
            
            const sorted = [...finances].sort((a, b) => new Date(a.date) - new Date(b.date));
            let cumulative = 0;
            const labels = [];
            const data = [];
            
            sorted.forEach(f => {
                cumulative += convertCurrency(f.amount, f.currency, currency);
                labels.push(formatDate(f.date));
                data.push(cumulative);
            });
            
            dashboardTotalEvolutionChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Balance Acumulado',
                        data: data,
                        borderColor: '#39ff14',
                        backgroundColor: 'rgba(57, 255, 20, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (ctx) => formatCurrency(ctx.parsed.y, currency, currency)
                            }
                        }
                    },
                    scales: {
                        x: { 
                            grid: { display: false },
                            ticks: { 
                                color: '#a0a0a0',
                                maxTicksLimit: 10
                            }
                        },
                        y: { 
                            grid: { color: '#2a2a2a' },
                            ticks: { 
                                color: '#a0a0a0',
                                callback: (val) => formatCurrency(val, currency, currency)
                            }
                        }
                    }
                }
            });
        }

        // Variables para gráficos de Capital Propio
        let capitalEvolutionChart = null;
        let capitalIncomeExpensesDonut = null;
        let capitalMonthlyPerformanceChart = null;
        let capitalTop3MovementsChart = null;
        let capitalWeeklyTrendChart = null;

        // ========================================
        // FUNCIONES DE SINCRONIZACIÓN FUNDED
        // ========================================
        
        // Auto-detectar y marcar cuentas funded por nombre
        function autoDetectFundedAccounts() {
            if (!DB.fundedAccounts || !DB.accounts) return;
            
            let updated = 0;
            
            DB.fundedAccounts.forEach(fundedAcc => {
                // Buscar cuenta en DB.accounts con el mismo nombre
                const matchingAccount = DB.accounts.find(acc => 
                    acc.name && fundedAcc.name && 
                    acc.name.trim().toLowerCase() === fundedAcc.name.trim().toLowerCase()
                );
                
                if (matchingAccount && matchingAccount.accountType !== 'funded') {
                    console.log(`🔗 Auto-vinculando cuenta: ${matchingAccount.name}`);
                    matchingAccount.accountType = 'funded';
                    matchingAccount.fundedAccountId = fundedAcc.id;
                    
                    // Guardar en IndexedDB
                    if (typeof dexieDB !== 'undefined') {
                        dexieDB.accounts.put(matchingAccount);
                    }
                    
                    updated++;
                }
            });
            
            if (updated > 0) {
                console.log(`✅ Auto-vinculadas ${updated} cuentas funded`);
                return true;
            }
            
            return false;
        }
        
        // Sincronizar balances de cuentas funded con operaciones
        function syncFundedAccountBalances(accounts, operations) {
            accounts.forEach(account => {
                // Calcular balance desde operaciones
                const accountOps = operations.filter(op => op.accountId === account.id);
                let calculatedBalance = parseFloat(account.initialBalance) || 0;
                let totalEarnings = 0;
                
                accountOps.forEach(op => {
                    const pl = op.pl || 0;
                    calculatedBalance += pl;
                    if (pl > 0) totalEarnings += pl;
                });
                
                // Actualizar balance si cambió
                if (account.balance !== calculatedBalance) {
                    account.balance = calculatedBalance;
                    account.earnings = totalEarnings;
                    // Guardar cambios
                    saveFundedAccountToLocalDB(account);
                }
            });
        }
        
        // Crear registro histórico cuando se borra o suspende una cuenta
        async function createFundedAccountHistoryRecord(account, action) {
            const historyRecord = {
                id: generateId(),
                accountId: account.id,
                accountName: account.name,
                firm: account.firm,
                balance: account.balance || 0,
                earnings: account.earnings || 0,
                fee: account.fee || 0,
                status: account.status,
                action: action, // 'suspended', 'deleted', 'completed'
                date: new Date().toISOString().split('T')[0],
                timestamp: Date.now(),
                notes: `Cuenta ${action === 'suspended' ? 'suspendida' : action === 'deleted' ? 'eliminada' : 'completada'}. Balance final: $${account.balance || 0}`
            };
            
            // Guardar en IndexedDB
            if (typeof dexieDB !== 'undefined') {
                await dexieDB.fundedHistory.add(historyRecord);
            }
            
            // Guardar en Supabase si hay usuario
            if (typeof currentUser !== 'undefined' && currentUser) {
                await saveFundedHistoryToSupabase(historyRecord);
            }
            
            console.log('📝 Registro histórico creado:', historyRecord);
            return historyRecord;
        }
        
        // Guardar cuenta funded en IndexedDB
        async function saveFundedAccountToLocalDB(account) {
            if (typeof dexieDB !== 'undefined') {
                await dexieDB.fundedAccounts.put(account);
            }
            
            // Actualizar en memoria
            const index = DB.fundedAccounts.findIndex(acc => acc.id === account.id);
            if (index !== -1) {
                DB.fundedAccounts[index] = account;
            }
        }
        
        // Guardar historial en Supabase
        async function saveFundedHistoryToSupabase(record) {
            if (typeof window.supabase === 'undefined') return;
            
            try {
                const { error } = await window.supabase
                    .from('funded_history')
                    .insert([{
                        user_id: currentUser.id,
                        account_id: record.accountId,
                        account_name: record.accountName,
                        firm: record.firm,
                        balance: record.balance,
                        earnings: record.earnings,
                        fee: record.fee,
                        status: record.status,
                        action: record.action,
                        notes: record.notes,
                        created_at: new Date().toISOString()
                    }]);
                
                if (error) throw error;
                console.log('✅ Historial guardado en Supabase');
            } catch (error) {
                console.error('❌ Error guardando historial:', error);
            }
        }

        // Función para poblar selector de cuentas de Capital Propio
        function populateCapitalPropioAccountSelect() {
            const select = document.getElementById('capital-propio-account-select');
            if (!select) return;
            
            // Filtrar solo cuentas que NO sean de fondeo
            const capitalAccounts = DB.accounts.filter(acc => 
                !acc.accountType || acc.accountType !== 'funded'
            );
            
            select.innerHTML = '<option value="all">Todas las cuentas</option>';
            
            capitalAccounts.forEach(acc => {
                const option = document.createElement('option');
                option.value = acc.id;
                option.textContent = acc.name;
                select.appendChild(option);
            });
        }
        
        // Función para poblar selector de cuentas Funded
        function populateFundedAccountSelect() {
            const select = document.getElementById('funded-account-select');
            if (!select) return;
            
            select.innerHTML = '<option value="all">Todas las cuentas</option>';
            
            // Solo mostrar cuentas activas (no suspendidas)
            const activeAccounts = (DB.fundedAccounts || []).filter(acc => acc.status === 'active');
            
            activeAccounts.forEach(acc => {
                const option = document.createElement('option');
                option.value = acc.id;
                option.textContent = acc.name;
                select.appendChild(option);
            });
            
            console.log('✅ Selector de cuentas funded poblado:', activeAccounts.length, 'cuentas activas');
        }
        
        // Función para poblar selector de cuentas del NUEVO Dashboard
        function populateNewDashboardAccountSelect() {
            const select = document.getElementById('new-dashboard-account-select');
            if (!select) return;
            
            select.innerHTML = '<option value="all">Todas las cuentas</option>';
            
            DB.accounts.forEach(acc => {
                const option = document.createElement('option');
                option.value = acc.id;
                option.textContent = acc.name;
                select.appendChild(option);
            });
            
            console.log('✅ Selector de cuentas del nuevo dashboard poblado:', DB.accounts.length, 'cuentas');
        }
        
        // Función para actualizar logo de cuenta en Capital Propio
        function updateCapitalPropioAccountLogo(accountId) {
            const logoContainer = document.getElementById('capital-propio-account-logo');
            const logoImg = document.getElementById('capital-propio-account-logo-img');
            if (!logoContainer || !logoImg) return;
            
            if (accountId === 'all') {
                logoContainer.style.display = 'none';
                logoImg.src = '';
                return;
            }
            
            const account = DB.accounts.find(a => a.id === accountId);
            if (!account) {
                logoContainer.style.display = 'none';
                logoImg.src = '';
                return;
            }
            
            const platformLogo = getPlatformLogo(account.platform);
            logoContainer.style.backgroundColor = platformLogo.color;
            logoContainer.style.display = 'flex';
            logoImg.src = platformLogo.file;
            logoImg.alt = account.platform;
            logoImg.style.display = 'block';
            
            logoImg.onerror = function() {
                logoImg.style.display = 'none';
                const existingInitials = logoContainer.querySelector('.platform-initials');
                if (existingInitials) existingInitials.remove();
                logoContainer.innerHTML += `<div class="platform-initials text-white font-bold text-lg">${platformLogo.initials}</div>`;
            };
            
            logoImg.onload = function() {
                const existingInitials = logoContainer.querySelector('.platform-initials');
                if (existingInitials) existingInitials.remove();
            };
        }
        
        // Función para actualizar logo de cuenta en Funded
        function updateFundedAccountLogo(accountId) {
            const logoContainer = document.getElementById('funded-account-logo');
            const logoImg = document.getElementById('funded-account-logo-img');
            if (!logoContainer || !logoImg) return;
            
            if (accountId === 'all') {
                logoContainer.style.display = 'none';
                logoImg.src = '';
                return;
            }
            
            const account = DB.fundedAccounts.find(a => a.id === accountId);
            if (!account) {
                logoContainer.style.display = 'none';
                logoImg.src = '';
                return;
            }
            
            // Para funded accounts, usar el logo de la firma (prop firm)
            const firmLogos = {
                'ftmo': { file: 'logos/ftmo-logo.png', color: '#1E3A8A', initials: 'FT' },
                'topstep': { file: 'logos/topstep-logo.png', color: '#059669', initials: 'TS' },
                'apex': { file: 'logos/apex-logo.png', color: '#DC2626', initials: 'AP' },
                'e8': { file: 'logos/e8-logo.png', color: '#7C3AED', initials: 'E8' },
                'fundedrading': { file: 'logos/funded-logo.png', color: '#0891B2', initials: 'FR' },
                'myfundedfx': { file: 'logos/myfunded-logo.png', color: '#10B981', initials: 'MF' },
                'ftprotrading': { file: 'logos/ftpro-logo.png', color: '#F59E0B', initials: 'FP' }
            };
            
            const firm = (account.firm || '').toLowerCase();
            const firmLogo = firmLogos[firm] || { file: '', color: '#F59E0B', initials: '🏆' };
            
            logoContainer.style.backgroundColor = firmLogo.color;
            logoContainer.style.display = 'flex';
            
            if (firmLogo.file) {
                logoImg.src = firmLogo.file;
                logoImg.alt = account.firm;
                logoImg.style.display = 'block';
                
                logoImg.onerror = function() {
                    logoImg.style.display = 'none';
                    const existingInitials = logoContainer.querySelector('.platform-initials');
                    if (existingInitials) existingInitials.remove();
                    logoContainer.innerHTML += `<div class="platform-initials text-white font-bold text-lg">${firmLogo.initials}</div>`;
                };
                
                logoImg.onload = function() {
                    const existingInitials = logoContainer.querySelector('.platform-initials');
                    if (existingInitials) existingInitials.remove();
                };
            } else {
                logoImg.style.display = 'none';
                const existingInitials = logoContainer.querySelector('.platform-initials');
                if (existingInitials) existingInitials.remove();
                logoContainer.innerHTML += `<div class="platform-initials text-white font-bold text-lg">${firmLogo.initials}</div>`;
            }
        }

        // Actualizar vista de Capital Propio
        function updateCapitalPropioView(finances, operations) {
            console.log('📊 updateCapitalPropioView - Finanzas recibidas:', finances.length);
            const targetCurrency = DB.settings.defaultCurrency;
            
            // Obtener cuenta seleccionada
            const selectedAccountId = document.getElementById('capital-propio-account-select')?.value || 'all';
            
            // DEBUG: Mostrar todas las cuentas y su tipo
            console.log('🔍 DEBUG - Todas las cuentas:');
            DB.accounts.forEach(acc => {
                console.log(`  - ${acc.name}: accountType="${acc.accountType || 'undefined'}" ${acc.accountType === 'funded' ? '🏆 FUNDED' : '💰 CAPITAL PROPIO'}`);
            });
            
            // CALCULAR BALANCE DE CUENTAS DE CAPITAL PROPIO
            // Son todas las cuentas que NO son de fondeo (accountType !== 'funded')
            let capitalAccounts = DB.accounts.filter(acc => 
                !acc.accountType || acc.accountType !== 'funded'
            );
            
            console.log(`✅ Cuentas de Capital Propio filtradas: ${capitalAccounts.length} de ${DB.accounts.length} totales`);
            
            // Filtrar por cuenta seleccionada si no es "all"
            if (selectedAccountId !== 'all') {
                capitalAccounts = capitalAccounts.filter(acc => acc.id === selectedAccountId);
                operations = operations.filter(op => op.accountId === selectedAccountId);
            }
            
            console.log('🏦 Cuentas de Capital Propio encontradas:', capitalAccounts.length);
            console.log('📋 DEBUG - Listado de cuentas:', capitalAccounts.map(acc => `${acc.name}`));
            
            let totalBalance = 0;
            let totalInitialBalance = 0;
            let totalPL = 0;
            let totalFees = 0;
            
            // Calcular balance y P/L de cada cuenta de capital propio
            capitalAccounts.forEach(account => {
                const initialBalance = parseFloat(account.initialBalance) || 0;
                totalInitialBalance += convertCurrency(initialBalance, account.currency, targetCurrency);
                
                // Calcular P/L de operaciones de esta cuenta
                const accountOps = operations.filter(op => op.accountId === account.id);
                accountOps.forEach(op => {
                    const pl = convertCurrency(op.pl || 0, op.currency, targetCurrency);
                    const fees = convertCurrency(op.fees || 0, op.currency, targetCurrency);
                    totalPL += pl;
                    totalFees += fees;
                });
            });
            
            // Balance actual = Balance inicial + P/L - Fees
            totalBalance = totalInitialBalance + totalPL - totalFees;
            
            // Movimientos manuales de finanzas de capital propio
            const capitalFinances = finances.filter(f => f.accountType === 'capital');
            let manualIncome = 0, manualExpenses = 0;
            capitalFinances.forEach(f => {
                const amount = convertCurrency(f.amount, f.currency, targetCurrency);
                if (amount > 0) manualIncome += amount;
                else manualExpenses += Math.abs(amount);
            });
            
            const netProfit = totalPL - totalFees;
            const roi = totalInitialBalance > 0 ? ((netProfit / totalInitialBalance) * 100) : 0;
            
            console.log('💰 Capital Propio Métricas:');
            console.log('   - Balance Inicial:', totalInitialBalance);
            console.log('   - P/L Trading:', totalPL);
            console.log('   - Fees:', totalFees);
            console.log('   - Balance Actual:', totalBalance);
            console.log('   - ROI:', roi.toFixed(2) + '%');
            
            // Actualizar métricas en el HTML
            const capitalBalanceEl = document.getElementById('capital-total-balance');
            const capitalProfitEl = document.getElementById('capital-total-profit');
            const capitalExpensesEl = document.getElementById('capital-total-expenses');
            const capitalRoiEl = document.getElementById('capital-roi');
            const capitalGrowthEl = document.getElementById('capital-growth');
            const capitalAccountsCountEl = document.getElementById('capital-accounts-count');
            
            if (capitalBalanceEl) capitalBalanceEl.textContent = formatCurrency(totalBalance, targetCurrency, targetCurrency);
            if (capitalProfitEl) capitalProfitEl.textContent = formatCurrency(totalPL, targetCurrency, targetCurrency);
            if (capitalExpensesEl) capitalExpensesEl.textContent = formatCurrency(totalFees, targetCurrency, targetCurrency);
            if (capitalRoiEl) capitalRoiEl.textContent = roi.toFixed(2) + '%';
            if (capitalGrowthEl) capitalGrowthEl.textContent = ((netProfit / totalInitialBalance) * 100).toFixed(2) + '%';
            if (capitalAccountsCountEl) capitalAccountsCountEl.textContent = capitalAccounts.length;
            
            // Actualizar tabla de cuentas
            updateCapitalAccountsTable(capitalAccounts, operations, targetCurrency);
            
            // Actualizar análisis por períodos
            updateCapitalPeriodAnalysis(capitalAccounts, operations, targetCurrency);
            
            // Actualizar gráficos solo si hay datos
            if (capitalAccounts.length > 0 || operations.length > 0) {
                updateCapitalEvolutionChart(capitalAccounts, operations, targetCurrency);
                updateCapitalIncomeExpensesDonut(capitalAccounts, operations, targetCurrency);
                updateCapitalMonthlyPerformance(capitalAccounts, operations, targetCurrency);
                updateCapitalTop3Movements(capitalAccounts, operations, targetCurrency);
                updateCapitalWeeklyTrend(capitalAccounts, operations, targetCurrency);
            } else {
                console.log('⚠️ No hay datos de Capital Propio para gráficos');
            }
        }

        // NUEVA FUNCIÓN: Tabla de cuentas de capital propio
        function updateCapitalAccountsTable(accounts, operations, currency) {
            const tbody = document.getElementById('capital-accounts-tbody');
            if (!tbody) return;
            
            tbody.innerHTML = '';
            
            accounts.forEach(account => {
                const initialBalance = parseFloat(account.initialBalance) || 0;
                const accountOps = operations.filter(op => op.accountId === account.id);
                
                let totalPL = 0;
                let totalFees = 0;
                let winCount = 0;
                let lossCount = 0;
                
                accountOps.forEach(op => {
                    const pl = convertCurrency(op.pl || 0, op.currency, currency);
                    const fees = convertCurrency(op.fees || 0, op.currency, currency);
                    totalPL += pl;
                    totalFees += fees;
                    
                    if (op.result === 'win') winCount++;
                    else if (op.result === 'loss') lossCount++;
                });
                
                const currentBalance = convertCurrency(initialBalance, account.currency, currency) + totalPL - totalFees;
                const netProfit = totalPL - totalFees;
                const roi = initialBalance > 0 ? ((netProfit / convertCurrency(initialBalance, account.currency, currency)) * 100) : 0;
                
                const row = `
                    <tr class="hover:bg-surface-light transition-colors">
                        <td class="py-3">${account.name}</td>
                        <td class="text-right hide-amount">${formatCurrency(convertCurrency(initialBalance, account.currency, currency), currency, currency)}</td>
                        <td class="text-right hide-amount font-semibold ${currentBalance >= initialBalance ? 'text-positive' : 'text-negative'}">${formatCurrency(currentBalance, currency, currency)}</td>
                        <td class="text-right hide-amount ${netProfit >= 0 ? 'text-positive' : 'text-negative'}">${formatCurrency(netProfit, currency, currency)}</td>
                        <td class="text-right">${accountOps.length} (${winCount}W/${lossCount}L)</td>
                        <td class="text-right ${roi >= 0 ? 'text-positive' : 'text-negative'}">${roi.toFixed(2)}%</td>
                        <td class="text-center">${account.currency}</td>
                        <td class="text-center"><span class="px-2 py-1 text-xs rounded bg-green-900 text-green">Activa</span></td>
                    </tr>
                `;
                tbody.innerHTML += row;
            });
        }

        function updateCapitalMovementsTable(finances) {
            const tbody = document.getElementById('capital-movements-tbody');
            if (!tbody) return;
            
            tbody.innerHTML = '';
            const sorted = [...finances].sort((a, b) => new Date(b.date) - new Date(a.date));
            
            sorted.forEach(f => {
                const row = `
                    <tr>
                        <td>${formatDate(f.date)}</td>
                        <td>${f.notes || 'Sin descripción'}</td>
                        <td class="${f.amount >= 0 ? 'text-positive' : 'text-negative'} font-semibold hide-amount">${formatCurrency(f.amount, f.currency, f.currency)}</td>
                        <td>${f.currency}</td>
                    </tr>
                `;
                tbody.innerHTML += row;
            });
        }

        // NUEVA FUNCIÓN: Análisis por períodos (Mensual, Trimestral, Anual)
        function updateCapitalPeriodAnalysis(accounts, operations, currency) {
            const now = new Date();
            const currentYear = now.getFullYear();
            const currentMonth = now.getMonth();
            const currentQuarter = Math.floor(currentMonth / 3);
            
            // Filtrar operaciones de cuentas de capital propio
            const capitalOps = operations.filter(op => {
                const account = accounts.find(acc => acc.id === op.accountId);
                return account !== undefined;
            });
            
            // Calcular balance inicial total
            let totalInitialBalance = 0;
            accounts.forEach(account => {
                totalInitialBalance += convertCurrency(parseFloat(account.initialBalance) || 0, account.currency, currency);
            });
            
            // ANÁLISIS MENSUAL
            const monthlyOps = capitalOps.filter(op => {
                const opDate = new Date(op.date);
                return opDate.getFullYear() === currentYear && opDate.getMonth() === currentMonth;
            });
            
            let monthlyPL = 0, monthlyFees = 0;
            monthlyOps.forEach(op => {
                monthlyPL += convertCurrency(op.pl || 0, op.currency, currency);
                monthlyFees += convertCurrency(op.fees || 0, op.currency, currency);
            });
            const monthlyBalance = monthlyPL - monthlyFees;
            const monthlyROI = totalInitialBalance > 0 ? ((monthlyBalance / totalInitialBalance) * 100) : 0;
            
            // ANÁLISIS TRIMESTRAL
            const quarterStartMonth = currentQuarter * 3;
            const quarterlyOps = capitalOps.filter(op => {
                const opDate = new Date(op.date);
                const opMonth = opDate.getMonth();
                return opDate.getFullYear() === currentYear && opMonth >= quarterStartMonth && opMonth < quarterStartMonth + 3;
            });
            
            let quarterlyPL = 0, quarterlyFees = 0;
            quarterlyOps.forEach(op => {
                quarterlyPL += convertCurrency(op.pl || 0, op.currency, currency);
                quarterlyFees += convertCurrency(op.fees || 0, op.currency, currency);
            });
            const quarterlyBalance = quarterlyPL - quarterlyFees;
            const quarterlyROI = totalInitialBalance > 0 ? ((quarterlyBalance / totalInitialBalance) * 100) : 0;
            
            // ANÁLISIS ANUAL
            const yearlyOps = capitalOps.filter(op => {
                const opDate = new Date(op.date);
                return opDate.getFullYear() === currentYear;
            });
            
            let yearlyPL = 0, yearlyFees = 0;
            yearlyOps.forEach(op => {
                yearlyPL += convertCurrency(op.pl || 0, op.currency, currency);
                yearlyFees += convertCurrency(op.fees || 0, op.currency, currency);
            });
            const yearlyBalance = yearlyPL - yearlyFees;
            const yearlyROI = totalInitialBalance > 0 ? ((yearlyBalance / totalInitialBalance) * 100) : 0;
            
            // Actualizar HTML - Mensual
            const monthlyBalanceEl = document.getElementById('capital-monthly-balance');
            const monthlyPLEl = document.getElementById('capital-monthly-pl');
            const monthlyTradesEl = document.getElementById('capital-monthly-trades');
            const monthlyROIEl = document.getElementById('capital-monthly-roi');
            
            if (monthlyBalanceEl) monthlyBalanceEl.textContent = formatCurrency(monthlyBalance, currency, currency);
            if (monthlyPLEl) monthlyPLEl.textContent = formatCurrency(monthlyPL, currency, currency);
            if (monthlyTradesEl) monthlyTradesEl.textContent = monthlyOps.length;
            if (monthlyROIEl) {
                monthlyROIEl.textContent = monthlyROI.toFixed(2) + '%';
                monthlyROIEl.className = 'text-sm font-bold ' + (monthlyROI > 0 ? 'text-green' : monthlyROI < 0 ? 'text-red' : '');
            }
            
            // Actualizar HTML - Trimestral
            const quarterlyBalanceEl = document.getElementById('capital-quarterly-balance');
            const quarterlyPLEl = document.getElementById('capital-quarterly-pl');
            const quarterlyTradesEl = document.getElementById('capital-quarterly-trades');
            const quarterlyROIEl = document.getElementById('capital-quarterly-roi');
            
            if (quarterlyBalanceEl) quarterlyBalanceEl.textContent = formatCurrency(quarterlyBalance, currency, currency);
            if (quarterlyPLEl) quarterlyPLEl.textContent = formatCurrency(quarterlyPL, currency, currency);
            if (quarterlyTradesEl) quarterlyTradesEl.textContent = quarterlyOps.length;
            if (quarterlyROIEl) {
                quarterlyROIEl.textContent = quarterlyROI.toFixed(2) + '%';
                quarterlyROIEl.className = 'text-sm font-bold ' + (quarterlyROI > 0 ? 'text-green' : quarterlyROI < 0 ? 'text-red' : '');
            }
            
            // Actualizar HTML - Anual
            const yearlyBalanceEl = document.getElementById('capital-yearly-balance');
            const yearlyPLEl = document.getElementById('capital-yearly-pl');
            const yearlyTradesEl = document.getElementById('capital-yearly-trades');
            const yearlyROIEl = document.getElementById('capital-yearly-roi');
            
            if (yearlyBalanceEl) yearlyBalanceEl.textContent = formatCurrency(yearlyBalance, currency, currency);
            if (yearlyPLEl) yearlyPLEl.textContent = formatCurrency(yearlyPL, currency, currency);
            if (yearlyTradesEl) yearlyTradesEl.textContent = yearlyOps.length;
            if (yearlyROIEl) {
                yearlyROIEl.textContent = yearlyROI.toFixed(2) + '%';
                yearlyROIEl.className = 'text-sm font-bold ' + (yearlyROI > 0 ? 'text-green' : yearlyROI < 0 ? 'text-red' : '');
            }
            
            console.log('📅 Análisis por Períodos:');
            console.log('   - Mensual: Balance=' + monthlyBalance.toFixed(2) + ', Operaciones=' + monthlyOps.length + ', ROI=' + monthlyROI.toFixed(2) + '%');
            console.log('   - Trimestral: Balance=' + quarterlyBalance.toFixed(2) + ', Operaciones=' + quarterlyOps.length + ', ROI=' + quarterlyROI.toFixed(2) + '%');
            console.log('   - Anual: Balance=' + yearlyBalance.toFixed(2) + ', Operaciones=' + yearlyOps.length + ', ROI=' + yearlyROI.toFixed(2) + '%');
        }

        function updateCapitalEvolutionChart(accounts, operations, currency) {
            const canvas = document.getElementById('capital-evolution-chart');
            if (!canvas) return;
            
            const existingChart = Chart.getChart(canvas);
            if (existingChart) existingChart.destroy();
            if (capitalEvolutionChart) capitalEvolutionChart = null;
            
            const ctx = canvas.getContext('2d');
            
            // Filtrar operaciones de cuentas de capital propio
            const capitalOps = operations.filter(op => {
                const account = accounts.find(acc => acc.id === op.accountId);
                return account !== undefined;
            }).sort((a, b) => new Date(a.date) - new Date(b.date));
            
            if (capitalOps.length === 0) {
                console.log('⚠️ No hay operaciones para gráfico de evolución de capital');
                return;
            }
            
            // Calcular balance inicial total
            let initialBalance = 0;
            accounts.forEach(account => {
                initialBalance += convertCurrency(parseFloat(account.initialBalance) || 0, account.currency, currency);
            });
            
            let cumulative = initialBalance;
            const labels = ['Inicial'];
            const data = [initialBalance];
            
            capitalOps.forEach(op => {
                const pl = convertCurrency(op.pl || 0, op.currency, currency);
                const fees = convertCurrency(op.fees || 0, op.currency, currency);
                cumulative += pl - fees;
                labels.push(formatDate(op.date));
                data.push(cumulative);
            });
            
            capitalEvolutionChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Capital Acumulado',
                        data: data,
                        borderColor: '#39ff14',
                        backgroundColor: 'rgba(57, 255, 20, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (ctx) => formatCurrency(ctx.parsed.y, currency, currency)
                            }
                        }
                    },
                    scales: {
                        x: { 
                            grid: { display: false },
                            ticks: { 
                                color: '#a0a0a0',
                                maxTicksLimit: 10
                            }
                        },
                        y: { 
                            grid: { color: '#2a2a2a' },
                            ticks: { 
                                color: '#a0a0a0',
                                callback: (val) => formatCurrency(val, currency, currency)
                            }
                        }
                    }
                }
            });
        }

        function updateCapitalIncomeExpensesDonut(accounts, operations, currency) {
            const canvas = document.getElementById('capital-income-expenses-donut');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            
            if (capitalIncomeExpensesDonut) capitalIncomeExpensesDonut.destroy();
            
            // Filtrar operaciones de cuentas de capital propio
            const capitalOps = operations.filter(op => {
                const account = accounts.find(acc => acc.id === op.accountId);
                return account !== undefined;
            });
            
            let income = 0, expenses = 0;
            capitalOps.forEach(op => {
                const pl = convertCurrency(op.pl || 0, op.currency, currency);
                const fees = convertCurrency(op.fees || 0, op.currency, currency);
                if (pl > 0) income += pl;
                // Gastos solo incluyen comisiones, NO pérdidas
                expenses += fees;
            });
            
            capitalIncomeExpensesDonut = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: ['Ingresos', 'Gastos'],
                    datasets: [{
                        data: [income, expenses],
                        backgroundColor: ['#00FF00', '#FF0000'],
                        borderColor: ['#39ff14', '#ff4136'],
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { 
                            display: true,
                            position: 'bottom',
                            labels: { color: '#ffffff', padding: 15 }
                        },
                        tooltip: {
                            callbacks: {
                                label: (ctx) => `${ctx.label}: ${formatCurrency(ctx.raw, currency, currency)}`
                            }
                        }
                    }
                }
            });
        }

        function updateCapitalMonthlyPerformance(accounts, operations, currency) {
            const canvas = document.getElementById('capital-monthly-performance-chart');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            
            if (capitalMonthlyPerformanceChart) capitalMonthlyPerformanceChart.destroy();
            
            // Filtrar operaciones de cuentas de capital propio
            const capitalOps = operations.filter(op => {
                const account = accounts.find(acc => acc.id === op.accountId);
                return account !== undefined;
            });
            
            const monthlyData = {};
            capitalOps.forEach(op => {
                const date = new Date(op.date);
                const key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                if (!monthlyData[key]) monthlyData[key] = 0;
                const pl = convertCurrency(op.pl || 0, op.currency, currency);
                const fees = convertCurrency(op.fees || 0, op.currency, currency);
                monthlyData[key] += pl - fees;
            });
            
            const sortedMonths = Object.keys(monthlyData).sort().slice(-5);
            const labels = sortedMonths.map(m => {
                const [year, month] = m.split('-');
                const monthNames = ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'];
                return `${monthNames[parseInt(month) - 1]}`;
            });
            const data = sortedMonths.map(m => monthlyData[m]);
            
            capitalMonthlyPerformanceChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Rendimiento',
                        data: data,
                        backgroundColor: data.map(v => v >= 0 ? '#00FF00' : '#FF0000'),
                        borderColor: data.map(v => v >= 0 ? '#39ff14' : '#ff4136'),
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (ctx) => formatCurrency(ctx.raw, currency, currency)
                            }
                        }
                    },
                    scales: {
                        x: { grid: { display: false }, ticks: { color: '#a0a0a0' } },
                        y: { 
                            grid: { color: '#2a2a2a' },
                            ticks: { 
                                color: '#a0a0a0',
                                callback: (val) => formatCurrency(val, currency, currency)
                            }
                        }
                    }
                }
            });
        }

        function updateCapitalTop3Movements(accounts, operations, currency) {
            const canvas = document.getElementById('capital-top3-movements-chart');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            
            if (capitalTop3MovementsChart) capitalTop3MovementsChart.destroy();
            
            // Filtrar operaciones de cuentas de capital propio
            const capitalOps = operations.filter(op => {
                const account = accounts.find(acc => acc.id === op.accountId);
                return account !== undefined;
            });
            
            const top3 = [...capitalOps]
                .sort((a, b) => {
                    const aNet = Math.abs(convertCurrency(a.pl || 0, a.currency, currency));
                    const bNet = Math.abs(convertCurrency(b.pl || 0, b.currency, currency));
                    return bNet - aNet;
                })
                .slice(0, 3);
            
            const labels = top3.map((_, i) => `#${i + 1}`);
            const data = top3.map(op => {
                const pl = convertCurrency(op.pl || 0, op.currency, currency);
                const fees = convertCurrency(op.fees || 0, op.currency, currency);
                return pl - fees;
            });
            
            capitalTop3MovementsChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Monto',
                        data: data,
                        backgroundColor: data.map(v => v >= 0 ? '#00FF00' : '#FF0000'),
                        borderColor: data.map(v => v >= 0 ? '#39ff14' : '#ff4136'),
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                title: (ctx) => {
                                    const op = top3[ctx[0].dataIndex];
                                    return op ? `${op.symbol || 'N/A'} - ${formatDate(op.date)}` : 'Sin datos';
                                },
                                label: (ctx) => formatCurrency(ctx.raw, currency, currency)
                            }
                        }
                    },
                    scales: {
                        x: { grid: { display: false }, ticks: { color: '#a0a0a0' } },
                        y: { 
                            grid: { color: '#2a2a2a' },
                            ticks: { 
                                color: '#a0a0a0',
                                callback: (val) => formatCurrency(val, currency, currency)
                            }
                        }
                    }
                }
            });
        }

        function updateCapitalWeeklyTrend(accounts, operations, currency) {
            const canvas = document.getElementById('capital-weekly-trend-chart');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            
            if (capitalWeeklyTrendChart) capitalWeeklyTrendChart.destroy();
            
            // Filtrar operaciones de cuentas de capital propio
            const capitalOps = operations.filter(op => {
                const account = accounts.find(acc => acc.id === op.accountId);
                return account !== undefined;
            });
            
            const weeklyData = {};
            capitalOps.forEach(op => {
                const date = new Date(op.date);
                const weekStart = new Date(date);
                weekStart.setDate(date.getDate() - date.getDay());
                const key = weekStart.toISOString().split('T')[0];
                if (!weeklyData[key]) weeklyData[key] = 0;
                const pl = convertCurrency(op.pl || 0, op.currency, currency);
                const fees = convertCurrency(op.fees || 0, op.currency, currency);
                weeklyData[key] += pl - fees;
            });
            
            const sortedWeeks = Object.keys(weeklyData).sort().slice(-5);
            const labels = sortedWeeks.map((_, i) => `Sem ${i + 1}`);
            const data = sortedWeeks.map(w => weeklyData[w]);
            
            capitalWeeklyTrendChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Balance',
                        data: data,
                        backgroundColor: data.map(v => v >= 0 ? '#00FF00' : '#FF0000'),
                        borderColor: data.map(v => v >= 0 ? '#39ff14' : '#ff4136'),
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (ctx) => formatCurrency(ctx.raw, currency, currency)
                            }
                        }
                    },
                    scales: {
                        x: { grid: { display: false }, ticks: { color: '#a0a0a0' } },
                        y: { 
                            grid: { color: '#2a2a2a' },
                            ticks: { 
                                color: '#a0a0a0',
                                callback: (val) => formatCurrency(val, currency, currency)
                            }
                        }
                    }
                }
            });
        }

        // Variables para gráficos de Funded
        let fundedEvolutionChart = null;
        let fundedExpensesDonut = null;
        let fundedProfitExpensesChart = null;
        let fundedAccountPerformanceChart = null;
        let fundedMonthlyTrendChart = null;

        // Actualizar vista de Funded
        function updateFundedView(finances, operations) {
            console.log('📊 updateFundedView - Iniciando...');
            console.log('📊 updateFundedView - DB.fundedAccounts:', DB.fundedAccounts?.length || 0);
            
            if (!DB.fundedAccounts || DB.fundedAccounts.length === 0) {
                console.warn('⚠️ No hay cuentas funded en DB.fundedAccounts');
                return;
            }
            
            console.log('📋 Cuentas funded:', DB.fundedAccounts);
            
            try {
                // Usar USD como moneda fija
                const currency = 'USD';
                
                // CALCULAR MÉTRICAS DIRECTAMENTE DE DB.fundedAccounts
                let totalBalance = 0;
                let totalEarnings = 0;
                let totalFees = 0;
                let activeAccounts = 0;
                let liveActiveAccounts = 0;
                
                DB.fundedAccounts.forEach(account => {
                    const balance = parseFloat(account.balance) || 0;
                    const earnings = parseFloat(account.earnings) || 0;
                    const fee = parseFloat(account.fee) || 0;
                    
                    console.log(`📋 ${account.name}: Balance=${balance}, Earnings=${earnings}, Fee=${fee}, Type=${account.type}, Status=${account.status}`);
                    
                    // Sumar todos los fees y earnings (todo el historial)
                    totalFees += fee;
                    totalEarnings += earnings;
                    
                    // Contar activas
                    if (account.status === 'active') {
                        activeAccounts++;
                    }
                    
                    // Sumar balance solo de cuentas LIVE ACTIVAS
                    if (account.type === 'live' && account.status === 'active') {
                        totalBalance += balance;
                        liveActiveAccounts++;
                    }
                });
                
                console.log('💰 TOTALES CALCULADOS:');
                console.log('   Balance:', totalBalance);
                console.log('   Earnings:', totalEarnings);
                console.log('   Fees:', totalFees);
                console.log('   Activas:', activeAccounts);
                console.log('   Live Activas:', liveActiveAccounts);
                
                const roi = totalFees > 0 ? ((totalEarnings / totalFees) * 100) : 0;
                const profitability = totalFees > 0 ? (((totalEarnings - totalFees) / totalFees) * 100) : 0;
                const avgBalance = liveActiveAccounts > 0 ? totalBalance / liveActiveAccounts : 0;
                
                // ACTUALIZAR ELEMENTOS DEL DOM
                const fundedBalanceEl = document.getElementById('funded-total-balance');
                const fundedProfitEl = document.getElementById('funded-total-profit');
                const fundedExpensesEl = document.getElementById('funded-total-expenses');
                const fundedRoiEl = document.getElementById('funded-roi');
                const fundedProfitabilityEl = document.getElementById('funded-profitability');
                const fundedActiveAccountsEl = document.getElementById('funded-active-accounts');
                const liveCapitalEl = document.getElementById('funded-live-capital-total');
                const liveCountEl = document.getElementById('funded-live-count-display');
                const avgBalanceEl = document.getElementById('funded-avg-balance-display');
                
                if (fundedBalanceEl) fundedBalanceEl.textContent = `$${totalBalance.toFixed(2)}`;
                if (fundedProfitEl) fundedProfitEl.textContent = `$${totalEarnings.toFixed(2)}`;
                if (fundedExpensesEl) fundedExpensesEl.textContent = `$${totalFees.toFixed(2)}`;
                if (fundedRoiEl) fundedRoiEl.textContent = `${roi.toFixed(2)}%`;
                if (fundedProfitabilityEl) fundedProfitabilityEl.textContent = `${profitability.toFixed(2)}%`;
                if (fundedActiveAccountsEl) fundedActiveAccountsEl.textContent = activeAccounts;
                if (liveCapitalEl) liveCapitalEl.textContent = `$${totalBalance.toFixed(2)}`;
                if (liveCountEl) liveCountEl.textContent = `${liveActiveAccounts} cuentas live activas`;
                if (avgBalanceEl) avgBalanceEl.textContent = `Promedio: $${avgBalance.toFixed(2)}`;
                
                console.log('✅ Métricas actualizadas en el DOM');
                
                // Actualizar tabla y gráficos
                updateFundedMovementsTable(finances);
                updateFundedEvolutionChart('USD');
                updateFundedExpensesDonut('USD');
                updateFundedProfitExpensesChart('USD');
                updateFundedAccountPerformanceChart('USD');
                updateFundedMonthlyTrendChart('USD');
                
                console.log('✅ updateFundedView completado');
                
            } catch (error) {
                console.error('❌ Error en updateFundedView:', error);
            }
        }

        function updateFundedMovementsTable(finances) {
            const tbody = document.getElementById('funded-movements-tbody');
            if (!tbody) return;
            
            tbody.innerHTML = '';
            
            const selectedAccountId = document.getElementById('funded-account-select')?.value || 'all';
            
            // MOSTRAR TODO EL HISTORIAL (activas + suspendidas)
            let accountsToShow = [];
            
            if (selectedAccountId === 'all') {
                // Mostrar TODAS las cuentas (activas + suspendidas)
                accountsToShow = DB.fundedAccounts || [];
            } else {
                // Mostrar solo la cuenta seleccionada
                accountsToShow = (DB.fundedAccounts || []).filter(acc => acc.id === selectedAccountId);
            }
            
            const allRecords = [];
            
            // Agregar gastos (fees) de activación de cuentas
            accountsToShow.forEach(account => {
                const fee = parseFloat(account.fee) || 0;
                if (fee > 0) {
                    allRecords.push({
                        date: account.activationDate || account.startDate,
                        description: account.company || account.firm,
                        accountName: account.name,
                        amount: -fee, // Negativo porque es un gasto
                        balance: parseFloat(account.balance) || 0,
                        type: 'gasto',
                        accountType: account.type,
                        accountStatus: account.status
                    });
                }
                
                // Agregar TODOS los retiros individuales de esta cuenta
                const withdrawals = Array.isArray(account.withdrawals) ? account.withdrawals : [];
                withdrawals.forEach(withdrawal => {
                    const amount = parseFloat(withdrawal.amount) || 0;
                    allRecords.push({
                        date: withdrawal.date,
                        description: account.company || account.firm,
                        accountName: account.name,
                        amount: amount, // Positivo porque es un ingreso
                        balance: parseFloat(account.balance) || 0,
                        type: 'retiro',
                        accountType: account.type,
                        accountStatus: account.status,
                        notes: withdrawal.notes
                    });
                });
            });
            
            // Ordenar por fecha (más reciente primero)
            const sorted = allRecords.sort((a, b) => new Date(b.date) - new Date(a.date));
            
            if (sorted.length > 0) {
                sorted.forEach(record => {
                    const isGasto = record.type === 'gasto';
                    const isRetiro = record.type === 'retiro';
                    const isSuspended = record.accountStatus === 'suspended';
                    
                    const statusBadge = isSuspended
                        ? '<span class="px-2 py-1 text-xs rounded bg-gray-900 text-gray">Suspendida</span>'
                        : record.accountType === 'live' 
                            ? '<span class="px-2 py-1 text-xs rounded bg-green-900 text-green">Live</span>' 
                            : '<span class="px-2 py-1 text-xs rounded bg-blue-900 text-blue">Evaluación</span>';
                    
                    const typeLabel = isGasto ? 'Gasto (Fee)' : 'Retiro';
                    const description = isRetiro && record.notes 
                        ? `${record.description} - ${record.notes}` 
                        : record.description;
                    
                    const row = `
                        <tr style="${isSuspended ? 'opacity: 0.6;' : ''}">
                            <td>${formatDate(record.date)}</td>
                            <td>${description}</td>
                            <td class="font-medium">${record.accountName}</td>
                            <td class="${record.amount >= 0 ? 'text-positive' : 'text-negative'} font-semibold hide-amount text-right">${record.amount >= 0 ? '+' : ''}$${Math.abs(record.amount).toFixed(2)}</td>
                            <td class="font-bold hide-amount text-right" style="color: ${isSuspended ? '#888' : '#39FF14'};">$${record.balance.toFixed(2)}</td>
                            <td class="text-center">USD</td>
                            <td class="text-center">${statusBadge}</td>
                        </tr>
                    `;
                    tbody.innerHTML += row;
                });
            } else {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="7" class="text-center text-text-secondary py-8">
                            No hay movimientos registrados
                        </td>
                    </tr>
                `;
            }
        }

        function updateFundedEvolutionChart(currency) {
            const canvas = document.getElementById('funded-evolution-chart');
            if (!canvas) {
                console.warn('⚠️ Canvas funded-evolution-chart no encontrado');
                return;
            }
            
            // Destruir gráfico existente
            const existingChart = Chart.getChart(canvas);
            if (existingChart) existingChart.destroy();
            if (fundedEvolutionChart) fundedEvolutionChart = null;
            
            const ctx = canvas.getContext('2d');
            
            // Obtener selector para decidir qué mostrar
            const selectedAccountId = document.getElementById('funded-account-select')?.value || 'all';
            
            // Si selector en "all", mostrar TODAS las cuentas (historial completo)
            // Si hay cuenta específica, mostrar solo esa
            let accountsToShow = [];
            if (selectedAccountId === 'all') {
                accountsToShow = DB.fundedAccounts || []; // Todas (activas + suspendidas)
            } else {
                accountsToShow = (DB.fundedAccounts || []).filter(acc => acc.id === selectedAccountId);
            }
            
            if (accountsToShow.length === 0) {
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.font = '14px Arial';
                ctx.fillStyle = '#8b949e';
                ctx.textAlign = 'center';
                ctx.fillText('No hay cuentas funded', canvas.width / 2, canvas.height / 2 - 10);
                ctx.fillText('Agrega cuentas para ver el rendimiento', canvas.width / 2, canvas.height / 2 + 15);
                console.log('📊 Balance por cuenta: Sin cuentas activas para mostrar');
                return;
            }
            
            // Crear gráfico de barras horizontales mostrando beneficio neto de cada cuenta
            const accountData = accountsToShow.map(account => {
                const balance = parseFloat(account.balance) || 0;
                const earnings = parseFloat(account.earnings) || 0;
                const fee = parseFloat(account.fee) || 0;
                const netProfit = earnings - fee;
                
                return {
                    name: account.name,
                    balance: balance,
                    netProfit: netProfit,
                    earnings: earnings,
                    fee: fee,
                    type: account.type,
                    status: account.status
                };
            });
            
            // Ordenar por beneficio neto (mayor a menor)
            accountData.sort((a, b) => b.netProfit - a.netProfit);
            
            const labels = accountData.map(a => a.name);
            const netProfits = accountData.map(a => a.netProfit);
            const balances = accountData.map(a => a.balance);
            const earnings = accountData.map(a => a.earnings);
            const fees = accountData.map(a => a.fee);
            
            // Colores: verde para positivo, rojo para negativo
            const backgroundColors = netProfits.map(profit => 
                profit >= 0 ? 'rgba(57, 255, 20, 0.8)' : 'rgba(255, 65, 54, 0.8)'
            );
            const borderColors = netProfits.map(profit => 
                profit >= 0 ? '#39ff14' : '#ff4136'
            );
            
            console.log('📊 Rendimiento por Cuenta: Creando gráfico con', labels.length, 'cuentas');
            
            fundedEvolutionChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Beneficio Neto',
                        data: netProfits,
                        backgroundColor: backgroundColors,
                        borderColor: borderColors,
                        borderWidth: 2
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { 
                            display: true,
                            labels: { color: '#ffffff' }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleColor: '#fff',
                            bodyColor: '#fff',
                            borderColor: '#39ff14',
                            borderWidth: 1,
                            callbacks: {
                                label: function(context) {
                                    const index = context.dataIndex;
                                    const profit = netProfits[index];
                                    const earning = earnings[index];
                                    const fee = fees[index];
                                    const balance = balances[index];
                                    return [
                                        `Beneficio Neto: €${profit.toFixed(2)}`,
                                        `Ganancias: €${earning.toFixed(2)}`,
                                        `Gastos: €${fee.toFixed(2)}`,
                                        `Balance: €${balance.toFixed(2)}`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { color: '#8b949e', maxRotation: 45, minRotation: 0 }
                        },
                        y: {
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { 
                                color: '#8b949e',
                                callback: (value) => `€${value.toFixed(0)}`
                            }
                        }
                    }
                }
            });
        }

        function updateFundedExpensesDonut(currency) {
            const canvas = document.getElementById('funded-expenses-donut');
            if (!canvas) {
                console.warn('⚠️ Canvas funded-expenses-donut no encontrado');
                return;
            }
            
            const existingChart = Chart.getChart(canvas);
            if (existingChart) existingChart.destroy();
            if (fundedExpensesDonut) fundedExpensesDonut = null;
            
            const ctx = canvas.getContext('2d');
            
            // Obtener selector para decidir qué mostrar
            const selectedAccountId = document.getElementById('funded-account-select')?.value || 'all';
            
            // Si selector en "all", mostrar TODAS las cuentas (historial completo)
            let accountsToShow = [];
            if (selectedAccountId === 'all') {
                accountsToShow = DB.fundedAccounts || []; // Todas (activas + suspendidas)
            } else {
                accountsToShow = (DB.fundedAccounts || []).filter(acc => acc.id === selectedAccountId);
            }
            
            if (accountsToShow.length === 0) {
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.font = '14px Arial';
                ctx.fillStyle = '#8b949e';
                ctx.textAlign = 'center';
                ctx.fillText('No hay cuentas funded', canvas.width / 2, canvas.height / 2 - 10);
                ctx.fillText('Agrega cuentas para ver la distribución', canvas.width / 2, canvas.height / 2 + 15);
                console.log('📊 Distribución: Sin cuentas para mostrar');
                return;
            }
            
            // Calcular totales de GANANCIAS vs GASTOS (todas las cuentas)
            let totalEarnings = 0;
            let totalFees = 0;
            
            accountsToShow.forEach(account => {
                const earnings = parseFloat(account.earnings) || 0;
                const fee = parseFloat(account.fee) || 0;
                
                totalEarnings += earnings;
                totalFees += fee;
            });
            
            console.log('📊 Comparación: Ganancias =', totalEarnings, '| Gastos =', totalFees);
            
            // Si no hay datos, mostrar mensaje
            if (totalEarnings === 0 && totalFees === 0) {
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.font = '14px Arial';
                ctx.fillStyle = '#8b949e';
                ctx.textAlign = 'center';
                ctx.fillText('No hay datos para mostrar', canvas.width / 2, canvas.height / 2);
                return;
            }
            
            const labels = ['Ganancias (Retiros)', 'Gastos (Fees)'];
            const data = [totalEarnings, totalFees];
            const colors = ['rgba(57, 255, 20, 0.8)', 'rgba(255, 65, 54, 0.8)'];
            const borderColors = ['#39ff14', '#ff4136'];
            
            fundedExpensesDonut = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: colors,
                        borderColor: borderColors,
                        borderWidth: 3
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { 
                            display: true,
                            position: 'bottom',
                            labels: { 
                                color: '#ffffff', 
                                padding: 15,
                                font: { size: 12, weight: 'bold' }
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleColor: '#fff',
                            bodyColor: '#fff',
                            borderWidth: 1,
                            callbacks: {
                                label: (ctx) => `${ctx.label}: ${formatCurrency(ctx.raw, currency, currency)}`
                            }
                        }
                    }
                }
            });
            
            console.log('✅ Gráfico de distribución creado exitosamente');
        }

        function updateFundedProfitExpensesChart(currency) {
            const canvas = document.getElementById('funded-profit-expenses-chart');
            if (!canvas) return;
            
            const existingChart = Chart.getChart(canvas);
            if (existingChart) existingChart.destroy();
            if (fundedProfitExpensesChart) fundedProfitExpensesChart = null;
            
            const ctx = canvas.getContext('2d');
            
            // Verificar si hay cuentas funded activas
            const activeFundedAccounts = (DB.fundedAccounts || []).filter(acc => acc.status === 'active');
            
            if (activeFundedAccounts.length === 0) {
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.font = '14px Arial';
                ctx.fillStyle = '#8b949e';
                ctx.textAlign = 'center';
                ctx.fillText('No hay cuentas funded activas', canvas.width / 2, canvas.height / 2);
                return;
            }
            
            const monthlyData = {};
            
            activeFundedAccounts.forEach(account => {
                const date = new Date(account.activationDate || account.startDate);
                const key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                if (!monthlyData[key]) monthlyData[key] = { profit: 0, expenses: 0 };
                monthlyData[key].profit += parseFloat(account.earnings) || 0;
                monthlyData[key].expenses += parseFloat(account.fee) || 0;
            });
            
            const sortedMonths = Object.keys(monthlyData).sort().slice(-5);
            const labels = sortedMonths.map(m => {
                const [year, month] = m.split('-');
                const monthNames = ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'];
                return `${monthNames[parseInt(month) - 1]}`;
            });
            
            fundedProfitExpensesChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Ganancias',
                            data: sortedMonths.map(m => monthlyData[m].profit),
                            backgroundColor: '#00FF00',
                            borderColor: '#39ff14',
                            borderWidth: 2
                        },
                        {
                            label: 'Gastos',
                            data: sortedMonths.map(m => monthlyData[m].expenses),
                            backgroundColor: '#FF0000',
                            borderColor: '#ff4136',
                            borderWidth: 2
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { 
                            display: true,
                            position: 'top',
                            labels: { color: '#ffffff' }
                        },
                        tooltip: {
                            callbacks: {
                                label: (ctx) => `${ctx.dataset.label}: ${formatCurrency(ctx.raw, currency, currency)}`
                            }
                        }
                    },
                    scales: {
                        x: { grid: { display: false }, ticks: { color: '#a0a0a0' } },
                        y: { 
                            grid: { color: '#2a2a2a' },
                            ticks: { 
                                color: '#a0a0a0',
                                callback: (val) => formatCurrency(val, currency, currency)
                            }
                        }
                    }
                }
            });
        }

        function updateFundedAccountPerformanceChart(currency) {
            const canvas = document.getElementById('funded-account-performance-chart');
            if (!canvas) return;
            
            const existingChart = Chart.getChart(canvas);
            if (existingChart) existingChart.destroy();
            if (fundedAccountPerformanceChart) fundedAccountPerformanceChart = null;
            
            const ctx = canvas.getContext('2d');
            
            // Usar TODAS las cuentas funded de DB (no filtrar por activas para ver historial completo)
            if (!DB.fundedAccounts || DB.fundedAccounts.length === 0) {
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.font = '14px Arial';
                ctx.fillStyle = '#8b949e';
                ctx.textAlign = 'center';
                ctx.fillText('No hay cuentas funded', canvas.width / 2, canvas.height / 2);
                return;
            }
            
            // Crear datos para el gráfico de barras: balance por cuenta
            const labels = [];
            const balanceData = [];
            const backgroundColors = [];
            
            DB.fundedAccounts.forEach(account => {
                const balance = parseFloat(account.balance) || 0;
                const earnings = parseFloat(account.earnings) || 0;
                const fee = parseFloat(account.fee) || 0;
                
                // Solo mostrar cuentas live activas con balance
                if (account.type === 'live' && account.status === 'active' && balance > 0) {
                    labels.push(account.name);
                    balanceData.push(balance);
                    // Color verde para cuentas activas
                    backgroundColors.push('#00FF00');
                }
            });
            
            // Si no hay cuentas para mostrar
            if (labels.length === 0) {
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.font = '14px Arial';
                ctx.fillStyle = '#8b949e';
                ctx.textAlign = 'center';
                ctx.fillText('No hay cuentas live activas con balance', canvas.width / 2, canvas.height / 2);
                return;
            }
            
            fundedAccountPerformanceChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Balance',
                        data: balanceData,
                        backgroundColor: backgroundColors,
                        borderColor: '#39ff14',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (ctx) => `Balance: $${ctx.raw.toFixed(2)}`
                            }
                        }
                    },
                    scales: {
                        x: { 
                            grid: { display: false }, 
                            ticks: { color: '#a0a0a0', maxRotation: 45, minRotation: 45 } 
                        },
                        y: { 
                            grid: { color: '#2a2a2a' },
                            ticks: { 
                                color: '#a0a0a0',
                                callback: (val) => `$${val.toFixed(0)}`
                            }
                        }
                    }
                }
            });
        }

        function updateFundedMonthlyTrendChart(currency) {
            const canvas = document.getElementById('funded-monthly-trend-chart');
            if (!canvas) return;
            
            const existingChart = Chart.getChart(canvas);
            if (existingChart) existingChart.destroy();
            if (fundedMonthlyTrendChart) fundedMonthlyTrendChart = null;
            
            const ctx = canvas.getContext('2d');
            
            // Verificar si hay cuentas funded activas
            const activeFundedAccounts = (DB.fundedAccounts || []).filter(acc => acc.status === 'active');
            
            if (activeFundedAccounts.length === 0) {
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.font = '14px Arial';
                ctx.fillStyle = '#8b949e';
                ctx.textAlign = 'center';
                ctx.fillText('No hay cuentas funded activas', canvas.width / 2, canvas.height / 2);
                return;
            }
            
            const monthlyData = {};
            
            activeFundedAccounts.forEach(account => {
                const date = new Date(account.activationDate || account.startDate);
                const key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                if (!monthlyData[key]) monthlyData[key] = 0;
                const netProfit = (parseFloat(account.earnings) || 0) - (parseFloat(account.fee) || 0);
                monthlyData[key] += netProfit;
            });
            
            const sortedMonths = Object.keys(monthlyData).sort().slice(-5);
            const labels = sortedMonths.map(m => {
                const [year, month] = m.split('-');
                const monthNames = ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'];
                return `${monthNames[parseInt(month) - 1]}`;
            });
            const data = sortedMonths.map(m => monthlyData[m]);
            
            fundedMonthlyTrendChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Balance Neto',
                        data: data,
                        backgroundColor: '#00FF00',
                        borderColor: '#39ff14',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (ctx) => formatCurrency(ctx.raw, currency, currency)
                            }
                        }
                    },
                    scales: {
                        x: { grid: { display: false }, ticks: { color: '#a0a0a0' } },
                        y: { 
                            grid: { color: '#2a2a2a' },
                            ticks: { 
                                color: '#a0a0a0',
                                callback: (val) => formatCurrency(val, currency, currency)
                            }
                        }
                    }
                }
            });
        }

        // Variables globales para las gráficas de calendario
        let calendarWeeklyTrendChart = null;
        let calendarMonthlyWeeksChart = null;
        let calendarDailyPLChart = null;
        let calendarDailyWinRateChart = null;

        // 1. Tendencia Semanal (barras simples)
        function updateCalendarWeeklyTrendChart(weekOperationsData, baseCurrency, initialBalanceForPercent) {
            const canvas = document.getElementById('calendar-weekly-trend-chart');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            if (calendarWeeklyTrendChart) calendarWeeklyTrendChart.destroy();

            const sortedWeeks = Object.values(weekOperationsData).sort((a, b) => parseInt(a.weekNumber) - parseInt(b.weekNumber));
            const labels = sortedWeeks.map(week => 'Sem ' + week.weekNumber);
            const dataPL = sortedWeeks.map(week => week.totalPL);
            const currencyMode = document.getElementById('calendar-currency-select') ? document.getElementById('calendar-currency-select').value : 'USD';

            calendarWeeklyTrendChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'P&L Semanal',
                        data: dataPL,
                        backgroundColor: dataPL.map(v => v >= 0 ? '#00FF00' : '#FF0000')
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            enabled: DB.settings.showTooltips,
                            callbacks: {
                                label: (ctx) => {
                                    let fPL;
                                    if (currencyMode === '%') {
                                        const p = initialBalanceForPercent > 0 ? (ctx.raw / initialBalanceForPercent) * 100 : 0;
                                        fPL = p.toFixed(2) + '%';
                                    } else {
                                        fPL = formatCurrency(ctx.raw, baseCurrency, currencyMode);
                                    }
                                    return 'P&L: ' + fPL;
                                }
                            }
                        }
                    },
                    scales: {
                        x: { grid: { display: false }, ticks: { color: '#a0a0a0' } },
                        y: {
                            beginAtZero: true,
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            ticks: {
                                color: '#a0a0a0',
                                callback: (val) => {
                                    if (currencyMode === '%') {
                                        const p = initialBalanceForPercent > 0 ? (val / initialBalanceForPercent) * 100 : 0;
                                        return p.toFixed(0) + '%';
                                    } else {
                                        return formatCurrency(val, baseCurrency, currencyMode).replace(/\.\d+/, '');
                                    }
                                }
                            }
                        }
                    }
                }
            });
        }

        // 2. P&L por Semana del Mes (Sem 1-5)
        function updateCalendarMonthlyWeeksChart(operations, baseCurrency, initialBalanceForPercent) {
            const canvas = document.getElementById('calendar-monthly-weeks-chart');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            if (calendarMonthlyWeeksChart) calendarMonthlyWeeksChart.destroy();

            const currencyMode = document.getElementById('calendar-currency-select') ? document.getElementById('calendar-currency-select').value : 'USD';
            
            // Agrupar por semana del mes (1-5)
            const weekPLs = [0, 0, 0, 0, 0]; // Semanas 1-5
            const weekCounts = [0, 0, 0, 0, 0];
            
            operations.forEach(op => {
                if (!op.date) return;
                const date = new Date(op.date + 'T00:00:00Z');
                const dayOfMonth = date.getUTCDate();
                
                // Determinar semana del mes basado en el día
                let weekOfMonth = Math.ceil(dayOfMonth / 7) - 1; // 0-4
                if (weekOfMonth > 4) weekOfMonth = 4; // Máximo 5 semanas
                
                let pl = op.pl;
                if (op.currency !== baseCurrency) {
                    pl = convertCurrency(pl, op.currency, baseCurrency);
                }
                
                weekPLs[weekOfMonth] += pl;
                weekCounts[weekOfMonth]++;
            });

            const labels = ['Sem 1', 'Sem 2', 'Sem 3', 'Sem 4', 'Sem 5'];
            
            calendarMonthlyWeeksChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'P&L',
                        data: weekPLs,
                        backgroundColor: weekPLs.map(v => v >= 0 ? '#00FF00' : '#FF0000')
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            enabled: DB.settings.showTooltips,
                            callbacks: {
                                label: (ctx) => {
                                    let fPL;
                                    if (currencyMode === '%') {
                                        const p = initialBalanceForPercent > 0 ? (ctx.raw / initialBalanceForPercent) * 100 : 0;
                                        fPL = p.toFixed(2) + '%';
                                    } else {
                                        fPL = formatCurrency(ctx.raw, baseCurrency, currencyMode);
                                    }
                                    return fPL + ' (' + weekCounts[ctx.dataIndex] + ' ops)';
                                }
                            }
                        }
                    },
                    scales: {
                        x: { grid: { display: false }, ticks: { color: '#a0a0a0' } },
                        y: {
                            beginAtZero: true,
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            ticks: {
                                color: '#a0a0a0',
                                callback: (val) => {
                                    if (currencyMode === '%') {
                                        const p = initialBalanceForPercent > 0 ? (val / initialBalanceForPercent) * 100 : 0;
                                        return p.toFixed(0) + '%';
                                    } else {
                                        return formatCurrency(val, baseCurrency, currencyMode).replace(/\.\d+/, '');
                                    }
                                }
                            }
                        }
                    }
                }
            });
        }

        // 3. P&L por Día de la Semana
        function updateCalendarDailyPLChart(operations, baseCurrency, initialBalanceForPercent) {
            const canvas = document.getElementById('calendar-daily-pl-chart');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            if (calendarDailyPLChart) calendarDailyPLChart.destroy();

            const currencyMode = document.getElementById('calendar-currency-select') ? document.getElementById('calendar-currency-select').value : 'USD';
            const dayNames = ['Dom', 'Lun', 'Mar', 'Mié', 'Jue', 'Vie', 'Sáb'];
            const dailyPL = [0, 0, 0, 0, 0, 0, 0];
            const dailyCounts = [0, 0, 0, 0, 0, 0, 0];
            
            operations.forEach(op => {
                if (!op.date) return;
                const date = new Date(op.date + 'T00:00:00Z');
                const dayOfWeek = date.getUTCDay();
                
                let pl = op.pl;
                if (op.currency !== baseCurrency) {
                    pl = convertCurrency(pl, op.currency, baseCurrency);
                }
                
                dailyPL[dayOfWeek] += pl;
                dailyCounts[dayOfWeek]++;
            });

            calendarDailyPLChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: dayNames,
                    datasets: [{
                        label: 'P&L por Día',
                        data: dailyPL,
                        backgroundColor: dailyPL.map(v => v >= 0 ? '#00FF00' : '#FF0000')
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            enabled: DB.settings.showTooltips,
                            callbacks: {
                                label: (ctx) => {
                                    let fPL;
                                    if (currencyMode === '%') {
                                        const p = initialBalanceForPercent > 0 ? (ctx.raw / initialBalanceForPercent) * 100 : 0;
                                        fPL = p.toFixed(2) + '%';
                                    } else {
                                        fPL = formatCurrency(ctx.raw, baseCurrency, currencyMode);
                                    }
                                    return fPL + ' (' + dailyCounts[ctx.dataIndex] + ' ops)';
                                }
                            }
                        }
                    },
                    scales: {
                        x: { grid: { display: false }, ticks: { color: '#a0a0a0' } },
                        y: {
                            beginAtZero: true,
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            ticks: {
                                color: '#a0a0a0',
                                callback: (val) => {
                                    if (currencyMode === '%') {
                                        const p = initialBalanceForPercent > 0 ? (val / initialBalanceForPercent) * 100 : 0;
                                        return p.toFixed(0) + '%';
                                    } else {
                                        return formatCurrency(val, baseCurrency, currencyMode).replace(/\.\d+/, '');
                                    }
                                }
                            }
                        }
                    }
                }
            });
        }

        // 4. Win Rate por Día de la Semana
        function updateCalendarDailyWinRateChart(operations) {
            const canvas = document.getElementById('calendar-daily-winrate-chart');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            if (calendarDailyWinRateChart) calendarDailyWinRateChart.destroy();

            const dayNames = ['Dom', 'Lun', 'Mar', 'Mié', 'Jue', 'Vie', 'Sáb'];
            const dailyWins = [0, 0, 0, 0, 0, 0, 0];
            const dailyTotal = [0, 0, 0, 0, 0, 0, 0];
            
            operations.forEach(op => {
                if (!op.date) return;
                const date = new Date(op.date + 'T00:00:00Z');
                const dayOfWeek = date.getUTCDay();
                
                dailyTotal[dayOfWeek]++;
                
                // Determinar si es win
                const isWin = op.result === 'win' || (!op.result && op.pl > 0);
                if (isWin) dailyWins[dayOfWeek]++;
            });
            
            // Calcular win rate en porcentaje
            const winRates = dailyTotal.map((total, idx) => 
                total > 0 ? (dailyWins[idx] / total) * 100 : 0
            );

            calendarDailyWinRateChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: dayNames,
                    datasets: [{
                        label: 'Win Rate',
                        data: winRates,
                        backgroundColor: winRates.map(v => v >= 50 ? '#00FF00' : '#FF0000')
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            enabled: DB.settings.showTooltips,
                            callbacks: {
                                label: (ctx) => {
                                    const wr = ctx.raw.toFixed(1);
                                    const wins = dailyWins[ctx.dataIndex];
                                    const total = dailyTotal[ctx.dataIndex];
                                    return `WR: ${wr}% (${wins}/${total})`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: { grid: { display: false }, ticks: { color: '#a0a0a0' } },
                        y: {
                            min: 0,
                            max: 100,
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            ticks: {
                                color: '#a0a0a0',
                                callback: (val) => val + '%'
                            }
                        }
                    }
                }
            });
        }

        let accountDetailChart = null;
        function updateAccountDetailChart(account, allAccountOps, timeRange = 'ALL') {
            const ctx = document.getElementById('account-detail-chart').getContext('2d');
            if (accountDetailChart) accountDetailChart.destroy();
            const chartTargetCurrency = account.currency;

            const startDateString = getStartDateForRange(timeRange);
            let chartOps = allAccountOps;
             if (startDateString) {
                 chartOps = allAccountOps.filter(op => op.date >= startDateString);
             }
            chartOps = [...chartOps].sort((a, b) => new Date(a.date + 'T00:00:00Z') - new Date(b.date + 'T00:00:00Z'));

            let startingBalance = account.initialBalance;
            if (startDateString) {
                const opsBeforeRange = DB.operations.filter(op =>
                    op.accountId === account.id && op.date < startDateString
                );
                opsBeforeRange.forEach(op => {
                    let pl = op.pl;
                    if (op.currency !== chartTargetCurrency) {
                        pl = convertCurrency(pl, op.currency, chartTargetCurrency);
                    }
                    startingBalance += pl;
                });
            }

            const labels = ['Inicio'];
            const data = [startingBalance];
            let currentBalance = startingBalance;
            chartOps.forEach(op => {
                let pl = op.pl;
                if (op.currency !== chartTargetCurrency) pl = convertCurrency(pl, op.currency, chartTargetCurrency);
                currentBalance += pl; data.push(currentBalance); labels.push(formatDate(op.date));
            });
            accountDetailChart = new Chart(ctx, {
                type: 'line', data: { labels: labels, datasets: [{ label: 'Balance', data: data, borderColor: '#00FF00', backgroundColor: '#00FF00', borderWidth: 0, fill: true, tension: 0.4, pointRadius: 0, pointHoverRadius: 6, pointHoverBackgroundColor: '#00FF00', pointHoverBorderColor: '#00FF00', pointHoverBorderWidth: 0 }] },
                options: { responsive: true, maintainAspectRatio: false, interaction: { mode: 'index', intersect: false }, plugins: { tooltip: { enabled: DB.settings.showTooltips, callbacks: { title: (ctx) => ctx[0].label, label: (ctx) => 'Balance: ' + formatCurrency(ctx.raw, chartTargetCurrency, chartTargetCurrency) } }, legend: { display: false } }, scales: { x: { grid: { display: false }, ticks: { color: '#FFFFFF'} }, y: { grid: { color: '#2a2a2a' }, ticks: { color: '#FFFFFF', callback: (val) => formatCurrency(val, chartTargetCurrency, chartTargetCurrency) } } } }
            });
        }

        function getLocalDateString(date) {
            if (typeof date === 'string') {
                date = new Date(date);
            }
            if (!(date instanceof Date) || isNaN(date)) {
                date = new Date();
            }

            const year = date.getFullYear();
            const month = (date.getMonth() + 1).toString().padStart(2, '0');
            const day = date.getDate().toString().padStart(2, '0');

            return `${year}-${month}-${day}`;
        }

        function calculateAdvancedMetrics(operations, accountId = 'all') {
            console.log('[calculateAdvancedMetrics] 🚀 INICIO - operations:', operations.length, 'accountId:', accountId);
            
            // Usar solo operaciones principales para métricas avanzadas
            const mainOps = operations.filter(op => !op.parentId || op.parentId === '' || op.parentId === null);
            console.log('[calculateAdvancedMetrics] 📊 mainOps filtradas:', mainOps.length);
            
            const metrics = calculateMetrics(operations, accountId);
            console.log('[calculateAdvancedMetrics] ✅ calculateMetrics completado');
            
            // Helper para determinar si es win/loss cuando result no existe
            const isWin = (op) => {
                if (op.result === 'win') return true;
                if (op.result === 'loss') return false;
                // Si no hay result, usar P/L
                return op.pl > 0;
            };
            const isLoss = (op) => {
                if (op.result === 'loss') return true;
                if (op.result === 'win') return false;
                // Si no hay result, usar P/L
                return op.pl < 0;
            };
            console.log('[calculateAdvancedMetrics] ✅ Helpers definidos');
            console.log('[calculateAdvancedMetrics] ✅ Helpers definidos');
            
            let totalPLInDefault = metrics.totalWin + metrics.totalLoss;
            const totalTrades = metrics.totalTrades;
            const totalWin = metrics.totalWin;
            const totalLoss = metrics.totalLoss;
            const winningTrades = metrics.winningTrades;
            const losingTrades = metrics.losingTrades;
            const initialBalance = metrics.initialBalance || 0;
            
            console.log('[calculateAdvancedMetrics] 📈 Variables básicas:', {
                totalPLInDefault,
                totalTrades,
                totalWin,
                totalLoss,
                winningTrades,
                losingTrades,
                initialBalance
            });
            
            // --- Basic averages ---
            const avgWin = winningTrades > 0 ? totalWin / winningTrades : 0;
            const avgLoss = losingTrades > 0 ? totalLoss / losingTrades : 0;
            const avgPLPerTrade = totalTrades > 0 ? totalPLInDefault / totalTrades : 0;
            
            console.log('[calculateAdvancedMetrics] 💰 Promedios básicos:', {
                avgWin,
                avgLoss,
                avgPLPerTrade
            });
            
            // --- Percentages ---
            const avgPLPercentage = initialBalance > 0 ? (avgPLPerTrade / initialBalance) * 100 : 0;
            const avgWinPercentage = initialBalance > 0 ? (avgWin / initialBalance) * 100 : 0;
            const avgLossPercentage = initialBalance > 0 ? (avgLoss / initialBalance) * 100 : 0;
            const totalWinPercentage = initialBalance > 0 ? (totalWin / initialBalance) * 100 : 0;
            const totalLossPercentage = initialBalance > 0 ? (totalLoss / initialBalance) * 100 : 0;
            
            console.log('[calculateAdvancedMetrics] 📊 Porcentajes calculados');
            console.log('[calculateAdvancedMetrics] 🔄 Iniciando agrupación por fechas...');
            // --- Per day/month/year ---
            console.log('[DEBUG] Starting date grouping. mainOps count:', mainOps.length);
            const opsByDay = {};
            const opsByMonth = {};
            const opsByYear = {};
            
            let groupingErrorCount = 0;
            mainOps.forEach((op, index) => {
                try {
                    if (!op.date) {
                        console.log(`[DEBUG] Op ${index} (${op.id}) has no date`);
                        return; // Skip if no date
                    }
                    // Normalize date format (handle both "2025-12-10" and "2026-01-21T16:31:35.000Z")
                    let dateStr = op.date;
                    if (dateStr.includes('T')) {
                        dateStr = dateStr.split('T')[0]; // Extract "2026-01-21" from "2026-01-21T16:31:35.000Z"
                    }
                    const day = dateStr.substring(0, 10); // YYYY-MM-DD
                    const month = dateStr.substring(0, 7); // YYYY-MM
                    const year = dateStr.substring(0, 4); // YYYY
                    if (!opsByDay[day]) opsByDay[day] = [];
                    if (!opsByMonth[month]) opsByMonth[month] = [];
                    if (!opsByYear[year]) opsByYear[year] = [];
                    opsByDay[day].push(op);
                    opsByMonth[month].push(op);
                    opsByYear[year].push(op);
                } catch (error) {
                    groupingErrorCount++;
                    if (groupingErrorCount <= 3) {
                        console.error(`[ERROR] Grouping failed for op ${index}:`, op, error);
                    }
                }
            });
            console.log('[DEBUG] Date grouping complete. Errors:', groupingErrorCount, 'Days:', Object.keys(opsByDay).length);
            
            console.log(`[calculateAdvancedMetrics] After grouping - Days: ${Object.keys(opsByDay).length}, Months: ${Object.keys(opsByMonth).length}`);
            
            console.log('[calculateAdvancedMetrics] 🔄 Calculando avgPLPerDay...');
            console.log('[calculateAdvancedMetrics] 📊 opsByDay valores:', Object.keys(opsByDay).length);
            console.log('[calculateAdvancedMetrics] 📊 Ejemplo opsByDay:', Object.keys(opsByDay).slice(0, 2).map(k => ({
                fecha: k,
                ops: opsByDay[k].length,
                pl: opsByDay[k].reduce((s, o) => s + o.pl, 0)
            })));
            
            // --- Averages per day/month/year ---
            const avgPLPerDay = Object.values(opsByDay).length > 0 ? Object.values(opsByDay).reduce((sum, arr) => sum + arr.reduce((s, o) => s + convertCurrency(o.pl, o.currency, DB.settings.defaultCurrency), 0), 0) / Object.values(opsByDay).length : 0;
            console.log('[calculateAdvancedMetrics] ✅ avgPLPerDay calculado:', avgPLPerDay);
            
            const avgPLPerMonth = Object.values(opsByMonth).length > 0 ? Object.values(opsByMonth).reduce((sum, arr) => sum + arr.reduce((s, o) => s + convertCurrency(o.pl, o.currency, DB.settings.defaultCurrency), 0), 0) / Object.values(opsByMonth).length : 0;
            console.log('[calculateAdvancedMetrics] ✅ avgPLPerMonth calculado:', avgPLPerMonth);
            
            const avgPLPerYear = Object.values(opsByYear).length > 0 ? Object.values(opsByYear).reduce((sum, arr) => sum + arr.reduce((s, o) => s + convertCurrency(o.pl, o.currency, DB.settings.defaultCurrency), 0), 0) / Object.values(opsByYear).length : 0;
            console.log('[calculateAdvancedMetrics] ✅ avgPLPerYear calculado:', avgPLPerYear);
            // --- Win/Loss per day/month/year ---
            const avgWinPerDay = Object.values(opsByDay).length > 0 ? Object.values(opsByDay).reduce((sum, arr) => sum + arr.filter(o => isWin(o)).reduce((s, o) => s + convertCurrency(o.pl, o.currency, DB.settings.defaultCurrency), 0), 0) / Object.values(opsByDay).length : 0;
            const avgWinPerMonth = Object.values(opsByMonth).length > 0 ? Object.values(opsByMonth).reduce((sum, arr) => sum + arr.filter(o => isWin(o)).reduce((s, o) => s + convertCurrency(o.pl, o.currency, DB.settings.defaultCurrency), 0), 0) / Object.values(opsByMonth).length : 0;
            const avgWinPerYear = Object.values(opsByYear).length > 0 ? Object.values(opsByYear).reduce((sum, arr) => sum + arr.filter(o => isWin(o)).reduce((s, o) => s + convertCurrency(o.pl, o.currency, DB.settings.defaultCurrency), 0), 0) / Object.values(opsByYear).length : 0;
            const avgLossPerDay = Object.values(opsByDay).length > 0 ? Object.values(opsByDay).reduce((sum, arr) => sum + arr.filter(o => isLoss(o)).reduce((s, o) => s + convertCurrency(o.pl, o.currency, DB.settings.defaultCurrency), 0), 0) / Object.values(opsByDay).length : 0;
            const avgLossPerMonth = Object.values(opsByMonth).length > 0 ? Object.values(opsByMonth).reduce((sum, arr) => sum + arr.filter(o => isLoss(o)).reduce((s, o) => s + convertCurrency(o.pl, o.currency, DB.settings.defaultCurrency), 0), 0) / Object.values(opsByMonth).length : 0;
            const avgLossPerYear = Object.values(opsByYear).length > 0 ? Object.values(opsByYear).reduce((sum, arr) => sum + arr.filter(o => isLoss(o)).reduce((s, o) => s + convertCurrency(o.pl, o.currency, DB.settings.defaultCurrency), 0), 0) / Object.values(opsByYear).length : 0;
            
            console.log('[calculateAdvancedMetrics] 🔄 Calculando largestWin y largestLoss...');
            
            // --- Best/Worst per trade/day ---
            let largestWin = 0, largestLoss = 0, largestWinPerDay = 0, largestLossPerDay = 0;
            
            console.log('[calculateAdvancedMetrics] 📊 Procesando opsByDay para largest wins/losses...');
            console.log('[calculateAdvancedMetrics] 📊 Procesando opsByDay para largest wins/losses...');
            
            Object.values(opsByDay).forEach(arr => {
                const dayWin = arr.filter(o => isWin(o)).reduce((s, o) => s + convertCurrency(o.pl, o.currency, DB.settings.defaultCurrency), 0);
                const dayLoss = arr.filter(o => isLoss(o)).reduce((s, o) => s + convertCurrency(o.pl, o.currency, DB.settings.defaultCurrency), 0);
                if (dayWin > largestWinPerDay) largestWinPerDay = dayWin;
                if (dayLoss < largestLossPerDay) largestLossPerDay = dayLoss;
            });
            
            console.log('[calculateAdvancedMetrics] ✅ largestWinPerDay:', largestWinPerDay, 'largestLossPerDay:', largestLossPerDay);
            console.log('[calculateAdvancedMetrics] 📊 Procesando mainOps para largest wins/losses individuales...');
            console.log('[calculateAdvancedMetrics] 📊 Procesando mainOps para largest wins/losses individuales...');
            
            mainOps.forEach(op => {
                let plInDefault = op.pl;
                if (op.currency !== DB.settings.defaultCurrency) {
                    plInDefault = convertCurrency(plInDefault, op.currency, DB.settings.defaultCurrency);
                }
                if (isWin(op) && plInDefault > largestWin) largestWin = plInDefault;
                if (isLoss(op) && plInDefault < largestLoss) largestLoss = plInDefault;
            });
            
            console.log('[calculateAdvancedMetrics] ✅ LARGEST WIN:', largestWin, 'LARGEST LOSS:', largestLoss);
            console.log('[DEBUG] avgPLPerDay:', avgPLPerDay, 'Days:', Object.keys(opsByDay).length);
            console.log('[DEBUG] largestWin:', largestWin, 'largestLoss:', largestLoss);
            console.log('[DEBUG] Sample mainOps:', mainOps.slice(0, 3).map(o => ({id: o.id, pl: o.pl, date: o.date})));
            
            // --- Streaks ---
            let longestWinStreak = 0;
            let currentWinStreak = 0;
            let longestLossStreak = 0;
            let currentLossStreak = 0;
            const sortedOpsByDate = [...mainOps].sort((a,b) => new Date(a.date + 'T00:00:00Z') - new Date(b.date + 'T00:00:00Z'));
            sortedOpsByDate.forEach(op => {
                if (isWin(op)) {
                    currentWinStreak++;
                    currentLossStreak = 0;
                    if (currentWinStreak > longestWinStreak) longestWinStreak = currentWinStreak;
                } else if (isLoss(op)) {
                    currentLossStreak++;
                    currentWinStreak = 0;
                    if (currentLossStreak > longestLossStreak) longestLossStreak = currentLossStreak;
                } else {
                    currentWinStreak = 0;
                    currentLossStreak = 0;
                }
            });
            // --- Last day/week/month/year metrics ---
            const today = getLocalDateString(new Date());
            const lastDayPL = mainOps.filter(op => op.date === today).reduce((sum, op) => sum + convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency), 0);
            const lastWeekStart = getLocalDateString(new Date(new Date().setDate(new Date().getDate() - 7)));
            const lastWeekPL = mainOps.filter(op => op.date >= lastWeekStart && op.date <= today).reduce((sum, op) => sum + convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency), 0);
            const lastMonthStart = getLocalDateString(new Date(new Date().setMonth(new Date().getMonth() - 1)));
            const lastMonthPL = mainOps.filter(op => op.date >= lastMonthStart && op.date <= today).reduce((sum, op) => sum + convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency), 0);
            const lastYearStart = getLocalDateString(new Date(new Date().setFullYear(new Date().getFullYear() - 1)));
            const lastYearPL = mainOps.filter(op => op.date >= lastYearStart && op.date <= today).reduce((sum, op) => sum + convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency), 0);

            const resultado = {
                avgWin, avgLoss, avgPLPerTrade, expectancy: ((metrics.winRate / 100) * avgWin) - (((winningTrades + losingTrades) > 0 ? losingTrades / (winningTrades + losingTrades) : 0) * Math.abs(avgLoss)),
                largestWin, largestLoss,
                longestWinStreak, longestLossStreak,
                avgPLPercentage, avgWinPercentage, avgLossPercentage, totalWinPercentage, totalLossPercentage,
                avgPLPerDay, avgPLPerMonth, avgPLPerYear,
                avgWinPerDay, avgWinPerMonth, avgWinPerYear,
                avgLossPerDay, avgLossPerMonth, avgLossPerYear,
                largestWinPerDay, largestLossPerDay,
                lastDayPL, lastWeekPL, lastMonthPL, lastYearPL
            };
            
            console.log('[calculateAdvancedMetrics] 🎯 RETURN FINAL:', {
                avgPLPerTrade: resultado.avgPLPerTrade,
                largestWin: resultado.largestWin,
                largestLoss: resultado.largestLoss,
                avgPLPerDay: resultado.avgPLPerDay,
                avgPLPerMonth: resultado.avgPLPerMonth,
                avgPLPerYear: resultado.avgPLPerYear
            });
            
            return resultado;
        }

        function calculateExtraAnalytics(operations, accountId = 'all') {
            const sortedOps = [...operations].sort((a, b) => new Date(a.date + 'T' + (a.entryTime || '00:00')) - new Date(b.date + 'T' + (b.entryTime || '00:00')));

            // --- Max Drawdown Calculation ---
            let initialBalanceForDD = 0;
            let currencyForDD = DB.settings.defaultCurrency;

            if (accountId !== 'all') {
                const account = DB.accounts.find(a => a.id === accountId);
                if (account) {
                    initialBalanceForDD = account.initialBalance;
                    currencyForDD = account.currency;
                }
            } else {
                initialBalanceForDD = DB.accounts.reduce((sum, acc) => sum + convertCurrency(acc.initialBalance, acc.currency, currencyForDD), 0);
            }

            let peakBalance = initialBalanceForDD;
            let maxDrawdownValue = 0;
            let currentBalance = initialBalanceForDD;
            sortedOps.forEach(op => {
                let pl = convertCurrency(op.pl, op.currency, currencyForDD);
                currentBalance += pl;
                if (currentBalance > peakBalance) peakBalance = currentBalance;
                const drawdown = peakBalance - currentBalance;
                if (drawdown > maxDrawdownValue) maxDrawdownValue = drawdown;
            });
            const maxDrawdownPercentage = initialBalanceForDD > 0 ? (maxDrawdownValue / initialBalanceForDD) * 100 : 0;

            // --- Average Holding Time ---
            let totalDurationMinutes = 0, tradesWithDuration = 0;
            operations.forEach(op => {
                if (op.entryTime && op.exitTime) {
                    try {
                        const startDate = new Date(`1970-01-01T${op.entryTime}`);
                        const endDate = new Date(`1970-01-01T${op.exitTime}`);
                        let duration = (endDate - startDate) / 60000;
                        if (duration < 0) duration += 24 * 60; // Overnight
                        totalDurationMinutes += duration;
                        tradesWithDuration++;
                    } catch (e) { /* ignore */ }
                }
            });
            let avgHoldTimeText = 'N/A';
            if (tradesWithDuration > 0) {
                const avgMinutes = totalDurationMinutes / tradesWithDuration;
                if (avgMinutes < 1) avgHoldTimeText = `${(avgMinutes * 60).toFixed(0)} seg`;
                else if (avgMinutes < 60) avgHoldTimeText = `${avgMinutes.toFixed(0)} min`;
                else avgHoldTimeText = `${Math.floor(avgMinutes / 60)}h ${Math.round(avgMinutes % 60)}m`;
            }

            // --- Standard Deviation of P/L ---
            let stdDevPL = 0;
            if (operations.length > 1) {
                const plsInDefaultCurrency = operations.map(op => convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency));
                const mean = plsInDefaultCurrency.reduce((sum, val) => sum + val, 0) / plsInDefaultCurrency.length;
                const variance = plsInDefaultCurrency.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / plsInDefaultCurrency.length;
                stdDevPL = Math.sqrt(variance);
            }

            // --- Average Win/Loss Ratio ---
            const basicMetrics = calculateMetrics(operations, accountId);
            const advancedMetricsForRatio = calculateAdvancedMetrics(operations, accountId);
            const avgWLRatio = Math.abs(advancedMetricsForRatio.avgLoss) > 0 ? Math.abs(advancedMetricsForRatio.avgWin / advancedMetricsForRatio.avgLoss) : (advancedMetricsForRatio.avgWin > 0 ? Infinity : 0);

            return {
                maxDrawdownValue, maxDrawdownPercentage, currencyForDD,
                avgHoldTimeText,
                stdDevPL,
                avgWLRatio
            };
        }

        function formatDurationText(minutes) {
            // Validar que minutes sea un número válido
            if (typeof minutes !== 'number' || isNaN(minutes) || minutes < 0) {
                return 'N/A';
            }
            
            if (minutes < 1) return `${(minutes * 60).toFixed(0)} seg`;
            if (minutes < 60) return `${minutes.toFixed(0)} min`;
            if (minutes < 1440) return `${Math.floor(minutes / 60)}h ${Math.round(minutes % 60)}m`;
            const days = Math.floor(minutes / 1440);
            const hours = Math.floor((minutes % 1440) / 60);
            return `${days}d ${hours}h`;
        }

        function calculateProfessionalMetrics(operations, accountId = 'all') {
            if (!operations || operations.length === 0) {
                return {
                    expectancyRatio: 0, kellyCriterion: 0, sharpeRatio: 0, sortinoRatio: 0,
                    calmarRatio: 0, recoveryFactor: 0, riskOfRuin: 0, zScore: 0,
                    avgMAE: 0, avgMFE: 0, maxWinStreak: 0, maxLossStreak: 0,
                    consistencyScore: 0, payoffRatio: 0, totalTradingDays: 0, avgRMultiple: 0
                };
            }

            const basicMetrics = calculateMetrics(operations, accountId);
            const advancedMetrics = calculateAdvancedMetrics(operations, accountId);
            
            // Expectancy Ratio = (Win% * AvgWin) - (Loss% * AvgLoss)
            const winRate = basicMetrics.winRate / 100;
            const lossRate = 1 - winRate;
            const expectancyRatio = (winRate * advancedMetrics.avgWin) + (lossRate * advancedMetrics.avgLoss);
            
            // Kelly Criterion = (Win% * AvgWin - Loss% * AvgLoss) / AvgWin
            const kellyCriterion = Math.abs(advancedMetrics.avgWin) > 0 
                ? ((winRate * Math.abs(advancedMetrics.avgWin) - lossRate * Math.abs(advancedMetrics.avgLoss)) / Math.abs(advancedMetrics.avgWin)) * 100
                : 0;
            
            // Sharpe Ratio = (Average Return - Risk Free Rate) / Std Dev of Returns
            const plArray = operations.map(op => {
                const plValue = op.pl ?? op.pnl ?? 0;
                return convertCurrency(plValue, op.currency, DB.settings.defaultCurrency);
            });
            const avgReturn = plArray.reduce((sum, pl) => sum + pl, 0) / plArray.length;
            const variance = plArray.reduce((sum, pl) => sum + Math.pow(pl - avgReturn, 2), 0) / plArray.length;
            const stdDev = Math.sqrt(variance);
            const sharpeRatio = stdDev > 0 ? (avgReturn / stdDev) * Math.sqrt(252) : 0; // Annualized
            
            // Sortino Ratio = Average Return / Downside Deviation
            const downsideReturns = plArray.filter(pl => pl < 0);
            const downsideVariance = downsideReturns.length > 0 
                ? downsideReturns.reduce((sum, pl) => sum + Math.pow(pl, 2), 0) / downsideReturns.length 
                : 0;
            const downsideDeviation = Math.sqrt(downsideVariance);
            const sortinoRatio = downsideDeviation > 0 ? (avgReturn / downsideDeviation) * Math.sqrt(252) : 0;
            
            // Max Drawdown for Calmar and Recovery
            const extraMetrics = calculateExtraAnalytics(operations, accountId);
            const maxDrawdown = extraMetrics.maxDrawdownValue;
            
            // Calmar Ratio = Annualized Return / Max Drawdown
            const totalDays = operations.length > 0 ? 
                (new Date(operations[operations.length - 1].date) - new Date(operations[0].date)) / (1000 * 60 * 60 * 24) : 1;
            const annualizedReturn = totalDays > 0 ? (basicMetrics.totalWin + basicMetrics.totalLoss) * (365 / totalDays) : 0;
            const calmarRatio = maxDrawdown > 0 ? annualizedReturn / maxDrawdown : 0;
            
            // Recovery Factor = Net Profit / Max Drawdown
            const recoveryFactor = maxDrawdown > 0 ? (basicMetrics.totalWin + basicMetrics.totalLoss) / maxDrawdown : 0;
            
            // Risk of Ruin (simplified formula)
            const payoffRatio = Math.abs(advancedMetrics.avgLoss) > 0 ? Math.abs(advancedMetrics.avgWin / advancedMetrics.avgLoss) : 1;
            const riskOfRuin = winRate > 0.5 ? Math.pow((1 - winRate) / winRate, payoffRatio) * 100 : 100;
            
            // Z-Score (streak consistency)
            let runs = 0, lastResult = null;
            operations.forEach(op => {
                if (op.result !== lastResult && lastResult !== null) runs++;
                lastResult = op.result;
            });
            const N = operations.length;
            const W = operations.filter(op => op.result === 'win').length;
            const L = N - W;
            const expectedRuns = W > 0 && L > 0 ? (2 * W * L) / N + 1 : runs;
            const variance_runs = W > 0 && L > 0 ? (2 * W * L * (2 * W * L - N)) / (N * N * (N - 1)) : 0;
            const stdDev_runs = Math.sqrt(variance_runs);
            const zScore = stdDev_runs > 0 ? (runs - expectedRuns) / stdDev_runs : 0;
            
            // MAE/MFE (simplified - usando drawdown como proxy)
            const avgMAE = maxDrawdown / operations.length;
            const avgMFE = Math.abs(advancedMetrics.largestWin) / 2; // Simplified
            
            // Max Win/Loss Streaks
            let currentWinStreak = 0, maxWinStreak = 0;
            let currentLossStreak = 0, maxLossStreak = 0;
            operations.forEach(op => {
                if (op.result === 'win') {
                    currentWinStreak++;
                    currentLossStreak = 0;
                    maxWinStreak = Math.max(maxWinStreak, currentWinStreak);
                } else if (op.result === 'loss') {
                    currentLossStreak++;
                    currentWinStreak = 0;
                    maxLossStreak = Math.max(maxLossStreak, currentLossStreak);
                }
            });
            
            // Consistency Score (0-100)
            const profitFactorScore = Math.min(basicMetrics.profitFactor / 3 * 40, 40);
            const winRateScore = Math.min(basicMetrics.winRate / 70 * 30, 30);
            const streakScore = maxLossStreak > 0 ? Math.max(30 - (maxLossStreak / 10 * 30), 0) : 30;
            const consistencyScore = Math.round(profitFactorScore + winRateScore + streakScore);
            
            // Total Trading Days
            const uniqueDays = [...new Set(operations.map(op => op.date))].length;
            
            // Average R-Multiple (simplified)
            const avgRMultiple = payoffRatio * winRate - (1 - winRate);
            
            return {
                expectancyRatio,
                kellyCriterion: Math.max(-100, Math.min(100, kellyCriterion)),
                sharpeRatio,
                sortinoRatio,
                calmarRatio,
                recoveryFactor,
                riskOfRuin: Math.min(100, Math.max(0, riskOfRuin)),
                zScore,
                avgMAE,
                avgMFE,
                maxWinStreak,
                maxLossStreak,
                consistencyScore,
                payoffRatio,
                totalTradingDays: uniqueDays,
                avgRMultiple
            };
        }

        function calculateTimeMetrics(operations) {
            let winDurations = [];
            let lossDurations = [];
            let hourlyPerformance = Array(24).fill(0).map(() => ({ pl: 0, count: 0 }));
            
            operations.forEach(op => {
                // Calculate trade duration
                if (op.entryTime && op.exitTime) {
                    try {
                        // Usar la fecha de la operación para el cálculo completo
                        let opDate = op.date || '2024-01-01';
                        
                        // Si la fecha ya tiene formato ISO completo, extraer solo la parte de fecha
                        if (typeof opDate === 'string' && opDate.includes('T')) {
                            opDate = opDate.split('T')[0];
                        }
                        
                        const startDateTime = new Date(`${opDate}T${op.entryTime}`);
                        const endDateTime = new Date(`${opDate}T${op.exitTime}`);
                        
                        // Verificar si las fechas son válidas
                        if (isNaN(startDateTime.getTime()) || isNaN(endDateTime.getTime())) {
                            // console.warn('⚠️ Fechas inválidas:', { date: opDate, entryTime: op.entryTime, exitTime: op.exitTime });
                            return;
                        }
                        
                        let duration = (endDateTime - startDateTime) / 60000; // minutes
                        
                        // Si la duración es negativa, puede ser que la operación cruzó la medianoche
                        if (duration < 0) {
                            duration += 24 * 60; // Ajuste para operaciones overnight
                        }
                        
                        // Validar que la duración sea razonable (menos de 7 días)
                        if (duration > 0 && duration < 10080) { // 10080 minutos = 7 días
                            if (op.result === 'win') {
                                winDurations.push(duration);
                            } else if (op.result === 'loss') {
                                lossDurations.push(duration);
                            }
                        } else {
                            console.warn('⚠️ Duración fuera de rango:', duration, 'minutos', op);
                        }
                    } catch (e) { 
                        console.warn('⚠️ Error calculando duración:', e, op);
                    }
                }
                
                // Calculate hourly performance
                if (op.entryTime) {
                    try {
                        const hour = parseInt(op.entryTime.split(':')[0], 10);
                        if (!isNaN(hour) && hour >= 0 && hour <= 23) {
                            const plInDefault = convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency);
                            hourlyPerformance[hour].pl += plInDefault;
                            hourlyPerformance[hour].count++;
                        }
                    } catch (e) { /* ignore invalid time */ }
                }
            });
            
            // Calculate averages
            const avgWinDuration = winDurations.length > 0 
                ? winDurations.reduce((sum, d) => sum + d, 0) / winDurations.length 
                : 0;
            const avgLossDuration = lossDurations.length > 0 
                ? lossDurations.reduce((sum, d) => sum + d, 0) / lossDurations.length 
                : 0;
            
            // Find best and worst hours
            let bestHour = -1;
            let bestHourPL = -Infinity;
            let worstHour = -1;
            let worstHourPL = Infinity;
            
            hourlyPerformance.forEach((data, hour) => {
                if (data.count > 0) {
                    if (data.pl > bestHourPL) {
                        bestHourPL = data.pl;
                        bestHour = hour;
                    }
                    if (data.pl < worstHourPL) {
                        worstHourPL = data.pl;
                        worstHour = hour;
                    }
                }
            });
            
            // Find longest win/loss and fastest win
            const longestWinDuration = winDurations.length > 0 ? Math.max(...winDurations) : 0;
            const longestLossDuration = lossDurations.length > 0 ? Math.max(...lossDurations) : 0;
            const fastestWin = winDurations.length > 0 ? Math.min(...winDurations) : 0;
            
            return {
                avgWinDuration,
                avgLossDuration,
                bestHour,
                worstHour,
                bestHourPL,
                worstHourPL,
                longestWinDuration,
                longestLossDuration,
                fastestWin,
                hasWins: winDurations.length > 0,
                hasLosses: lossDurations.length > 0
            };
        }


        function initAnalytics() {
            updateAccountSelect('analytics-account-select');
            refreshAnalytics();
            
            const accountSelect = document.getElementById('analytics-account-select');
            if (accountSelect) {
                accountSelect.addEventListener('change', function() {
                    const selectedAccount = this.value;
                    syncAccountSelection(selectedAccount); // Sincronizar con todas las secciones
                    updateSelectorLogo('analytics-account-select');
                    refreshAnalytics();
                });
            }
            
            // Selector de moneda Analytics
            const currencySelect = document.getElementById('analytics-currency-select');
            if (currencySelect) {
                currencySelect.addEventListener('change', refreshAnalytics);
            }

            // Botón de filtros
            const filtersBtn = document.getElementById('analytics-filters-btn');
            if (filtersBtn) {
                filtersBtn.addEventListener('click', () => {
                    currentFilterSection = 'analytics';
                    toggleFiltersSidebar();
                });
            }

            // Botón de descarga - Abrir modal de PDF Report profesional
            const downloadBtn = document.getElementById('analytics-download-btn');
            if (downloadBtn) {
                downloadBtn.addEventListener('click', () => openPDFReportModal());
            }
            
            // NUEVO: Listeners para el modal de detalles
            const closeBtn = document.getElementById('analytics-detail-close-btn');
            if (closeBtn) {
                closeBtn.addEventListener('click', closeAnalyticsDetailModal);
            }
            
            const modal = document.getElementById('analytics-detail-modal');
            if (modal) {
                modal.addEventListener('click', (e) => {
                    if (e.target.id === 'analytics-detail-modal') {
                        closeAnalyticsDetailModal();
                    }
                });
            }

            // Event listeners para notas
            const saveNotesBtn = document.getElementById('analytics-detail-save-notes-btn');
            const gotoNotebookBtn = document.getElementById('analytics-detail-goto-notebook-btn');
            const voiceNoteBtn = document.getElementById('analytics-voice-note-btn');
            const downloadNoteBtn = document.getElementById('analytics-download-note-btn');

            if (saveNotesBtn) {
                saveNotesBtn.addEventListener('click', async () => {
                    const analysisType = modal.dataset.analysisType;
                    const editor = document.getElementById('analytics-detail-notes-editor');
                    const notes = editor ? editor.innerHTML : '';
                    
                    if (analysisType === 'date') {
                        const dateStr = modal.dataset.currentDate;
                        await saveDailyNotes(dateStr, notes);
                    } else if (analysisType === 'month') {
                        const monthStr = modal.dataset.currentMonth;
                        await saveMonthlyNotes(monthStr, notes);
                    } else if (analysisType === 'week') {
                        const weekKey = modal.dataset.currentWeek;
                        const [startDate, endDate] = weekKey.split('_');
                        await saveWeeklyNotes(startDate, endDate, notes);
                    } else if (analysisType === 'quarter') {
                        const quarter = modal.dataset.currentQuarter;
                        await saveQuarterlyNotes(quarter, notes);
                    }
                });
            }

            if (gotoNotebookBtn) {
                gotoNotebookBtn.addEventListener('click', () => {
                    const dateStr = modal.dataset.currentDate;
                    closeAnalyticsDetailModal();
                    // Cambiar a sección notebook y buscar la nota del día
                    changeSection('notebook');
                    // TODO: Filtrar/buscar la nota específica del día
                });
            }

            if (voiceNoteBtn) {
                voiceNoteBtn.addEventListener('click', () => {
                    showToast('🎤 Función de nota de voz próximamente disponible', 'info');
                });
            }

            if (downloadNoteBtn) {
                downloadNoteBtn.addEventListener('click', downloadAnalyticsNote);
            }
            
            // Event listeners para el modal de PDF Report
            const pdfModal = document.getElementById('pdf-report-modal');
            const closePdfBtn = document.getElementById('close-pdf-report-modal');
            const cancelPdfBtn = document.getElementById('cancel-pdf-report');
            const generatePdfBtn = document.getElementById('generate-pdf-report');
            const periodSelect = document.getElementById('pdf-period-select');
            const customDatesDiv = document.getElementById('pdf-custom-dates');
            
            if (closePdfBtn) {
                closePdfBtn.addEventListener('click', closePDFReportModal);
            }
            
            if (cancelPdfBtn) {
                cancelPdfBtn.addEventListener('click', closePDFReportModal);
            }
            
            if (generatePdfBtn) {
                generatePdfBtn.addEventListener('click', generateProfessionalPDF);
            }
            
            if (periodSelect && customDatesDiv) {
                periodSelect.addEventListener('change', (e) => {
                    customDatesDiv.style.display = e.target.value === 'custom' ? 'grid' : 'none';
                });
            }
            
            if (pdfModal) {
                pdfModal.addEventListener('click', (e) => {
                    if (e.target.id === 'pdf-report-modal') {
                        closePDFReportModal();
                    }
                });
            }
            
            // Event listeners para las cards de tipo de reporte
            document.querySelectorAll('.pdf-report-option').forEach(card => {
                card.addEventListener('click', function() {
                    // Remover active de todas
                    document.querySelectorAll('.pdf-report-option').forEach(c => {
                        c.classList.remove('active');
                        c.style.border = '2px solid var(--border)';
                        c.style.background = 'transparent';
                    });
                    
                    // Activar la seleccionada
                    this.classList.add('active');
                    this.style.border = '2px solid var(--primary)';
                    this.style.background = 'rgba(57, 255, 20, 0.05)';
                    
                    // Actualizar valor
                    document.getElementById('pdf-report-type-value').value = this.dataset.value;
                });
            });
        }

        function initInforme() {
            updateAccountSelect('informe-account-select');
            
            // Selector de moneda Informe
            const currencySelect = document.getElementById('informe-currency-select');
            if (currencySelect) {
                currencySelect.addEventListener('change', () => {
                    refreshActiveInformeSubTab();
                });
            }

            // Botón de filtros
            const filtersBtn = document.getElementById('informe-filters-btn');
            if (filtersBtn) {
                filtersBtn.addEventListener('click', () => {
                    currentFilterSection = 'informe';
                    toggleFiltersSidebar();
                });
            }

            // Botón de descarga
            const downloadBtn = document.getElementById('informe-download-btn');
            if (downloadBtn) {
                downloadBtn.addEventListener('click', () => downloadSectionPDF('informe', 'Informe'));
            }

            const toggleFiltersBtn = document.getElementById('informe-toggle-filters-btn');
            const filtersPanel = document.getElementById('informe-filters-panel');
            const applyFiltersBtn = document.getElementById('informe-apply-filters-btn');
            const clearFiltersBtn = document.getElementById('informe-clear-filters-btn');

            if (toggleFiltersBtn && filtersPanel) {
                toggleFiltersBtn.addEventListener('click', () => {
                    filtersPanel.classList.toggle('hidden');
                });
            }

            if (applyFiltersBtn) {
                applyFiltersBtn.addEventListener('click', () => {
                informeFilters.symbol = document.getElementById('informe-filter-symbol').value.toUpperCase();
                informeFilters.type = document.getElementById('informe-filter-type').value;
                informeFilters.result = document.getElementById('informe-filter-result').value;
                const plMin = document.getElementById('informe-filter-pl-min').value;
                const plMax = document.getElementById('informe-filter-pl-max').value;
                informeFilters.plMin = plMin === '' ? null : parseFloat(plMin);
                informeFilters.plMax = plMax === '' ? null : parseFloat(plMax);
                informeFilters.day = document.getElementById('informe-filter-day').value;

                refreshActiveInformeSubTab();
                });
            }

            if (clearFiltersBtn) {
                clearFiltersBtn.addEventListener('click', () => {
                    document.getElementById('informe-filter-symbol').value = '';
                    document.getElementById('informe-filter-type').value = 'all';
                    document.getElementById('informe-filter-result').value = 'all';
                    document.getElementById('informe-filter-pl-min').value = '';
                    document.getElementById('informe-filter-pl-max').value = '';
                    document.getElementById('informe-filter-day').value = 'all';

                    informeFilters = { symbol: '', type: 'all', result: 'all', plMin: null, plMax: null, day: 'all' };
                    refreshActiveInformeSubTab();
                });
            }

            const informeSubTabs = document.querySelectorAll('.informe-sub-tab');
            const informeSubSections = document.querySelectorAll('.informe-sub-section-container');

            informeSubTabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    informeSubTabs.forEach(t => {
                        t.classList.remove('active');
                        t.style.color = 'var(--text-secondary)';
                        t.style.borderBottomColor = 'transparent';
                        t.style.fontWeight = 'normal';
                    });
                    informeSubSections.forEach(s => s.classList.remove('active'));

                    tab.classList.add('active');
                    tab.style.color = 'var(--text)'; // Active tab text color
                    tab.style.borderBottomColor = 'var(--primary)';
                    tab.style.fontWeight = '600';

                    const targetId = tab.dataset.target;
                    const targetSection = document.getElementById(targetId);
                    if (targetSection) {
                        targetSection.classList.add('active');
                    }

                    switch (targetId) {
                        case 'informe-informes-content':
                            refreshInforme();
                            break; // Refresh main informe metrics
                        case 'informe-metricas-content':
                            refreshMetricas();
                            break; // Refresh new metrics tab
                        case 'informe-metricas-avanzadas-content':
                            refreshMetricasAvanzadas();
                            break; // Refresh advanced metrics tab
                        case 'informe-simbolos-content':
                            refreshSimbolos();
                            break; // Refresh symbols tab
                        case 'informe-tiempo-content':
                            refreshTiempo();
                            break; // Refresh time metrics tab
                        case 'informe-graficos-content':
                            setTimeout(() => window.refreshGraficosCharts && window.refreshGraficosCharts(), 50);
                            break;
                    }
                });
            });

            document.getElementById('informe-account-select').addEventListener('change', function() {
                const selectedAccount = this.value;
                console.log('=== ACCOUNT CHANGED === [EVENT LISTENER #1]', selectedAccount);
                
                // Actualizar cuenta global SIN sincronizar (para evitar loop infinito)
                globalSelectedAccount = selectedAccount;
                
                // Sincronizar con OTRAS secciones solamente (no dispara change en informe-account-select)
                const selectors = [
                    'dashboard-account-select',
                    'new-dashboard-account-select',
                    'analytics-account-select',
                    'daily-journal-account-select',
                    'calendar-account-select',
                    'equity-account-select',
                    'filter-account',
                    'chartbook-account-select'
                ];
                
                selectors.forEach(selectorId => {
                    const selectElement = document.getElementById(selectorId);
                    if (selectElement && selectElement.value !== selectedAccount) {
                        selectElement.value = selectedAccount;
                        updateSelectorLogo(selectorId);
                    }
                });
                
                updateSelectorLogo('informe-account-select');
                const activeSubTab = document.querySelector('.informe-sub-tab.active');
                if (activeSubTab) {
                    const targetId = activeSubTab.dataset.target;
                    console.log('Active sub-tab:', targetId);
                    switch (targetId) {
                        case 'informe-informes-content':
                            console.log('Calling refreshInforme()...');
                            setTimeout(() => refreshInforme(), 50);
                            break; // Refresh main informe metrics
                        case 'informe-metricas-content':
                            setTimeout(() => refreshMetricas(), 50);
                            break; // Refresh new metrics tab
                        case 'informe-metricas-avanzadas-content':
                            setTimeout(() => refreshMetricasAvanzadas(), 50);
                            break; // Refresh advanced metrics tab
                        case 'informe-simbolos-content':
                            setTimeout(() => refreshSimbolos(), 50);
                            break; // Refresh symbols tab
                        case 'informe-tiempo-content':
                            setTimeout(() => refreshTiempo(), 50);
                            break; // Refresh time metrics tab
                        case 'informe-graficos-content':
                            setTimeout(() => window.refreshGraficosCharts && window.refreshGraficosCharts(), 50);
                            break;
                        case 'informe-comisiones-content':
                            if (typeof window.refreshComisiones === 'function') {
                                window.refreshComisiones();
                            }
                            break; // Refresh commissions tab
                    }
                } else {
                    refreshInforme();
                }
            });

            // Add listener for date filter changes within the Informe tab
            document.getElementById('informe-date-filter-btn').addEventListener('click', function() {
                // The date range modal logic is global, but after it applies a filter,
                // we need to ensure the correct sub-tab refreshes.
                // The `updateGlobalDateFilter` function already calls `refreshAllViews`,
                // which in turn calls `refreshInforme` if the main tab is active.
                // The `refreshInforme` function will then delegate to the correct sub-tab refresh function.
                // So, no extra logic is needed here, but it's good to confirm the flow.
                // The main date range modal listener will handle opening the modal.
            });


        }

        let informeMetricasEvolutionChart = null;
        let informeMetricasRadarChart = null;
        let informeMetricasPositionSizeChart = null;
        let informeMetricasPlByRiskChart = null;
        let informeMetricasCapitalEffChart = null;
        let informeMetricasRRComparisonChart = null;

        function refreshMetricas() {
            console.log('[Métricas] 🔄 Refreshing...');
            const dataView = document.getElementById('informe-metricas-data-view');
            const noDataView = document.getElementById('informe-metricas-no-data');
            if (!dataView || !noDataView) return;

            const selectedAccount = document.getElementById('informe-account-select').value;
            const currencySelect = document.getElementById('informe-currency-select');
            const displayCurrency = currencySelect ? currencySelect.value : 'USD';

            console.log('[Métricas] Selected account:', selectedAccount);
            let operations = applyDateFilterToData(DB.operations);
            console.log('[Métricas] Operations after date filter:', operations.length);
            if (selectedAccount !== 'all') {
                operations = operations.filter(op => op.accountId === selectedAccount);
            }
            console.log('[Métricas] Operations after account filter:', operations.length);
            operations = applyInformeFilters(operations);
            console.log('[Métricas] Operations after additional filters:', operations.length);

            if (operations.length === 0) {
                dataView.style.display = 'none';
                noDataView.style.display = 'block';
                return;
            }

            dataView.style.display = 'block';
            noDataView.style.display = 'none';

            // Destruir charts anteriores
            if (informeMetricasPositionSizeChart) { informeMetricasPositionSizeChart.destroy(); informeMetricasPositionSizeChart = null; }
            if (informeMetricasPlByRiskChart) { informeMetricasPlByRiskChart.destroy(); informeMetricasPlByRiskChart = null; }
            if (informeMetricasCapitalEffChart) { informeMetricasCapitalEffChart.destroy(); informeMetricasCapitalEffChart = null; }
            if (informeMetricasRRComparisonChart) { informeMetricasRRComparisonChart.destroy(); informeMetricasRRComparisonChart = null; }

            const basicMetrics = calculateMetrics(operations, selectedAccount);

            // Trades by Day/Month/Year
            const dailyTrades = {};
            const monthlyTrades = {};
            const yearlyTrades = {};
            operations.forEach(op => {
                const day = op.date;
                const month = op.date.substring(0, 7);
                const year = op.date.substring(0, 4);
                dailyTrades[day] = (dailyTrades[day] || 0) + 1;
                monthlyTrades[month] = (monthlyTrades[month] || 0) + 1;
                yearlyTrades[year] = (yearlyTrades[year] || 0) + 1;
            });

            const totalTradingDays = Object.keys(dailyTrades).length;
            const totalTradingMonths = Object.keys(monthlyTrades).length;
            const totalTradingYears = Object.keys(yearlyTrades).length;

            const avgTradesPerDay = totalTradingDays > 0 ? operations.length / totalTradingDays : 0;
            const avgTradesPerMonth = totalTradingMonths > 0 ? operations.length / totalTradingMonths : 0;
            const avgTradesPerYear = totalTradingYears > 0 ? operations.length / totalTradingYears : 0;

            const maxTradesPerDay = totalTradingDays > 0 ? Math.max(...Object.values(dailyTrades)) : 0;
            const maxTradesPerMonth = totalTradingMonths > 0 ? Math.max(...Object.values(monthlyTrades)) : 0;
            const maxTradesPerYear = totalTradingYears > 0 ? Math.max(...Object.values(yearlyTrades)) : 0;

            // Winning/Losing Days
            const dailyPL = {};
            operations.forEach(op => {
                const date = op.date;
                if (!dailyPL[date]) dailyPL[date] = 0;
                const plValue = op.pl ?? op.pnl ?? 0;
                dailyPL[date] += convertCurrency(plValue, op.currency, DB.settings.defaultCurrency);
            });
            const winningDays = Object.values(dailyPL).filter(pl => pl > 0).length;
            const losingDays = Object.values(dailyPL).filter(pl => pl < 0).length;
            const totalDaysOperated = winningDays + losingDays; // Assuming breakeven days are not counted as winning/losing

            // Long/Short Trades
            const longTradesCount = operations.filter(op => op.type === 'buy').length;
            const shortTradesCount = operations.filter(op => op.type === 'sell').length;

            // Update UI for Metrics
            const updateMetric = (id, value, isPercent = false, total = 1) => {
                const el = document.getElementById(id);
                if (el) {
                    if (isPercent) {
                        el.textContent = `${(total > 0 ? (value / total) * 100 : 0).toFixed(2)}%`;
                    } else {
                        if (Number.isInteger(value)) {
                            el.textContent = value.toLocaleString();
                        } else {
                            el.textContent = value.toFixed(2);
                        }
                    }
                }
            };

            document.getElementById('informe-metricas-total-trades').textContent = basicMetrics.totalTrades;
            console.log('[Métricas] ✅ Updated total-trades to:', basicMetrics.totalTrades);

            document.getElementById('informe-metricas-winning-trades').textContent = basicMetrics.winningTrades;
            updateMetric('informe-metricas-winning-trades-percent', basicMetrics.winningTrades, true, basicMetrics.totalTrades);
            console.log('[Métricas] ✅ Updated winning-trades to:', basicMetrics.winningTrades);

            document.getElementById('informe-metricas-losing-trades').textContent = basicMetrics.losingTrades;
            updateMetric('informe-metricas-losing-trades-percent', basicMetrics.losingTrades, true, basicMetrics.totalTrades);

            document.getElementById('informe-metricas-breakeven-trades').textContent = basicMetrics.breakevenTrades;
            updateMetric('informe-metricas-breakeven-trades-percent', basicMetrics.breakevenTrades, true, basicMetrics.totalTrades);

            document.getElementById('informe-metricas-long-trades').textContent = longTradesCount;
            updateMetric('informe-metricas-long-trades-percent', longTradesCount, true, basicMetrics.totalTrades);

            document.getElementById('informe-metricas-short-trades').textContent = shortTradesCount;
            updateMetric('informe-metricas-short-trades-percent', shortTradesCount, true, basicMetrics.totalTrades);

            document.getElementById('informe-metricas-winning-days').textContent = winningDays;
            updateMetric('informe-metricas-winning-days-percent', winningDays, true, totalDaysOperated);

            document.getElementById('informe-metricas-losing-days').textContent = losingDays;
            updateMetric('informe-metricas-losing-days-percent', losingDays, true, totalDaysOperated);

            document.getElementById('informe-metricas-avg-trades-day').textContent = avgTradesPerDay.toFixed(2);
            document.getElementById('informe-metricas-avg-trades-month').textContent = avgTradesPerMonth.toFixed(2);
            document.getElementById('informe-metricas-avg-trades-year').textContent = avgTradesPerYear.toFixed(2);

            document.getElementById('informe-metricas-max-trades-day').textContent = maxTradesPerDay;
            document.getElementById('informe-metricas-max-trades-month').textContent = maxTradesPerMonth;
            document.getElementById('informe-metricas-max-trades-year').textContent = maxTradesPerYear;

            // ===== ACTUALIZAR BARRAS DE DISTRIBUCIÓN WIN/LOSS =====
            const mainOps = operations.filter(op => !op.parentId || op.parentId === '' || op.parentId === null);
            
            const winOps = mainOps.filter(op => op.result === 'win');
            const lossOps = mainOps.filter(op => op.result === 'loss');
            const breakevenOps = mainOps.filter(op => op.result === 'breakeven' || (!op.result && op.pl === 0));
            const totalOps = mainOps.length;
            
            const winCount = winOps.length;
            const lossCount = lossOps.length;
            const breakevenCount = breakevenOps.length;
            
            const winPercentage = totalOps > 0 ? (winCount / totalOps * 100) : 0;
            const lossPercentage = totalOps > 0 ? (lossCount / totalOps * 100) : 0;
            const breakevenPercentage = totalOps > 0 ? (breakevenCount / totalOps * 100) : 0;
            
            const totalWinAmount = winOps.reduce((sum, op) => sum + convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency), 0);
            const totalLossAmount = lossOps.reduce((sum, op) => sum + convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency), 0);
            
            // Actualizar contadores y barras
            const winCountBarEl = document.getElementById('informe-win-count-bar');
            if (winCountBarEl) winCountBarEl.textContent = `${winCount} (${winPercentage.toFixed(1)}%)`;
            
            const lossCountBarEl = document.getElementById('informe-loss-count-bar');
            if (lossCountBarEl) lossCountBarEl.textContent = `${lossCount} (${lossPercentage.toFixed(1)}%)`;
            
            const breakevenCountBarEl = document.getElementById('informe-breakeven-count-bar');
            if (breakevenCountBarEl) breakevenCountBarEl.textContent = `${breakevenCount} (${breakevenPercentage.toFixed(1)}%)`;
            
            // Actualizar anchos de barras
            const winBarEl = document.getElementById('informe-win-bar');
            if (winBarEl) {
                winBarEl.style.width = `${winPercentage}%`;
                const winAmountEl = document.getElementById('informe-win-amount-bar');
                if (winAmountEl) winAmountEl.textContent = formatCurrency(totalWinAmount, DB.settings.defaultCurrency, displayCurrency);
            }
            
            const lossBarEl = document.getElementById('informe-loss-bar');
            if (lossBarEl) {
                lossBarEl.style.width = `${lossPercentage}%`;
                const lossAmountEl = document.getElementById('informe-loss-amount-bar');
                if (lossAmountEl) lossAmountEl.textContent = formatCurrency(totalLossAmount, DB.settings.defaultCurrency, displayCurrency);
            }
            
            const breakevenBarEl = document.getElementById('informe-breakeven-bar');
            if (breakevenBarEl) {
                breakevenBarEl.style.width = `${breakevenPercentage}%`;
                const breakevenCountText = document.getElementById('informe-breakeven-count-text');
                if (breakevenCountText) breakevenCountText.textContent = breakevenCount;
            }
            
            // Actualizar métricas complementarias
            const winLossRatio = lossCount > 0 ? winCount / lossCount : winCount;
            const winLossRatioEl = document.getElementById('informe-win-loss-ratio-bar');
            if (winLossRatioEl) {
                winLossRatioEl.textContent = winLossRatio.toFixed(2);
                winLossRatioEl.classList.remove('text-positive', 'text-negative', 'text-neutral', 'text-primary', 'text-white');
                winLossRatioEl.classList.add(winLossRatio >= 1 ? 'text-positive' : 'text-negative');
            }
            
            // Expectativa matemática: (Win% × AvgWin) - (Loss% × AvgLoss)
            const avgWinAmount = winCount > 0 ? totalWinAmount / winCount : 0;
            const avgLossAmount = lossCount > 0 ? Math.abs(totalLossAmount / lossCount) : 0;
            const mathExpectancy = (winPercentage / 100 * avgWinAmount) - (lossPercentage / 100 * avgLossAmount);
            
            const mathExpectancyEl = document.getElementById('informe-math-expectancy-bar');
            if (mathExpectancyEl) {
                mathExpectancyEl.textContent = formatCurrency(mathExpectancy, DB.settings.defaultCurrency, displayCurrency);
                mathExpectancyEl.classList.remove('text-positive', 'text-negative', 'text-neutral');
                mathExpectancyEl.classList.add(mathExpectancy > 0 ? 'text-positive' : mathExpectancy < 0 ? 'text-negative' : 'text-neutral');
            }

            // Render Charts
            const activeRangeButton = document.querySelector('#informe-metricas-content .time-range-btn.active');
            const timeRange = activeRangeButton ? activeRangeButton.dataset.range : 'ALL';
            updateInformeMetricasEvolutionChart(operations, selectedAccount, timeRange);
            updateInformeMetricasRadarChart(operations, selectedAccount);
            
            // Actualizar nuevos gráficos
            updateReduccionAcumuladaChart(operations, selectedAccount, timeRange);
            updatePnLAcumuladoChart(operations, selectedAccount, timeRange);
            updateCuentasDailyPnLChart(operations, selectedAccount);
            updateCuentasDailyWinLossChart(operations, selectedAccount);
            
            // ===== NUEVAS MÉTRICAS DE GESTIÓN DE RIESGO =====
            updateRiskManagementMetrics(operations, selectedAccount, displayCurrency);
        }
        
        // Nueva función para Gestión de Riesgo
        function updateRiskManagementMetrics(operations, selectedAccount, displayCurrency) {
            // Calcular tamaño promedio de posición
            const volumes = operations.map(op => op.volume || 0).filter(v => v > 0);
            const avgPositionSize = volumes.length > 0 ? volumes.reduce((a,b) => a+b, 0) / volumes.length : 0;
            
            // Calcular riesgo promedio por trade (si existe el campo riskPercent o calcularlo)
            let totalRisk = 0;
            let riskCount = 0;
            operations.forEach(op => {
                if (op.stopLoss && op.entryPrice) {
                    const riskPerUnit = Math.abs(op.entryPrice - op.stopLoss);
                    const volume = op.volume || 1;
                    const accountSize = 10000; // Valor por defecto, debería venir de la cuenta
                    if (selectedAccount !== 'all') {
                        const acc = DB.accounts.find(a => a.id === selectedAccount);
                        if (acc) accountSize = acc.initialBalance;
                    }
                    const riskAmount = riskPerUnit * volume;
                    const riskPercent = (riskAmount / accountSize) * 100;
                    totalRisk += riskPercent;
                    riskCount++;
                }
            });
            const avgRiskPercent = riskCount > 0 ? totalRisk / riskCount : 0;
            
            // Calcular R:R Realizado
            const winOps = operations.filter(op => op.result === 'win');
            const lossOps = operations.filter(op => op.result === 'loss');
            let totalRRRealized = 0;
            let rrCount = 0;
            
            operations.forEach(op => {
                if (op.stopLoss && op.entryPrice && op.pl) {
                    const riskPerUnit = Math.abs(op.entryPrice - op.stopLoss);
                    const volume = op.volume || 1;
                    const riskAmount = riskPerUnit * volume;
                    if (riskAmount > 0) {
                        const rrRatio = Math.abs(op.pl) / riskAmount;
                        totalRRRealized += rrRatio;
                        rrCount++;
                    }
                }
            });
            const avgRRRealized = rrCount > 0 ? totalRRRealized / rrCount : 0;
            
            // Capital utilizado promedio (estimado como % del balance)
            const avgCapitalUsage = avgPositionSize > 0 ? Math.min((avgPositionSize * 100), 100) : 0;
            
            // Actualizar métricas en UI
            const el1 = document.getElementById('informe-metricas-avg-position-size');
            if (el1) el1.textContent = avgPositionSize.toFixed(2);
            
            const el2 = document.getElementById('informe-metricas-avg-risk-percent');
            if (el2) el2.textContent = avgRiskPercent.toFixed(2) + '%';
            
            const el3 = document.getElementById('informe-metricas-avg-rr-realized');
            if (el3) el3.textContent = avgRRRealized.toFixed(2);
            
            const el4 = document.getElementById('informe-metricas-capital-usage');
            if (el4) el4.textContent = avgCapitalUsage.toFixed(2) + '%';
            
            // Gráfica 1: Distribución de Tamaño de Posición
            const positionSizeCtx = document.getElementById('informe-metricas-position-size-distribution-chart')?.getContext('2d');
            if (positionSizeCtx) {
                const ranges = [0.01, 0.1, 0.5, 1, 2, 5, 10, Infinity];
                const rangeLabels = ['<0.01', '0.01-0.1', '0.1-0.5', '0.5-1', '1-2', '2-5', '5-10', '>10'];
                const rangeCounts = Array(rangeLabels.length).fill(0);
                
                volumes.forEach(vol => {
                    for (let i = 0; i < ranges.length; i++) {
                        if (vol < ranges[i]) {
                            rangeCounts[i]++;
                            break;
                        }
                    }
                });
                
                informeMetricasPositionSizeChart = new Chart(positionSizeCtx, {
                    type: 'bar',
                    data: {
                        labels: rangeLabels,
                        datasets: [{
                            label: 'Número de Trades',
                            data: rangeCounts,
                            backgroundColor: '#00FF00'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0', stepSize: 1 } },
                            x: { grid: { display: false }, ticks: { color: '#a0a0a0' } }
                        }
                    }
                });
            }
            
            // Gráfica 2: P/L por Nivel de Riesgo
            const plByRiskCtx = document.getElementById('informe-metricas-pl-by-risk-chart')?.getContext('2d');
            if (plByRiskCtx) {
                const riskRanges = {'<1%': [], '1-2%': [], '2-3%': [], '3-5%': [], '>5%': []};
                
                operations.forEach(op => {
                    const pl = convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency);
                    
                    // Si tiene stopLoss y entryPrice, calcular riesgo real
                    if (op.stopLoss && op.entryPrice && op.volume) {
                        const riskPerUnit = Math.abs(op.entryPrice - op.stopLoss);
                        const volume = op.volume;
                        const accountSize = 10000; // Default, idealmente usar balance real
                        const riskAmount = riskPerUnit * volume;
                        const riskPercent = (riskAmount / accountSize) * 100;
                        
                        if (riskPercent < 1) riskRanges['<1%'].push(pl);
                        else if (riskPercent < 2) riskRanges['1-2%'].push(pl);
                        else if (riskPercent < 3) riskRanges['2-3%'].push(pl);
                        else if (riskPercent < 5) riskRanges['3-5%'].push(pl);
                        else riskRanges['>5%'].push(pl);
                    } else {
                        // Si no hay datos de riesgo, clasificar por volumen
                        const vol = op.volume || 0.1;
                        if (vol < 0.5) riskRanges['<1%'].push(pl);
                        else if (vol < 1) riskRanges['1-2%'].push(pl);
                        else if (vol < 2) riskRanges['2-3%'].push(pl);
                        else if (vol < 5) riskRanges['3-5%'].push(pl);
                        else riskRanges['>5%'].push(pl);
                    }
                });
                
                const labels = Object.keys(riskRanges);
                const avgPL = labels.map(label => {
                    const arr = riskRanges[label];
                    return arr.length > 0 ? arr.reduce((a,b) => a+b, 0) / arr.length : 0;
                });
                const counts = labels.map(label => riskRanges[label].length);
                
                informeMetricasPlByRiskChart = new Chart(plByRiskCtx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'P/L Promedio',
                            data: avgPL,
                            backgroundColor: avgPL.map(pl => pl >= 0 ? '#00FF00' : '#FF0000')
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { 
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: (ctx) => `P/L: $${ctx.parsed.y.toFixed(2)} (${counts[ctx.dataIndex]} trades)`
                                }
                            }
                        },
                        scales: {
                            y: { 
                                beginAtZero: true,
                                grid: { color: 'rgba(255,255,255,0.1)' }, 
                                ticks: { color: '#a0a0a0' } 
                            },
                            x: { grid: { display: false }, ticks: { color: '#a0a0a0' } }
                        }
                    }
                });
            }
            
            // Gráfica 3: R:R Realizado vs Planificado (simulado con promedio)
            const rrComparisonCtx = document.getElementById('informe-metricas-rr-comparison-chart')?.getContext('2d');
            if (rrComparisonCtx) {
                const rrPlanned = 2; // Valor por defecto
                const rrActual = avgRRRealized;
                
                informeMetricasRRComparisonChart = new Chart(rrComparisonCtx, {
                    type: 'bar',
                    data: {
                        labels: ['R:R Planificado', 'R:R Realizado'],
                        datasets: [{
                            label: 'Ratio',
                            data: [rrPlanned, rrActual],
                            backgroundColor: ['#00FF00', rrActual >= rrPlanned ? '#00FF00' : '#FF0000']
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0' } },
                            x: { grid: { display: false }, ticks: { color: '#a0a0a0' } }
                        }
                    }
                });
            }
            
            // Gráfica 4: Rendimiento por Capital Utilizado
            const capitalEffCtx = document.getElementById('informe-metricas-capital-efficiency-chart')?.getContext('2d');
            if (capitalEffCtx) {
                const capitalRanges = {'<25%': 0, '25-50%': 0, '50-75%': 0, '>75%': 0};
                const capitalCounts = {'<25%': 0, '25-50%': 0, '50-75%': 0, '>75%': 0};
                
                operations.forEach(op => {
                    const volume = op.volume || 0;
                    const capitalUsed = Math.min((volume * 100), 100);
                    const pl = convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency);
                    
                    if (capitalUsed < 25) { capitalRanges['<25%'] += pl; capitalCounts['<25%']++; }
                    else if (capitalUsed < 50) { capitalRanges['25-50%'] += pl; capitalCounts['25-50%']++; }
                    else if (capitalUsed < 75) { capitalRanges['50-75%'] += pl; capitalCounts['50-75%']++; }
                    else { capitalRanges['>75%'] += pl; capitalCounts['>75%']++; }
                });
                
                const labels = Object.keys(capitalRanges);
                const avgPL = labels.map(label => capitalCounts[label] > 0 ? capitalRanges[label] / capitalCounts[label] : 0);
                
                informeMetricasCapitalEffChart = new Chart(capitalEffCtx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'P/L Promedio',
                            data: avgPL,
                            backgroundColor: avgPL.map(pl => pl >= 0 ? '#00FF00' : '#FF0000')
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0' } },
                            x: { grid: { display: false }, ticks: { color: '#a0a0a0' } }
                        }
                    }
                });
            }
        }

        // New chart functions for Informe -> Metricas
        function updateInformeMetricasEvolutionChart(allAccountOps, accountId, timeRange = 'ALL') {
            const ctx = document.getElementById('informe-metricas-evolution-chart').getContext('2d');
            if (informeMetricasEvolutionChart) informeMetricasEvolutionChart.destroy();
            const currencySelect = document.getElementById('informe-currency-select');
            const displayCurrency = currencySelect ? currencySelect.value : 'USD';

            // The `allAccountOps` parameter is already filtered by global date and selected account.
            // The `startDateStringForChartRange` is for *further* filtering based on the chart's specific time range buttons (1W, 1M, etc.).
            const startDateStringForChartRange = getStartDateForRange(timeRange);
            let chartOps = allAccountOps;
            if (startDateStringForChartRange) {
                chartOps = allAccountOps.filter(op => op.date >= startDateStringForChartRange);
            }
            chartOps = [...chartOps].sort((a, b) => new Date(a.date + 'T' + (a.entryTime || "00:00:00")) - new Date(b.date + 'T' + (b.entryTime || "00:00:00")));

            let startingBalance = 0;
            let chartTargetCurrency = displayCurrency === '%' ? DB.settings.defaultCurrency : displayCurrency;
            let initialBalanceForPercentCalc = 0;

            if (accountId !== 'all') {
                const account = DB.accounts.find(a => a.id === accountId);
                if (account) {
                    startingBalance = account.initialBalance;
                    initialBalanceForPercentCalc = convertCurrency(account.initialBalance, account.currency, chartTargetCurrency);
                    if (account.currency !== chartTargetCurrency) {
                        startingBalance = convertCurrency(startingBalance, account.currency, chartTargetCurrency);
                    }
                    const operationsBeforeChartRange = DB.operations.filter(op =>
                        op.accountId === accountId &&
                        op.date < (chartOps.length > 0 ? chartOps[0].date : getLocalDateString(new Date()))
                    );
                    operationsBeforeChartRange.forEach(op => {
                        let pl = op.pl;
                        if (op.currency !== chartTargetCurrency) {
                            pl = convertCurrency(pl, op.currency, chartTargetCurrency);
                        }
                        startingBalance += pl;
                    });
                }
            } else {
                startingBalance = DB.accounts.reduce((sum, acc) => {
                    let accEffectiveInitialBalance = acc.initialBalance;
                    const opsBeforeRangeForThisAccount = DB.operations.filter(op =>
                        op.accountId === acc.id && op.date < (chartOps.length > 0 ? chartOps[0].date : getLocalDateString(new Date()))
                    );
                    opsBeforeRangeForThisAccount.forEach(op => {
                        let pl = op.pl;
                        if (op.currency !== acc.currency) {
                            pl = convertCurrency(pl, op.currency, acc.currency);
                        }
                        accEffectiveInitialBalance += pl;
                    });
                    if (acc.currency !== chartTargetCurrency) {
                        accEffectiveInitialBalance = convertCurrency(accEffectiveInitialBalance, acc.currency, chartTargetCurrency);
                    }
                    return sum + accEffectiveInitialBalance;
                }, 0);

                initialBalanceForPercentCalc = DB.accounts.reduce((sum, acc) => {
                    let iBalance = acc.initialBalance;
                    if (acc.currency !== chartTargetCurrency) {
                        iBalance = convertCurrency(iBalance, acc.currency, chartTargetCurrency);
                    }
                    return sum + iBalance;
                }, 0);
            }

            const labels = ['Inicio'];
            const dataPoints = [startingBalance];
            chartOps.reduce((balance, op) => {
                let pl = op.pl;
                if (op.currency !== chartTargetCurrency) pl = convertCurrency(pl, op.currency, chartTargetCurrency);
                const newBalance = balance + pl;
                dataPoints.push(newBalance);
                labels.push(formatDate(op.date));
                return newBalance;
            }, startingBalance);

            const finalData = displayCurrency === '%' && initialBalanceForPercentCalc !== 0
                ? dataPoints.map(val => ((val / initialBalanceForPercentCalc) * 100) - 100)
                : dataPoints;

            const yAxisFormatter = displayCurrency === '%'
                ? (val) => (val > 0 ? '+' : '') + val.toFixed(1) + '%'
                : (val) => formatCurrency(val, chartTargetCurrency, chartTargetCurrency);

            informeMetricasEvolutionChart = new Chart(ctx, {
                type: 'line',
                data: { labels, datasets: [{ label: 'Balance', data: finalData, borderColor: '#00FF00', backgroundColor: '#00FF00', borderWidth: 0, fill: true, tension: 0.4, pointRadius: 0, pointHoverRadius: 6, pointHoverBackgroundColor: '#00FF00', pointHoverBorderColor: '#00FF00', pointHoverBorderWidth: 0 }] },
                options: { responsive: true, maintainAspectRatio: false, interaction: { mode: 'index', intersect: false }, plugins: { legend: { display: false }, tooltip: { callbacks: { label: (c) => `Balance: ${yAxisFormatter(c.raw)}` } } }, scales: { x: { grid: { color: '#2a2a2a' }, ticks: { color: '#FFFFFF' } }, y: { grid: { color: '#2a2a2a' }, ticks: { color: '#FFFFFF', callback: yAxisFormatter }, zeroLineColor: '#2a2a2a' } } }
            });
        }

        function updateInformeMetricasRadarChart(operations, accountId) {
            const ctx = document.getElementById('informe-metricas-radar-chart')?.getContext('2d');
            if (!ctx) return;
            if (informeMetricasRadarChart) informeMetricasRadarChart.destroy();

            const basicMetrics = calculateMetrics(operations, accountId);
            const advancedMetrics = calculateAdvancedMetrics(operations, accountId);

            let maxDrawdownPercentage = 0;
            if (operations.length > 0) {
                const sortedOps = [...operations].sort((a, b) => new Date(a.date + 'T' + (a.entryTime || '00:00')) - new Date(b.date + 'T' + (b.entryTime || '00:00')));
                let accountInitialBalance = 0;
                let accountCurrency = DB.settings.defaultCurrency;

                if (accountId !== 'all') {
                    const account = DB.accounts.find(a => a.id === accountId);
                    if (account) {
                        accountInitialBalance = account.initialBalance;
                        accountCurrency = account.currency;
                    }
                } else {
                    accountInitialBalance = DB.accounts.reduce((sum, acc) => sum + convertCurrency(acc.initialBalance, acc.currency, DB.settings.defaultCurrency), 0);
                }

                if (accountInitialBalance > 0) {
                    let peakBalance = accountInitialBalance;
                    let maxDrawdownValue = 0;
                    let currentBalance = accountInitialBalance;
                    sortedOps.forEach(op => {
                        let pl = convertCurrency(op.pl, op.currency, accountCurrency);
                        currentBalance += pl;
                        if (currentBalance > peakBalance) peakBalance = currentBalance;
                        const drawdown = peakBalance - currentBalance;
                        if (drawdown > maxDrawdownValue) maxDrawdownValue = drawdown;
                    });
                    maxDrawdownPercentage = (maxDrawdownValue / accountInitialBalance) * 100;
                }
            }

            const winRateScore = basicMetrics.winRate || 0;
            const profitFactorScore = Math.min(basicMetrics.profitFactor / 3, 1) * 100; // PF of 3.0 is 100%
            const avgWLRatio = advancedMetrics.avgWin && advancedMetrics.avgLoss ? Math.abs(advancedMetrics.avgWin / advancedMetrics.avgLoss) : 0;
            const avgWLRatioScore = Math.min(avgWLRatio / 3, 1) * 100; // Ratio of 3.0 is 100%
            const drawdownScore = Math.max(0, (1 - Math.min(maxDrawdownPercentage / 20, 1)) * 100); // 20% DD is 0 score

            let consistencyScore = 0;
            if (operations.length > 1) {
                const dailyPL = {};
                operations.forEach(op => {
                    if (!dailyPL[op.date]) dailyPL[op.date] = 0;
                    const plValue = op.pl ?? op.pnl ?? 0;
                    const feeValue = op.fee ?? op.fees ?? 0;
                    const plInDefaultCurrency = convertCurrency(plValue, op.currency, DB.settings.defaultCurrency);
                    const feesInDefaultCurrency = convertCurrency(feeValue, op.currency, DB.settings.defaultCurrency);
                    dailyPL[op.date] += plInDefaultCurrency - feesInDefaultCurrency;
                });
                
                const dailyValues = Object.values(dailyPL);
                if (dailyValues.length >= 2) {
                    const avg = dailyValues.reduce((sum, v) => sum + v, 0) / dailyValues.length;
                    const variance = dailyValues.reduce((sum, v) => sum + Math.pow(v - avg, 2), 0) / dailyValues.length;
                    const stdDev = Math.sqrt(variance);
                    
                    if (Math.abs(avg) > 0.01) {
                        const coefficientOfVariation = stdDev / Math.abs(avg);
                        
                        if (coefficientOfVariation < 0.3) {
                            consistencyScore = 95 + (0.3 - coefficientOfVariation) * 16.67;
                        } else if (coefficientOfVariation < 0.8) {
                            consistencyScore = 80 + (0.8 - coefficientOfVariation) * 30;
                        } else if (coefficientOfVariation < 1.5) {
                            consistencyScore = 60 + (1.5 - coefficientOfVariation) * 28.57;
                        } else if (coefficientOfVariation < 2.5) {
                            consistencyScore = 35 + (2.5 - coefficientOfVariation) * 25;
                        } else if (coefficientOfVariation < 4.0) {
                            consistencyScore = 10 + (4.0 - coefficientOfVariation) * 16.67;
                        } else {
                            consistencyScore = Math.max(0, 10 - (coefficientOfVariation - 4.0) * 2.5);
                        }
                        
                        consistencyScore = Math.max(0, Math.min(100, consistencyScore));
                    } else {
                        // Si avg es ~0, usar win rate diario
                        const winningDays = dailyValues.filter(pl => pl > 0).length;
                        consistencyScore = (winningDays / dailyValues.length) * 100;
                    }
                }
            }

            informeMetricasRadarChart = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: ['Win %', 'Profit Factor', 'Avg Win/Loss', 'Drawdown Ctrl', 'Consistencia'],
                    datasets: [{
                        label: 'Puntuación',
                        data: [winRateScore, profitFactorScore, avgWLRatioScore, drawdownScore, consistencyScore],
                        fill: true,
                        backgroundColor: 'rgba(57, 255, 20, 0.2)',
                        borderColor: 'rgba(57, 255, 20, 0.8)',
                        pointBackgroundColor: 'var(--primary)',
                        pointBorderColor: '#0a0a0a',
                        pointHoverBackgroundColor: '#FFFFFF',
                        pointHoverBorderColor: 'var(--primary)'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        r: {
                            min: 0,
                            max: 100,
                            angleLines: { color: '#2a2a2a' },
                            grid: { color: '#2a2a2a' },
                            pointLabels: { color: '#FFFFFF', font: { size: 11 } },
                            ticks: { display: false, stepSize: 20 }
                        }
                    },
                    plugins: { legend: { display: false } }
                }
            });
        }

        // Variables globales para los nuevos gráficos
        let reduccionAcumuladaChart = null;
        let pnlAcumuladoChart = null;
        let accountReduccionAcumuladaChart = null;
        let accountPnlAcumuladoChart = null;
        let cuentasDailyPnlChart = null;
        let cuentasDailyWinLossChart = null;
        let accountDailyPnlChart = null;
        let accountDailyWinLossChart = null;

        function updateReduccionAcumuladaChart(allAccountOps, accountId, timeRange = 'ALL') {
            const ctx = document.getElementById('reduccion-acumulada-chart')?.getContext('2d');
            if (!ctx) return;
            if (reduccionAcumuladaChart) reduccionAcumuladaChart.destroy();

            const startDateStringForChartRange = getStartDateForRange(timeRange);
            let chartOps = allAccountOps;
            if (startDateStringForChartRange) {
                chartOps = allAccountOps.filter(op => op.date >= startDateStringForChartRange);
            }
            const filteredOps = accountId === 'all' ? chartOps : chartOps.filter(op => op.accountId === accountId);
            
            if (filteredOps.length === 0) {
                reduccionAcumuladaChart = new Chart(ctx, {
                    type: 'line',
                    data: { labels: ['Sin datos'], datasets: [] },
                    options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } } }
                });
                return;
            }

            // Ordenar operaciones por fecha
            const sortedOps = [...filteredOps].sort((a, b) => new Date(a.date + 'T' + (a.entryTime || '00:00')) - new Date(b.date + 'T' + (b.entryTime || '00:00')));
            
            // Calcular balance inicial
            let startingBalance = 0;
            let chartTargetCurrency = DB.settings.defaultCurrency;
            
            if (accountId !== 'all') {
                const account = DB.accounts.find(a => a.id === accountId);
                if (account) {
                    startingBalance = account.initialBalance;
                    chartTargetCurrency = account.currency;
                }
            } else {
                startingBalance = DB.accounts.reduce((sum, acc) => sum + convertCurrency(acc.initialBalance, acc.currency, chartTargetCurrency), 0);
            }

            // Calcular drawdown acumulado
            const labels = ['Inicio'];
            const balancePoints = [startingBalance];
            const drawdownPoints = [0]; // Drawdown inicia en 0
            let maxBalance = startingBalance;
            
            sortedOps.reduce((balance, op) => {
                let pl = op.pl;
                if (op.currency !== chartTargetCurrency) pl = convertCurrency(pl, op.currency, chartTargetCurrency);
                const newBalance = balance + pl;
                
                // Actualizar máximo balance
                if (newBalance > maxBalance) maxBalance = newBalance;
                
                // Calcular drawdown actual (negativo)
                const currentDrawdown = newBalance - maxBalance;
                
                balancePoints.push(newBalance);
                drawdownPoints.push(currentDrawdown);
                labels.push(formatDate(op.date));
                return newBalance;
            }, startingBalance);

            reduccionAcumuladaChart = new Chart(ctx, {
                type: 'line',
                data: { 
                    labels, 
                    datasets: [{ 
                        label: 'Reducción Acumulada', 
                        data: drawdownPoints, 
                        borderColor: '#ef4444', 
                        backgroundColor: 'rgba(239, 68, 68, 0.1)', 
                        borderWidth: 2, 
                        fill: true, 
                        tension: 0.4, 
                        pointRadius: 0, 
                        pointHoverRadius: 5, 
                        pointHoverBackgroundColor: '#ef4444' 
                    }] 
                },
                options: { 
                    responsive: true, 
                    maintainAspectRatio: false, 
                    interaction: { mode: 'index', intersect: false }, 
                    plugins: { 
                        legend: { display: false }, 
                        tooltip: { 
                            callbacks: { 
                                label: (c) => `Drawdown: ${formatCurrency(c.raw, chartTargetCurrency, chartTargetCurrency)}` 
                            } 
                        } 
                    }, 
                    scales: { 
                        x: { 
                            grid: { color: '#2a2a2a' }, 
                            ticks: { color: '#FFFFFF' } 
                        }, 
                        y: { 
                            grid: { color: '#2a2a2a' }, 
                            ticks: { 
                                color: '#FFFFFF', 
                                callback: (val) => formatCurrency(val, chartTargetCurrency, chartTargetCurrency) 
                            },
                            max: 0 // Forzar que el máximo sea 0 (sin drawdown)
                        } 
                    } 
                }
            });
        }

        function updatePnLAcumuladoChart(allAccountOps, accountId, timeRange = 'ALL') {
            const ctx = document.getElementById('pnl-acumulado-chart')?.getContext('2d');
            if (!ctx) return;
            if (pnlAcumuladoChart) pnlAcumuladoChart.destroy();

            const startDateStringForChartRange = getStartDateForRange(timeRange);
            let chartOps = allAccountOps;
            if (startDateStringForChartRange) {
                chartOps = allAccountOps.filter(op => op.date >= startDateStringForChartRange);
            }
            const filteredOps = accountId === 'all' ? chartOps : chartOps.filter(op => op.accountId === accountId);
            
            if (filteredOps.length === 0) {
                pnlAcumuladoChart = new Chart(ctx, {
                    type: 'line',
                    data: { labels: ['Sin datos'], datasets: [] },
                    options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } } }
                });
                return;
            }

            // Ordenar operaciones por fecha
            const sortedOps = [...filteredOps].sort((a, b) => new Date(a.date + 'T' + (a.entryTime || '00:00')) - new Date(b.date + 'T' + (b.entryTime || '00:00')));
            
            let chartTargetCurrency = DB.settings.defaultCurrency;
            if (accountId !== 'all') {
                const account = DB.accounts.find(a => a.id === accountId);
                if (account) chartTargetCurrency = account.currency;
            }

            // Calcular P&L acumulado
            const labels = ['Inicio'];
            const pnlPoints = [0]; // P&L inicia en 0
            
            sortedOps.reduce((accumulatedPL, op) => {
                let pl = op.pl;
                if (op.currency !== chartTargetCurrency) pl = convertCurrency(pl, op.currency, chartTargetCurrency);
                const newAccumulatedPL = accumulatedPL + pl;
                
                pnlPoints.push(newAccumulatedPL);
                labels.push(formatDate(op.date));
                return newAccumulatedPL;
            }, 0);

            // Determinar color basado en P&L final
            const finalPL = pnlPoints[pnlPoints.length - 1];
            const lineColor = finalPL >= 0 ? '#10B981' : '#ef4444'; // Verde fluorescente o rojo
            const fillColor = finalPL >= 0 ? 'rgba(16, 185, 129, 0.1)' : 'rgba(239, 68, 68, 0.1)';

            pnlAcumuladoChart = new Chart(ctx, {
                type: 'line',
                data: { 
                    labels, 
                    datasets: [{ 
                        label: 'P&L Acumulado', 
                        data: pnlPoints, 
                        borderColor: lineColor, 
                        backgroundColor: fillColor, 
                        borderWidth: 2, 
                        fill: true, 
                        tension: 0.4, 
                        pointRadius: 0, 
                        pointHoverRadius: 5, 
                        pointHoverBackgroundColor: lineColor 
                    }] 
                },
                options: { 
                    responsive: true, 
                    maintainAspectRatio: false, 
                    interaction: { mode: 'index', intersect: false }, 
                    plugins: { 
                        legend: { display: false }, 
                        tooltip: { 
                            callbacks: { 
                                label: (c) => `P&L: ${formatCurrency(c.raw, chartTargetCurrency, chartTargetCurrency)}` 
                            } 
                        } 
                    }, 
                    scales: { 
                        x: { 
                            grid: { color: '#2a2a2a' }, 
                            ticks: { color: '#FFFFFF' } 
                        }, 
                        y: { 
                            grid: { color: '#2a2a2a' }, 
                            ticks: { 
                                color: '#FFFFFF', 
                                callback: (val) => formatCurrency(val, chartTargetCurrency, chartTargetCurrency) 
                            } 
                        } 
                    } 
                }
            });
        }

        function updateCuentasDailyPnLChart(allAccountOps, accountId) {
            const ctx = document.getElementById('cuentas-daily-pnl-chart')?.getContext('2d');
            if (!ctx) return;
            if (cuentasDailyPnlChart) cuentasDailyPnlChart.destroy();

            const filteredOps = accountId === 'all' ? allAccountOps : allAccountOps.filter(op => op.accountId === accountId);
            
            if (filteredOps.length === 0) {
                cuentasDailyPnlChart = new Chart(ctx, {
                    type: 'bar',
                    data: { labels: ['Sin datos'], datasets: [] },
                    options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } } }
                });
                return;
            }

            let chartTargetCurrency = DB.settings.defaultCurrency;
            if (accountId !== 'all') {
                const account = DB.accounts.find(a => a.id === accountId);
                if (account) chartTargetCurrency = account.currency;
            }

            // Agrupar por fecha
            const dailyPnL = {};
            filteredOps.forEach(op => {
                const date = op.date;
                if (!dailyPnL[date]) {
                    dailyPnL[date] = 0;
                }
                let pl = op.pl;
                if (op.currency !== chartTargetCurrency) {
                    pl = convertCurrency(pl, op.currency, chartTargetCurrency);
                }
                dailyPnL[date] += pl;
            });

            // Ordenar por fecha
            const sortedDates = Object.keys(dailyPnL).sort((a, b) => new Date(a) - new Date(b));
            const labels = sortedDates.map(date => formatDate(date));
            const data = sortedDates.map(date => dailyPnL[date]);
            const colors = data.map(val => val >= 0 ? '#39FF14' : '#FF0000'); // Verde fluorescente o rojo

            cuentasDailyPnlChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels,
                    datasets: [{
                        label: 'P&L Neto Diario',
                        data,
                        backgroundColor: colors,
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (c) => `P&L: ${formatCurrency(c.raw, chartTargetCurrency, chartTargetCurrency)}`
                            }
                        }
                    },
                    scales: {
                        x: { grid: { color: '#2a2a2a' }, ticks: { color: '#FFFFFF' } },
                        y: { 
                            grid: { color: '#2a2a2a' }, 
                            ticks: { 
                                color: '#FFFFFF',
                                callback: (val) => formatCurrency(val, chartTargetCurrency, chartTargetCurrency)
                            } 
                        }
                    }
                }
            });
        }

        function updateCuentasDailyWinLossChart(allAccountOps, accountId) {
            const ctx = document.getElementById('cuentas-daily-winloss-chart')?.getContext('2d');
            if (!ctx) return;
            if (cuentasDailyWinLossChart) cuentasDailyWinLossChart.destroy();

            const filteredOps = accountId === 'all' ? allAccountOps : allAccountOps.filter(op => op.accountId === accountId);
            
            if (filteredOps.length === 0) {
                cuentasDailyWinLossChart = new Chart(ctx, {
                    type: 'bar',
                    data: { labels: ['Sin datos'], datasets: [] },
                    options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } } }
                });
                return;
            }

            // Agrupar por fecha
            const dailyWinLoss = {};
            filteredOps.forEach(op => {
                const date = op.date;
                if (!dailyWinLoss[date]) {
                    dailyWinLoss[date] = { wins: 0, losses: 0 };
                }
                if (op.result === 'win') {
                    dailyWinLoss[date].wins++;
                } else if (op.result === 'loss') {
                    dailyWinLoss[date].losses++;
                }
            });

            // Ordenar por fecha
            const sortedDates = Object.keys(dailyWinLoss).sort((a, b) => new Date(a) - new Date(b));
            const labels = sortedDates.map(date => formatDate(date));
            const winsData = sortedDates.map(date => dailyWinLoss[date].wins);
            const lossesData = sortedDates.map(date => dailyWinLoss[date].losses);

            cuentasDailyWinLossChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels,
                    datasets: [
                        {
                            label: 'Victorias',
                            data: winsData,
                            backgroundColor: '#39FF14', // Verde fluorescente
                        },
                        {
                            label: 'Derrotas',
                            data: lossesData,
                            backgroundColor: '#FF0000', // Rojo
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { 
                            display: true,
                            labels: { color: '#FFFFFF' }
                        },
                        tooltip: {
                            callbacks: {
                                label: (c) => `${c.dataset.label}: ${c.raw}`
                            }
                        }
                    },
                    scales: {
                        x: { 
                            grid: { color: '#2a2a2a' }, 
                            ticks: { color: '#FFFFFF' },
                            stacked: false
                        },
                        y: { 
                            grid: { color: '#2a2a2a' }, 
                            ticks: { 
                                color: '#FFFFFF',
                                stepSize: 1
                            },
                            stacked: false
                        }
                    }
                }
            });
        }

        function updateAccountReduccionAcumuladaChart(allAccountOps, account, timeRange = 'ALL') {
            const ctx = document.getElementById('account-reduccion-acumulada-chart')?.getContext('2d');
            if (!ctx) return;
            if (accountReduccionAcumuladaChart) accountReduccionAcumuladaChart.destroy();

            const startDateStringForChartRange = getStartDateForRange(timeRange);
            let chartOps = allAccountOps;
            if (startDateStringForChartRange) {
                chartOps = allAccountOps.filter(op => op.date >= startDateStringForChartRange);
            }
            const filteredOps = chartOps.filter(op => op.accountId === account.id);
            
            if (filteredOps.length === 0) {
                accountReduccionAcumuladaChart = new Chart(ctx, {
                    type: 'line',
                    data: { labels: ['Sin datos'], datasets: [] },
                    options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } } }
                });
                return;
            }

            // Ordenar operaciones por fecha
            const sortedOps = [...filteredOps].sort((a, b) => new Date(a.date + 'T' + (a.entryTime || '00:00')) - new Date(b.date + 'T' + (b.entryTime || '00:00')));
            
            // Calcular balance inicial
            let startingBalance = account.initialBalance;
            let chartTargetCurrency = account.currency;

            // Calcular drawdown acumulado
            const labels = ['Inicio'];
            const balancePoints = [startingBalance];
            const drawdownPoints = [0]; // Drawdown inicia en 0
            let maxBalance = startingBalance;
            
            sortedOps.reduce((balance, op) => {
                let pl = op.pl;
                if (op.currency !== chartTargetCurrency) pl = convertCurrency(pl, op.currency, chartTargetCurrency);
                const newBalance = balance + pl;
                
                // Actualizar máximo balance
                if (newBalance > maxBalance) maxBalance = newBalance;
                
                // Calcular drawdown actual (negativo)
                const currentDrawdown = newBalance - maxBalance;
                
                balancePoints.push(newBalance);
                drawdownPoints.push(currentDrawdown);
                labels.push(formatDate(op.date));
                return newBalance;
            }, startingBalance);

            accountReduccionAcumuladaChart = new Chart(ctx, {
                type: 'line',
                data: { 
                    labels, 
                    datasets: [{ 
                        label: 'Reducción Acumulada', 
                        data: drawdownPoints, 
                        borderColor: '#ef4444', 
                        backgroundColor: 'rgba(239, 68, 68, 0.1)', 
                        borderWidth: 2, 
                        fill: true, 
                        tension: 0.4, 
                        pointRadius: 0, 
                        pointHoverRadius: 5, 
                        pointHoverBackgroundColor: '#ef4444' 
                    }] 
                },
                options: { 
                    responsive: true, 
                    maintainAspectRatio: false, 
                    interaction: { mode: 'index', intersect: false }, 
                    plugins: { 
                        legend: { display: false }, 
                        tooltip: { 
                            callbacks: { 
                                label: (c) => `Drawdown: ${formatCurrency(c.raw, chartTargetCurrency, chartTargetCurrency)}` 
                            } 
                        } 
                    }, 
                    scales: { 
                        x: { 
                            grid: { color: '#2a2a2a' }, 
                            ticks: { color: '#FFFFFF' } 
                        }, 
                        y: { 
                            grid: { color: '#2a2a2a' }, 
                            ticks: { 
                                color: '#FFFFFF', 
                                callback: (val) => formatCurrency(val, chartTargetCurrency, chartTargetCurrency) 
                            },
                            max: 0 // Forzar que el máximo sea 0 (sin drawdown)
                        } 
                    } 
                }
            });
        }

        function updateAccountPnLAcumuladoChart(allAccountOps, account, timeRange = 'ALL') {
            const ctx = document.getElementById('account-pnl-acumulado-chart')?.getContext('2d');
            if (!ctx) return;
            if (accountPnlAcumuladoChart) accountPnlAcumuladoChart.destroy();

            const startDateStringForChartRange = getStartDateForRange(timeRange);
            let chartOps = allAccountOps;
            if (startDateStringForChartRange) {
                chartOps = allAccountOps.filter(op => op.date >= startDateStringForChartRange);
            }
            const filteredOps = chartOps.filter(op => op.accountId === account.id);
            
            if (filteredOps.length === 0) {
                accountPnlAcumuladoChart = new Chart(ctx, {
                    type: 'line',
                    data: { labels: ['Sin datos'], datasets: [] },
                    options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } } }
                });
                return;
            }

            // Ordenar operaciones por fecha
            const sortedOps = [...filteredOps].sort((a, b) => new Date(a.date + 'T' + (a.entryTime || '00:00')) - new Date(b.date + 'T' + (b.entryTime || '00:00')));
            
            let chartTargetCurrency = account.currency;

            // Calcular P&L acumulado
            const labels = ['Inicio'];
            const pnlPoints = [0]; // P&L inicia en 0
            
            sortedOps.reduce((accumulatedPL, op) => {
                let pl = op.pl;
                if (op.currency !== chartTargetCurrency) pl = convertCurrency(pl, op.currency, chartTargetCurrency);
                const newAccumulatedPL = accumulatedPL + pl;
                
                pnlPoints.push(newAccumulatedPL);
                labels.push(formatDate(op.date));
                return newAccumulatedPL;
            }, 0);

            // Determinar color basado en P&L final
            const finalPL = pnlPoints[pnlPoints.length - 1];
            const lineColor = finalPL >= 0 ? '#39ff14' : '#ef4444'; // Verde fluorescente o rojo
            const fillColor = finalPL >= 0 ? 'rgba(57, 255, 20, 0.1)' : 'rgba(239, 68, 68, 0.1)';

            accountPnlAcumuladoChart = new Chart(ctx, {
                type: 'line',
                data: { 
                    labels, 
                    datasets: [{ 
                        label: 'P&L Acumulado', 
                        data: pnlPoints, 
                        borderColor: lineColor, 
                        backgroundColor: fillColor, 
                        borderWidth: 2, 
                        fill: true, 
                        tension: 0.4, 
                        pointRadius: 0, 
                        pointHoverRadius: 5, 
                        pointHoverBackgroundColor: lineColor 
                    }] 
                },
                options: { 
                    responsive: true, 
                    maintainAspectRatio: false, 
                    interaction: { mode: 'index', intersect: false }, 
                    plugins: { 
                        legend: { display: false }, 
                        tooltip: { 
                            callbacks: { 
                                label: (c) => `P&L: ${formatCurrency(c.raw, chartTargetCurrency, chartTargetCurrency)}` 
                            } 
                        } 
                    }, 
                    scales: { 
                        x: { 
                            grid: { color: '#2a2a2a' }, 
                            ticks: { color: '#FFFFFF' } 
                        }, 
                        y: { 
                            grid: { color: '#2a2a2a' }, 
                            ticks: { 
                                color: '#FFFFFF', 
                                callback: (val) => formatCurrency(val, chartTargetCurrency, chartTargetCurrency) 
                            } 
                        } 
                    } 
                }
            });
        }

        function updateAccountDailyPnLChart(allAccountOps, account) {
            const ctx = document.getElementById('account-daily-pnl-chart')?.getContext('2d');
            if (!ctx) return;
            if (accountDailyPnlChart) accountDailyPnlChart.destroy();

            const filteredOps = allAccountOps.filter(op => op.accountId === account.id);
            
            if (filteredOps.length === 0) {
                accountDailyPnlChart = new Chart(ctx, {
                    type: 'bar',
                    data: { labels: ['Sin datos'], datasets: [] },
                    options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } } }
                });
                return;
            }

            const chartTargetCurrency = account.currency;

            // Agrupar por fecha
            const dailyPnL = {};
            filteredOps.forEach(op => {
                const date = op.date;
                if (!dailyPnL[date]) {
                    dailyPnL[date] = 0;
                }
                let pl = op.pl;
                if (op.currency !== chartTargetCurrency) {
                    pl = convertCurrency(pl, op.currency, chartTargetCurrency);
                }
                dailyPnL[date] += pl;
            });

            // Ordenar por fecha
            const sortedDates = Object.keys(dailyPnL).sort((a, b) => new Date(a) - new Date(b));
            const labels = sortedDates.map(date => formatDate(date));
            const data = sortedDates.map(date => dailyPnL[date]);
            const colors = data.map(val => val >= 0 ? 'rgba(16, 185, 129, 0.7)' : 'rgba(239, 68, 68, 0.7)');

            accountDailyPnlChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels,
                    datasets: [{
                        label: 'P&L Neto Diario',
                        data,
                        backgroundColor: colors,
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (c) => `P&L: ${formatCurrency(c.raw, chartTargetCurrency, chartTargetCurrency)}`
                            }
                        }
                    },
                    scales: {
                        x: { grid: { color: '#2a2a2a' }, ticks: { color: '#FFFFFF' } },
                        y: { 
                            grid: { color: '#2a2a2a' }, 
                            ticks: { 
                                color: '#FFFFFF',
                                callback: (val) => formatCurrency(val, chartTargetCurrency, chartTargetCurrency)
                            } 
                        }
                    }
                }
            });
        }

        function updateAccountDailyWinLossChart(allAccountOps, account) {
            const ctx = document.getElementById('account-daily-winloss-chart')?.getContext('2d');
            if (!ctx) return;
            if (accountDailyWinLossChart) accountDailyWinLossChart.destroy();

            const filteredOps = allAccountOps.filter(op => op.accountId === account.id);
            
            if (filteredOps.length === 0) {
                accountDailyWinLossChart = new Chart(ctx, {
                    type: 'bar',
                    data: { labels: ['Sin datos'], datasets: [] },
                    options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } } }
                });
                return;
            }

            // Agrupar por fecha
            const dailyWinLoss = {};
            filteredOps.forEach(op => {
                const date = op.date;
                if (!dailyWinLoss[date]) {
                    dailyWinLoss[date] = { wins: 0, losses: 0 };
                }
                if (op.result === 'win') {
                    dailyWinLoss[date].wins++;
                } else if (op.result === 'loss') {
                    dailyWinLoss[date].losses++;
                }
            });

            // Ordenar por fecha
            const sortedDates = Object.keys(dailyWinLoss).sort((a, b) => new Date(a) - new Date(b));
            const labels = sortedDates.map(date => formatDate(date));
            const winsData = sortedDates.map(date => dailyWinLoss[date].wins);
            const lossesData = sortedDates.map(date => dailyWinLoss[date].losses);

            accountDailyWinLossChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels,
                    datasets: [
                        {
                            label: 'Victorias',
                            data: winsData,
                            backgroundColor: 'rgba(16, 185, 129, 0.7)',
                        },
                        {
                            label: 'Derrotas',
                            data: lossesData,
                            backgroundColor: 'rgba(239, 68, 68, 0.7)',
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { 
                            display: true,
                            labels: { color: '#FFFFFF' }
                        },
                        tooltip: {
                            callbacks: {
                                label: (c) => `${c.dataset.label}: ${c.raw}`
                            }
                        }
                    },
                    scales: {
                        x: { 
                            grid: { color: '#2a2a2a' }, 
                            ticks: { color: '#FFFFFF' },
                            stacked: false
                        },
                        y: { 
                            grid: { color: '#2a2a2a' }, 
                            ticks: { 
                                color: '#FFFFFF',
                                stepSize: 1
                            },
                            stacked: false
                        }
                    }
                }
            });
        }

        // Add event listener for time range buttons in Informe -> Metricas
        document.addEventListener('DOMContentLoaded', () => {
            const informeMetricasTimeRangeContainer = document.querySelector('#informe-metricas-content .time-range-buttons');
            if (informeMetricasTimeRangeContainer) {
                informeMetricasTimeRangeContainer.addEventListener('click', (event) => {
                    if (event.target.classList.contains('time-range-btn')) {
                        informeMetricasTimeRangeContainer.querySelectorAll('.time-range-btn').forEach(btn => btn.classList.remove('active'));
                        event.target.classList.add('active');
                        const timeRange = event.target.dataset.range;
                        const selectedAccount = document.getElementById('informe-account-select').value;

                        let operations = applyDateFilterToData(DB.operations);
                        if (selectedAccount !== 'all') {
                            operations = operations.filter(op => op.accountId === selectedAccount);
                        }
                        updateInformeMetricasEvolutionChart(operations, selectedAccount, timeRange);
                    }
                });
            }

            // Event listeners para los nuevos gráficos
            const drawdownTimeRangeContainer = document.querySelector('.drawdown-range-btn').parentNode;
            if (drawdownTimeRangeContainer) {
                drawdownTimeRangeContainer.addEventListener('click', (event) => {
                    if (event.target.classList.contains('drawdown-range-btn')) {
                        drawdownTimeRangeContainer.querySelectorAll('.drawdown-range-btn').forEach(btn => btn.classList.remove('active'));
                        event.target.classList.add('active');
                        const timeRange = event.target.dataset.range;
                        const selectedAccount = document.getElementById('informe-account-select').value;

                        let operations = applyDateFilterToData(DB.operations);
                        if (selectedAccount !== 'all') {
                            operations = operations.filter(op => op.accountId === selectedAccount);
                        }
                        updateReduccionAcumuladaChart(operations, selectedAccount, timeRange);
                    }
                });
            }

            const pnlTimeRangeContainer = document.querySelector('.pnl-range-btn').parentNode;
            if (pnlTimeRangeContainer) {
                pnlTimeRangeContainer.addEventListener('click', (event) => {
                    if (event.target.classList.contains('pnl-range-btn')) {
                        pnlTimeRangeContainer.querySelectorAll('.pnl-range-btn').forEach(btn => btn.classList.remove('active'));
                        event.target.classList.add('active');
                        const timeRange = event.target.dataset.range;
                        const selectedAccount = document.getElementById('informe-account-select').value;

                        let operations = applyDateFilterToData(DB.operations);
                        if (selectedAccount !== 'all') {
                            operations = operations.filter(op => op.accountId === selectedAccount);
                        }
                        updatePnLAcumuladoChart(operations, selectedAccount, timeRange);
                    }
                });
            }

            // Event listener duplicado ELIMINADO - ya existe en línea 11661
        });
        function refreshSimbolos() {
            const container = document.getElementById('informe-simbolos-content');
            if (!container) return;


            // Obtener operaciones filtradas por fecha y cuenta
            const selectedAccount = document.getElementById('informe-account-select').value;
            let operations = applyDateFilterToData(DB.operations);
            if (selectedAccount !== 'all') {
                operations = operations.filter(op => op.accountId === selectedAccount);
            }
            operations = applyInformeFilters(operations);

            // Aggregate by symbol (using DB.settings.defaultCurrency for internal calculations)
            const symbolPerformance = {};

            if (operations.length === 0) {
                container.innerHTML = '<div class="text-center p-8 text-text-secondary">No hay datos de operaciones para mostrar en el período o cuenta seleccionada.</div>';
                return;
            }
            operations.forEach(op => {
                if (!op.instrument) return;
                const symbol = op.instrument.toUpperCase(); // Ensure symbol is uppercase
                if (!symbolPerformance[symbol]) {
                    symbolPerformance[symbol] = { pnl: 0, wins: 0, losses: 0, trades: 0, volume: 0 };
                }
                symbolPerformance[symbol].pnl += convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency);
                symbolPerformance[symbol].trades++;
                symbolPerformance[symbol].volume += op.volume;
                if (op.result === 'win') {
                    symbolPerformance[symbol].wins++;
                } else if (op.result === 'loss') {
                    symbolPerformance[symbol].losses++;
                }
            });

            // Sort symbols by PnL descending for consistent display
            const sortedSymbols = Object.entries(symbolPerformance).sort(([,a],[,b]) => b.pnl - a.pnl);

            if (sortedSymbols.length === 0) {
                container.innerHTML = '<div class="text-center p-8 text-text-secondary">No hay símbolos con operaciones para analizar.</div>';
                return;
            }
            // Calcular métricas especiales
            function getMax(arr, key) {
                if (!arr || arr.length === 0) return [null, { [key]: -Infinity }];
                return arr.reduce((max, item) => item[1][key] > max[1][key] ? item : max, arr[0]);
            }
            function getMin(arr, key) {
                if (!arr || arr.length === 0) return [null, { [key]: Infinity }];
                return arr.reduce((min, item) => item[1][key] < min[1][key] ? item : min, arr[0]);
            }
            // Más victorias
            const maxWins = getMax(sortedSymbols, 'wins'); // [symbol, {wins: X, ...}]
            // Más pérdidas
            const maxLosses = getMax(sortedSymbols, 'losses');
            // Más rentable
            const maxPnl = getMax(sortedSymbols, 'pnl'); // [symbol, {pnl: X, ...}]
            // Menos rentable
            const minPnl = getMin(sortedSymbols, 'pnl');
            // Volumen más comercializado
            const maxVol = getMax(sortedSymbols, 'volume');
            // Volumen menos comercializado
            const minVol = getMin(sortedSymbols, 'volume');
            // Oficios más comercializado
            const maxTrades = getMax(sortedSymbols, 'trades');
            // Oficios menos comercializado (count is always positive, but it's a "least" metric)
            const minTrades = getMin(sortedSymbols, 'trades'); // [symbol, {trades: X, ...}]

            // Tarjetas horizontales replicando el diseño
            // Helper function to generate a metric card HTML
            const generateSymbolMetricCard = (title, subTitle, symbol, value, valueType = 'currency', isPositive = null) => {
                if (symbol === null || value === undefined || value === Infinity || value === -Infinity) return ''; // No renderizar si no hay datos
                let valueClass = 'text-neutral'; // Default to neutral
                let formattedValue = '';
                const currencySelect = document.getElementById('informe-currency-select');
                const displayCurrency = currencySelect ? currencySelect.value : 'USD';

                if (valueType === 'currency') {
                    formattedValue = formatCurrency(value, DB.settings.defaultCurrency, displayCurrency);
                    if (value > 0) valueClass = 'text-positive';
                    else if (value < 0) valueClass = 'text-negative';
                    else valueClass = 'text-neutral'; // For 0 PnL
                } else if (valueType === 'count' || valueType === 'volume') {
                    formattedValue = value.toLocaleString();
                    // For counts/volumes, default to neutral unless overridden
                }

                if (isPositive !== null) { // Override for explicit positive/negative
                    valueClass = isPositive ? 'text-positive' : 'text-negative';
                }

                return `
                    <div class="metric-card p-4">
                        <p class="text-sm text-text-secondary">${title}</p>
                        <p class="text-xs text-text-secondary mb-2">${subTitle}</p>
                        <p class="text-xl font-bold ${valueClass}">
                            <span class="inline-block px-2 py-0.5 rounded bg-surface-light text-primary font-bold text-xs mr-2">${symbol}</span>
                            ${formattedValue}
                        </p>
                    </div>
                `;
            };

            let resumenHtml = `
                <h3 class="text-2xl font-bold mb-6 w-full text-left">Resumen por Símbolo</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-8">
                    ${generateSymbolMetricCard('Símbolo con más victorias', 'Mayor número de operaciones ganadoras', maxWins[0], maxWins[1].wins, 'count', true)}
                    ${generateSymbolMetricCard('Símbolo con más pérdidas', 'Mayor número de operaciones perdedoras', maxLosses[0], maxLosses[1].losses, 'count', false)}
                    ${generateSymbolMetricCard('Símbolo más rentable', 'Mayor PnL total', maxPnl[0], maxPnl[1].pnl, 'currency')}
                    ${generateSymbolMetricCard('Símbolo menos rentable', 'Menor PnL total', minPnl[0], minPnl[1].pnl, 'currency')}
                    ${generateSymbolMetricCard('Símbolo más comercializado', 'Mayor volumen total', maxVol[0], maxVol[1].volume, 'volume')}
                    ${generateSymbolMetricCard('Símbolo menos comercializado', 'Menor volumen total', minVol[0], minVol[1].volume, 'volume')}
                    ${generateSymbolMetricCard('Símbolo con más operaciones', 'Mayor número de trades', maxTrades[0], maxTrades[1].trades, 'count', true)}
                    ${generateSymbolMetricCard('Símbolo con menos operaciones', 'Menor número de trades', minTrades[0], minTrades[1].trades, 'count', false)}
                </div>
            `; // End of resumenHtml

            // Contenedores de gráficas básicas
            resumenHtml += `<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mt-8">
                <div class="metric-card"><h3 class="text-lg font-semibold mb-2">PnL por Símbolo</h3><div class="chart-container" style="height: 250px;"><canvas id="simbolos-pnl-chart"></canvas></div></div>
                <div class="metric-card"><h3 class="text-lg font-semibold mb-2">Wins/Losses por Símbolo</h3><div class="chart-container" style="height: 250px;"><canvas id="simbolos-wl-chart"></canvas></div></div>
                <div class="metric-card"><h3 class="text-lg font-semibold mb-2">Volumen por Símbolo</h3><div class="chart-container" style="height: 250px;"><canvas id="simbolos-volume-chart"></canvas></div></div>
            </div>`;

            // Agregar sección de análisis avanzado
            resumenHtml += `
                <h3 class="text-2xl font-bold mb-4 mt-8">Análisis Avanzado por Símbolo</h3>
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-2">Volumen de Operaciones: Long vs Short</h3>
                        <p class="text-xs text-text-secondary mb-2">Cantidad de trades por símbolo según dirección (todos los símbolos operados)</p>
                        <div class="chart-container" style="height: 500px; overflow-y: auto;">
                            <canvas id="simbolos-volume-longshort-chart"></canvas>
                        </div>
                    </div>
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-2">Expectancy: Long vs Short por Símbolo</h3>
                        <p class="text-xs text-text-secondary mb-2">Expectativa matemática por dirección - Mayor valor = mejor rendimiento esperado (todos los símbolos operados)</p>
                        <div class="chart-container" style="height: 500px; overflow-y: auto;">
                            <canvas id="simbolos-expectancy-longshort-chart"></canvas>
                        </div>
                    </div>
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-2">Profit Factor por Símbolo</h3>
                        <p class="text-xs text-text-secondary mb-2">Top 15 símbolos ordenados por profit factor</p>
                        <div class="chart-container" style="height: 280px;">
                            <canvas id="simbolos-profit-factor-chart"></canvas>
                        </div>
                    </div>
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-2">Mejores Horas por Símbolo</h3>
                        <p class="text-xs text-text-secondary mb-2">Hora más rentable para cada símbolo (Top 15)</p>
                        <div class="chart-container" style="height: 280px;">
                            <canvas id="simbolos-best-hours-chart"></canvas>
                        </div>
                    </div>
                </div>
                
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-2">Mejores Días por Símbolo</h3>
                        <p class="text-xs text-text-secondary mb-2">Día de la semana más rentable para cada símbolo (Top 15)</p>
                        <div class="chart-container" style="height: 280px;">
                            <canvas id="simbolos-best-days-chart"></canvas>
                        </div>
                    </div>
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-2">Comisiones Totales por Símbolo</h3>
                        <p class="text-xs text-text-secondary mb-2">Total de comisiones pagadas (Top 15)</p>
                        <div class="chart-container" style="height: 280px;">
                            <canvas id="simbolos-commissions-chart"></canvas>
                        </div>
                    </div>
                </div>
                    </div>
                </div>
                
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-2">P/L Neto (después de comisiones) por Símbolo</h3>
                        <p class="text-xs text-text-secondary mb-2">Ganancia real después de costos (Top 15)</p>
                        <div class="chart-container" style="height: 280px;">
                            <canvas id="simbolos-net-pl-chart"></canvas>
                        </div>
                    </div>
                    <div class="metric-card">
                        <h3 class="text-lg font-semibold mb-2">Ratio Comisión/P/L por Símbolo</h3>
                        <p class="text-xs text-text-secondary mb-2">% de ganancia consumido por comisiones (Top 15)</p>
                        <div class="chart-container" style="height: 280px;">
                            <canvas id="simbolos-commission-ratio-chart"></canvas>
                        </div>
                    </div>
                </div>
            `;

            container.innerHTML = resumenHtml;

            // Render charts
            // PnL Chart
            const pnlCtx = document.getElementById('simbolos-pnl-chart').getContext('2d');
            new Chart(pnlCtx, {
                type: 'bar',
                data: {
                    labels: sortedSymbols.map(item => item[0]),
                    datasets: [{
                        label: 'PnL',
                        data: sortedSymbols.map(item => item[1].pnl),
                        backgroundColor: sortedSymbols.map(item => item[1].pnl >= 0 ? '#00FF00' : '#FF0000'),
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        x: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0' } },
                        y: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0' } }
                    }
                }
            });
            // Wins/Losses Chart
            const wlCtx = document.getElementById('simbolos-wl-chart').getContext('2d');
            new Chart(wlCtx, {
                type: 'bar',
                data: {
                    labels: sortedSymbols.map(item => item[0]),
                    datasets: [
                        {
                            label: 'Ganadas',
                            data: sortedSymbols.map(item => item[1].wins),
                            backgroundColor: '#00FF00',
                        },
                        {
                            label: 'Perdidas',
                            data: sortedSymbols.map(item => -item[1].losses),
                            backgroundColor: '#FF0000',
                        }
                    ]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { labels: { color: '#a0a0a0' } } },
                    scales: {
                        x: { stacked: true, grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0' } },
                        y: { stacked: true, grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0' } }
                    }
                }
            });
            // Volume Chart
            const volCtx = document.getElementById('simbolos-volume-chart').getContext('2d');
            new Chart(volCtx, {
                type: 'bar',
                data: {
                    labels: sortedSymbols.map(item => item[0]),
                    datasets: [{
                        label: 'Volumen',
                        data: sortedSymbols.map(item => item[1].volume),
                        backgroundColor: 'rgba(54,162,235,0.7)',
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        x: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0' } },
                        y: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0' } }
                    }
                }
            });

            // ========== NUEVAS GRÁFICAS: ANÁLISIS LONG VS SHORT ==========
            
            // Calcular datos Long vs Short por símbolo
            const symbolLongShortAnalysis = {};
            operations.forEach(op => {
                if (!op.instrument) return;
                const symbol = op.instrument.toUpperCase();
                const opType = (op.type || op.side || '').toLowerCase().trim();
                const isLong = opType === 'long' || opType === 'buy' || opType === 'compra';
                const isShort = opType === 'short' || opType === 'sell' || opType === 'venta';
                const pl = convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency);
                const isWin = op.result === 'win' || (!op.result && op.pl > 0);
                
                if (!symbolLongShortAnalysis[symbol]) {
                    symbolLongShortAnalysis[symbol] = {
                        longCount: 0, shortCount: 0,
                        longWins: 0, shortWins: 0,
                        longPL: 0, shortPL: 0,
                        longWinPL: 0, shortWinPL: 0,
                        longLossPL: 0, shortLossPL: 0
                    };
                }
                
                if (isLong) {
                    symbolLongShortAnalysis[symbol].longCount++;
                    symbolLongShortAnalysis[symbol].longPL += pl;
                    if (isWin) {
                        symbolLongShortAnalysis[symbol].longWins++;
                        symbolLongShortAnalysis[symbol].longWinPL += pl;
                    } else {
                        symbolLongShortAnalysis[symbol].longLossPL += Math.abs(pl);
                    }
                } else if (isShort) {
                    symbolLongShortAnalysis[symbol].shortCount++;
                    symbolLongShortAnalysis[symbol].shortPL += pl;
                    if (isWin) {
                        symbolLongShortAnalysis[symbol].shortWins++;
                        symbolLongShortAnalysis[symbol].shortWinPL += pl;
                    } else {
                        symbolLongShortAnalysis[symbol].shortLossPL += Math.abs(pl);
                    }
                }
            });
            
            // TODOS los símbolos con Long/Short
            const allSymbolsLS = Object.entries(symbolLongShortAnalysis)
                .filter(([, data]) => data.longCount + data.shortCount >= 1)
                .sort(([,a], [,b]) => (b.longCount + b.shortCount) - (a.longCount + a.shortCount));
            
            // Gráfica 1: Volumen de Operaciones Long vs Short
            const volLSCtx = document.getElementById('simbolos-volume-longshort-chart').getContext('2d');
            new Chart(volLSCtx, {
                type: 'bar',
                data: {
                    labels: allSymbolsLS.map(item => item[0]),
                    datasets: [
                        {
                            label: 'Long (Compra)',
                            data: allSymbolsLS.map(item => item[1].longCount),
                            backgroundColor: '#00FF00',
                        },
                        {
                            label: 'Short (Venta)',
                            data: allSymbolsLS.map(item => item[1].shortCount),
                            backgroundColor: '#FF0000',
                        }
                    ]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { labels: { color: '#a0a0a0' } },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return context.dataset.label + ': ' + context.parsed.x + ' ops';
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            stacked: true,
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            ticks: { color: '#a0a0a0' }
                        },
                        y: {
                            stacked: true,
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            ticks: { color: '#a0a0a0' }
                        }
                    }
                }
            });
            
            // Gráfica 2: Expectancy Long vs Short por Símbolo
            const expectancyData = allSymbolsLS.map(([symbol, data]) => {
                const longWR = data.longCount > 0 ? data.longWins / data.longCount : 0;
                const longLR = 1 - longWR;
                const longAvgWin = data.longWins > 0 ? data.longWinPL / data.longWins : 0;
                const longAvgLoss = (data.longCount - data.longWins) > 0 ? data.longLossPL / (data.longCount - data.longWins) : 0;
                const longExpectancy = data.longCount > 0 ? (longWR * longAvgWin) - (longLR * longAvgLoss) : 0;
                
                const shortWR = data.shortCount > 0 ? data.shortWins / data.shortCount : 0;
                const shortLR = 1 - shortWR;
                const shortAvgWin = data.shortWins > 0 ? data.shortWinPL / data.shortWins : 0;
                const shortAvgLoss = (data.shortCount - data.shortWins) > 0 ? data.shortLossPL / (data.shortCount - data.shortWins) : 0;
                const shortExpectancy = data.shortCount > 0 ? (shortWR * shortAvgWin) - (shortLR * shortAvgLoss) : 0;
                
                return [symbol, { longExp: longExpectancy, shortExp: shortExpectancy }];
            });
            
            const expLSCtx = document.getElementById('simbolos-expectancy-longshort-chart').getContext('2d');
            new Chart(expLSCtx, {
                type: 'bar',
                data: {
                    labels: expectancyData.map(item => item[0]),
                    datasets: [
                        {
                            label: 'Expectancy Long',
                            data: expectancyData.map(item => item[1].longExp),
                            backgroundColor: '#00FF00',
                        },
                        {
                            label: 'Expectancy Short',
                            data: expectancyData.map(item => item[1].shortExp),
                            backgroundColor: '#FF0000',
                        }
                    ]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { labels: { color: '#a0a0a0' } },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return context.dataset.label + ': $' + context.parsed.x.toFixed(2);
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            stacked: true,
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            ticks: {
                                color: '#a0a0a0',
                                callback: function(value) {
                                    return '$' + value.toFixed(0);
                                }
                            }
                        },
                        y: {
                            stacked: true,
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            ticks: { color: '#a0a0a0' }
                        }
                    }
                }
            });

            // ========== NUEVAS GRÁFICAS AVANZADAS ==========
            
            // 1. Calcular Win Rate por Símbolo
            const symbolWinRate = {};
            sortedSymbols.forEach(([symbol, data]) => {
                const total = data.wins + data.losses;
                symbolWinRate[symbol] = total > 0 ? (data.wins / total) * 100 : 0;
            });
            
            // 2. Calcular Profit Factor por Símbolo
            const symbolProfitFactor = {};
            operations.forEach(op => {
                if (!op.instrument) return;
                const symbol = op.instrument.toUpperCase();
                if (!symbolProfitFactor[symbol]) {
                    symbolProfitFactor[symbol] = { totalWins: 0, totalLosses: 0 };
                }
                const plConverted = convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency);
                if (op.result === 'win') {
                    symbolProfitFactor[symbol].totalWins += plConverted;
                } else if (op.result === 'loss') {
                    symbolProfitFactor[symbol].totalLosses += Math.abs(plConverted);
                }
            });
            
            const symbolPF = {};
            Object.keys(symbolProfitFactor).forEach(symbol => {
                const { totalWins, totalLosses } = symbolProfitFactor[symbol];
                symbolPF[symbol] = totalLosses > 0 ? totalWins / totalLosses : (totalWins > 0 ? 999 : 0);
            });
            
            // 3. Calcular Mejores Horas por Símbolo
            const symbolHourlyPL = {};
            operations.forEach(op => {
                if (!op.instrument || !op.entryTime) return;
                const symbol = op.instrument.toUpperCase();
                if (!symbolHourlyPL[symbol]) {
                    symbolHourlyPL[symbol] = {};
                }
                try {
                    const hour = parseInt(op.entryTime.split(':')[0], 10);
                    if (!isNaN(hour) && hour >= 0 && hour <= 23) {
                        if (!symbolHourlyPL[symbol][hour]) {
                            symbolHourlyPL[symbol][hour] = 0;
                        }
                        symbolHourlyPL[symbol][hour] += convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency);
                    }
                } catch (e) { /* ignore */ }
            });
            
            const symbolBestHours = {};
            Object.keys(symbolHourlyPL).forEach(symbol => {
                let bestHour = -1;
                let bestPL = -Infinity;
                Object.keys(symbolHourlyPL[symbol]).forEach(hour => {
                    if (symbolHourlyPL[symbol][hour] > bestPL) {
                        bestPL = symbolHourlyPL[symbol][hour];
                        bestHour = hour;
                    }
                });
                symbolBestHours[symbol] = { hour: bestHour, pl: bestPL };
            });
            
            // 4. Calcular Mejores Días por Símbolo
            const symbolDailyPL = {};
            const dayNames = ['Dom', 'Lun', 'Mar', 'Mié', 'Jue', 'Vie', 'Sáb'];
            operations.forEach(op => {
                if (!op.instrument || !op.date) return;
                const symbol = op.instrument.toUpperCase();
                if (!symbolDailyPL[symbol]) {
                    symbolDailyPL[symbol] = {};
                }
                try {
                    const dayOfWeek = new Date(op.date + 'T00:00:00Z').getUTCDay();
                    if (!symbolDailyPL[symbol][dayOfWeek]) {
                        symbolDailyPL[symbol][dayOfWeek] = 0;
                    }
                    symbolDailyPL[symbol][dayOfWeek] += convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency);
                } catch (e) { /* ignore */ }
            });
            
            const symbolBestDays = {};
            Object.keys(symbolDailyPL).forEach(symbol => {
                let bestDay = -1;
                let bestPL = -Infinity;
                Object.keys(symbolDailyPL[symbol]).forEach(day => {
                    if (symbolDailyPL[symbol][day] > bestPL) {
                        bestPL = symbolDailyPL[symbol][day];
                        bestDay = day;
                    }
                });
                symbolBestDays[symbol] = { day: bestDay, pl: bestPL, dayName: dayNames[bestDay] };
            });
            
            // Renderizar las 4 nuevas gráficas
            
            // Gráfica 1: Win Rate por Símbolo
            const winRateCtx = document.getElementById('simbolos-winrate-chart')?.getContext('2d');
            if (winRateCtx) {
                const sortedByWinRate = Object.entries(symbolWinRate).sort(([,a], [,b]) => b - a).slice(0, 15);
                new Chart(winRateCtx, {
                    type: 'bar',
                    data: {
                        labels: sortedByWinRate.map(([symbol]) => symbol),
                        datasets: [{
                            label: 'Win Rate (%)',
                            data: sortedByWinRate.map(([, wr]) => wr),
                            backgroundColor: sortedByWinRate.map(([, wr]) => wr >= 50 ? '#00FF00' : '#FF0000'),
                        }]
                    },
                    options: {
                        indexAxis: 'y',
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { 
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: (context) => `Win Rate: ${context.parsed.x.toFixed(1)}%`
                                }
                            }
                        },
                        scales: {
                            x: { 
                                grid: { color: 'rgba(255,255,255,0.1)' }, 
                                ticks: { color: '#a0a0a0', callback: (value) => value + '%' },
                                min: 0,
                                max: 100
                            },
                            y: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0' } }
                        }
                    }
                });
            }
            
            // Gráfica 2: Profit Factor por Símbolo
            const pfCtx = document.getElementById('simbolos-profit-factor-chart')?.getContext('2d');
            if (pfCtx) {
                const sortedByPF = Object.entries(symbolPF).sort(([,a], [,b]) => b - a).slice(0, 15);
                new Chart(pfCtx, {
                    type: 'bar',
                    data: {
                        labels: sortedByPF.map(([symbol]) => symbol),
                        datasets: [{
                            label: 'Profit Factor',
                            data: sortedByPF.map(([, pf]) => Math.min(pf, 10)), // Cap at 10 for display
                            backgroundColor: sortedByPF.map(([, pf]) => pf >= 1.5 ? '#00FF00' : pf >= 1 ? 'rgba(255,193,7,0.7)' : '#FF0000'),
                        }]
                    },
                    options: {
                        indexAxis: 'y',
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { 
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: (context) => {
                                        const actualPF = sortedByPF[context.dataIndex][1];
                                        return `Profit Factor: ${actualPF.toFixed(2)}`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: { 
                                grid: { color: 'rgba(255,255,255,0.1)' }, 
                                ticks: { color: '#a0a0a0' },
                                min: 0
                            },
                            y: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0' } }
                        }
                    }
                });
            }
            
            // Gráfica 3: Mejores Horas por Símbolo
            const bestHoursCtx = document.getElementById('simbolos-best-hours-chart')?.getContext('2d');
            if (bestHoursCtx) {
                const sortedByBestHour = Object.entries(symbolBestHours)
                    .filter(([, data]) => data.hour >= 0)
                    .sort(([,a], [,b]) => b.pl - a.pl)
                    .slice(0, 15);
                
                new Chart(bestHoursCtx, {
                    type: 'bar',
                    data: {
                        labels: sortedByBestHour.map(([symbol, data]) => `${symbol} (${String(data.hour).padStart(2, '0')}:00)`),
                        datasets: [{
                            label: 'P/L en Mejor Hora',
                            data: sortedByBestHour.map(([, data]) => data.pl),
                            backgroundColor: sortedByBestHour.map(([, data]) => data.pl >= 0 ? '#00FF00' : '#FF0000'),
                        }]
                    },
                    options: {
                        indexAxis: 'y',
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { 
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: (context) => {
                                        const [symbol, data] = sortedByBestHour[context.dataIndex];
                                        return `${symbol} a las ${String(data.hour).padStart(2, '0')}:00 - P/L: $${data.pl.toFixed(2)}`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0' } },
                            y: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0', font: { size: 9 } } }
                        }
                    }
                });
            }
            
            // Gráfica 4: Mejores Días por Símbolo
            const bestDaysCtx = document.getElementById('simbolos-best-days-chart')?.getContext('2d');
            if (bestDaysCtx) {
                const sortedByBestDay = Object.entries(symbolBestDays)
                    .filter(([, data]) => data.day >= 0)
                    .sort(([,a], [,b]) => b.pl - a.pl)
                    .slice(0, 15);
                
                new Chart(bestDaysCtx, {
                    type: 'bar',
                    data: {
                        labels: sortedByBestDay.map(([symbol, data]) => `${symbol} (${data.dayName})`),
                        datasets: [{
                            label: 'P/L en Mejor Día',
                            data: sortedByBestDay.map(([, data]) => data.pl),
                            backgroundColor: sortedByBestDay.map(([, data]) => data.pl >= 0 ? '#00FF00' : '#FF0000'),
                        }]
                    },
                    options: {
                        indexAxis: 'y',
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { 
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: (context) => {
                                        const [symbol, data] = sortedByBestDay[context.dataIndex];
                                        return `${symbol} los ${data.dayName} - P/L: $${data.pl.toFixed(2)}`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0' } },
                            y: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0', font: { size: 9 } } }
                        }
                    }
                });
            }
            
            // ===== NUEVAS GRÁFICAS: COMISIONES Y COSTOS =====
            
            // Calcular comisiones por símbolo
            const symbolCommissions = {};
            const symbolSlippage = {};
            const symbolNetPL = {};
            
            operations.forEach(op => {
                if (!op.instrument) return;
                const symbol = op.instrument.toUpperCase();
                
                if (!symbolCommissions[symbol]) {
                    symbolCommissions[symbol] = 0;
                    symbolSlippage[symbol] = { total: 0, count: 0 };
                    symbolNetPL[symbol] = 0;
                }
                
                // Comisión (si no existe, estimar 0.1% del volumen)
                const commission = op.commission || (Math.abs(op.pl) * 0.001);
                symbolCommissions[symbol] += Math.abs(convertCurrency(commission, op.currency, DB.settings.defaultCurrency));
                
                // Calcular slippage (si no hay executedPrice, usar valor pequeño estimado)
                const slippage = op.executedPrice 
                    ? Math.abs((op.entryPrice || 0) - op.executedPrice)
                    : (op.entryPrice || 0) * 0.0001; // 1 pip estimado
                    
                if (slippage > 0) {
                    symbolSlippage[symbol].total += slippage;
                    symbolSlippage[symbol].count++;
                }
                
                const pl = convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency);
                symbolNetPL[symbol] += pl - commission;
            });
            
            // Gráfica 1: Comisiones por Símbolo
            const commissionsCtx = document.getElementById('simbolos-commissions-chart')?.getContext('2d');
            if (commissionsCtx) {
                const sortedCommissions = Object.entries(symbolCommissions)
                    .sort(([,a], [,b]) => Math.abs(b) - Math.abs(a))
                    .slice(0, 15);
                
                new Chart(commissionsCtx, {
                    type: 'bar',
                    data: {
                        labels: sortedCommissions.map(([symbol]) => symbol),
                        datasets: [{
                            label: 'Comisiones Totales',
                            data: sortedCommissions.map(([, comm]) => Math.abs(comm)),
                            backgroundColor: 'rgba(255,193,7,0.7)',
                            borderColor: 'rgba(255,193,7,1)',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        indexAxis: 'y',
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { 
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: (context) => `Comisiones: $${context.parsed.x.toFixed(2)}`
                                }
                            }
                        },
                        scales: {
                            x: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0' } },
                            y: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0', font: { size: 9 } } }
                        }
                    }
                });
            }
            
            // Gráfica 2: Win Rate por Símbolo
            const winrateCtx = document.getElementById('simbolos-winrate-chart')?.getContext('2d');
            if (winrateCtx) {
                const symbolWinRateData = {};
                Object.keys(symbolStats).forEach(symbol => {
                    const stats = symbolStats[symbol];
                    const total = stats.wins + stats.losses;
                    if (total >= 3) { // Mínimo 3 trades para ser relevante
                        symbolWinRateData[symbol] = {
                            winRate: (stats.wins / total) * 100,
                            trades: total,
                            wins: stats.wins,
                            losses: stats.losses
                        };
                    }
                });
                
                const sortedWinRate = Object.entries(symbolWinRateData)
                    .sort(([,a], [,b]) => b.trades - a.trades) // Ordenar por más operados
                    .slice(0, 15);
                
                if (sortedWinRate.length > 0) {
                    new Chart(winrateCtx, {
                        type: 'bar',
                        data: {
                            labels: sortedWinRate.map(([symbol]) => symbol),
                            datasets: [{
                                label: 'Win Rate %',
                                data: sortedWinRate.map(([, data]) => data.winRate),
                                backgroundColor: sortedWinRate.map(([, data]) => {
                                    if (data.winRate >= 60) return 'rgba(57, 255, 20, 0.8)'; // Verde fluorescente
                                    if (data.winRate >= 50) return 'rgba(57, 255, 20, 0.8)'; // Verde
                                    if (data.winRate >= 40) return 'rgba(251, 191, 36, 0.8)'; // Amarillo
                                    return 'rgba(239, 68, 68, 0.8)'; // Rojo
                                }),
                                borderColor: sortedWinRate.map(([, data]) => {
                                    if (data.winRate >= 60) return 'rgba(57, 255, 20, 1)';
                                    if (data.winRate >= 50) return 'rgba(57, 255, 20, 1)';
                                    if (data.winRate >= 40) return 'rgba(251, 191, 36, 1)';
                                    return 'rgba(239, 68, 68, 1)';
                                }),
                                borderWidth: 2
                            }]
                        },
                        options: {
                            indexAxis: 'y',
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false },
                                tooltip: {
                                    callbacks: {
                                        label: (context) => {
                                            const data = sortedWinRate[context.dataIndex][1];
                                            return [
                                                `Win Rate: ${context.parsed.x.toFixed(1)}%`,
                                                `Wins: ${data.wins} | Losses: ${data.losses}`,
                                                `Total Trades: ${data.trades}`
                                            ];
                                        }
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    beginAtZero: true,
                                    max: 100,
                                    grid: { color: 'rgba(255,255,255,0.1)' },
                                    ticks: {
                                        color: '#a0a0a0',
                                        callback: (value) => value + '%'
                                    },
                                    title: { display: true, text: 'Win Rate (%)', color: '#a0a0a0' }
                                },
                                y: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0', font: { size: 9 } } }
                            }
                        }
                    });
                } else {
                    // Sin datos suficientes
                    new Chart(winrateCtx, {
                        type: 'bar',
                        data: {
                            labels: ['Sin datos'],
                            datasets: [{
                                label: 'Win Rate',
                                data: [0],
                                backgroundColor: 'rgba(100,100,100,0.5)'
                            }]
                        },
                        options: {
                            indexAxis: 'y',
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: { legend: { display: false } },
                            scales: {
                                x: { ticks: { color: '#a0a0a0' }, grid: { color: '#2a2a2a' } },
                                y: { ticks: { color: '#a0a0a0' }, grid: { color: '#2a2a2a' } }
                            }
                        }
                    });
                }
            }
            
            // Gráfica 3: P/L Neto (después de comisiones)
            const netPLCtx = document.getElementById('simbolos-net-pl-chart')?.getContext('2d');
            if (netPLCtx) {
                const sortedNetPL = Object.entries(symbolNetPL)
                    .sort(([,a], [,b]) => b - a)
                    .slice(0, 15);
                
                new Chart(netPLCtx, {
                    type: 'bar',
                    data: {
                        labels: sortedNetPL.map(([symbol]) => symbol),
                        datasets: [{
                            label: 'P/L Neto',
                            data: sortedNetPL.map(([, pl]) => pl),
                            backgroundColor: sortedNetPL.map(([, pl]) => pl >= 0 ? '#00FF00' : '#FF0000')
                        }]
                    },
                    options: {
                        indexAxis: 'y',
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { 
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: (context) => `P/L Neto: $${context.parsed.x.toFixed(2)}`
                                }
                            }
                        },
                        scales: {
                            x: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0' } },
                            y: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0', font: { size: 9 } } }
                        }
                    }
                });
            }
            
            // Gráfica 4: Ratio Comisión/P/L
            const commissionRatioCtx = document.getElementById('simbolos-commission-ratio-chart')?.getContext('2d');
            if (commissionRatioCtx) {
                const commissionRatio = {};
                Object.keys(symbolPerformance).forEach(symbol => {
                    const totalPL = Math.abs(symbolPerformance[symbol].pnl);
                    const totalComm = Math.abs(symbolCommissions[symbol] || 0);
                    if (totalPL > 0 && totalComm > 0) {
                        commissionRatio[symbol] = (totalComm / totalPL) * 100;
                    } else if (totalComm > 0) {
                        commissionRatio[symbol] = 100; // Si hay comisión pero no P/L
                    }
                });
                
                const sortedRatio = Object.entries(commissionRatio)
                    .sort(([,a], [,b]) => b - a)
                    .slice(0, 15);
                
                if (sortedRatio.length > 0) {
                    new Chart(commissionRatioCtx, {
                        type: 'bar',
                        data: {
                            labels: sortedRatio.map(([symbol]) => symbol),
                            datasets: [{
                                label: 'Ratio Comisión/P/L (%)',
                                data: sortedRatio.map(([, ratio]) => ratio),
                                backgroundColor: sortedRatio.map(([, ratio]) => 
                                    ratio > 30 ? 'rgba(239,68,68,0.7)' : 
                                    ratio > 15 ? 'rgba(255,193,7,0.7)' : 
                                    '#00FF00'
                                )
                            }]
                        },
                        options: {
                            indexAxis: 'y',
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: { 
                                legend: { display: false },
                                tooltip: {
                                    callbacks: {
                                        label: (context) => `${context.parsed.x.toFixed(1)}% de P/L en comisiones`
                                    }
                                }
                            },
                            scales: {
                                x: { 
                                    beginAtZero: true,
                                    grid: { color: 'rgba(255,255,255,0.1)' }, 
                                    ticks: { 
                                        color: '#a0a0a0',
                                        callback: (value) => value + '%'
                                    } 
                                },
                                y: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0', font: { size: 9 } } }
                            }
                        }
                    });
                } else {
                    // Sin datos
                    new Chart(commissionRatioCtx, {
                        type: 'bar',
                        data: {
                            labels: ['Sin datos'],
                            datasets: [{
                                label: 'Ratio',
                                data: [0],
                                backgroundColor: 'rgba(100,100,100,0.5)'
                            }]
                        },
                        options: {
                            indexAxis: 'y',
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: { legend: { display: false } },
                            scales: {
                                x: { ticks: { color: '#a0a0a0' }, grid: { color: '#2a2a2a' } },
                                y: { ticks: { color: '#a0a0a0' }, grid: { color: '#2a2a2a' } }
                            }
                        }
                    });
                }
            }
        }

        // Variables globales para gráficos de Tiempo
        let tiempoSessionPLChart = null;
        let tiempoSessionCountChart = null;

        function refreshTiempo() {
            console.log('[Tiempo] 🔄 Refreshing...');
            const selectedAccount = document.getElementById('informe-account-select').value;
            const currencySelect = document.getElementById('informe-currency-select');
            const displayCurrency = currencySelect ? currencySelect.value : 'USD';
            
            console.log('[Tiempo] Selected account:', selectedAccount);
            let operations = applyDateFilterToData(DB.operations);
            console.log('[Tiempo] Operations after date filter:', operations.length);
            if (selectedAccount !== 'all') {
                operations = operations.filter(op => op.accountId === selectedAccount);
            }
            console.log('[Tiempo] Operations after account filter:', operations.length);
            operations = applyInformeFilters(operations);
            console.log('[Tiempo] Operations after additional filters:', operations.length);
            
            // Destruir charts anteriores
            if (tiempoSessionPLChart) { tiempoSessionPLChart.destroy(); tiempoSessionPLChart = null; }
            if (tiempoSessionCountChart) { tiempoSessionCountChart.destroy(); tiempoSessionCountChart = null; }
            
            if (operations.length === 0) {
                document.getElementById('informe-tiempo-content').innerHTML = '<div class="text-center p-8 text-text-secondary">No hay datos de operaciones para mostrar en el período o cuenta seleccionada.</div>';
                return;
            }
            
            // Calcular métricas de tiempo
            const timeMetrics = calculateTimeMetrics(operations);
            const extraMetrics = calculateExtraAnalytics(operations, selectedAccount);
            
            // Poblar métricas en tarjetas
            const avgWinDurEl = document.getElementById('informe-tiempo-avg-win-duration');
            if (avgWinDurEl) avgWinDurEl.textContent = timeMetrics.hasWins ? formatDurationText(timeMetrics.avgWinDuration) : 'N/A';
            
            const avgLossDurEl = document.getElementById('informe-tiempo-avg-loss-duration');
            if (avgLossDurEl) avgLossDurEl.textContent = timeMetrics.hasLosses ? formatDurationText(timeMetrics.avgLossDuration) : 'N/A';
            
            const bestHourEl = document.getElementById('informe-tiempo-best-hour');
            if (bestHourEl && timeMetrics.bestHour >= 0) {
                bestHourEl.textContent = `${String(timeMetrics.bestHour).padStart(2, '0')}:00 (${formatCurrency(timeMetrics.bestHourPL, DB.settings.defaultCurrency, displayCurrency)})`;
            } else if (bestHourEl) {
                bestHourEl.textContent = 'N/A';
            }
            
            const worstHourEl = document.getElementById('informe-tiempo-worst-hour');
            if (worstHourEl && timeMetrics.worstHour >= 0) {
                worstHourEl.textContent = `${String(timeMetrics.worstHour).padStart(2, '0')}:00 (${formatCurrency(timeMetrics.worstHourPL, DB.settings.defaultCurrency, displayCurrency)})`;
            } else if (worstHourEl) {
                worstHourEl.textContent = 'N/A';
            }
            
            const longestWinEl = document.getElementById('informe-tiempo-longest-win');
            if (longestWinEl) longestWinEl.textContent = timeMetrics.hasWins ? formatDurationText(timeMetrics.longestWinDuration) : 'N/A';
            
            const longestLossEl = document.getElementById('informe-tiempo-longest-loss');
            if (longestLossEl) longestLossEl.textContent = timeMetrics.hasLosses ? formatDurationText(timeMetrics.longestLossDuration) : 'N/A';
            
            const fastestWinEl = document.getElementById('informe-tiempo-fastest-win');
            if (fastestWinEl) fastestWinEl.textContent = timeMetrics.hasWins ? formatDurationText(timeMetrics.fastestWin) : 'N/A';
            
            const avgTradeDurEl = document.getElementById('informe-tiempo-avg-trade-duration');
            if (avgTradeDurEl) avgTradeDurEl.textContent = extraMetrics.avgHoldTimeText;
            
            // Nueva métrica: Ratio de Duración Win/Loss
            const durationRatioEl = document.getElementById('informe-tiempo-duration-ratio');
            if (durationRatioEl) {
                if (timeMetrics.hasWins && timeMetrics.hasLosses && timeMetrics.avgLossDuration > 0) {
                    const ratio = timeMetrics.avgWinDuration / timeMetrics.avgLossDuration;
                    durationRatioEl.textContent = ratio.toFixed(2);
                    durationRatioEl.classList.remove('text-positive', 'text-negative', 'text-white', 'text-yellow');
                    if (ratio >= 1.5) {
                        durationRatioEl.classList.add('text-positive'); // Excelente: dejas correr ganancias
                    } else if (ratio >= 1.0) {
                        durationRatioEl.classList.add('text-primary'); // Bueno: duración similar
                    } else if (ratio >= 0.7) {
                        durationRatioEl.classList.add('text-yellow'); // Advertencia: cierras rápido ganancias
                    } else {
                        durationRatioEl.classList.add('text-negative'); // Problema: mantienes mucho las pérdidas
                    }
                } else {
                    durationRatioEl.textContent = 'N/A';
                    durationRatioEl.classList.remove('text-positive', 'text-negative', 'text-primary', 'text-yellow');
                    durationRatioEl.classList.add('text-white');
                }
            }
            
            // === GRÁFICA 1: Duración Wins vs Losses ===
            if (tiempoChartDurationComp) {
                tiempoChartDurationComp.destroy();
                tiempoChartDurationComp = null;
            }
            const durationCompCtx = document.getElementById('tiempo-duration-comparison-chart')?.getContext('2d');
            if (durationCompCtx) {
                tiempoChartDurationComp = new Chart(durationCompCtx, {
                    type: 'bar',
                    data: {
                        labels: ['Wins', 'Losses'],
                        datasets: [{
                            label: 'Duración Promedio (minutos)',
                            data: [timeMetrics.avgWinDuration, timeMetrics.avgLossDuration],
                            backgroundColor: ['#00FF00', '#FF0000']
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { 
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: (context) => `Duración: ${formatDurationText(context.parsed.y)}`
                                }
                            }
                        },
                        scales: {
                            y: { 
                                beginAtZero: true,
                                grid: { color: 'rgba(255,255,255,0.1)' }, 
                                ticks: { 
                                    color: '#a0a0a0',
                                    callback: (value) => value < 60 ? `${value}m` : `${(value/60).toFixed(1)}h`
                                }
                            },
                            x: { grid: { display: false }, ticks: { color: '#a0a0a0' } }
                        }
                    }
                });
            }
            
            // === GRÁFICA 2: P/L por Hora ===
            if (tiempoChartHourlyPL) {
                tiempoChartHourlyPL.destroy();
                tiempoChartHourlyPL = null;
            }
            const hourlyPLCtx = document.getElementById('tiempo-hourly-pl-chart')?.getContext('2d');
            if (hourlyPLCtx) {
                const hourlyPL = Array(24).fill(0);
                operations.forEach(op => {
                    if (op.entryTime) {
                        try {
                            const hour = parseInt(op.entryTime.split(':')[0], 10);
                            if (!isNaN(hour) && hour >= 0 && hour <= 23) {
                                hourlyPL[hour] += convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency);
                            }
                        } catch (e) { /* ignore */ }
                    }
                });
                
                tiempoChartHourlyPL = new Chart(hourlyPLCtx, {
                    type: 'bar',
                    data: {
                        labels: Array.from({length: 24}, (_, i) => `${String(i).padStart(2, '0')}:00`),
                        datasets: [{
                            label: 'P/L por Hora',
                            data: hourlyPL,
                            backgroundColor: hourlyPL.map(v => v >= 0 ? '#00FF00' : '#FF0000')
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0' } },
                            x: { grid: { display: false }, ticks: { color: '#a0a0a0', maxRotation: 45, minRotation: 45 } }
                        }
                    }
                });
            }
            
            // === GRÁFICA 3: P/L por Día de la Semana ===
            if (tiempoChartDailyPL) {
                tiempoChartDailyPL.destroy();
                tiempoChartDailyPL = null;
            }
            const dailyPLCtx = document.getElementById('tiempo-daily-pl-chart')?.getContext('2d');
            if (dailyPLCtx) {
                const dayNames = ['Dom', 'Lun', 'Mar', 'Mié', 'Jue', 'Vie', 'Sáb'];
                const dailyPL = Array(7).fill(0);
                operations.forEach(op => {
                    if (op.date) {
                        try {
                            const dayOfWeek = new Date(op.date + 'T00:00:00Z').getUTCDay();
                            dailyPL[dayOfWeek] += convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency);
                        } catch (e) { /* ignore */ }
                    }
                });
                
                tiempoChartDailyPL = new Chart(dailyPLCtx, {
                    type: 'bar',
                    data: {
                        labels: dayNames,
                        datasets: [{
                            label: 'P/L por Día',
                            data: dailyPL,
                            backgroundColor: dailyPL.map(v => v >= 0 ? '#00FF00' : '#FF0000')
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0' } },
                            x: { grid: { display: false }, ticks: { color: '#a0a0a0' } }
                        }
                    }
                });
            }
            
            // === GRÁFICA 4: Distribución de Duración ===
            if (tiempoChartDurationDist) {
                tiempoChartDurationDist.destroy();
                tiempoChartDurationDist = null;
            }
            const durationDistCtx = document.getElementById('tiempo-duration-distribution-chart')?.getContext('2d');
            if (durationDistCtx) {
                const durations = [];
                operations.forEach(op => {
                    if (op.entryTime && op.exitTime) {
                        try {
                            const startDate = new Date(`1970-01-01T${op.entryTime}`);
                            const endDate = new Date(`1970-01-01T${op.exitTime}`);
                            let duration = (endDate - startDate) / 60000;
                            if (duration < 0) duration += 24 * 60;
                            durations.push(duration);
                        } catch (e) { /* ignore */ }
                    }
                });
                
                // Crear rangos: <15min, 15-30min, 30-60min, 1-2h, 2-4h, 4-8h, >8h
                const ranges = [15, 30, 60, 120, 240, 480, Infinity];
                const rangeLabels = ['<15min', '15-30min', '30-60min', '1-2h', '2-4h', '4-8h', '>8h'];
                const rangeCounts = Array(rangeLabels.length).fill(0);
                
                durations.forEach(d => {
                    for (let i = 0; i < ranges.length; i++) {
                        if (d < ranges[i]) {
                            rangeCounts[i]++;
                            break;
                        }
                    }
                });
                
                tiempoChartDurationDist = new Chart(durationDistCtx, {
                    type: 'bar',
                    data: {
                        labels: rangeLabels,
                        datasets: [{
                            label: 'Número de Trades',
                            data: rangeCounts,
                            backgroundColor: '#00FF00'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: { 
                                beginAtZero: true,
                                grid: { color: 'rgba(255,255,255,0.1)' }, 
                                ticks: { color: '#a0a0a0', stepSize: 1 }
                            },
                            x: { grid: { display: false }, ticks: { color: '#a0a0a0' } }
                        }
                    }
                });
            }
            
            // === NUEVA GRÁFICA: P/L por Rango de Duración ===
            if (tiempoChartPLByDuration) {
                tiempoChartPLByDuration.destroy();
                tiempoChartPLByDuration = null;
            }
            const plByDurationCtx = document.getElementById('tiempo-pl-by-duration-chart')?.getContext('2d');
            if (plByDurationCtx) {
                const durationsWithPL = [];
                operations.forEach(op => {
                    if (op.entryTime && op.exitTime) {
                        try {
                            const startDate = new Date(`1970-01-01T${op.entryTime}`);
                            const endDate = new Date(`1970-01-01T${op.exitTime}`);
                            let duration = (endDate - startDate) / 60000;
                            if (duration < 0) duration += 24 * 60;
                            durationsWithPL.push({ duration, pl: convertCurrency(op.pl, op.currency, displayCurrency) });
                        } catch (e) { /* ignore */ }
                    }
                });
                
                // Crear rangos: <15min, 15-30min, 30-60min, 1-2h, 2-4h, 4-8h, >8h
                const ranges = [15, 30, 60, 120, 240, 480, Infinity];
                const rangeLabels = ['<15min', '15-30min', '30-60min', '1-2h', '2-4h', '4-8h', '>8h'];
                const rangePL = Array(rangeLabels.length).fill(0);
                const rangeCounts = Array(rangeLabels.length).fill(0);
                
                durationsWithPL.forEach(item => {
                    for (let i = 0; i < ranges.length; i++) {
                        if (item.duration < ranges[i]) {
                            rangePL[i] += item.pl;
                            rangeCounts[i]++;
                            break;
                        }
                    }
                });
                
                // Calcular P/L promedio por rango
                const rangeAvgPL = rangePL.map((total, idx) => rangeCounts[idx] > 0 ? total / rangeCounts[idx] : 0);
                
                // Colores según positivo/negativo
                const colors = rangeAvgPL.map(pl => pl > 0 ? 'rgba(57, 255, 20, 0.8)' : 'rgba(255, 65, 54, 0.8)');
                
                tiempoChartPLByDuration = new Chart(plByDurationCtx, {
                    type: 'bar',
                    data: {
                        labels: rangeLabels,
                        datasets: [{
                            label: 'P/L Promedio',
                            data: rangeAvgPL,
                            backgroundColor: colors
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { 
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        return 'P/L Promedio: ' + formatCurrency(context.parsed.y, DB.settings.defaultCurrency, displayCurrency);
                                    }
                                }
                            }
                        },
                        scales: {
                            y: { 
                                beginAtZero: true,
                                grid: { color: 'rgba(255,255,255,0.1)' }, 
                                ticks: { 
                                    color: '#a0a0a0',
                                    callback: function(value) {
                                        return formatCurrency(value, DB.settings.defaultCurrency, displayCurrency).replace(/\.\d+/, '');
                                    }
                                }
                            },
                            x: { grid: { display: false }, ticks: { color: '#a0a0a0' } }
                        }
                    }
                });
            }
            
            // ===== HEAT MAP: HORA × DÍA DE LA SEMANA =====
            const heatmapContainer = document.getElementById('tiempo-heatmap-container');
            if (heatmapContainer) {
                // Estructura de datos: 7 días × 24 horas
                const dayNames = ['Dom', 'Lun', 'Mar', 'Mié', 'Jue', 'Vie', 'Sáb'];
                const heatmapData = Array(7).fill(null).map(() => Array(24).fill(0));
                const heatmapCounts = Array(7).fill(null).map(() => Array(24).fill(0));
                
                // Acumular P/L por día y hora
                operations.forEach(op => {
                    if (op.date && op.entryTime) {
                        try {
                            const dayOfWeek = new Date(op.date + 'T00:00:00Z').getUTCDay();
                            const hour = parseInt(op.entryTime.split(':')[0], 10);
                            if (!isNaN(hour) && hour >= 0 && hour <= 23) {
                                heatmapData[dayOfWeek][hour] += convertCurrency(op.pl, op.currency, displayCurrency);
                                heatmapCounts[dayOfWeek][hour]++;
                            }
                        } catch (e) { /* ignore */ }
                    }
                });
                
                // Encontrar valores máximo y mínimo para escalar colores
                let maxPL = 0, minPL = 0;
                heatmapData.forEach(row => {
                    row.forEach(val => {
                        if (val > maxPL) maxPL = val;
                        if (val < minPL) minPL = val;
                    });
                });
                
                // Función para obtener color basado en P/L
                function getHeatColor(value) {
                    if (value === 0) return '#2a2a2a'; // Sin datos
                    
                    const absMax = Math.max(Math.abs(maxPL), Math.abs(minPL));
                    const intensity = Math.abs(value) / absMax;
                    
                    if (value > 0) {
                        // Verde para ganancias
                        if (intensity > 0.7) return '#2ecc40'; // Verde oscuro
                        if (intensity > 0.4) return '#85e085'; // Verde claro
                        return '#c8f0c8'; // Verde muy claro
                    } else {
                        // Rojo para pérdidas
                        if (intensity > 0.7) return '#ff4136'; // Rojo oscuro
                        if (intensity > 0.4) return '#ff8577'; // Rojo claro
                        return '#ffb3ab'; // Rojo muy claro
                    }
                }
                
                // Generar HTML del heat map
                let html = `
                    <div style="overflow-x: auto;">
                    <table class="w-full border-collapse" style="min-width: 800px;">
                        <thead>
                            <tr>
                                <th class="p-2 text-xs text-text-secondary border border-border" style="width: 60px;"></th>
                                ${Array.from({length: 24}, (_, i) => `<th class="p-1 text-xs text-text-secondary border border-border">${String(i).padStart(2, '0')}h</th>`).join('')}
                            </tr>
                        </thead>
                        <tbody>
                `;
                
                heatmapData.forEach((row, dayIndex) => {
                    html += `<tr>`;
                    html += `<td class="p-2 text-xs font-semibold text-white border border-border bg-surface">${dayNames[dayIndex]}</td>`;
                    row.forEach((value, hourIndex) => {
                        const color = getHeatColor(value);
                        const count = heatmapCounts[dayIndex][hourIndex];
                        const displayValue = value === 0 ? '-' : formatCurrency(value, DB.settings.defaultCurrency, displayCurrency);
                        const tooltip = count > 0 ? `${count} trade${count > 1 ? 's' : ''}: ${displayValue}` : 'Sin datos';
                        
                        html += `
                            <td class="p-2 text-center border border-border cursor-pointer hover:opacity-80 transition-opacity" 
                                style="background-color: ${color}; min-width: 40px; height: 40px;"
                                title="${tooltip}">
                                <div class="text-xs font-semibold" style="color: ${value === 0 ? '#666' : (Math.abs(value) / Math.max(Math.abs(maxPL), Math.abs(minPL)) > 0.5 ? '#fff' : '#000')};">
                                    ${count > 0 ? count : ''}
                                </div>
                            </td>
                        `;
                    });
                    html += `</tr>`;
                });
                
                html += `
                        </tbody>
                    </table>
                    </div>
                `;
                
                heatmapContainer.innerHTML = html;
            }
            
            // ===== NUEVAS GRÁFICAS: SESIONES Y EXPOSICIÓN =====
            
            // Calcular métricas por sesión de mercado
            const sessions = { Asia: {pl: 0, count: 0, wins: 0, total: 0}, Europa: {pl: 0, count: 0, wins: 0, total: 0}, America: {pl: 0, count: 0, wins: 0, total: 0} };
            let totalExposureWins = 0, totalExposureLosses = 0, countWins = 0, countLosses = 0;
            let totalMarketTime = 0;
            let opsWithoutTimes = 0;
            let opsWithTimes = 0;
            
            console.log('[Tiempo Exposure] Procesando', operations.length, 'operaciones');
            console.log('[Tiempo Exposure] Muestra primeras 3 ops:', operations.slice(0, 3).map(op => ({
                id: op.id,
                entryTime: op.entryTime,
                exitTime: op.exitTime,
                result: op.result,
                pl: op.pl
            })));
            
            operations.forEach(op => {
                if (op.entryTime) {
                    const hour = parseInt(op.entryTime.split(':')[0]);
                    let session = 'America';
                    if (hour >= 0 && hour < 8) session = 'Asia';
                    else if (hour >= 8 && hour < 16) session = 'Europa';
                    
                    const pl = convertCurrency(op.pl, op.currency, displayCurrency);
                    sessions[session].pl += pl;
                    sessions[session].count++;
                    sessions[session].total++;
                    
                    // Determinar si es win usando result o pl
                    const isWin = op.result === 'win' || (!op.result && op.pl > 0);
                    if (isWin) sessions[session].wins++;
                    
                    // Calcular duración - Si no hay exitTime, usar entryTime (duración = 0)
                    const finalExitTime = op.exitTime || op.entryTime;
                    if (finalExitTime) {
                        opsWithTimes++;
                        try {
                            const start = new Date(`1970-01-01T${op.entryTime}`);
                            const end = new Date(`1970-01-01T${finalExitTime}`);
                            let duration = (end - start) / (1000 * 60 * 60); // hours
                            if (duration < 0) duration += 24;
                            // Si no hay exitTime, la duración será 0 pero igual la contamos
                            totalMarketTime += duration;
                            
                            // Determinar si es win o loss usando result o pl
                            const isWinTrade = op.result === 'win' || (!op.result && op.pl > 0);
                            const isLossTrade = op.result === 'loss' || (!op.result && op.pl < 0);
                            
                            if (isWinTrade) {
                                totalExposureWins += duration;
                                countWins++;
                            } else if (isLossTrade) {
                                totalExposureLosses += duration;
                                countLosses++;
                            }
                        } catch(e) {
                            console.error('[Tiempo Exposure] Error calculando duración:', e);
                        }
                    } else {
                        opsWithoutTimes++;
                    }
                }
            });
            
            console.log('[Tiempo Exposure] Stats:', {
                opsTotal: operations.length,
                opsWithTimes,
                opsWithoutTimes
            });
            console.log('[Tiempo Exposure] Resultados:', {
                countWins,
                countLosses,
                totalExposureWins: totalExposureWins.toFixed(2),
                totalExposureLosses: totalExposureLosses.toFixed(2),
                avgWin: countWins > 0 ? (totalExposureWins / countWins).toFixed(2) : 0,
                avgLoss: countLosses > 0 ? (totalExposureLosses / countLosses).toFixed(2) : 0
            });
            
            // Actualizar métricas numéricas
            const marketExposureEl = document.getElementById('informe-tiempo-market-exposure');
            if (marketExposureEl) marketExposureEl.textContent = totalMarketTime.toFixed(1) + 'h';
            
            const avgExposureEl = document.getElementById('informe-tiempo-avg-exposure');
            if (avgExposureEl && operations.length > 0) {
                avgExposureEl.textContent = (totalMarketTime / operations.length).toFixed(2) + 'h';
            }
            
            // Calcular tiempo inactivo total (tiempo entre trades)
            let totalInactiveTime = 0;
            let maxInactiveTime = 0;
            let inactiveCount = 0;
            const sortedOps = [...operations].sort((a, b) => {
                const dateA = new Date(a.date + 'T' + (a.exitTime || '00:00'));
                const dateB = new Date(b.date + 'T' + (b.exitTime || '00:00'));
                return dateA - dateB;
            });
            
            for (let i = 0; i < sortedOps.length - 1; i++) {
                const currentOp = sortedOps[i];
                const nextOp = sortedOps[i + 1];
                
                if (currentOp.exitTime && nextOp.entryTime) {
                    try {
                        const exitDateTime = new Date(currentOp.date + 'T' + currentOp.exitTime);
                        const entryDateTime = new Date(nextOp.date + 'T' + nextOp.entryTime);
                        const inactiveHours = (entryDateTime - exitDateTime) / (1000 * 60 * 60);
                        
                        if (inactiveHours > 0 && inactiveHours < 720) { // Máximo 30 días para evitar datos incorrectos
                            totalInactiveTime += inactiveHours;
                            inactiveCount++;
                            if (inactiveHours > maxInactiveTime) {
                                maxInactiveTime = inactiveHours;
                            }
                        }
                    } catch(e) { /* ignore */ }
                }
            }
            
            const avgInactiveTime = inactiveCount > 0 ? totalInactiveTime / inactiveCount : 0;
            
            // Actualizar elemento principal de tiempo inactivo
            const inactiveTimeEl = document.getElementById('informe-tiempo-inactive-time');
            if (inactiveTimeEl) {
                if (totalInactiveTime >= 24) {
                    inactiveTimeEl.textContent = (totalInactiveTime / 24).toFixed(1) + 'd';
                } else {
                    inactiveTimeEl.textContent = totalInactiveTime.toFixed(1) + 'h';
                }
            }
            
            // Actualizar elementos del gráfico de tiempo inactivo
            const inactiveTimeChartEl = document.getElementById('informe-tiempo-inactive-time-chart');
            if (inactiveTimeChartEl) {
                if (totalInactiveTime >= 24) {
                    inactiveTimeChartEl.textContent = (totalInactiveTime / 24).toFixed(1) + 'd';
                } else {
                    inactiveTimeChartEl.textContent = totalInactiveTime.toFixed(1) + 'h';
                }
            }
            
            const avgInactiveEl = document.getElementById('informe-tiempo-avg-inactive');
            if (avgInactiveEl) {
                if (avgInactiveTime >= 24) {
                    avgInactiveEl.textContent = (avgInactiveTime / 24).toFixed(1) + 'd';
                } else if (avgInactiveTime >= 1) {
                    avgInactiveEl.textContent = avgInactiveTime.toFixed(1) + 'h';
                } else {
                    avgInactiveEl.textContent = (avgInactiveTime * 60).toFixed(0) + 'min';
                }
            }
            
            const maxInactiveEl = document.getElementById('informe-tiempo-max-inactive');
            if (maxInactiveEl) {
                if (maxInactiveTime >= 24) {
                    maxInactiveEl.textContent = (maxInactiveTime / 24).toFixed(1) + 'd';
                } else if (maxInactiveTime >= 1) {
                    maxInactiveEl.textContent = maxInactiveTime.toFixed(1) + 'h';
                } else {
                    maxInactiveEl.textContent = (maxInactiveTime * 60).toFixed(0) + 'min';
                }
            }
            
            const bestSessionEl = document.getElementById('informe-tiempo-best-session');
            const worstSessionEl = document.getElementById('informe-tiempo-worst-session');
            const bestSession = Object.entries(sessions).sort((a,b) => b[1].pl - a[1].pl)[0];
            const worstSession = Object.entries(sessions).sort((a,b) => a[1].pl - b[1].pl)[0];
            if (bestSessionEl) bestSessionEl.textContent = `${bestSession[0]} (${formatCurrency(bestSession[1].pl, DB.settings.defaultCurrency, displayCurrency)})`;
            if (worstSessionEl) worstSessionEl.textContent = `${worstSession[0]} (${formatCurrency(worstSession[1].pl, DB.settings.defaultCurrency, displayCurrency)})`;
            
            // Gráfica 1: P/L por Sesión
            const sessionPLCtx = document.getElementById('tiempo-session-pl-chart')?.getContext('2d');
            if (sessionPLCtx) {
                tiempoSessionPLChart = new Chart(sessionPLCtx, {
                    type: 'bar',
                    data: {
                        labels: ['Asia (00-08h)', 'Europa (08-16h)', 'América (16-00h)'],
                        datasets: [{
                            label: 'P/L por Sesión',
                            data: [sessions.Asia.pl, sessions.Europa.pl, sessions.America.pl],
                            backgroundColor: [
                                sessions.Asia.pl >= 0 ? '#00FF00' : '#FF0000',
                                sessions.Europa.pl >= 0 ? '#00FF00' : '#FF0000',
                                sessions.America.pl >= 0 ? '#00FF00' : '#FF0000'
                            ]
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0' } },
                            x: { grid: { display: false }, ticks: { color: '#a0a0a0' } }
                        }
                    }
                });
            }
            
            // Gráfica 2: Trades por Sesión
            const sessionCountCtx = document.getElementById('tiempo-session-count-chart')?.getContext('2d');
            if (sessionCountCtx) {
                tiempoSessionCountChart = new Chart(sessionCountCtx, {
                    type: 'bar',
                    data: {
                        labels: ['Asia (00-08h)', 'Europa (08-16h)', 'América (16-00h)'],
                        datasets: [{
                            label: 'Número de Trades',
                            data: [sessions.Asia.count, sessions.Europa.count, sessions.America.count],
                            backgroundColor: '#00FF00'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0', stepSize: 1 } },
                            x: { grid: { display: false }, ticks: { color: '#a0a0a0' } }
                        }
                    }
                });
            }
            
            // Gráfica 3: Exposición Wins vs Losses
            if (tiempoChartExposureComparison) {
                tiempoChartExposureComparison.destroy();
                tiempoChartExposureComparison = null;
            }
            const exposureCompCtx = document.getElementById('tiempo-exposure-comparison-chart')?.getContext('2d');
            if (exposureCompCtx) {
                const avgExposureWin = countWins > 0 ? totalExposureWins / countWins : 0;
                const avgExposureLoss = countLosses > 0 ? totalExposureLosses / countLosses : 0;
                
                console.log('[Tiempo Chart] 📊 Renderizando chart exposure...');
                console.log('[Tiempo Chart] avgExposureWin:', avgExposureWin, 'horas');
                console.log('[Tiempo Chart] avgExposureLoss:', avgExposureLoss, 'horas');
                console.log('[Tiempo Chart] Chart data:', [avgExposureWin, avgExposureLoss]);
                
                // Si no hay datos, mostrar valores mínimos para que se vea el chart vacío
                const chartData = [avgExposureWin || 0.001, avgExposureLoss || 0.001];
                
                tiempoChartExposureComparison = new Chart(exposureCompCtx, {
                    type: 'bar',
                    data: {
                        labels: ['Trades Ganadores', 'Trades Perdedores'],
                        datasets: [{
                            label: 'Tiempo Promedio (horas)',
                            data: chartData,
                            backgroundColor: ['#00FF00', '#FF0000']
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { 
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: (ctx) => `${ctx.parsed.y.toFixed(2)} horas`
                                }
                            }
                        },
                        scales: {
                            y: { 
                                beginAtZero: true,
                                grid: { color: 'rgba(255,255,255,0.1)' }, 
                                ticks: { 
                                    color: '#a0a0a0',
                                    callback: (val) => val + 'h'
                                } 
                            },
                            x: { grid: { display: false }, ticks: { color: '#a0a0a0' } }
                        }
                    }
                });
            }
            
            // Gráfica 4: Win Rate por Sesión
            if (tiempoChartSessionWinRate) {
                tiempoChartSessionWinRate.destroy();
                tiempoChartSessionWinRate = null;
            }
            const sessionWRCtx = document.getElementById('tiempo-session-winrate-chart')?.getContext('2d');
            if (sessionWRCtx) {
                const winRates = [
                    sessions.Asia.total > 0 ? (sessions.Asia.wins / sessions.Asia.total) * 100 : 0,
                    sessions.Europa.total > 0 ? (sessions.Europa.wins / sessions.Europa.total) * 100 : 0,
                    sessions.America.total > 0 ? (sessions.America.wins / sessions.America.total) * 100 : 0
                ];
                
                tiempoChartSessionWinRate = new Chart(sessionWRCtx, {
                    type: 'bar',
                    data: {
                        labels: ['Asia (00-08h)', 'Europa (08-16h)', 'América (16-00h)'],
                        datasets: [{
                            label: 'Win Rate (%)',
                            data: winRates,
                            backgroundColor: winRates.map(wr => wr >= 50 ? '#00FF00' : '#FF0000')
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { 
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: (ctx) => `Win Rate: ${ctx.parsed.y.toFixed(1)}%`
                                }
                            }
                        },
                        scales: {
                            y: { 
                                min: 0,
                                max: 100,
                                grid: { color: 'rgba(255,255,255,0.1)' }, 
                                ticks: { 
                                    color: '#a0a0a0',
                                    callback: (val) => val + '%'
                                } 
                            },
                            x: { grid: { display: false }, ticks: { color: '#a0a0a0' } }
                        }
                    }
                });
            }

            // === NUEVO: GRÁFICO SCATTER - CALIDAD DE EJECUCIÓN ===
            if (tiempoChartExecutionQuality) {
                tiempoChartExecutionQuality.destroy();
                tiempoChartExecutionQuality = null;
            }
            const executionQualityCtx = document.getElementById('tiempo-execution-quality-scatter')?.getContext('2d');
            if (executionQualityCtx) {
                const scatterData = [];
                
                operations.forEach(op => {
                    if (op.entryTime && op.exitTime) {
                        try {
                            // Calcular duración en horas
                            const startDate = new Date(`1970-01-01T${op.entryTime}`);
                            const endDate = new Date(`1970-01-01T${op.exitTime}`);
                            let duration = (endDate - startDate) / 3600000; // Horas
                            if (duration < 0) duration += 24;
                            
                            // Calcular múltiplo de R (asumiendo riesgo estándar si no hay SL)
                            let rMultiple = 0;
                            const pl = convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency);
                            
                            if (op.stopLoss && op.entryPrice) {
                                const risk = Math.abs(op.entryPrice - op.stopLoss) * (op.volume || 1);
                                rMultiple = risk > 0 ? pl / risk : (pl / 100); // Fallback si risk es 0
                            } else {
                                // Si no hay SL, usar un estimado basado en el P/L
                                rMultiple = pl / 100; // Asumiendo riesgo base de $100
                            }
                            
                            scatterData.push({
                                x: duration,
                                y: rMultiple,
                                pl: pl,
                                result: op.result
                            });
                        } catch (e) { /* ignore */ }
                    }
                });
                
                // Separar wins y losses para diferentes colores
                const winData = scatterData.filter(d => d.result === 'win' || d.pl > 0);
                const lossData = scatterData.filter(d => d.result === 'loss' || d.pl < 0);
                
                tiempoChartExecutionQuality = new Chart(executionQualityCtx, {
                    type: 'scatter',
                    data: {
                        datasets: [
                            {
                                label: 'Trades Ganadores',
                                data: winData,
                                backgroundColor: 'rgba(57, 255, 20, 0.6)',
                                borderColor: 'rgba(57, 255, 20, 1)',
                                borderWidth: 1,
                                pointRadius: 6,
                                pointHoverRadius: 8
                            },
                            {
                                label: 'Trades Perdedores',
                                data: lossData,
                                backgroundColor: 'rgba(255, 65, 54, 0.6)',
                                borderColor: 'rgba(255, 65, 54, 1)',
                                borderWidth: 1,
                                pointRadius: 6,
                                pointHoverRadius: 8
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top',
                                labels: {
                                    color: '#ffffff',
                                    font: { size: 12 },
                                    usePointStyle: true,
                                    padding: 15
                                }
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const point = context.raw;
                                        return [
                                            `Duración: ${point.x.toFixed(2)} horas`,
                                            `R-Multiple: ${point.y.toFixed(2)}R`,
                                            `P/L: ${formatCurrency(point.pl, DB.settings.defaultCurrency, displayCurrency)}`
                                        ];
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'linear',
                                position: 'bottom',
                                title: {
                                    display: true,
                                    text: 'Duración (Horas)',
                                    color: '#a0a0a0',
                                    font: { size: 12, weight: 'bold' }
                                },
                                grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                ticks: { 
                                    color: '#a0a0a0',
                                    callback: (value) => value.toFixed(1) + 'h'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'Resultado (Múltiplos de Riesgo - R)',
                                    color: '#a0a0a0',
                                    font: { size: 12, weight: 'bold' }
                                },
                                grid: { 
                                    color: 'rgba(255, 255, 255, 0.1)',
                                    drawBorder: true
                                },
                                ticks: { 
                                    color: '#a0a0a0',
                                    callback: (value) => value.toFixed(1) + 'R'
                                }
                            }
                        }
                    }
                });
                
                // Actualizar contador de trades
                const totalTradesEl = document.getElementById('tiempo-scatter-total-trades');
                if (totalTradesEl) totalTradesEl.textContent = scatterData.length;
            }
        }

        // Variables globales para charts de Métricas Avanzadas
        let metricasAvanzadasChartRachas = null;
        let metricasAvanzadasChartVolumen = null;
        let metricasAvanzadasChartSesiones = null;
        let metricasAvanzadasChartWinrateHorario = null;
        let metricasAvanzadasChartPlAfterWins = null;
        let metricasAvanzadasChartPlAfterLosses = null;
        let metricasAvanzadasChartRevenge = null;
        let metricasAvanzadasChartOvertrading = null;

        function refreshMetricasAvanzadas() {
            console.log('[Métricas Avanzadas] 🔄 Refreshing...');
            const selectedAccount = document.getElementById('informe-account-select').value;
            const currencySelect = document.getElementById('informe-currency-select');
            const displayCurrency = currencySelect ? currencySelect.value : 'USD';
            
            console.log('[Métricas Avanzadas] Selected account:', selectedAccount);
            let operations = applyDateFilterToData(DB.operations);
            console.log('[Métricas Avanzadas] Operations after date filter:', operations.length);
            if (selectedAccount !== 'all') {
                operations = operations.filter(op => op.accountId === selectedAccount);
            }
            console.log('[Métricas Avanzadas] Operations after account filter:', operations.length);
            operations = applyInformeFilters(operations);
            console.log('[Métricas Avanzadas] Operations after additional filters:', operations.length);
            
            if (operations.length === 0) {
                document.getElementById('informe-metricas-avanzadas-content').innerHTML = '<div class="text-center p-8 text-text-secondary">No hay datos de operaciones para mostrar en el período o cuenta seleccionada.</div>';
                return;
            }
            
            // === CALCULAR Y POBLAR MÉTRICAS PROFESIONALES ===
            const professionalMetrics = calculateProfessionalMetrics(operations, selectedAccount);
            
            document.getElementById('informe-expectancy-ratio').textContent = formatCurrency(professionalMetrics.expectancyRatio, DB.settings.defaultCurrency, displayCurrency);
            document.getElementById('informe-kelly-criterion').textContent = professionalMetrics.kellyCriterion.toFixed(2) + '%';
            document.getElementById('informe-sharpe-ratio').textContent = professionalMetrics.sharpeRatio.toFixed(2);
            document.getElementById('informe-sortino-ratio').textContent = professionalMetrics.sortinoRatio.toFixed(2);
            document.getElementById('informe-calmar-ratio').textContent = professionalMetrics.calmarRatio.toFixed(2);
            document.getElementById('informe-recovery-factor').textContent = professionalMetrics.recoveryFactor.toFixed(2);
            document.getElementById('informe-risk-of-ruin').textContent = professionalMetrics.riskOfRuin.toFixed(2) + '%';
            document.getElementById('informe-z-score').textContent = professionalMetrics.zScore.toFixed(2);
            document.getElementById('informe-avg-mae').textContent = formatCurrency(professionalMetrics.avgMAE, DB.settings.defaultCurrency, displayCurrency);
            document.getElementById('informe-avg-mfe').textContent = formatCurrency(professionalMetrics.avgMFE, DB.settings.defaultCurrency, displayCurrency);
            document.getElementById('informe-max-win-streak').textContent = professionalMetrics.maxWinStreak;
            document.getElementById('informe-max-loss-streak').textContent = professionalMetrics.maxLossStreak;
            document.getElementById('informe-consistency-score').textContent = professionalMetrics.consistencyScore;
            document.getElementById('informe-payoff-ratio').textContent = professionalMetrics.payoffRatio.toFixed(2);
            document.getElementById('informe-total-trading-days').textContent = professionalMetrics.totalTradingDays;
            document.getElementById('informe-avg-r-multiple').textContent = professionalMetrics.avgRMultiple.toFixed(2) + 'R';
            
            // Destruir charts anteriores
            if (metricasAvanzadasChartRachas) { metricasAvanzadasChartRachas.destroy(); metricasAvanzadasChartRachas = null; }
            if (metricasAvanzadasChartVolumen) { metricasAvanzadasChartVolumen.destroy(); metricasAvanzadasChartVolumen = null; }
            if (metricasAvanzadasChartSesiones) { metricasAvanzadasChartSesiones.destroy(); metricasAvanzadasChartSesiones = null; }
            if (metricasAvanzadasChartWinrateHorario) { metricasAvanzadasChartWinrateHorario.destroy(); metricasAvanzadasChartWinrateHorario = null; }
            if (metricasAvanzadasChartPlAfterWins) { metricasAvanzadasChartPlAfterWins.destroy(); metricasAvanzadasChartPlAfterWins = null; }
            if (metricasAvanzadasChartPlAfterLosses) { metricasAvanzadasChartPlAfterLosses.destroy(); metricasAvanzadasChartPlAfterLosses = null; }
            if (metricasAvanzadasChartRevenge) { metricasAvanzadasChartRevenge.destroy(); metricasAvanzadasChartRevenge = null; }
            if (metricasAvanzadasChartOvertrading) { metricasAvanzadasChartOvertrading.destroy(); metricasAvanzadasChartOvertrading = null; }
            
            // === GRÁFICA 1: Rachas Ganadoras/Perdedoras por Tipo (Long/Short) ===
            const longOps = operations.filter(op => op.type === 'buy');
            const shortOps = operations.filter(op => op.type === 'sell');
            
            const calcRachas = (ops) => {
                let maxWinStreak = 0, maxLossStreak = 0, currentWinStreak = 0, currentLossStreak = 0;
                const sortedOps = [...ops].sort((a, b) => new Date(a.date + 'T' + (a.entryTime || '00:00')) - new Date(b.date + 'T' + (b.entryTime || '00:00')));
                sortedOps.forEach(op => {
                    if (op.pl > 0) {
                        currentWinStreak++;
                        currentLossStreak = 0;
                        if (currentWinStreak > maxWinStreak) maxWinStreak = currentWinStreak;
                    } else {
                        currentLossStreak++;
                        currentWinStreak = 0;
                        if (currentLossStreak > maxLossStreak) maxLossStreak = currentLossStreak;
                    }
                });
                return { maxWinStreak, maxLossStreak };
            };
            
            const longRachas = calcRachas(longOps);
            const shortRachas = calcRachas(shortOps);
            
            const rachasCtx = document.getElementById('metricas-avanzadas-rachas-chart')?.getContext('2d');
            if (rachasCtx) {
                metricasAvanzadasChartRachas = new Chart(rachasCtx, {
                    type: 'bar',
                    data: {
                        labels: ['Long Wins', 'Long Losses', 'Short Wins', 'Short Losses'],
                        datasets: [{
                            label: 'Racha Máxima',
                            data: [longRachas.maxWinStreak, longRachas.maxLossStreak, shortRachas.maxWinStreak, shortRachas.maxLossStreak],
                            backgroundColor: ['#00FF00', '#FF0000', '#00FF00', '#FF0000']
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: { beginAtZero: true, ticks: { color: '#a0a0a0', stepSize: 1 }, grid: { color: 'rgba(255,255,255,0.1)' } },
                            x: { ticks: { color: '#a0a0a0' }, grid: { display: false } }
                        }
                    }
                });
            }
            
            // === GRÁFICA 2: Volumen de Ganancias/Pérdidas Temporal ===
            const calcVolumen = (periodo) => {
                const wins = operations.filter(op => op.pl > 0);
                const losses = operations.filter(op => op.pl < 0);
                
                let volumenWins = 0, volumenLosses = 0;
                if (periodo === 'dia') {
                    volumenWins = wins.length / Math.max(1, new Set(wins.map(op => op.date)).size);
                    volumenLosses = losses.length / Math.max(1, new Set(losses.map(op => op.date)).size);
                } else if (periodo === 'semana') {
                    const getWeek = (date) => {
                        const d = new Date(date + 'T00:00:00Z');
                        return `${d.getUTCFullYear()}-W${Math.ceil((d.getUTCDate() + d.getUTCDay()) / 7)}`;
                    };
                    volumenWins = wins.length / Math.max(1, new Set(wins.map(op => getWeek(op.date))).size);
                    volumenLosses = losses.length / Math.max(1, new Set(losses.map(op => getWeek(op.date))).size);
                } else if (periodo === 'mes') {
                    volumenWins = wins.length / Math.max(1, new Set(wins.map(op => op.date.substring(0, 7))).size);
                    volumenLosses = losses.length / Math.max(1, new Set(losses.map(op => op.date.substring(0, 7))).size);
                }
                return { volumenWins, volumenLosses };
            };
            
            const volDia = calcVolumen('dia');
            const volSemana = calcVolumen('semana');
            const volMes = calcVolumen('mes');
            
            const volumenCtx = document.getElementById('metricas-avanzadas-volumen-chart')?.getContext('2d');
            if (volumenCtx) {
                metricasAvanzadasChartVolumen = new Chart(volumenCtx, {
                    type: 'bar',
                    data: {
                        labels: ['Día', 'Semana', 'Mes'],
                        datasets: [
                            {
                                label: 'Wins Promedio',
                                data: [volDia.volumenWins, volSemana.volumenWins, volMes.volumenWins],
                                backgroundColor: '#00FF00'
                            },
                            {
                                label: 'Losses Promedio',
                                data: [volDia.volumenLosses, volSemana.volumenLosses, volMes.volumenLosses],
                                backgroundColor: '#FF0000'
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: true, labels: { color: '#ffffff' } } },
                        scales: {
                            y: { beginAtZero: true, ticks: { color: '#a0a0a0' }, grid: { color: 'rgba(255,255,255,0.1)' } },
                            x: { ticks: { color: '#a0a0a0' }, grid: { display: false } }
                        }
                    }
                });
            }
            
            // === GRÁFICA 3: Distribución de P/L por Sesión de Trading ===
            // Asiática: 00:00-08:00, Europea: 08:00-16:00, Americana: 16:00-24:00
            const sesiones = { asiatica: [], europea: [], americana: [] };
            operations.forEach(op => {
                if (op.entryTime) {
                    try {
                        const hour = parseInt(op.entryTime.split(':')[0], 10);
                        const pl = convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency);
                        if (hour >= 0 && hour < 8) sesiones.asiatica.push(pl);
                        else if (hour >= 8 && hour < 16) sesiones.europea.push(pl);
                        else if (hour >= 16 && hour < 24) sesiones.americana.push(pl);
                    } catch (e) { /* ignore */ }
                }
            });
            
            const avgAsiatica = sesiones.asiatica.length > 0 ? sesiones.asiatica.reduce((a, b) => a + b, 0) / sesiones.asiatica.length : 0;
            const avgEuropea = sesiones.europea.length > 0 ? sesiones.europea.reduce((a, b) => a + b, 0) / sesiones.europea.length : 0;
            const avgAmericana = sesiones.americana.length > 0 ? sesiones.americana.reduce((a, b) => a + b, 0) / sesiones.americana.length : 0;
            
            const sesionesCtx = document.getElementById('metricas-avanzadas-sesiones-chart')?.getContext('2d');
            if (sesionesCtx) {
                metricasAvanzadasChartSesiones = new Chart(sesionesCtx, {
                    type: 'bar',
                    data: {
                        labels: ['Asiática (0-8h)', 'Europea (8-16h)', 'Americana (16-24h)'],
                        datasets: [{
                            label: 'P/L Promedio',
                            data: [avgAsiatica, avgEuropea, avgAmericana],
                            backgroundColor: [
                                avgAsiatica >= 0 ? '#00FF00' : '#FF0000',
                                avgEuropea >= 0 ? '#00FF00' : '#FF0000',
                                avgAmericana >= 0 ? '#00FF00' : '#FF0000'
                            ]
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: { ticks: { color: '#a0a0a0' }, grid: { color: 'rgba(255,255,255,0.1)' } },
                            x: { ticks: { color: '#a0a0a0' }, grid: { display: false } }
                        }
                    }
                });
            }
            
            // === GRÁFICA 4: Win Rate por Rango Horario (intervalos de 4 horas) ===
            const rangosHorarios = [
                { label: '0-4h', min: 0, max: 4, wins: 0, total: 0 },
                { label: '4-8h', min: 4, max: 8, wins: 0, total: 0 },
                { label: '8-12h', min: 8, max: 12, wins: 0, total: 0 },
                { label: '12-16h', min: 12, max: 16, wins: 0, total: 0 },
                { label: '16-20h', min: 16, max: 20, wins: 0, total: 0 },
                { label: '20-24h', min: 20, max: 24, wins: 0, total: 0 }
            ];
            
            operations.forEach(op => {
                if (op.entryTime) {
                    try {
                        const hour = parseInt(op.entryTime.split(':')[0], 10);
                        const rango = rangosHorarios.find(r => hour >= r.min && hour < r.max);
                        if (rango) {
                            rango.total++;
                            if (op.pl > 0) rango.wins++;
                        }
                    } catch (e) { /* ignore */ }
                }
            });
            
            const winRates = rangosHorarios.map(r => r.total > 0 ? (r.wins / r.total) * 100 : 0);
            
            const winrateHorarioCtx = document.getElementById('metricas-avanzadas-winrate-horario-chart')?.getContext('2d');
            if (winrateHorarioCtx) {
                metricasAvanzadasChartWinrateHorario = new Chart(winrateHorarioCtx, {
                    type: 'bar',
                    data: {
                        labels: rangosHorarios.map(r => r.label),
                        datasets: [{
                            label: 'Win Rate (%)',
                            data: winRates,
                            backgroundColor: winRates.map(wr => wr >= 50 ? '#00FF00' : '#FF0000')
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { 
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: (context) => `Win Rate: ${context.parsed.y.toFixed(1)}%`
                                }
                            }
                        },
                        scales: {
                            y: { 
                                beginAtZero: true, 
                                max: 100,
                                ticks: { color: '#a0a0a0', callback: (value) => value + '%' }, 
                                grid: { color: 'rgba(255,255,255,0.1)' } 
                            },
                            x: { ticks: { color: '#a0a0a0' }, grid: { display: false } }
                        }
                    }
                });
            }
            
            // ===== NUEVAS MÉTRICAS: ANÁLISIS PSICOLÓGICO =====
            updatePsychologicalMetrics(operations, selectedAccount, displayCurrency);
        }
        
        // Nueva función para Análisis Psicológico
        function updatePsychologicalMetrics(operations, selectedAccount, displayCurrency) {
            // Ordenar operaciones por fecha y hora
            const sortedOps = [...operations].sort((a, b) => {
                const dateA = new Date(a.date + 'T' + (a.entryTime || '00:00'));
                const dateB = new Date(b.date + 'T' + (b.entryTime || '00:00'));
                return dateA - dateB;
            });
            
            // Calcular racha actual
            let currentStreak = 0;
            let currentStreakType = 'N/A';
            for (let i = sortedOps.length - 1; i >= 0; i--) {
                const op = sortedOps[i];
                if (i === sortedOps.length - 1) {
                    currentStreakType = op.result === 'win' ? 'Wins' : 'Losses';
                    currentStreak = 1;
                } else {
                    const prevType = currentStreakType === 'Wins' ? 'win' : 'loss';
                    if (op.result === prevType) {
                        currentStreak++;
                    } else {
                        break;
                    }
                }
            }
            
            // Calcular semanas consecutivas positivas/negativas
            const weeklyPL = {};
            sortedOps.forEach(op => {
                const week = op.date.substring(0, 10).replace(/-/g, ''); // Simple week grouping
                const weekKey = `${op.date.substring(0, 4)}-W${Math.ceil(parseInt(op.date.substring(5, 7)) * 4.33 / 12)}`;
                if (!weeklyPL[weekKey]) weeklyPL[weekKey] = 0;
                weeklyPL[weekKey] += convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency);
            });
            
            const weeks = Object.keys(weeklyPL).sort();
            let maxPositiveWeeks = 0, maxNegativeWeeks = 0;
            let currentPositive = 0, currentNegative = 0;
            weeks.forEach(week => {
                if (weeklyPL[week] > 0) {
                    currentPositive++;
                    currentNegative = 0;
                    if (currentPositive > maxPositiveWeeks) maxPositiveWeeks = currentPositive;
                } else if (weeklyPL[week] < 0) {
                    currentNegative++;
                    currentPositive = 0;
                    if (currentNegative > maxNegativeWeeks) maxNegativeWeeks = currentNegative;
                }
            });
            
            // Calcular índice de overtrading
            const dailyCount = {};
            sortedOps.forEach(op => {
                if (!dailyCount[op.date]) dailyCount[op.date] = 0;
                dailyCount[op.date]++;
            });
            const overtradingDays = Object.values(dailyCount).filter(count => count > 10).length;
            const overtradingIndex = Object.keys(dailyCount).length > 0 ? (overtradingDays / Object.keys(dailyCount).length) * 100 : 0;
            
            // Actualizar UI
            const currentStreakEl = document.getElementById('informe-current-streak');
            if (currentStreakEl) currentStreakEl.textContent = currentStreak;
            
            const currentStreakTypeEl = document.getElementById('informe-current-streak-type');
            if (currentStreakTypeEl) currentStreakTypeEl.textContent = `(${currentStreak} ${currentStreakType} consecutivos)`;
            
            const maxPosWeeksEl = document.getElementById('informe-max-positive-weeks');
            if (maxPosWeeksEl) maxPosWeeksEl.textContent = maxPositiveWeeks;
            
            const maxNegWeeksEl = document.getElementById('informe-max-negative-weeks');
            if (maxNegWeeksEl) maxNegWeeksEl.textContent = maxNegativeWeeks;
            
            const overtradingEl = document.getElementById('informe-overtrading-index');
            if (overtradingEl) overtradingEl.textContent = overtradingIndex.toFixed(1) + '%';
            
            // Gráfica 1: P/L Después de Rachas Ganadoras
            const plAfterWinsCtx = document.getElementById('metricas-avanzadas-pl-after-wins-chart')?.getContext('2d');
            if (plAfterWinsCtx) {
                const plAfterWinStreak = {'1 Win': [], '2 Wins': [], '3 Wins': [], '4+ Wins': []};
                let consecutiveWins = 0;
                
                sortedOps.forEach((op, idx) => {
                    if (idx > 0 && sortedOps[idx-1].result === 'win') {
                        consecutiveWins++;
                    } else {
                        consecutiveWins = 0;
                    }
                    
                    const pl = convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency);
                    if (consecutiveWins === 1) plAfterWinStreak['1 Win'].push(pl);
                    else if (consecutiveWins === 2) plAfterWinStreak['2 Wins'].push(pl);
                    else if (consecutiveWins === 3) plAfterWinStreak['3 Wins'].push(pl);
                    else if (consecutiveWins >= 4) plAfterWinStreak['4+ Wins'].push(pl);
                });
                
                const labels = Object.keys(plAfterWinStreak);
                const avgPL = labels.map(label => {
                    const arr = plAfterWinStreak[label];
                    return arr.length > 0 ? arr.reduce((a,b) => a+b, 0) / arr.length : 0;
                });
                
                metricasAvanzadasChartPlAfterWins = new Chart(plAfterWinsCtx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'P/L Promedio',
                            data: avgPL,
                            backgroundColor: avgPL.map(pl => pl >= 0 ? '#00FF00' : '#FF0000')
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0' } },
                            x: { grid: { display: false }, ticks: { color: '#a0a0a0' } }
                        }
                    }
                });
            }
            
            // Gráfica 2: P/L Después de Rachas Perdedoras
            const plAfterLossesCtx = document.getElementById('metricas-avanzadas-pl-after-losses-chart')?.getContext('2d');
            if (plAfterLossesCtx) {
                const plAfterLossStreak = {'1 Loss': [], '2 Losses': [], '3 Losses': [], '4+ Losses': []};
                let consecutiveLosses = 0;
                
                sortedOps.forEach((op, idx) => {
                    if (idx > 0 && sortedOps[idx-1].result === 'loss') {
                        consecutiveLosses++;
                    } else {
                        consecutiveLosses = 0;
                    }
                    
                    const pl = convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency);
                    if (consecutiveLosses === 1) plAfterLossStreak['1 Loss'].push(pl);
                    else if (consecutiveLosses === 2) plAfterLossStreak['2 Losses'].push(pl);
                    else if (consecutiveLosses === 3) plAfterLossStreak['3 Losses'].push(pl);
                    else if (consecutiveLosses >= 4) plAfterLossStreak['4+ Losses'].push(pl);
                });
                
                const labels = Object.keys(plAfterLossStreak);
                const avgPL = labels.map(label => {
                    const arr = plAfterLossStreak[label];
                    return arr.length > 0 ? arr.reduce((a,b) => a+b, 0) / arr.length : 0;
                });
                
                metricasAvanzadasChartPlAfterLosses = new Chart(plAfterLossesCtx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'P/L Promedio',
                            data: avgPL,
                            backgroundColor: avgPL.map(pl => pl >= 0 ? '#00FF00' : '#FF0000')
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0' } },
                            x: { grid: { display: false }, ticks: { color: '#a0a0a0' } }
                        }
                    }
                });
            }
            
            // Gráfica 3: Revenge Trading Detector
            const revengeTradingCtx = document.getElementById('metricas-avanzadas-revenge-trading-chart')?.getContext('2d');
            if (revengeTradingCtx) {
                const revengeTrades = [];
                const normalTrades = [];
                
                sortedOps.forEach((op, idx) => {
                    if (idx > 0) {
                        const prevOp = sortedOps[idx - 1];
                        if (prevOp.result === 'loss') {
                            const prevTime = window.parseOperationDateTime(prevOp, true);   // usar exitTime
                            const currentTime = window.parseOperationDateTime(op, false);   // usar entryTime
                            const diffMinutes = (currentTime - prevTime) / (1000 * 60);
                            
                            const pl = convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency);
                            if (diffMinutes < 30) {
                                revengeTrades.push(pl);
                            } else {
                                normalTrades.push(pl);
                            }
                        } else {
                            normalTrades.push(convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency));
                        }
                    }
                });
                
                const avgRevenge = revengeTrades.length > 0 ? revengeTrades.reduce((a,b) => a+b, 0) / revengeTrades.length : 0;
                const avgNormal = normalTrades.length > 0 ? normalTrades.reduce((a,b) => a+b, 0) / normalTrades.length : 0;
                
                metricasAvanzadasChartRevenge = new Chart(revengeTradingCtx, {
                    type: 'bar',
                    data: {
                        labels: ['Revenge Trades (<30min)', 'Trades Normales'],
                        datasets: [{
                            label: 'P/L Promedio',
                            data: [avgRevenge, avgNormal],
                            backgroundColor: [
                                avgRevenge >= 0 ? '#00FF00' : '#FF0000',
                                avgNormal >= 0 ? '#00FF00' : '#FF0000'
                            ]
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { 
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: (ctx) => `P/L: $${ctx.parsed.y.toFixed(2)} (${ctx.label === 'Revenge Trades (<30min)' ? revengeTrades.length : normalTrades.length} trades)`
                                }
                            }
                        },
                        scales: {
                            y: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0' } },
                            x: { grid: { display: false }, ticks: { color: '#a0a0a0' } }
                        }
                    }
                });
            }
            
            // Gráfica 4: Overtrading Analysis
            const overtradingCtx = document.getElementById('metricas-avanzadas-overtrading-chart')?.getContext('2d');
            if (overtradingCtx) {
                const tradeRanges = {'1-3': [], '4-6': [], '7-10': [], '>10': []};
                
                Object.entries(dailyCount).forEach(([date, count]) => {
                    const dayPL = sortedOps
                        .filter(op => op.date === date)
                        .reduce((sum, op) => sum + convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency), 0);
                    
                    if (count <= 3) tradeRanges['1-3'].push(dayPL);
                    else if (count <= 6) tradeRanges['4-6'].push(dayPL);
                    else if (count <= 10) tradeRanges['7-10'].push(dayPL);
                    else tradeRanges['>10'].push(dayPL);
                });
                
                const labels = Object.keys(tradeRanges);
                const avgPL = labels.map(label => {
                    const arr = tradeRanges[label];
                    return arr.length > 0 ? arr.reduce((a,b) => a+b, 0) / arr.length : 0;
                });
                
                metricasAvanzadasChartOvertrading = new Chart(overtradingCtx, {
                    type: 'bar',
                    data: {
                        labels: labels.map(l => l + ' trades/día'),
                        datasets: [{
                            label: 'P/L Promedio Diario',
                            data: avgPL,
                            backgroundColor: avgPL.map(pl => pl >= 0 ? '#00FF00' : '#FF0000')
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0' } },
                            x: { grid: { display: false }, ticks: { color: '#a0a0a0' } }
                        }
                    }
                });
            }
        }

        let informeChartPnLDesc = null;
        let informeChartPnLAsc = null;
        let informeChartWLDesc = null;
        let informeChartWLAsc = null;
        let informeChartVolumeSymbol = null;
        let informeChartDailyVolume = null;
        let informeChartLongShortSymbol = null;
        let informeChartWinRateLongShort = null;
        let informeChartWinRateBySymbol = null;
        let informeChartAvgPLBySymbol = null;
        
        // Charts de Tiempo
        let tiempoChartDurationComp = null;
        let tiempoChartHourlyPL = null;
        let tiempoChartDailyPL = null;
        let tiempoChartDurationDist = null;
        let tiempoChartPLByDuration = null;
        let tiempoChartExecutionQuality = null; // NUEVO: Scatter chart
        let tiempoChartExposureComparison = null; // Gráfico de exposición wins vs losses
        let tiempoChartSessionWinRate = null; // Gráfico de win rate por sesión
        
        // Nuevas gráficas de análisis
        let plDistributionChart = null;
        let monthlyPerformanceChart = null;
        
        // NUEVAS MÉTRICAS DE BARRA - Gráficos Chart.js
        let informeLongShortChart = null;
        let informeTradingStylesChart = null;
        let informePLRangeChart = null;
        let informeVolumeRangeChart = null;
        let informeSessionsChart = null;
        let informeWeekdayChart = null;
        let informeCommissionsChart = null;
        let informeRRChart = null;

        // Función para destruir todos los gráficos de Informe
        function destroyInformeCharts() {
            if (informeLongShortChart) { informeLongShortChart.destroy(); informeLongShortChart = null; }
            if (informeTradingStylesChart) { informeTradingStylesChart.destroy(); informeTradingStylesChart = null; }
            if (informePLRangeChart) { informePLRangeChart.destroy(); informePLRangeChart = null; }
            if (informeVolumeRangeChart) { informeVolumeRangeChart.destroy(); informeVolumeRangeChart = null; }
            if (informeSessionsChart) { informeSessionsChart.destroy(); informeSessionsChart = null; }
            if (informeWeekdayChart) { informeWeekdayChart.destroy(); informeWeekdayChart = null; }
            if (informeCommissionsChart) { informeCommissionsChart.destroy(); informeCommissionsChart = null; }
            if (informeRRChart) { informeRRChart.destroy(); informeRRChart = null; }
            if (plDistributionChart) { plDistributionChart.destroy(); plDistributionChart = null; }
            if (monthlyPerformanceChart) { monthlyPerformanceChart.destroy(); monthlyPerformanceChart = null; }
        }

        function refreshInforme() {
            console.log('[Informe] 🔄 Refreshing...');
            
            // Destruir todos los gráficos existentes antes de recrear
            destroyInformeCharts();
            console.log("--- Refreshing Informe ---");

            const accountSelect = document.getElementById('informe-account-select');
            const currencySelect = document.getElementById('informe-currency-select');
            
            if (!accountSelect || !currencySelect) {
                console.error('[Informe] ❌ Account or currency select not found!');
                return;
            }
            
            const selectedAccount = accountSelect.value;
            const displayCurrency = currencySelect.value;

            let operations = applyDateFilterToData(DB.operations);
            let finances = applyDateFilterToData(DB.finances);

            console.log('🔍 Informe - Total operations before filter:', operations.length);
            console.log('🔍 Informe - Selected account:', selectedAccount);

            if (selectedAccount !== 'all') {
                operations = operations.filter(op => op.accountId === selectedAccount);
                console.log('🔍 Informe - Operations after account filter:', operations.length);
            }
            operations = applyInformeFilters(operations);
            console.log('🔍 Informe - Operations after additional filters:', operations.length);

            // Solo operaciones principales para métricas
            const mainOps = operations.filter(op => !op.parentId || op.parentId === '' || op.parentId === null);
            console.log('🔍 Informe - Main operations (no parents):', mainOps.length);

            // Calcular métricas solo con principales
            const basicMetrics = calculateMetrics(operations, selectedAccount);
            const advancedMetrics = calculateAdvancedMetrics(operations, selectedAccount);
            const extraMetrics = calculateExtraAnalytics(operations, selectedAccount);

            console.log('[Informe] 📊 Metrics calculated:');
            console.log('  - Basic PL:', basicMetrics.totalWin + basicMetrics.totalLoss);
            console.log('  - Advanced avgPLPerTrade:', advancedMetrics.avgPLPerTrade);
            console.log('  - Advanced largestWin:', advancedMetrics.largestWin);
            console.log('  - Advanced avgPLPerDay:', advancedMetrics.avgPLPerDay);

            // Calcular depósitos y retiros para totalMonetaryTransactions
            const totalDeposits = finances.filter(f => f.amount > 0).reduce((sum, f) => sum + convertCurrency(f.amount, f.currency, DB.settings.defaultCurrency), 0);
            const totalWithdrawals = finances.filter(f => f.amount < 0).reduce((sum, f) => sum + convertCurrency(f.amount, f.currency, DB.settings.defaultCurrency), 0);
            const totalMonetaryTransactions = totalDeposits + totalWithdrawals;

            const updateMetric = (id, value, currency = DB.settings.defaultCurrency, isPercent = false) => {
                const el = document.getElementById(id);
                if (!el) return;
                // Handle null/undefined values
                if (value === null || value === undefined || isNaN(value)) {
                    value = 0;
                }
                let formattedValue = isPercent ? `${value.toFixed(2)}%` : formatCurrency(value, currency, displayCurrency);
                el.textContent = formattedValue;
                el.classList.remove('text-positive', 'text-negative', 'text-neutral');
                if (value > 0) {
                    el.classList.add('text-positive');
                } else if (value < 0) {
                    el.classList.add('text-negative');
                } else {
                    el.classList.add('text-neutral');
                }
            };

            // Métricas principales
            const grossPLInforme = basicMetrics.totalWin + basicMetrics.totalLoss;
            const netPLInforme = grossPLInforme - basicMetrics.totalFees;
            updateMetric('informe-total-pl', grossPLInforme);
            updateMetric('informe-realized-pl', netPLInforme);
            updateMetric('informe-unrealized-pl', 0);
            updateMetric('informe-only-win-pl', basicMetrics.totalWin);
            updateMetric('informe-only-loss-pl', basicMetrics.totalLoss);
            updateMetric('informe-total-account-value', netPLInforme + totalMonetaryTransactions);
            updateMetric('informe-total-monetary-transactions', totalMonetaryTransactions);
            updateMetric('informe-total-deposits', totalDeposits);
            updateMetric('informe-total-withdrawals', totalWithdrawals);

            // Promedios y porcentajes
            updateMetric('informe-avg-pl-trade', advancedMetrics.avgPLPerTrade);
            updateMetric('informe-avg-pl-percentage', advancedMetrics.avgPLPercentage, DB.settings.defaultCurrency, true);
            updateMetric('informe-avg-pl-day', advancedMetrics.avgPLPerDay);
            updateMetric('informe-avg-pl-month', advancedMetrics.avgPLPerMonth);
            updateMetric('informe-avg-pl-year', advancedMetrics.avgPLPerYear);

            updateMetric('informe-avg-win-pl-trade', advancedMetrics.avgWin);
            updateMetric('informe-avg-win-pl-day', advancedMetrics.avgWinPerDay);
            updateMetric('informe-avg-win-pl-month', advancedMetrics.avgWinPerMonth);
            updateMetric('informe-avg-win-pl-year', advancedMetrics.avgWinPerYear);

            updateMetric('informe-avg-loss-pl-trade', advancedMetrics.avgLoss);
            updateMetric('informe-avg-loss-pl-day', advancedMetrics.avgLossPerDay);
            updateMetric('informe-avg-loss-pl-month', advancedMetrics.avgLossPerMonth);
            updateMetric('informe-avg-loss-pl-year', advancedMetrics.avgLossPerYear);

            updateMetric('informe-avg-win-pl-percentage', advancedMetrics.avgWinPercentage, DB.settings.defaultCurrency, true);
            updateMetric('informe-total-win-pl-percentage', advancedMetrics.totalWinPercentage, DB.settings.defaultCurrency, true);
            updateMetric('informe-avg-loss-pl-percentage', advancedMetrics.avgLossPercentage, DB.settings.defaultCurrency, true);
            updateMetric('informe-total-loss-pl-percentage', advancedMetrics.totalLossPercentage, DB.settings.defaultCurrency, true);

            updateMetric('informe-best-win-pl-trade', advancedMetrics.largestWin);
            updateMetric('informe-worst-loss-pl-trade', advancedMetrics.largestLoss);
            updateMetric('informe-best-win-pl-day', advancedMetrics.largestWinPerDay);
            updateMetric('informe-worst-loss-pl-day', advancedMetrics.largestLossPerDay);

            // Métricas de día, semana, mes, año
            updateMetric('informe-last-day-pl', advancedMetrics.lastDayPL);
            updateMetric('informe-last-week-pl', advancedMetrics.lastWeekPL);
            updateMetric('informe-last-month-pl', advancedMetrics.lastMonthPL);
            updateMetric('informe-last-year-pl', advancedMetrics.lastYearPL);

            // Nuevas métricas profesionales avanzadas
            const professionalMetrics = calculateProfessionalMetrics(operations, selectedAccount);
            
            updateMetric('informe-expectancy-ratio', professionalMetrics.expectancyRatio);
            updateMetric('informe-kelly-criterion', professionalMetrics.kellyCriterion, DB.settings.defaultCurrency, true);
            
            const sharpeEl = document.getElementById('informe-sharpe-ratio');
            if (sharpeEl) {
                sharpeEl.textContent = professionalMetrics.sharpeRatio.toFixed(2);
                sharpeEl.classList.remove('text-positive', 'text-negative', 'text-neutral');
                sharpeEl.classList.add(professionalMetrics.sharpeRatio > 1 ? 'text-positive' : 'text-white');
            }
            
            const sortinoEl = document.getElementById('informe-sortino-ratio');
            if (sortinoEl) {
                sortinoEl.textContent = professionalMetrics.sortinoRatio.toFixed(2);
                sortinoEl.classList.remove('text-positive', 'text-negative', 'text-neutral');
                sortinoEl.classList.add(professionalMetrics.sortinoRatio > 1 ? 'text-positive' : 'text-white');
            }
            
            const calmarEl = document.getElementById('informe-calmar-ratio');
            if (calmarEl) {
                calmarEl.textContent = professionalMetrics.calmarRatio.toFixed(2);
                calmarEl.classList.remove('text-positive', 'text-negative', 'text-neutral');
                calmarEl.classList.add(professionalMetrics.calmarRatio > 3 ? 'text-positive' : 'text-white');
            }
            
            updateMetric('informe-recovery-factor', professionalMetrics.recoveryFactor);
            updateMetric('informe-risk-of-ruin', professionalMetrics.riskOfRuin, DB.settings.defaultCurrency, true);
            
            const zScoreEl = document.getElementById('informe-z-score');
            if (zScoreEl) {
                zScoreEl.textContent = professionalMetrics.zScore.toFixed(2);
                zScoreEl.classList.remove('text-positive', 'text-negative', 'text-neutral');
                const absZ = Math.abs(professionalMetrics.zScore);
                zScoreEl.classList.add(absZ < 1.96 ? 'text-positive' : 'text-yellow');
            }
            
            updateMetric('informe-avg-mae', professionalMetrics.avgMAE);
            updateMetric('informe-avg-mfe', professionalMetrics.avgMFE);
            
            const maxWinStreakEl = document.getElementById('informe-max-win-streak');
            if (maxWinStreakEl) {
                maxWinStreakEl.textContent = professionalMetrics.maxWinStreak;
                maxWinStreakEl.classList.add('text-positive');
            }
            
            const maxLossStreakEl = document.getElementById('informe-max-loss-streak');
            if (maxLossStreakEl) {
                maxLossStreakEl.textContent = professionalMetrics.maxLossStreak;
                maxLossStreakEl.classList.add('text-negative');
            }
            
            const consistencyEl = document.getElementById('informe-consistency-score');
            if (consistencyEl) {
                consistencyEl.textContent = professionalMetrics.consistencyScore;
                consistencyEl.classList.remove('text-positive', 'text-negative', 'text-primary');
                consistencyEl.classList.add(professionalMetrics.consistencyScore >= 70 ? 'text-positive' : professionalMetrics.consistencyScore >= 50 ? 'text-primary' : 'text-yellow');
            }
            
            const payoffEl = document.getElementById('informe-payoff-ratio');
            if (payoffEl) {
                payoffEl.textContent = professionalMetrics.payoffRatio.toFixed(2);
                payoffEl.classList.remove('text-positive', 'text-negative', 'text-neutral');
                payoffEl.classList.add(professionalMetrics.payoffRatio > 1 ? 'text-positive' : 'text-white');
            }
            
            const tradingDaysEl = document.getElementById('informe-total-trading-days');
            if (tradingDaysEl) {
                tradingDaysEl.textContent = professionalMetrics.totalTradingDays;
                tradingDaysEl.classList.add('text-white');
            }
            
            const rMultipleEl = document.getElementById('informe-avg-r-multiple');
            if (rMultipleEl) {
                rMultipleEl.textContent = professionalMetrics.avgRMultiple.toFixed(2) + 'R';
                rMultipleEl.classList.remove('text-positive', 'text-negative', 'text-neutral');
                rMultipleEl.classList.add(professionalMetrics.avgRMultiple > 0 ? 'text-positive' : 'text-negative');
            }

            // === ACTUALIZAR BARRAS DE DISTRIBUCIÓN WIN/LOSS ===
            console.log('📊 Distribución - Total mainOps:', mainOps.length);
            console.log('📊 Distribución - Selected Account:', selectedAccount);
            console.log('📊 Distribución - Muestra de mainOps:', mainOps.slice(0, 3).map(op => ({
                id: op.id,
                accountId: op.accountId,
                pl: op.pl,
                result: op.result,
                instrument: op.instrument
            })));
            
            const winOps = mainOps.filter(op => op.result === 'win');
            const lossOps = mainOps.filter(op => op.result === 'loss');
            const breakevenOps = mainOps.filter(op => op.result === 'breakeven' || (!op.result && op.pl === 0));
            const totalOps = mainOps.length;
            
            console.log('📊 Wins:', winOps.length, 'Losses:', lossOps.length, 'Breakeven:', breakevenOps.length);
            console.log('📊 Operaciones sin result:', mainOps.filter(op => !op.result).length);
            
            const winCount = winOps.length;
            const lossCount = lossOps.length;
            const breakevenCount = breakevenOps.length;
            
            const winPercentage = totalOps > 0 ? (winCount / totalOps * 100) : 0;
            const lossPercentage = totalOps > 0 ? (lossCount / totalOps * 100) : 0;
            const breakevenPercentage = totalOps > 0 ? (breakevenCount / totalOps * 100) : 0;
            
            const totalWinAmount = winOps.reduce((sum, op) => sum + convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency), 0);
            const totalLossAmount = lossOps.reduce((sum, op) => sum + convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency), 0);
            
            // Actualizar contadores y barras
            const winCountBarEl = document.getElementById('informe-win-count-bar');
            if (winCountBarEl) winCountBarEl.textContent = `${winCount} (${winPercentage.toFixed(1)}%)`;
            
            const lossCountBarEl = document.getElementById('informe-loss-count-bar');
            if (lossCountBarEl) lossCountBarEl.textContent = `${lossCount} (${lossPercentage.toFixed(1)}%)`;
            
            const breakevenCountBarEl = document.getElementById('informe-breakeven-count-bar');
            if (breakevenCountBarEl) breakevenCountBarEl.textContent = `${breakevenCount} (${breakevenPercentage.toFixed(1)}%)`;
            
            // Actualizar anchos de barras
            const winBarEl = document.getElementById('informe-win-bar');
            if (winBarEl) {
                winBarEl.style.width = `${winPercentage}%`;
                const winAmountEl = document.getElementById('informe-win-amount-bar');
                if (winAmountEl) winAmountEl.textContent = formatCurrency(totalWinAmount, DB.settings.defaultCurrency, displayCurrency);
            }
            
            const lossBarEl = document.getElementById('informe-loss-bar');
            if (lossBarEl) {
                lossBarEl.style.width = `${lossPercentage}%`;
                const lossAmountEl = document.getElementById('informe-loss-amount-bar');
                if (lossAmountEl) lossAmountEl.textContent = formatCurrency(totalLossAmount, DB.settings.defaultCurrency, displayCurrency);
            }
            
            const breakevenBarEl = document.getElementById('informe-breakeven-bar');
            if (breakevenBarEl) {
                breakevenBarEl.style.width = `${breakevenPercentage}%`;
                const breakevenCountText = document.getElementById('informe-breakeven-count-text');
                if (breakevenCountText) breakevenCountText.textContent = breakevenCount;
            }
            
            // Actualizar métricas complementarias
            const winLossRatio = lossCount > 0 ? winCount / lossCount : winCount;
            const winLossRatioEl = document.getElementById('informe-win-loss-ratio-bar');
            if (winLossRatioEl) {
                winLossRatioEl.textContent = winLossRatio.toFixed(2);
                winLossRatioEl.classList.remove('text-positive', 'text-negative', 'text-neutral', 'text-primary', 'text-white');
                winLossRatioEl.classList.add(winLossRatio >= 1 ? 'text-positive' : 'text-negative');
            }
            
            // Expectativa matemática: (Win% × AvgWin) - (Loss% × AvgLoss)
            const avgWinAmount = winCount > 0 ? totalWinAmount / winCount : 0;
            const avgLossAmount = lossCount > 0 ? Math.abs(totalLossAmount / lossCount) : 0;
            const mathExpectancy = (winPercentage / 100 * avgWinAmount) - (lossPercentage / 100 * avgLossAmount);
            
            const mathExpectancyEl = document.getElementById('informe-math-expectancy-bar');
            if (mathExpectancyEl) {
                mathExpectancyEl.textContent = formatCurrency(mathExpectancy, DB.settings.defaultCurrency, displayCurrency);
                mathExpectancyEl.classList.remove('text-positive', 'text-negative', 'text-neutral');
                mathExpectancyEl.classList.add(mathExpectancy > 0 ? 'text-positive' : mathExpectancy < 0 ? 'text-negative' : 'text-neutral');
            }

            const symbolPerformance = {};
            operations.forEach(op => {
                if (!op.instrument) return;
                const symbol = op.instrument.toUpperCase();
                if (!symbolPerformance[symbol]) {
                    symbolPerformance[symbol] = { pnl: 0, wins: 0, losses: 0, trades: 0, volume: 0 };
                }
                symbolPerformance[symbol].pnl += convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency);
                symbolPerformance[symbol].trades++;
                symbolPerformance[symbol].volume += (op.volume || 0);
                if (op.result === 'win') {
                    symbolPerformance[symbol].wins++;
                } else if (op.result === 'loss') {
                    symbolPerformance[symbol].losses++;
                }
            });

            const sortedByPnL = Object.entries(symbolPerformance).sort(([,a],[,b]) => b.pnl - a.pnl);
            const sortedByWL = Object.entries(symbolPerformance).sort(([,a],[,b]) => (b.wins - b.losses) - (a.wins - a.losses));
            const sortedByVolume = Object.entries(symbolPerformance).sort(([,a],[,b]) => b.volume - a.volume);

            updateInformeChart('informe-chart-pnl-desc', sortedByPnL.slice(0, 10), 'pnl', 'PnL por Símbolo (Top 10 Ganadores)');
            updateInformeChart('informe-chart-pnl-asc', sortedByPnL.slice(-10).reverse(), 'pnl', 'PnL por Símbolo (Top 10 Perdedores)');
            updateInformeWLChart('informe-chart-wl-desc', sortedByWL.slice(0, 10), 'Wins/Losses por Símbolo (Mejor Ratio)');
            updateInformeWLChart('informe-chart-wl-asc', sortedByWL.slice(-10).reverse(), 'Wins/Losses por Símbolo (Peor Ratio)');
            updateInformeVolumeChart('informe-chart-volume-symbol', sortedByVolume.slice(0, 10), 'Volumen por Símbolo');
            
            // Agregado por fecha para Daily Volume
            const dailyVolume = {};
            operations.forEach(op => {
                const date = op.date;
                if (!dailyVolume[date]) {
                    dailyVolume[date] = 0;
                }
                dailyVolume[date] += (op.volume || 0);
            });
            
            const sortedByDate = Object.entries(dailyVolume).sort(([a], [b]) => new Date(a) - new Date(b));
            updateInformeDailyVolumeChart('informe-chart-daily-volume', sortedByDate, 'Volumen Diario');
            
            // ============ NUEVAS GRÁFICAS: LONG VS SHORT ============
            
            // Calcular P&L Long vs Short por Símbolo (Todos los símbolos)
            const symbolLongShortPerf = {};
            
            operations.forEach(op => {
                if (!op.instrument) return;
                const symbol = op.instrument.toUpperCase();
                const opType = (op.type || op.side || '').toLowerCase().trim();
                const isLong = opType === 'long' || opType === 'buy' || opType === 'compra';
                const isShort = opType === 'short' || opType === 'sell' || opType === 'venta';
                
                if (!symbolLongShortPerf[symbol]) {
                    symbolLongShortPerf[symbol] = { longPL: 0, shortPL: 0, longCount: 0, shortCount: 0 };
                }
                
                const pl = convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency);
                
                if (isLong) {
                    symbolLongShortPerf[symbol].longPL += pl;
                    symbolLongShortPerf[symbol].longCount++;
                } else if (isShort) {
                    symbolLongShortPerf[symbol].shortPL += pl;
                    symbolLongShortPerf[symbol].shortCount++;
                }
            });
            
            // Ordenar por volumen total de operaciones - TODOS LOS SÍMBOLOS
            const sortedSymbolsLS = Object.entries(symbolLongShortPerf)
                .sort(([,a], [,b]) => (b.longCount + b.shortCount) - (a.longCount + a.shortCount));
            
            updateInformeLongShortSymbolChart('informe-chart-long-short-symbol', sortedSymbolsLS);
            
            // Calcular Win Rate Long vs Short Global
            const longOpsForWR = operations.filter(op => {
                const opType = (op.type || op.side || '').toLowerCase().trim();
                return opType === 'long' || opType === 'buy' || opType === 'compra';
            });
            const shortOpsForWR = operations.filter(op => {
                const opType = (op.type || op.side || '').toLowerCase().trim();
                return opType === 'short' || opType === 'sell' || opType === 'venta';
            });
            const longWins = longOpsForWR.filter(op => op.result === 'win' || (!op.result && op.pl > 0)).length;
            const shortWins = shortOpsForWR.filter(op => op.result === 'win' || (!op.result && op.pl > 0)).length;
            const longWinRate = longOpsForWR.length > 0 ? (longWins / longOpsForWR.length) * 100 : 0;
            const shortWinRate = shortOpsForWR.length > 0 ? (shortWins / shortOpsForWR.length) * 100 : 0;
            
            updateInformeWinRateLongShortChart('informe-chart-winrate-long-short', longWinRate, shortWinRate, longOpsForWR.length, shortOpsForWR.length);
            
            // NUEVA GRÁFICA: Win Rate por Símbolo (Long vs Short)
            const symbolWinRateData = {};
            operations.forEach(op => {
                if (!op.instrument) return;
                const symbol = op.instrument.toUpperCase();
                const opType = (op.type || op.side || '').toLowerCase().trim();
                const isLong = opType === 'long' || opType === 'buy' || opType === 'compra';
                const isShort = opType === 'short' || opType === 'sell' || opType === 'venta';
                const isWin = op.result === 'win' || (!op.result && op.pl > 0);
                
                if (!symbolWinRateData[symbol]) {
                    symbolWinRateData[symbol] = { longWins: 0, longTotal: 0, shortWins: 0, shortTotal: 0 };
                }
                
                if (isLong) {
                    symbolWinRateData[symbol].longTotal++;
                    if (isWin) symbolWinRateData[symbol].longWins++;
                } else if (isShort) {
                    symbolWinRateData[symbol].shortTotal++;
                    if (isWin) symbolWinRateData[symbol].shortWins++;
                }
            });
            
            const sortedSymbolsWR = Object.entries(symbolWinRateData)
                .filter(([, data]) => data.longTotal + data.shortTotal >= 1) // Al menos 1 trade
                .sort(([,a], [,b]) => (b.longTotal + b.shortTotal) - (a.longTotal + a.shortTotal))
                .map(([symbol, data]) => [symbol, {
                    longWR: data.longTotal > 0 ? (data.longWins / data.longTotal) * 100 : 0,
                    shortWR: data.shortTotal > 0 ? (data.shortWins / data.shortTotal) * 100 : 0,
                    longCount: data.longTotal,
                    shortCount: data.shortTotal
                }]);
            
            updateInformeWinRateBySymbolChart('informe-chart-winrate-by-symbol', sortedSymbolsWR);
            
            // NUEVA GRÁFICA: Promedio P&L por Trade por Símbolo (Long vs Short)
            const symbolAvgPLData = {};
            operations.forEach(op => {
                if (!op.instrument) return;
                const symbol = op.instrument.toUpperCase();
                const opType = (op.type || op.side || '').toLowerCase().trim();
                const isLong = opType === 'long' || opType === 'buy' || opType === 'compra';
                const isShort = opType === 'short' || opType === 'sell' || opType === 'venta';
                const pl = convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency);
                
                if (!symbolAvgPLData[symbol]) {
                    symbolAvgPLData[symbol] = { longPL: 0, longCount: 0, shortPL: 0, shortCount: 0 };
                }
                
                if (isLong) {
                    symbolAvgPLData[symbol].longPL += pl;
                    symbolAvgPLData[symbol].longCount++;
                } else if (isShort) {
                    symbolAvgPLData[symbol].shortPL += pl;
                    symbolAvgPLData[symbol].shortCount++;
                }
            });
            
            const sortedSymbolsAvgPL = Object.entries(symbolAvgPLData)
                .filter(([, data]) => data.longCount + data.shortCount >= 1) // Al menos 1 trade
                .sort(([,a], [,b]) => (b.longCount + b.shortCount) - (a.longCount + a.shortCount))
                .map(([symbol, data]) => [symbol, {
                    longAvg: data.longCount > 0 ? data.longPL / data.longCount : 0,
                    shortAvg: data.shortCount > 0 ? data.shortPL / data.shortCount : 0,
                    longCount: data.longCount,
                    shortCount: data.shortCount
                }]);
            
            updateInformeAvgPLBySymbolChart('informe-chart-avgpl-by-symbol', sortedSymbolsAvgPL);
            
            // ============ NUEVAS MÉTRICAS DE BARRA - GRÁFICOS CHART.JS ============
            
            // MÉTRICA 3: Distribución Long/Short
            const longOps = mainOps.filter(op => {
                const opType = (op.type || op.side || '').toLowerCase().trim();
                return opType === 'long' || opType === 'buy' || opType === 'compra';
            });
            const shortOps = mainOps.filter(op => {
                const opType = (op.type || op.side || '').toLowerCase().trim();
                return opType === 'short' || opType === 'sell' || opType === 'venta';
            });
            const longPL = longOps.reduce((sum, op) => sum + convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency), 0);
            const shortPL = shortOps.reduce((sum, op) => sum + convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency), 0);
            
            console.log(`[Long/Short] Total operations: ${mainOps.length}`);
            console.log(`[Long/Short] Long: ${longOps.length} trades, P/L: $${longPL.toFixed(2)}`);
            console.log(`[Long/Short] Short: ${shortOps.length} trades, P/L: $${shortPL.toFixed(2)}`);
            if (mainOps.length > 0) {
                console.log(`[Long/Short] Sample op.type:`, mainOps[0].type, 'op.side:', mainOps[0].side);
            }
            updateLongShortChart(longOps.length, shortOps.length, longPL, shortPL, displayCurrency);
            
            // MÉTRICA 3b: Trading Styles por duración
            const scalpingOps = mainOps.filter(op => (op.duration_minutes || 0) < 15);
            const dayTradingOps = mainOps.filter(op => {
                const dur = op.duration_minutes || 0;
                return dur >= 15 && dur < 480;
            });
            const swingOps = mainOps.filter(op => (op.duration_minutes || 0) >= 480);
            
            console.log(`[Trading Styles] Scalping: ${scalpingOps.length}, Day: ${dayTradingOps.length}, Swing: ${swingOps.length}, Total mainOps: ${mainOps.length}`);
            updateTradingStylesChart(scalpingOps.length, dayTradingOps.length, swingOps.length);
            
            // MÉTRICA 1: Distribución de P/L por Rango
            const plRanges = {
                'Pérdidas Grandes\n(< -$500)': mainOps.filter(op => convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency) < -500).length,
                'Pérdidas Medianas\n(-$500 a -$200)': mainOps.filter(op => {
                    const pl = convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency);
                    return pl >= -500 && pl < -200;
                }).length,
                'Pérdidas Pequeñas\n(-$200 a -$50)': mainOps.filter(op => {
                    const pl = convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency);
                    return pl >= -200 && pl < -50;
                }).length,
                'Pequeñas Ganancias\n($50 a $200)': mainOps.filter(op => {
                    const pl = convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency);
                    return pl >= 50 && pl < 200;
                }).length,
                'Ganancias Medianas\n($200 a $500)': mainOps.filter(op => {
                    const pl = convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency);
                    return pl >= 200 && pl < 500;
                }).length,
                'Ganancias Grandes\n(> $500)': mainOps.filter(op => convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency) >= 500).length
            };
            
            updatePLRangeChart(plRanges);
            
            // MÉTRICA 2: Distribución de Volumen por Rango
            const volRanges = {
                'Micro Lotes\n(0.01-0.1)': mainOps.filter(op => (op.volume || 0) >= 0.01 && (op.volume || 0) < 0.1).length,
                'Lotes Pequeños\n(0.1-0.5)': mainOps.filter(op => (op.volume || 0) >= 0.1 && (op.volume || 0) < 0.5).length,
                'Lotes Medianos\n(0.5-1.0)': mainOps.filter(op => (op.volume || 0) >= 0.5 && (op.volume || 0) < 1.0).length,
                'Lotes Grandes\n(1.0-5.0)': mainOps.filter(op => (op.volume || 0) >= 1.0 && (op.volume || 0) < 5.0).length,
                'Lotes Muy Grandes\n(> 5.0)': mainOps.filter(op => (op.volume || 0) >= 5.0).length
            };
            
            updateVolumeRangeChart(volRanges);
            
            // MÉTRICA 4: Distribución de Sesiones de Trading
            const sessions = {
                asian: { ops: [], pl: 0 },
                european: { ops: [], pl: 0 },
                american: { ops: [], pl: 0 }
            };
            
            mainOps.forEach(op => {
                // Intentar obtener la hora de entry o de date
                let hour = null;
                if (op.entry) {
                    const entryDate = new Date(op.entry);
                    if (!isNaN(entryDate.getTime())) {
                        hour = entryDate.getUTCHours();
                    }
                }
                // Si no hay entry válida, intentar con date
                if (hour === null && op.date) {
                    // Si solo hay fecha sin hora, usar la fecha + hora del timestamp si existe
                    if (op.timestamp) {
                        const tsDate = new Date(op.timestamp);
                        if (!isNaN(tsDate.getTime())) {
                            hour = tsDate.getUTCHours();
                        }
                    }
                }
                
                // Si no tenemos hora, saltar esta operación
                if (hour === null) return;
                
                const pl = convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency);
                if (hour >= 23 || hour < 8) {
                    sessions.asian.ops.push(op);
                    sessions.asian.pl += pl;
                } else if (hour >= 8 && hour < 16) {
                    sessions.european.ops.push(op);
                    sessions.european.pl += pl;
                } else {
                    sessions.american.ops.push(op);
                    sessions.american.pl += pl;
                }
            });
            
            updateSessionsChart(sessions, displayCurrency);
            
            // MÉTRICA 7: Distribución por día de la semana
            const weekdays = {
                'Lunes': { ops: [], pl: 0 },
                'Martes': { ops: [], pl: 0 },
                'Miércoles': { ops: [], pl: 0 },
                'Jueves': { ops: [], pl: 0 },
                'Viernes': { ops: [], pl: 0 }
            };
            
            const dayMap = ['Domingo', 'Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sábado'];
            mainOps.forEach(op => {
                // Intentar obtener el día de entry o date
                let dayIndex = null;
                if (op.entry) {
                    const entryDate = new Date(op.entry);
                    if (!isNaN(entryDate.getTime())) {
                        dayIndex = entryDate.getDay();
                    }
                }
                // Si no hay entry válida, usar date
                if (dayIndex === null && op.date) {
                    const dateObj = new Date(op.date + 'T00:00:00Z');
                    if (!isNaN(dateObj.getTime())) {
                        dayIndex = dateObj.getUTCDay();
                    }
                }
                
                // Si no tenemos día válido, saltar
                if (dayIndex === null) return;
                
                const dayName = dayMap[dayIndex];
                if (weekdays[dayName]) {
                    weekdays[dayName].ops.push(op);
                    weekdays[dayName].pl += convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency);
                }
            });
            
            updateWeekdayChart(weekdays, displayCurrency);
            
            // MÉTRICA 5: Distribución de Comisiones
            const commRanges = {
                'Muy Bajas\n($0-$5)': mainOps.filter(op => {
                    const c = Math.abs(op.fee || op.fees || 0);
                    return c < 5;
                }).length,
                'Bajas\n($5-$20)': mainOps.filter(op => {
                    const c = Math.abs(op.fee || op.fees || 0);
                    return c >= 5 && c < 20;
                }).length,
                'Medianas\n($20-$50)': mainOps.filter(op => {
                    const c = Math.abs(op.fee || op.fees || 0);
                    return c >= 20 && c < 50;
                }).length,
                'Altas\n($50-$100)': mainOps.filter(op => {
                    const c = Math.abs(op.fee || op.fees || 0);
                    return c >= 50 && c < 100;
                }).length,
                'Muy Altas\n(> $100)': mainOps.filter(op => Math.abs(op.fee || op.fees || 0) >= 100).length
            };
            
            updateCommissionsChart(commRanges);
            
            // MÉTRICA 6: Distribución de R:R
            const rrRanges = {
                'Desfavorable\n(< 1:1)': mainOps.filter(op => (op.risk_reward_ratio || 0) < 1).length,
                'Conservador\n(1:1 a 1:1.5)': mainOps.filter(op => {
                    const rr = op.risk_reward_ratio || 0;
                    return rr >= 1 && rr < 1.5;
                }).length,
                'Equilibrado\n(1:1.5 a 1:2)': mainOps.filter(op => {
                    const rr = op.risk_reward_ratio || 0;
                    return rr >= 1.5 && rr < 2;
                }).length,
                'Favorable\n(1:2 a 1:3)': mainOps.filter(op => {
                    const rr = op.risk_reward_ratio || 0;
                    return rr >= 2 && rr < 3;
                }).length,
                'Excelente\n(> 1:3)': mainOps.filter(op => (op.risk_reward_ratio || 0) >= 3).length
            };
            
            updateRRChart(rrRanges);
            
            // ============ FIN NUEVAS MÉTRICAS DE BARRA ============
            
            console.log(`📊 Calling chart functions with ${mainOps.length} mainOps`);
            // Nuevas gráficas de análisis (usando mainOps para excluir parciales)
            updatePLDistributionHistogram(mainOps, displayCurrency);
            updateMonthlyPerformanceChart(mainOps, displayCurrency);
            
            // Refrescar gráficos de la pestaña Gráficos si está activa o si existen los canvas
            const graficosContent = document.getElementById('informe-graficos-content');
            console.log('[Graficos] Contenedor encontrado:', !!graficosContent);
            console.log('[Graficos] Función disponible:', typeof window.refreshGraficosCharts);
            
            if (graficosContent) {
                if (typeof window.refreshGraficosCharts === 'function') {
                    console.log('[Graficos] ✅ Llamando a refreshGraficosCharts...');
                    window.refreshGraficosCharts();
                } else {
                    console.warn('[Graficos] ⚠️ refreshGraficosCharts no está definida aún');
                }
            }
        }

        function updateInformeVolumeChart(canvasId, data, label) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            if (!ctx) return;

            if (informeChartVolumeSymbol) {
                informeChartVolumeSymbol.destroy();
            }

            const chart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: data.map(item => item[0]),
                    datasets: [{
                        label: label,
                        data: data.map(item => item[1].volume),
                        backgroundColor: 'rgba(54, 162, 235, 0.7)',
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        x: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0' } },
                        y: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0' } }
                    }
                }
            });

            informeChartVolumeSymbol = chart;
        }

        function updateInformeDailyVolumeChart(canvasId, data, label) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            if (!ctx) return;

            if (informeChartDailyVolume) {
                informeChartDailyVolume.destroy();
            }

            const chart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: data.map(item => item[0]),
                    datasets: [{
                        label: label,
                        data: data.map(item => item[1]),
                        backgroundColor: '#00FF00',
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        x: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0' } },
                        y: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0' } }
                    }
                }
            });

            informeChartDailyVolume = chart;
        }
        
        // ============ FUNCIONES DE GRÁFICOS DE DISTRIBUCIÓN ============
        
        function updateLongShortChart(longCount, shortCount, longPL, shortPL, displayCurrency) {
            const canvas = document.getElementById('informe-long-short-chart');
            if (!canvas) {
                console.warn('[Long/Short] Canvas not found');
                return;
            }
            const ctx = canvas.getContext('2d');
            if (!ctx) {
                console.warn('[Long/Short] Could not get context');
                return;
            }
            
            // Destruir gráfico anterior
            if (informeLongShortChart) {
                informeLongShortChart.destroy();
                informeLongShortChart = null;
            }
            
            const currSymbol = displayCurrency === 'EUR' ? '€' : displayCurrency === 'USD' ? '$' : displayCurrency;
            const totalCount = longCount + shortCount;
            
            // Verificar que hay datos
            if (totalCount === 0) {
                console.log('No data for Long/Short chart');
                // Mostrar gráfico vacío
                informeLongShortChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: ['Long', 'Short', 'Total'],
                        datasets: [{
                            label: 'Cantidad de Trades',
                            data: [0, 0, 0],
                            backgroundColor: ['rgba(156, 163, 175, 0.5)', 'rgba(156, 163, 175, 0.5)', 'rgba(156, 163, 175, 0.5)']
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: { beginAtZero: true, grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0' } },
                            x: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0' } }
                        }
                    }
                });
                return;
            }
            
            console.log(`Creating Long/Short chart: Long=${longCount}, Short=${shortCount}, Total=${totalCount}`);
            
            // Colores: Verde fluorescente para Long, Rojo para Short, Azul para Total
            informeLongShortChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['Long (Compras)', 'Short (Ventas)', 'Total'],
                    datasets: [{
                        label: 'Cantidad de Trades',
                        data: [longCount, shortCount, totalCount],
                        backgroundColor: [
                            'rgba(57, 255, 20, 0.8)',  // Verde fluorescente
                            'rgba(239, 68, 68, 0.8)',  // Rojo
                            'rgba(255, 193, 7, 0.8)'  // Amarillo
                        ],
                        borderColor: [
                            'rgba(57, 255, 20, 1)',
                            'rgba(239, 68, 68, 1)',
                            'rgba(255, 193, 7, 1)'
                        ],
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                afterLabel: function(context) {
                                    const idx = context.dataIndex;
                                    if (idx === 0) return 'P/L: ' + currSymbol + longPL.toFixed(2);
                                    if (idx === 1) return 'P/L: ' + currSymbol + shortPL.toFixed(2);
                                    if (idx === 2) return 'P/L: ' + currSymbol + (longPL + shortPL).toFixed(2);
                                    return '';
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            ticks: { color: '#a0a0a0' },
                            title: { display: true, text: 'Cantidad de Trades', color: '#a0a0a0' }
                        },
                        x: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0' } }
                    }
                }
            });
        }
        
        function updateTradingStylesChart(scalpingCount, dayTradingCount, swingCount) {
            const canvas = document.getElementById('informe-trading-styles-chart');
            if (!canvas) {
                console.warn('[Trading Styles] Canvas not found');
                return;
            }
            const ctx = canvas.getContext('2d');
            
            // Destruir gráfico anterior
            if (informeTradingStylesChart) {
                informeTradingStylesChart.destroy();
                informeTradingStylesChart = null;
            }
            
            const total = scalpingCount + dayTradingCount + swingCount;
            
            // Colores: Azul, Verde fluorescente, Gris
            informeTradingStylesChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['Scalping\n(<15min)', 'Day Trading\n(15min-8h)', 'Swing Trading\n(>8h)'],
                    datasets: [{
                        label: 'Cantidad de Trades',
                        data: [scalpingCount, dayTradingCount, swingCount],
                        backgroundColor: [
                            'rgba(255, 193, 7, 0.8)',    // Amarillo
                            'rgba(57, 255, 20, 0.8)',    // Verde fluorescente
                            'rgba(156, 163, 175, 0.8)'   // Gris
                        ],
                        borderColor: [
                            'rgba(255, 193, 7, 1)',
                            'rgba(57, 255, 20, 1)',
                            'rgba(156, 163, 175, 1)'
                        ],
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: 'y',
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const percentage = total > 0 ? ((context.parsed.x / total) * 100).toFixed(1) : '0.0';
                                    return context.parsed.x + ' trades (' + percentage + '%)';
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            beginAtZero: true,
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            ticks: { color: '#a0a0a0' },
                            title: { display: true, text: 'Cantidad', color: '#a0a0a0' }
                        },
                        y: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0' } }
                    }
                }
            });
        }
        
        function updatePLRangeChart(ranges) {
            const canvas = document.getElementById('informe-pl-range-chart');
            if (!canvas) {
                console.warn('[P/L Range] Canvas not found');
                return;
            }
            const ctx = canvas.getContext('2d');
            
            console.log('[P/L Range] Creating chart with data:', ranges);
            
            // Destruir gráfico anterior
            if (informePLRangeChart) {
                informePLRangeChart.destroy();
                informePLRangeChart = null;
            }
            
            const labels = Object.keys(ranges);
            const data = Object.values(ranges);
            const colors = [
                'rgba(185, 28, 28, 0.8)',   // Rojo oscuro - Pérdidas grandes
                'rgba(239, 68, 68, 0.8)',   // Rojo - Pérdidas medianas
                'rgba(248, 113, 113, 0.8)', // Rojo claro - Pérdidas pequeñas
                'rgba(134, 239, 172, 0.8)', // Verde claro - Ganancias pequeñas
                'rgba(57, 255, 20, 0.8)',   // Verde fluorescente - Ganancias medianas
                'rgba(34, 197, 94, 0.8)'    // Verde oscuro - Ganancias grandes
            ];
            
            informePLRangeChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Cantidad de Trades',
                        data: data,
                        backgroundColor: colors,
                        borderColor: colors.map(c => c.replace('0.7', '1')),
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: 'y',
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return context.parsed.x + ' trades';
                                }
                            }
                        }
                    },
                    scales: {
                        x: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0' }, title: { display: true, text: 'Cantidad de Trades', color: '#a0a0a0' } },
                        y: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0', font: { size: 10 } } }
                    }
                }
            });
        }
        
        function updateVolumeRangeChart(ranges) {
            const canvas = document.getElementById('informe-volume-range-chart');
            if (!canvas) {
                console.warn('[Volume Range] Canvas not found');
                return;
            }
            const ctx = canvas.getContext('2d');
            
            // Destruir gráfico anterior
            if (informeVolumeRangeChart) {
                informeVolumeRangeChart.destroy();
                informeVolumeRangeChart = null;
            }
            
            informeVolumeRangeChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: Object.keys(ranges),
                    datasets: [{
                        label: 'Cantidad de Trades',
                        data: Object.values(ranges),
                        backgroundColor: [
                            'rgba(255, 193, 7, 0.8)',    // Amarillo oscuro
                            'rgba(251, 191, 36, 0.8)',   // Amarillo medio
                            'rgba(253, 224, 71, 0.8)',   // Amarillo claro
                            'rgba(156, 163, 175, 0.8)',  // Gris medio
                            'rgba(107, 114, 128, 0.8)'   // Gris oscuro
                        ],
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: 'y',
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return context.parsed.x + ' trades';
                                }
                            }
                        }
                    },
                    scales: {
                        x: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0' }, title: { display: true, text: 'Cantidad', color: '#a0a0a0' } },
                        y: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0', font: { size: 10 } } }
                    }
                }
            });
        }
        
        function updateSessionsChart(sessions, displayCurrency) {
            const canvas = document.getElementById('informe-sessions-chart');
            if (!canvas) {
                console.warn('[Sessions] Canvas not found');
                return;
            }
            const ctx = canvas.getContext('2d');
            
            // Destruir gráfico anterior
            if (informeSessionsChart) {
                informeSessionsChart.destroy();
                informeSessionsChart = null;
            }
            
            const currSymbol = displayCurrency === 'EUR' ? '€' : displayCurrency === 'USD' ? '$' : displayCurrency;
            const totalCount = sessions.asian.ops.length + sessions.european.ops.length + sessions.american.ops.length;
            const totalPL = sessions.asian.pl + sessions.european.pl + sessions.american.pl;
            
            // Colores: Azul (Asiática), Verde fluorescente (Europea), Rojo (Americana), Gris (Total)
            informeSessionsChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['Asiática\n(23:00-08:00)', 'Europea\n(08:00-16:00)', 'Americana\n(16:00-23:00)', 'Total'],
                    datasets: [{
                        label: 'Cantidad de Trades',
                        data: [sessions.asian.ops.length, sessions.european.ops.length, sessions.american.ops.length, totalCount],
                        backgroundColor: [
                            'rgba(255, 193, 7, 0.8)',    // Amarillo
                            'rgba(57, 255, 20, 0.8)',    // Verde fluorescente
                            'rgba(239, 68, 68, 0.8)',    // Rojo
                            'rgba(156, 163, 175, 0.8)'   // Gris
                        ],
                        borderColor: [
                            'rgba(255, 193, 7, 1)',
                            'rgba(57, 255, 20, 1)',
                            'rgba(239, 68, 68, 1)',
                            'rgba(156, 163, 175, 1)'
                        ],
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                afterLabel: function(context) {
                                    const idx = context.dataIndex;
                                    if (idx === 0) return 'P/L: ' + currSymbol + sessions.asian.pl.toFixed(2);
                                    if (idx === 1) return 'P/L: ' + currSymbol + sessions.european.pl.toFixed(2);
                                    if (idx === 2) return 'P/L: ' + currSymbol + sessions.american.pl.toFixed(2);
                                    if (idx === 3) return 'P/L: ' + currSymbol + totalPL.toFixed(2);
                                    return '';
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            ticks: { color: '#a0a0a0' },
                            title: { display: true, text: 'Cantidad', color: '#a0a0a0' }
                        },
                        x: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0', font: { size: 10 } } }
                    }
                }
            });
        }
        
        function updateWeekdayChart(weekdays, displayCurrency) {
            const canvas = document.getElementById('informe-weekday-chart');
            if (!canvas) {
                console.warn('[Weekday] Canvas not found');
                return;
            }
            const ctx = canvas.getContext('2d');
            
            // Destruir gráfico anterior
            if (informeWeekdayChart) {
                informeWeekdayChart.destroy();
                informeWeekdayChart = null;
            }
            
            const currSymbol = displayCurrency === 'EUR' ? '€' : displayCurrency === 'USD' ? '$' : displayCurrency;
            const labels = Object.keys(weekdays);
            const counts = labels.map(day => weekdays[day].ops.length);
            const pls = labels.map(day => weekdays[day].pl);
            const totalCount = counts.reduce((a, b) => a + b, 0);
            const totalPL = pls.reduce((a, b) => a + b, 0);
            
            // Agregar Total al final
            const allLabels = [...labels, 'Total'];
            const allCounts = [...counts, totalCount];
            
            // Colores degradados de azul a verde fluorescente + gris para total
            informeWeekdayChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: allLabels,
                    datasets: [{
                        label: 'Cantidad de Trades',
                        data: allCounts,
                        backgroundColor: [
                            'rgba(255, 193, 7, 0.8)',    // Lunes - Amarillo
                            'rgba(251, 191, 36, 0.8)',   // Martes - Amarillo claro
                            'rgba(253, 224, 71, 0.8)',   // Miércoles - Amarillo más claro
                            'rgba(134, 239, 172, 0.8)',  // Jueves - Verde claro
                            'rgba(57, 255, 20, 0.8)',    // Viernes - Verde fluorescente
                            'rgba(156, 163, 175, 0.8)'   // Total - Gris
                        ],
                        borderColor: [
                            'rgba(255, 193, 7, 1)',
                            'rgba(251, 191, 36, 1)',
                            'rgba(253, 224, 71, 1)',
                            'rgba(134, 239, 172, 1)',
                            'rgba(57, 255, 20, 1)',
                            'rgba(156, 163, 175, 1)'
                        ],
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                afterLabel: function(context) {
                                    const idx = context.dataIndex;
                                    if (idx < pls.length) return 'P/L: ' + currSymbol + pls[idx].toFixed(2);
                                    if (idx === pls.length) return 'P/L: ' + currSymbol + totalPL.toFixed(2);
                                    return '';
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            ticks: { color: '#a0a0a0' },
                            title: { display: true, text: 'Cantidad', color: '#a0a0a0' }
                        },
                        x: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0' } }
                    }
                }
            });
        }
        
        function updateCommissionsChart(ranges) {
            const canvas = document.getElementById('informe-commissions-chart');
            if (!canvas) {
                console.warn('[Commissions] Canvas not found');
                return;
            }
            const ctx = canvas.getContext('2d');
            
            // Destruir gráfico anterior
            if (informeCommissionsChart) {
                informeCommissionsChart.destroy();
                informeCommissionsChart = null;
            }
            
            informeCommissionsChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: Object.keys(ranges),
                    datasets: [{
                        label: 'Cantidad de Trades',
                        data: Object.values(ranges),
                        backgroundColor: [
                            'rgba(57, 255, 20, 0.8)',    // Verde fluorescente - Muy bajas
                            'rgba(134, 239, 172, 0.8)',  // Verde claro - Bajas
                            'rgba(156, 163, 175, 0.8)',  // Gris - Medianas
                            'rgba(251, 113, 133, 0.8)',  // Rojo claro - Altas
                            'rgba(239, 68, 68, 0.8)'     // Rojo - Muy altas
                        ],
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: 'y',
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return context.parsed.x + ' trades';
                                }
                            }
                        }
                    },
                    scales: {
                        x: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0' }, title: { display: true, text: 'Cantidad', color: '#a0a0a0' } },
                        y: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0', font: { size: 10 } } }
                    }
                }
            });
        }
        
        function updateRRChart(ranges) {
            const canvas = document.getElementById('informe-rr-chart');
            if (!canvas) {
                console.warn('[R:R] Canvas not found');
                return;
            }
            const ctx = canvas.getContext('2d');
            
            // Destruir gráfico anterior
            if (informeRRChart) {
                informeRRChart.destroy();
                informeRRChart = null;
            }
            
            informeRRChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: Object.keys(ranges),
                    datasets: [{
                        label: 'Cantidad de Trades',
                        data: Object.values(ranges),
                        backgroundColor: [
                            'rgba(239, 68, 68, 0.8)',    // Rojo - Desfavorable
                            'rgba(251, 191, 36, 0.8)',   // Amarillo - Conservador
                            'rgba(255, 193, 7, 0.8)',    // Amarillo oscuro - Equilibrado
                            'rgba(134, 239, 172, 0.8)',  // Verde claro - Favorable
                            'rgba(57, 255, 20, 0.8)'     // Verde fluorescente - Excelente
                        ],
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: 'y',
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return context.parsed.x + ' trades';
                                }
                            }
                        }
                    },
                    scales: {
                        x: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0' }, title: { display: true, text: 'Cantidad', color: '#a0a0a0' } },
                        y: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0', font: { size: 10 } } }
                    }
                }
            });
        }
        
        // ============ FIN FUNCIONES DE GRÁFICOS DE DISTRIBUCIÓN ============
        
        // Nueva función: Distribución de P/L (Histograma)
        function updatePLDistributionHistogram(operations, displayCurrency) {
            const canvas = document.getElementById('pl-distribution-histogram-chart');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            
            if (plDistributionChart) plDistributionChart.destroy();
            
            // Extraer P/L de todas las operaciones
            const plValues = operations.map(op => convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency));
            
            if (plValues.length === 0) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                return;
            }
            
            // Determinar rangos para el histograma
            const minPL = Math.min(...plValues);
            const maxPL = Math.max(...plValues);
            const range = maxPL - minPL;
            const binCount = Math.min(20, Math.max(5, Math.floor(Math.sqrt(plValues.length))));
            const binSize = range / binCount;
            
            // Crear bins
            const bins = Array(binCount).fill(0);
            const binLabels = [];
            
            for (let i = 0; i < binCount; i++) {
                const binStart = minPL + (i * binSize);
                const binEnd = binStart + binSize;
                binLabels.push(`$${binStart.toFixed(0)} - $${binEnd.toFixed(0)}`);
            }
            
            // Llenar bins
            plValues.forEach(pl => {
                const binIndex = Math.min(Math.floor((pl - minPL) / binSize), binCount - 1);
                bins[binIndex]++;
            });
            
            plDistributionChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: binLabels,
                    datasets: [{
                        label: 'Cantidad de Trades',
                        data: bins,
                        backgroundColor: bins.map((_, index) => {
                            const binMidPoint = minPL + (index + 0.5) * binSize;
                            return binMidPoint >= 0 ? '#00FF00' : '#FF0000';
                        }),
                        borderColor: bins.map((_, index) => {
                            const binMidPoint = minPL + (index + 0.5) * binSize;
                            return binMidPoint >= 0 ? 'rgba(57,255,20,1)' : 'rgba(255,65,54,1)';
                        }),
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (ctx) => `Trades: ${ctx.parsed.y}`
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            ticks: {
                                color: '#a0a0a0',
                                stepSize: 1
                            },
                            title: {
                                display: true,
                                text: 'Cantidad de Trades',
                                color: '#ffffff'
                            }
                        },
                        x: {
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            ticks: {
                                color: '#a0a0a0',
                                maxRotation: 45,
                                minRotation: 45,
                                font: { size: 9 }
                            },
                            title: {
                                display: true,
                                text: 'Rango de P/L',
                                color: '#ffffff'
                            }
                        }
                    }
                }
            });
        }
        
        // Nueva función: Performance por Mes (Barras comparativas)
        function updateMonthlyPerformanceChart(operations, displayCurrency) {
            console.log(`[Monthly Performance] Received ${operations.length} operations`);
            const canvas = document.getElementById('monthly-performance-chart');
            if (!canvas) {
                console.warn('[Monthly Performance] Canvas not found');
                return;
            }
            const ctx = canvas.getContext('2d');
            
            if (monthlyPerformanceChart) monthlyPerformanceChart.destroy();
            
            // Agrupar por mes
            const monthlyData = {};
            
            operations.forEach(op => {
                if (!op.date) return;
                const monthKey = op.date.substring(0, 7); // YYYY-MM
                
                if (!monthlyData[monthKey]) {
                    monthlyData[monthKey] = {
                        wins: 0,
                        losses: 0,
                        winPL: 0,
                        lossPL: 0
                    };
                }
                
                const pl = convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency);
                
                if (pl > 0) {
                    monthlyData[monthKey].wins++;
                    monthlyData[monthKey].winPL += pl;
                } else if (pl < 0) {
                    monthlyData[monthKey].losses++;
                    monthlyData[monthKey].lossPL += pl;
                }
            });
            
            // Ordenar por fecha
            const sortedMonths = Object.keys(monthlyData).sort();
            const labels = sortedMonths.map(m => {
                const [year, month] = m.split('-');
                const monthNames = ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'];
                return `${monthNames[parseInt(month) - 1]} ${year}`;
            });
            
            const winPLData = sortedMonths.map(m => monthlyData[m].winPL);
            const lossPLData = sortedMonths.map(m => monthlyData[m].lossPL);
            const netPLData = sortedMonths.map(m => monthlyData[m].winPL + monthlyData[m].lossPL);
            
            monthlyPerformanceChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Ganancias',
                            data: winPLData,
                            backgroundColor: '#00FF00',
                            borderColor: 'rgba(57,255,20,1)',
                            borderWidth: 1,
                            stack: 'stack0'
                        },
                        {
                            label: 'Pérdidas',
                            data: lossPLData,
                            backgroundColor: '#FF0000',
                            borderColor: 'rgba(255,65,54,1)',
                            borderWidth: 1,
                            stack: 'stack0'
                        },
                        {
                            label: 'P/L Neto',
                            data: netPLData,
                            type: 'line',
                            borderColor: 'rgba(135,206,250,1)',
                            backgroundColor: 'rgba(135,206,250,0.2)',
                            borderWidth: 2,
                            fill: false,
                            tension: 0.3,
                            pointRadius: 4,
                            pointHoverRadius: 6,
                            yAxisID: 'y'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: { color: '#ffffff', font: { size: 12 } }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) label += ': ';
                                    label += '$' + Math.abs(context.parsed.y).toFixed(2);
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            stacked: false,
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            ticks: {
                                color: '#a0a0a0',
                                callback: (value) => '$' + value.toFixed(0)
                            },
                            title: {
                                display: true,
                                text: 'P/L ($)',
                                color: '#ffffff'
                            }
                        },
                        x: {
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            ticks: {
                                color: '#a0a0a0',
                                maxRotation: 45,
                                minRotation: 0
                            }
                        }
                    }
                }
            });
        }

        function updateInformeChart(canvasId, data, key, label) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            if (!ctx) return;

            if (canvasId === 'informe-chart-pnl-desc') {
                if (informeChartPnLDesc) informeChartPnLDesc.destroy();
            } else if (canvasId === 'informe-chart-pnl-asc') {
                if (informeChartPnLAsc) informeChartPnLAsc.destroy();
            }

            const chart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: data.map(item => item[0]),
                    datasets: [{
                        label: label,
                        data: data.map(item => item[1][key]),
                        backgroundColor: data.map(item => item[1][key] >= 0 ? '#00FF00' : '#FF0000'),
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        x: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0' } },
                        y: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0' } }
                    }
                }
            });

            if (canvasId === 'informe-chart-pnl-desc') {
                informeChartPnLDesc = chart;
            } else if (canvasId === 'informe-chart-pnl-asc') {
                informeChartPnLAsc = chart;
            }
        }

        function updateInformeWLChart(canvasId, data, label) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            if (!ctx) return;

             if (canvasId === 'informe-chart-wl-desc') {
                if (informeChartWLDesc) informeChartWLDesc.destroy();
            } else if (canvasId === 'informe-chart-wl-asc') {
                if (informeChartWLAsc) informeChartWLAsc.destroy();
            }

            const chart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: data.map(item => item[0]),
                    datasets: [
                        {
                            label: 'Wins',
                            data: data.map(item => item[1].wins),
                            backgroundColor: '#00FF00',
                        },
                        {
                            label: 'Losses',
                            data: data.map(item => -item[1].losses),
                            backgroundColor: '#FF0000',
                        }
                    ]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { labels: { color: '#a0a0a0' } } },
                    scales: {
                        x: { stacked: true, grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0' } },
                        y: { stacked: true, grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0' } }
                    }
                }
            });

            if (canvasId === 'informe-chart-wl-desc') {
                informeChartWLDesc = chart;
            } else if (canvasId === 'informe-chart-wl-asc') {
                informeChartWLAsc = chart;
            }
        }

        // NUEVA FUNCIÓN: P&L Long vs Short por Símbolo
        function updateInformeLongShortSymbolChart(canvasId, data) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            if (!ctx) return;

            if (informeChartLongShortSymbol) informeChartLongShortSymbol.destroy();

            const labels = data.map(item => item[0]);
            const longData = data.map(item => item[1].longPL);
            const shortData = data.map(item => item[1].shortPL);

            informeChartLongShortSymbol = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Long (Compra)',
                            data: longData,
                            backgroundColor: '#00FF00',
                        },
                        {
                            label: 'Short (Venta)',
                            data: shortData,
                            backgroundColor: '#FF0000',
                        }
                    ]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { 
                        legend: { 
                            display: true,
                            labels: { color: '#a0a0a0' } 
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.dataset.label || '';
                                    const value = context.parsed.x;
                                    return label + ': $' + value.toFixed(2);
                                }
                            }
                        }
                    },
                    scales: {
                        x: { 
                            stacked: true,
                            grid: { color: 'rgba(255,255,255,0.1)' }, 
                            ticks: { 
                                color: '#a0a0a0',
                                callback: function(value) {
                                    return '$' + value.toFixed(0);
                                }
                            } 
                        },
                        y: { 
                            stacked: true,
                            grid: { color: 'rgba(255,255,255,0.1)' }, 
                            ticks: { color: '#a0a0a0' } 
                        }
                    }
                }
            });
        }

        // NUEVA FUNCIÓN: Win Rate Long vs Short
        function updateInformeWinRateLongShortChart(canvasId, longWinRate, shortWinRate, longCount, shortCount) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            if (!ctx) return;

            if (informeChartWinRateLongShort) informeChartWinRateLongShort.destroy();

            informeChartWinRateLongShort = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['Long (Compra)', 'Short (Venta)'],
                    datasets: [{
                        label: 'Win Rate (%)',
                        data: [longWinRate, shortWinRate],
                        backgroundColor: [
                            longWinRate >= 50 ? '#00FF00' : '#FF0000',
                            shortWinRate >= 50 ? '#00FF00' : '#FF0000'
                        ]
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { 
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const wr = context.parsed.y;
                                    const count = context.dataIndex === 0 ? longCount : shortCount;
                                    return 'WR: ' + wr.toFixed(1) + '% (' + count + ' ops)';
                                }
                            }
                        }
                    },
                    scales: {
                        y: { 
                            min: 0,
                            max: 100,
                            grid: { color: 'rgba(255,255,255,0.1)' }, 
                            ticks: { 
                                color: '#a0a0a0',
                                callback: function(value) {
                                    return value + '%';
                                }
                            } 
                        },
                        x: { 
                            grid: { display: false }, 
                            ticks: { color: '#a0a0a0' } 
                        }
                    }
                }
            });
        }

        // NUEVA FUNCIÓN: Win Rate Long vs Short por Símbolo
        function updateInformeWinRateBySymbolChart(canvasId, data) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            if (!ctx) return;

            if (informeChartWinRateBySymbol) informeChartWinRateBySymbol.destroy();

            const labels = data.map(item => item[0]);
            const longWRData = data.map(item => item[1].longWR);
            const shortWRData = data.map(item => item[1].shortWR);

            informeChartWinRateBySymbol = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Long WR (%)',
                            data: longWRData,
                            backgroundColor: '#00FF00',
                        },
                        {
                            label: 'Short WR (%)',
                            data: shortWRData,
                            backgroundColor: '#FF0000',
                        }
                    ]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { 
                        legend: { 
                            display: true,
                            labels: { color: '#a0a0a0' } 
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const dataIndex = context.dataIndex;
                                    const datasetIndex = context.datasetIndex;
                                    const wr = context.parsed.x;
                                    const count = datasetIndex === 0 ? data[dataIndex][1].longCount : data[dataIndex][1].shortCount;
                                    return context.dataset.label + ': ' + wr.toFixed(1) + '% (' + count + ' ops)';
                                }
                            }
                        }
                    },
                    scales: {
                        x: { 
                            stacked: true,
                            min: 0,
                            max: 100,
                            grid: { color: 'rgba(255,255,255,0.1)' }, 
                            ticks: { 
                                color: '#a0a0a0',
                                callback: function(value) {
                                    return value + '%';
                                }
                            } 
                        },
                        y: { 
                            stacked: true,
                            grid: { color: 'rgba(255,255,255,0.1)' }, 
                            ticks: { color: '#a0a0a0' } 
                        }
                    }
                }
            });
        }

        // NUEVA FUNCIÓN: Promedio P&L por Trade por Símbolo
        function updateInformeAvgPLBySymbolChart(canvasId, data) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            if (!ctx) return;

            if (informeChartAvgPLBySymbol) informeChartAvgPLBySymbol.destroy();

            const labels = data.map(item => item[0]);
            const longAvgData = data.map(item => item[1].longAvg);
            const shortAvgData = data.map(item => item[1].shortAvg);

            informeChartAvgPLBySymbol = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Promedio Long',
                            data: longAvgData,
                            backgroundColor: '#00FF00',
                        },
                        {
                            label: 'Promedio Short',
                            data: shortAvgData,
                            backgroundColor: '#FF0000',
                        }
                    ]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { 
                        legend: { 
                            display: true,
                            labels: { color: '#a0a0a0' } 
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const dataIndex = context.dataIndex;
                                    const datasetIndex = context.datasetIndex;
                                    const avg = context.parsed.x;
                                    const count = datasetIndex === 0 ? data[dataIndex][1].longCount : data[dataIndex][1].shortCount;
                                    return context.dataset.label + ': $' + avg.toFixed(2) + ' (' + count + ' ops)';
                                }
                            }
                        }
                    },
                    scales: {
                        x: { 
                            stacked: true,
                            grid: { color: 'rgba(255,255,255,0.1)' }, 
                            ticks: { 
                                color: '#a0a0a0',
                                callback: function(value) {
                                    return '$' + value.toFixed(0);
                                }
                            } 
                        },
                        y: { 
                            stacked: true,
                            grid: { color: 'rgba(255,255,255,0.1)' }, 
                            ticks: { color: '#a0a0a0' } 
                        }
                    }
                }
            });
        }


        function refreshAnalytics() {
            console.log('[refreshAnalytics] Iniciado');
            
            const accountSelect = document.getElementById('analytics-account-select');
            const currencySelect = document.getElementById('analytics-currency-select');
            
            if (!accountSelect || !currencySelect) return;
            
            const selectedAccount = accountSelect.value;
            
            console.log('[Analytics] Cuenta seleccionada:', selectedAccount);
            console.log('[Analytics] Filtro de fecha:', globalDateFilter);
            console.log('[Analytics] Filtros personalizados:', analyticsFilters);
            
            let operationsForAnalytics = applyDateFilterToData(DB.operations);
            console.log('[Analytics] Después de filtro de fecha:', operationsForAnalytics.length, 'operaciones');
            
            // Aplicar filtro de cuentas (soporte para selección múltiple)
            operationsForAnalytics = filterBySelectedAccounts(operationsForAnalytics, selectedAccount);
            console.log('[Analytics] Después de filtro de cuenta:', operationsForAnalytics.length, 'operaciones');
            
            // Aplicar filtros de Analytics
            operationsForAnalytics = applyAnalyticsFilters(operationsForAnalytics);
            console.log('[Analytics] Después de filtros personalizados:', operationsForAnalytics.length, 'operaciones');
            
            const displayCurrency = currencySelect.value;

            console.log('[Analytics] Actualizado con', operationsForAnalytics.length, 'operaciones');

            const basicMetrics = calculateMetrics(operationsForAnalytics, selectedAccount);
            const advancedMetrics = calculateAdvancedMetrics(operationsForAnalytics, selectedAccount);
            const extraMetrics = calculateExtraAnalytics(operationsForAnalytics, selectedAccount);
            const timeMetrics = calculateTimeMetrics(operationsForAnalytics);

            // AHORA calculateMetrics devuelve P/L BRUTO + totalFees por separado
            const grossPL = basicMetrics.totalWin + basicMetrics.totalLoss;
            const totalFees = basicMetrics.totalFees;
            const netPlAfterFees = grossPL - totalFees;
            
            const avgFee = basicMetrics.totalTrades > 0 ? totalFees / basicMetrics.totalTrades : 0;

            const totalPlEl = document.getElementById('analytics-total-pl');
            const plBrutoTradesEl = document.getElementById('analytics-pl-bruto-trades');
            if (totalPlEl) {
                // Mostrar P/L BRUTO con indicador
                const plLabel = totalPlEl.closest('.metric-card')?.querySelector('.text-sm');
                if (plLabel && !plLabel.textContent.includes('Bruto')) {
                    plLabel.textContent = 'P&L Bruto Total';
                }
                totalPlEl.textContent = formatCurrency(grossPL, DB.settings.defaultCurrency, displayCurrency);
                totalPlEl.className = `text-2xl font-bold mb-2 ${grossPL >= 0 ? 'text-green' : 'text-negative'}`;
                
                // Actualizar contador de trades
                if (plBrutoTradesEl) {
                    plBrutoTradesEl.textContent = `${basicMetrics.totalTrades} trades`;
                }
                
                // Crear gauge radial para P&L Bruto
                updatePlBrutoGauge(grossPL, basicMetrics.totalWin, basicMetrics.totalLoss);
            }

            // Actualizar Net P&L (después de restar comisiones)
            const netPlEl = document.getElementById('analytics-net-pl');
            if (netPlEl) {
                const netPL = netPlAfterFees; // Usar la variable calculada arriba
                const plLabel = netPlEl.closest('.metric-card')?.querySelector('.text-sm');
                if (plLabel && !plLabel.textContent.includes('Neto')) {
                    plLabel.textContent = 'P&L Neto Total (después de comisiones)';
                }
                netPlEl.textContent = formatCurrency(netPL, DB.settings.defaultCurrency, displayCurrency);
                netPlEl.className = `text-2xl font-bold mb-2 ${netPL >= 0 ? 'text-green' : 'text-red'}`;
                
                // Crear gauge radial para P&L Neto
                updatePlNetoGauge(netPL, basicMetrics.totalWin, basicMetrics.totalLoss, totalFees);
            }

            // Actualizar Win Rate
            const winRateEl = document.getElementById('analytics-win-rate');
            if (winRateEl) {
                winRateEl.textContent = basicMetrics.winRate.toFixed(2) + '%';
            }

            // Actualizar Profit Factor
            const pfEl = document.getElementById('analytics-profit-factor');
            if (pfEl) {
                pfEl.textContent = isFinite(basicMetrics.profitFactor) ? basicMetrics.profitFactor.toFixed(2) : "∞";
            }

            // Actualizar Total Trades
            const totalTradesEl = document.getElementById('analytics-total-trades');
            if (totalTradesEl) {
                totalTradesEl.textContent = basicMetrics.totalTrades;
            }

            // Actualizar Wins y Losses
            const winsEl = document.getElementById('analytics-wins');
            if (winsEl) winsEl.textContent = basicMetrics.winningTrades;
            
            const lossesEl = document.getElementById('analytics-losses');
            if (lossesEl) lossesEl.textContent = basicMetrics.losingTrades;

            // Calcular Day Win %
            const dayStats = calculateDayWinStats(operationsForAnalytics);
            const dayWinRateEl = document.getElementById('analytics-day-win-rate');
            if (dayWinRateEl) {
                dayWinRateEl.textContent = dayStats.dayWinRate.toFixed(2) + '%';
            }
            const dayWinsEl = document.getElementById('analytics-day-wins');
            if (dayWinsEl) dayWinsEl.textContent = dayStats.winningDays;
            
            const dayNeutralEl = document.getElementById('analytics-day-neutral');
            if (dayNeutralEl) dayNeutralEl.textContent = dayStats.breakevenDays;
            
            const dayLossesEl = document.getElementById('analytics-day-losses');
            if (dayLossesEl) dayLossesEl.textContent = dayStats.losingDays;

            // Actualizar Avg Win/Loss Trade
            const avgWinTradeEl = document.getElementById('analytics-avg-win-trade');
            if (avgWinTradeEl) {
                const avgWin = advancedMetrics.avgWin;
                avgWinTradeEl.textContent = formatCurrency(Math.abs(avgWin), DB.settings.defaultCurrency, displayCurrency);
            }

            const avgLossTradeEl = document.getElementById('analytics-avg-loss-trade');
            if (avgLossTradeEl) {
                const avgLoss = advancedMetrics.avgLoss;
                avgLossTradeEl.textContent = formatCurrency(Math.abs(avgLoss), DB.settings.defaultCurrency, displayCurrency);
            }

            // Calcular y actualizar el ratio y las barras
            const avgRatioEl = document.getElementById('analytics-avg-ratio');
            if (avgRatioEl && advancedMetrics.avgWin !== 0 && advancedMetrics.avgLoss !== 0) {
                const ratio = Math.abs(advancedMetrics.avgWin / advancedMetrics.avgLoss);
                avgRatioEl.textContent = ratio.toFixed(2);

                // Actualizar las barras de progreso
                const totalAbs = Math.abs(advancedMetrics.avgWin) + Math.abs(advancedMetrics.avgLoss);
                const winPercent = (Math.abs(advancedMetrics.avgWin) / totalAbs) * 100;
                const lossPercent = (Math.abs(advancedMetrics.avgLoss) / totalAbs) * 100;

                const winBarEl = document.getElementById('analytics-win-bar');
                if (winBarEl) winBarEl.style.width = winPercent.toFixed(1) + '%';

                const lossBarEl = document.getElementById('analytics-loss-bar');
                if (lossBarEl) lossBarEl.style.width = lossPercent.toFixed(1) + '%';
            }

            document.getElementById('analytics-win-rate').textContent = basicMetrics.winRate.toFixed(0) + '%';
            document.getElementById('analytics-profit-factor').textContent = isFinite(basicMetrics.profitFactor) ? basicMetrics.profitFactor.toFixed(2) : "∞";
            document.getElementById('analytics-total-trades').textContent = basicMetrics.totalTrades;

            // Mostrar comisiones
            document.getElementById('analytics-total-fees').textContent = formatCurrency(totalFees, DB.settings.defaultCurrency, displayCurrency);
            document.getElementById('analytics-avg-fee').textContent = formatCurrency(avgFee, DB.settings.defaultCurrency, displayCurrency);

            const feesTotal = document.getElementById('analytics-fees-total');
            if (feesTotal) feesTotal.textContent = formatCurrency(totalFees, DB.settings.defaultCurrency, displayCurrency);

            const netPlAfterFeesEl = document.getElementById('analytics-net-pl-after-fees');
            if (netPlAfterFeesEl) {
                netPlAfterFeesEl.textContent = formatCurrency(netPlAfterFees, DB.settings.defaultCurrency, displayCurrency);
                netPlAfterFeesEl.className = `font-bold ${netPlAfterFees >= 0 ? 'text-green' : 'text-red'}`;
            }

            document.getElementById('analytics-avg-win').textContent = formatCurrency(advancedMetrics.avgWin, DB.settings.defaultCurrency, displayCurrency);
            document.getElementById('analytics-avg-loss').textContent = formatCurrency(advancedMetrics.avgLoss, DB.settings.defaultCurrency, displayCurrency);

            const avgPlTradeEl = document.getElementById('analytics-avg-pl-trade');
            avgPlTradeEl.textContent = formatCurrency(advancedMetrics.avgPLPerTrade, DB.settings.defaultCurrency, displayCurrency);
            avgPlTradeEl.className = `font-semibold ${advancedMetrics.avgPLPerTrade >= 0 ? 'text-white' : 'text-negative'}`;

            const expectancyEl = document.getElementById('analytics-expectancy');
            expectancyEl.textContent = formatCurrency(advancedMetrics.expectancy, DB.settings.defaultCurrency, displayCurrency);
            expectancyEl.className = `font-semibold ${advancedMetrics.expectancy >= 0 ? 'text-green' : 'text-negative'}`;

            document.getElementById('analytics-largest-win').textContent = formatCurrency(advancedMetrics.largestWin, DB.settings.defaultCurrency, displayCurrency);
            document.getElementById('analytics-largest-loss').textContent = formatCurrency(advancedMetrics.largestLoss, DB.settings.defaultCurrency, displayCurrency);

            document.getElementById('analytics-longest-win-streak').textContent = advancedMetrics.longestWinStreak;
            document.getElementById('analytics-longest-loss-streak').textContent = advancedMetrics.longestLossStreak;
            document.getElementById('analytics-total-wins-count').textContent = basicMetrics.winningTrades;
            document.getElementById('analytics-total-losses-count').textContent = basicMetrics.losingTrades;
            document.getElementById('analytics-total-breakeven-count').textContent = basicMetrics.breakevenTrades;

            // Populate new extra metrics
            document.getElementById('analytics-max-drawdown').textContent = `${formatCurrency(extraMetrics.maxDrawdownValue, extraMetrics.currencyForDD, displayCurrency)} (${extraMetrics.maxDrawdownPercentage.toFixed(1)}%)`;
            const ddShortEl = document.getElementById('analytics-max-drawdown-short');
            if (ddShortEl) ddShortEl.textContent = formatCurrency(extraMetrics.maxDrawdownValue, extraMetrics.currencyForDD, displayCurrency);
            const avgWLRatioEl = document.getElementById('analytics-avg-wl-ratio');
            avgWLRatioEl.textContent = isFinite(extraMetrics.avgWLRatio) ? extraMetrics.avgWLRatio.toFixed(2) : "∞";
            avgWLRatioEl.className = `font-semibold ${extraMetrics.avgWLRatio >= 1 ? 'text-green' : 'text-negative'}`;
            document.getElementById('analytics-avg-hold-time').textContent = extraMetrics.avgHoldTimeText;
            document.getElementById('analytics-std-dev-pl').textContent = formatCurrency(extraMetrics.stdDevPL, DB.settings.defaultCurrency, displayCurrency);

            // Populate new time-based metrics
            const avgWinDurEl = document.getElementById('analytics-avg-win-duration');
            avgWinDurEl.textContent = timeMetrics.hasWins ? formatDurationText(timeMetrics.avgWinDuration) : 'N/A';
            
            const avgLossDurEl = document.getElementById('analytics-avg-loss-duration');
            avgLossDurEl.textContent = timeMetrics.hasLosses ? formatDurationText(timeMetrics.avgLossDuration) : 'N/A';
            
            const bestHourEl = document.getElementById('analytics-best-hour');
            if (timeMetrics.bestHour >= 0) {
                bestHourEl.textContent = `${String(timeMetrics.bestHour).padStart(2, '0')}:00 (${formatCurrency(timeMetrics.bestHourPL, DB.settings.defaultCurrency, displayCurrency)})`;
            } else {
                bestHourEl.textContent = 'N/A';
            }
            
            const worstHourEl = document.getElementById('analytics-worst-hour');
            if (timeMetrics.worstHour >= 0) {
                worstHourEl.textContent = `${String(timeMetrics.worstHour).padStart(2, '0')}:00 (${formatCurrency(timeMetrics.worstHourPL, DB.settings.defaultCurrency, displayCurrency)})`;
            } else {
                worstHourEl.textContent = 'N/A';
            }
            
            const longestWinEl = document.getElementById('analytics-longest-win-duration');
            longestWinEl.textContent = timeMetrics.hasWins ? formatDurationText(timeMetrics.longestWinDuration) : 'N/A';
            
            const longestLossEl = document.getElementById('analytics-longest-loss-duration');
            longestLossEl.textContent = timeMetrics.hasLosses ? formatDurationText(timeMetrics.longestLossDuration) : 'N/A';
            
            const fastestWinEl = document.getElementById('analytics-fastest-win');
            fastestWinEl.textContent = timeMetrics.hasWins ? formatDurationText(timeMetrics.fastestWin) : 'N/A';


            populateAnalyticsDailyPerformance(operationsForAnalytics, selectedAccount);
            populateAnalyticsMonthlyPerformance(operationsForAnalytics, selectedAccount);
            populateAnalyticsWeeklyPerformance(operationsForAnalytics, selectedAccount);
            populateAnalyticsQuarterlyPerformance(operationsForAnalytics, selectedAccount);
            populateAnalyticsLastWeekPerformance(operationsForAnalytics, selectedAccount);
            updateInstrumentPerformanceChart(operationsForAnalytics, 'analytics-instrument-performance-chart');
            updateHourlyPerformanceChart(operationsForAnalytics, 'analytics-hourly-performance-chart');
            
            // Actualizar las nuevas gráficas
            updateAnalyticsCumulativePLChart(operationsForAnalytics, selectedAccount);
            updateAnalyticsNetDailyPLChart(operationsForAnalytics, selectedAccount);
            
            // Actualizar los nuevos gauges
            updateTradeWinGauge(basicMetrics.winRate);
            updateDayWinGauge(dayStats.dayWinRate);
            updateProfitFactorGauge(basicMetrics.profitFactor);

            // Update mini visuals
            updateAnalyticsSparkline(operationsForAnalytics);
            updateAnalyticsPFGauge(basicMetrics.profitFactor);
            updateAnalyticsWinDonut(basicMetrics.winRate, basicMetrics.winningTrades, basicMetrics.losingTrades);
        }
        
        // Gráfica: Daily Net Cumulative P&L
        let analyticsCumulativePLChart = null;
        function updateAnalyticsCumulativePLChart(operations, accountId) {
            const canvas = document.getElementById('analytics-cumulative-pl-chart');
            if (!canvas) {
                console.error('Canvas analytics-cumulative-pl-chart no encontrado');
                return;
            }
            
            const ctx = canvas.getContext('2d');
            if (analyticsCumulativePLChart) analyticsCumulativePLChart.destroy();

            const currencySelect = document.getElementById('analytics-currency-select');
            const displayCurrency = currencySelect ? currencySelect.value : 'USD';
            const targetCurrency = displayCurrency === '%' ? DB.settings.defaultCurrency : displayCurrency;

            console.log('📊 Creando gráfica acumulativa con', operations.length, 'operaciones');
            const sorted = [...operations].sort((a, b) => new Date(a.date) - new Date(b.date));

            let cumulative = 0;
            const labels = [];
            const data = [];

            sorted.forEach(op => {
                let plConverted = op.pl;
                if (op.currency !== targetCurrency) {
                    plConverted = convertCurrency(op.pl, op.currency, targetCurrency);
                }
                cumulative += plConverted;
                labels.push(op.date);
                data.push(cumulative);
            });

            if (data.length === 0) {
                labels.push(new Date().toISOString().split('T')[0]);
                data.push(0);
            }

            console.log('📊 Gráfica acumulativa - Puntos de datos:', data.length, 'Último valor:', data[data.length - 1]);

            analyticsCumulativePLChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels,
                    datasets: [{
                        data,
                        borderColor: '#39ff14',
                        backgroundColor: 'rgba(57, 255, 20, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 0,
                        pointHoverRadius: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: (ctx) => `P&L: ${formatCurrency(ctx.raw, targetCurrency, displayCurrency)}`
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: { color: '#2a2a2a', display: true },
                            ticks: { color: '#a0a0a0', maxTicksLimit: 8 }
                        },
                        y: {
                            grid: { color: '#2a2a2a' },
                            ticks: {
                                color: '#a0a0a0',
                                callback: (val) => formatCurrency(val, targetCurrency, displayCurrency)
                            }
                        }
                    }
                }
            });
        }

        // Gráfica: Net Daily P&L
        let analyticsNetDailyPLChart = null;
        function updateAnalyticsNetDailyPLChart(operations, accountId) {
            const canvas = document.getElementById('analytics-net-daily-pl-chart');
            if (!canvas) {
                console.error('Canvas analytics-net-daily-pl-chart no encontrado');
                return;
            }
            
            const ctx = canvas.getContext('2d');
            if (analyticsNetDailyPLChart) analyticsNetDailyPLChart.destroy();

            const currencySelect = document.getElementById('analytics-currency-select');
            const displayCurrency = currencySelect ? currencySelect.value : 'USD';
            const targetCurrency = displayCurrency === '%' ? DB.settings.defaultCurrency : displayCurrency;

            console.log('📊 Creando gráfica diaria con', operations.length, 'operaciones');
            const dailyPL = {};
            operations.forEach(op => {
                const date = op.date;
                if (!dailyPL[date]) dailyPL[date] = 0;
                
                let plConverted = op.pl;
                if (op.currency !== targetCurrency) {
                    plConverted = convertCurrency(op.pl, op.currency, targetCurrency);
                }
                dailyPL[date] += plConverted;
            });

            const sorted = Object.keys(dailyPL).sort();
            const labels = sorted;
            const data = sorted.map(date => dailyPL[date]);

            if (data.length === 0) {
                labels.push(new Date().toISOString().split('T')[0]);
                data.push(0);
            }

            console.log('📊 Gráfica diaria - Días con datos:', data.length, 'Valores:', data);

            analyticsNetDailyPLChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels,
                    datasets: [{
                        label: 'P&L Diario',
                        data,
                        backgroundColor: data.map(val => val >= 0 ? 'rgba(57, 255, 20, 0.8)' : 'rgba(255, 65, 54, 0.8)'),
                        borderColor: data.map(val => val >= 0 ? '#39ff14' : '#ff4136'),
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (ctx) => `P&L: ${formatCurrency(ctx.raw, targetCurrency, displayCurrency)}`
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: { display: false },
                            ticks: { color: '#a0a0a0', maxTicksLimit: 10 }
                        },
                        y: {
                            grid: { color: '#2a2a2a' },
                            ticks: {
                                color: '#a0a0a0',
                                callback: (val) => formatCurrency(val, targetCurrency, displayCurrency)
                            }
                        }
                    }
                }
            });
        }
        
        // --- Gauge Charts para las métricas principales ---
        
        // Gauge Chart: Trade Win %
        let tradeWinGaugeChart = null;
        function updateTradeWinGauge(winRate) {
            const canvas = document.getElementById('analytics-trade-win-gauge');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            if (tradeWinGaugeChart) tradeWinGaugeChart.destroy();
            
            const percentage = Math.min(Math.max(winRate, 0), 100);
            const remaining = 100 - percentage;
            
            tradeWinGaugeChart = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    datasets: [{
                        data: [percentage, remaining],
                        backgroundColor: [
                            percentage >= 50 ? '#39ff14' : '#ff4136',
                            'rgba(42, 42, 42, 0.3)'
                        ],
                        borderWidth: 0,
                        circumference: 180,
                        rotation: 270
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    cutout: '75%',
                    plugins: {
                        legend: { display: false },
                        tooltip: { enabled: false }
                    }
                }
            });
        }
        
        // Gauge Chart: Day Win %
        let dayWinGaugeChart = null;
        function updateDayWinGauge(dayWinRate) {
            const canvas = document.getElementById('analytics-day-win-gauge');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            if (dayWinGaugeChart) dayWinGaugeChart.destroy();
            
            const percentage = Math.min(Math.max(dayWinRate, 0), 100);
            const remaining = 100 - percentage;
            
            dayWinGaugeChart = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    datasets: [{
                        data: [percentage, remaining],
                        backgroundColor: [
                            percentage >= 50 ? '#39ff14' : '#ff4136',
                            'rgba(42, 42, 42, 0.3)'
                        ],
                        borderWidth: 0,
                        circumference: 180,
                        rotation: 270
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    cutout: '75%',
                    plugins: {
                        legend: { display: false },
                        tooltip: { enabled: false }
                    }
                }
            });
        }
        
        // Speedometer Chart: Profit Factor
        let profitFactorGaugeChart = null;
        function updateProfitFactorGauge(profitFactor) {
            const canvas = document.getElementById('analytics-profit-factor-gauge');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            if (profitFactorGaugeChart) profitFactorGaugeChart.destroy();
            
            // Mapear profit factor (0-5) a porcentaje (0-100)
            const maxPF = 5;
            const pf = Math.min(Math.max(profitFactor, 0), maxPF);
            const percentage = (pf / maxPF) * 100;
            const remaining = 100 - percentage;
            
            // Color basado en el valor
            let color;
            if (pf < 1) color = '#ff4136'; // Rojo (malo)
            else if (pf < 1.5) color = '#ffbb33'; // Amarillo (regular)
            else color = '#39ff14'; // Verde (bueno)
            
            profitFactorGaugeChart = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    datasets: [{
                        data: [percentage, remaining],
                        backgroundColor: [
                            color,
                            'rgba(42, 42, 42, 0.3)'
                        ],
                        borderWidth: 0,
                        circumference: 180,
                        rotation: 270
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    cutout: '75%',
                    plugins: {
                        legend: { display: false },
                        tooltip: { enabled: false }
                    }
                }
            });
        }
        
        // Gauge Chart: P&L Bruto
        let plBrutoGaugeChart = null;
        function updatePlBrutoGauge(grossPL, totalWin, totalLoss) {
            const canvas = document.getElementById('analytics-pl-bruto-gauge');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            if (plBrutoGaugeChart) plBrutoGaugeChart.destroy();
            
            // Calcular porcentaje basado en la proporción de ganancia vs pérdida
            const totalAbsolute = Math.abs(totalWin) + Math.abs(totalLoss);
            let percentage = 50; // Neutral por defecto
            
            if (totalAbsolute > 0) {
                // Si hay más ganancias que pérdidas, el porcentaje sube de 50%
                // Si hay más pérdidas, el porcentaje baja de 50%
                percentage = (Math.abs(totalWin) / totalAbsolute) * 100;
            }
            
            const remaining = 100 - percentage;
            const color = grossPL >= 0 ? '#39ff14' : '#ff4136';
            
            plBrutoGaugeChart = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    datasets: [{
                        data: [percentage, remaining],
                        backgroundColor: [
                            color,
                            'rgba(42, 42, 42, 0.3)'
                        ],
                        borderWidth: 0,
                        circumference: 180,
                        rotation: 270
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    cutout: '75%',
                    plugins: {
                        legend: { display: false },
                        tooltip: { enabled: false }
                    }
                }
            });
        }
        
        // Gauge Chart: P&L Neto
        let plNetoGaugeChart = null;
        function updatePlNetoGauge(netPL, totalWin, totalLoss, totalFees) {
            const canvas = document.getElementById('analytics-pl-neto-gauge');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            if (plNetoGaugeChart) plNetoGaugeChart.destroy();
            
            // Calcular porcentaje considerando el impacto de las comisiones
            const totalAbsolute = Math.abs(totalWin) + Math.abs(totalLoss);
            let percentage = 50; // Neutral por defecto
            
            if (totalAbsolute > 0) {
                // Porcentaje basado en el P&L neto respecto al total
                const netRatio = (totalWin - totalFees) / totalAbsolute;
                percentage = Math.max(0, Math.min(100, (netRatio + 1) * 50)); // Normalizar a 0-100
            }
            
            const remaining = 100 - percentage;
            const color = netPL >= 0 ? '#39ff14' : '#ff4136';
            
            plNetoGaugeChart = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    datasets: [{
                        data: [percentage, remaining],
                        backgroundColor: [
                            color,
                            'rgba(42, 42, 42, 0.3)'
                        ],
                        borderWidth: 0,
                        circumference: 180,
                        rotation: 270
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    cutout: '75%',
                    plugins: {
                        legend: { display: false },
                        tooltip: { enabled: false }
                    }
                }
            });
        }
        
        // --- Rendimiento de Última Semana (Lunes a Domingo) - Tabla limpia ---
        function populateAnalyticsLastWeekPerformance(operations, accountId) {
            const tbody = document.getElementById('analytics-lastweek-performance');
            if (!tbody) return;
            tbody.innerHTML = '';
            const currencySelect = document.getElementById('analytics-currency-select');
            const displayCurrency = currencySelect ? currencySelect.value : 'USD';
            const targetCurrency = displayCurrency === '%' ? DB.settings.defaultCurrency : displayCurrency;

            const today = new Date();
            const utcToday = new Date(Date.UTC(today.getUTCFullYear(), today.getUTCMonth(), today.getUTCDate()));
            let dayOfWeek = utcToday.getUTCDay();
            let daysSinceLastMonday = (dayOfWeek + 6) % 7 + 7;
            const lastMonday = new Date(utcToday);
            lastMonday.setUTCDate(utcToday.getUTCDate() - daysSinceLastMonday);
            const lastSunday = new Date(lastMonday);
            lastSunday.setUTCDate(lastMonday.getUTCDate() + 6);

            const daysOfWeek = ['Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sábado', 'Domingo'];
            const weekData = daysOfWeek.map((name, i) => {
                const date = new Date(lastMonday);
                date.setUTCDate(lastMonday.getUTCDate() + i);
                return {
                    name,
                    date: date.toISOString().slice(0, 10),
                    pl: 0,
                    trades: 0,
                    wins: 0,
                    losses: 0
                };
            });

            const weekOps = operations.filter(op => {
                const opDate = new Date(op.date + 'T00:00:00Z');
                return opDate >= lastMonday && opDate <= lastSunday;
            });

            console.log('📅 Tabla semana - Operaciones totales:', operations.length, 'Operaciones de la semana:', weekOps.length);
            console.log('📅 Rango:', lastMonday.toISOString().split('T')[0], 'a', lastSunday.toISOString().split('T')[0]);

            // Agrupar operaciones por día
            weekData.forEach(day => { day.operations = []; });
            
            weekOps.forEach(op => {
                const opDate = new Date(op.date + 'T00:00:00Z');
                const dayIdx = Math.floor((opDate - lastMonday) / (24*60*60*1000));
                if (dayIdx >= 0 && dayIdx < 7) {
                    weekData[dayIdx].operations.push(op);
                }
            });
            
            // Calcular P&L NETO por día usando calculateMetrics
            weekData.forEach(day => {
                if (day.operations && day.operations.length > 0) {
                    const dayMetrics = calculateMetrics(day.operations, accountId);
                    const grossPL = dayMetrics.totalWin + dayMetrics.totalLoss;
                    day.pl = grossPL - dayMetrics.totalFees; // P&L NETO
                    day.trades = dayMetrics.totalTrades;
                    day.wins = dayMetrics.winningTrades;
                    day.losses = dayMetrics.losingTrades;
                }
            });

            let initialBalanceForPercent = 0;
            if (displayCurrency === '%') {
                if (accountId === 'all') {
                    initialBalanceForPercent = DB.accounts.reduce((sum, acc) => sum + convertCurrency(acc.initialBalance, acc.currency, targetCurrency), 0);
                } else {
                    const account = DB.accounts.find(a => a.id === accountId);
                    if (account) initialBalanceForPercent = convertCurrency(account.initialBalance, account.currency, targetCurrency);
                }
            }

            // Botón para ver análisis completo de la semana
            const weekTotalRow = document.createElement('tr');
            weekTotalRow.className = 'border-t-2 border-primary bg-surface-light cursor-pointer hover:bg-surface transition-colors';
            const weekTotalPL = weekData.reduce((sum, d) => sum + d.pl, 0);
            const weekTotalTrades = weekData.reduce((sum, d) => sum + d.trades, 0);
            const weekTotalWins = weekData.reduce((sum, d) => sum + d.wins, 0);
            const weekTotalLosses = weekData.reduce((sum, d) => sum + d.losses, 0);
            const weekWinRate = (weekTotalWins + weekTotalLosses) > 0 ? (weekTotalWins / (weekTotalWins + weekTotalLosses)) * 100 : 0;
            
            let weekTotalPLDisplay;
            if (displayCurrency === '%') {
                weekTotalPLDisplay = initialBalanceForPercent !== 0 ? ((weekTotalPL / initialBalanceForPercent) * 100).toFixed(2) + '%' : '0.00%';
            } else {
                weekTotalPLDisplay = formatCurrency(weekTotalPL, targetCurrency, targetCurrency);
            }
            const weekPLClass = weekTotalPL > 0 ? 'text-green' : (weekTotalPL < 0 ? 'text-red' : 'text-text-secondary');
            
            weekTotalRow.innerHTML = `
                <td class="py-3 text-xs font-bold text-primary">TOTAL SEMANA</td>
                <td class="py-3 text-right ${weekPLClass} font-bold text-xs">${weekTotalPLDisplay}</td>
                <td class="py-3 text-right font-bold text-xs">${weekTotalTrades}</td>
                <td class="py-3 text-right font-bold text-xs">${weekWinRate > 0 ? weekWinRate.toFixed(0) + '%' : '-'}</td>
            `;
            
            weekTotalRow.addEventListener('click', () => {
                openAnalyticsDetailModal('week', 
                    { startDate: lastMonday.toISOString().slice(0, 10), endDate: lastSunday.toISOString().slice(0, 10) },
                    `Semana del ${lastMonday.toISOString().slice(0, 10)} al ${lastSunday.toISOString().slice(0, 10)}`
                );
            });
            
            tbody.appendChild(weekTotalRow);
            
            // Mostrar TODOS los días de la semana (incluso si no hay trades)
            weekData.forEach((day) => {
                const winRate = (day.wins + day.losses) > 0 ? (day.wins / (day.wins + day.losses)) * 100 : 0;
                let plDisplay;
                if (displayCurrency === '%') {
                    plDisplay = initialBalanceForPercent !== 0 ? ((day.pl / initialBalanceForPercent) * 100).toFixed(2) + '%' : '0.00%';
                } else {
                    plDisplay = formatCurrency(day.pl, targetCurrency, targetCurrency);
                }
                
                const plClass = day.pl > 0 ? 'text-green' : (day.pl < 0 ? 'text-red' : 'text-text-secondary');
                const dayNumber = day.date.split('-')[2];
                
                const row = document.createElement('tr');
                row.className = 'border-b border-surface hover:bg-surface-light transition-colors';
                if (day.trades > 0) {
                    row.classList.add('cursor-pointer');
                    row.addEventListener('click', () => openAnalyticsDetailModal('date', day.date, `${day.name} ${day.date}`));
                }
                
                row.innerHTML = `
                    <td class="py-3 text-xs">
                        ${day.name} <span class="text-green font-bold">${dayNumber}</span>
                    </td>
                    <td class="py-3 text-right ${plClass} font-semibold text-xs">${plDisplay}</td>
                    <td class="py-3 text-right text-xs">${day.trades}</td>
                    <td class="py-3 text-right text-xs ${winRate >= 50 ? 'text-green' : 'text-red'}">${winRate > 0 ? winRate.toFixed(0) + '%' : '-'}</td>
                `;
                
                tbody.appendChild(row);
            });
        }

        let analyticsSparklineChart = null;
        function updateAnalyticsSparkline(operations) {
            const canvas = document.getElementById('analytics-sparkline-chart');
            if (!canvas) return;
            if (typeof Chart === 'undefined') return;

            const sorted = [...operations].sort((a,b) => new Date(a.date) - new Date(b.date));
            let cumulative = 0;
            const labels = [];
            const data = [];
            sorted.forEach(op => {
                const rawPL = op.manualPL ?? op.pl ?? 0;
                const plInDefault = op.currency && op.currency !== DB.settings.defaultCurrency ? convertCurrency(rawPL, op.currency, DB.settings.defaultCurrency) : rawPL;
                cumulative += plInDefault;
                labels.push(op.date);
                data.push(cumulative);
            });
            if (data.length === 0) { labels.push(new Date().toISOString().split('T')[0]); data.push(0); }

            if (analyticsSparklineChart) analyticsSparklineChart.destroy();
            const ctx = canvas.getContext('2d');
            analyticsSparklineChart = new Chart(ctx, { type: 'line', data: { labels, datasets: [{ data, borderColor: '#10b981', backgroundColor: 'rgba(16,185,129,0.08)', borderWidth: 2, fill: true, pointRadius: 0 }] }, options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } }, scales: { x: { display: false }, y: { display: false } } } });
        }

        function updateAnalyticsPFGauge(pf) {
            const gaugeEl = document.getElementById('analytics-pf-gauge');
            if (gaugeEl) {
                let percentage = 0;
                if (pf >= 3) percentage = 100;
                else if (pf >= 2) percentage = 66 + (pf - 2) * 34;
                else if (pf >= 1) percentage = 33 + (pf - 1) * 33;
                else percentage = pf * 33;
                gaugeEl.style.width = Math.min(100, Math.max(0, percentage)) + '%';
            }
        }

        function updateAnalyticsWinDonut(winRate, wins, losses) {
            const circleEl = document.getElementById('analytics-win-circle');
            const textEl = document.getElementById('analytics-win-text');
            const winsEl = document.getElementById('analytics-wins');
            const lossesEl = document.getElementById('analytics-losses');
            if (circleEl) {
                const dash = `${winRate.toFixed(0)}, 100`;
                circleEl.setAttribute('stroke-dasharray', dash);
                let color = '#ef4444';
                if (winRate >= 60) color = '#22c55e';
                else if (winRate >= 40) color = '#eab308';
                circleEl.setAttribute('stroke', color);
            }
            if (textEl) textEl.textContent = Math.round(winRate) + '%';
            if (winsEl) winsEl.textContent = wins;
            if (lossesEl) lossesEl.textContent = losses;
        }

        let analyticsHourlyPerformanceChart = null;
        function updateHourlyPerformanceChart(operations, chartId) {
            const ctx = document.getElementById(chartId)?.getContext('2d');
            if (!ctx) return;

            if (analyticsHourlyPerformanceChart) {
                analyticsHourlyPerformanceChart.destroy();
            }

            const hourlyPerformance = Array(24).fill(0);
            operations.forEach(op => {
                if (op.entryTime) {
                    try {
                        const hour = parseInt(op.entryTime.split(':')[0], 10);
                        if (!isNaN(hour) && hour >= 0 && hour <= 23) {
                             hourlyPerformance[hour] += convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency);
                        }
                    } catch(e) { /* ignore invalid time */ }
                }
            });

            const labels = Array.from({length: 24}, (_, i) => `${String(i).padStart(2, '0')}:00`);

            analyticsHourlyPerformanceChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'P/L por Hora',
                        data: hourlyPerformance,
                        backgroundColor: hourlyPerformance.map(v => v >= 0 ? 'rgba(57, 255, 20, 0.8)' : 'rgba(255, 65, 54, 0.8)'),
                        borderColor: hourlyPerformance.map(v => v >= 0 ? '#39FF14' : '#FF4136'),
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { 
                        legend: { 
                            display: true,
                            labels: { color: '#FFFFFF' }
                        } 
                    },
                    scales: {
                        x: { grid: { display: false }, ticks: { color: '#FFFFFF', maxRotation: 90, minRotation: 45, autoSkip: true, maxTicksLimit: 12 } },
                        y: { grid: { color: '#2a2a2a' }, ticks: { color: '#FFFFFF' } }
                    }
                }
            });
        }


        function populateAnalyticsDailyPerformance(operations, accountId) {
            const tbody = document.getElementById('analytics-daily-performance');
            if (!tbody) return;
            tbody.innerHTML = '';
            const currencySelect = document.getElementById('analytics-currency-select');
            const displayCurrency = currencySelect ? currencySelect.value : 'USD';
            const targetCurrency = displayCurrency === '%' ? DB.settings.defaultCurrency : displayCurrency;

            const daysOfWeek = ['Domingo', 'Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sábado'];
            const dailyPerformance = daysOfWeek.map(() => ({ operations: [], trades: 0, wins: 0, losses: 0, pl: 0 }));

            // Agrupar operaciones por día de la semana
            operations.forEach(op => {
                try {
                    const dayIndex = new Date(op.date + 'T00:00:00Z').getUTCDay();
                    if (dayIndex >= 0 && dayIndex < dailyPerformance.length && dailyPerformance[dayIndex]) {
                        dailyPerformance[dayIndex].operations.push(op);
                    }
                } catch (error) {
                    console.error('❌ Error agrupando operación por día:', error, op);
                }
            });
            
            // Calcular P&L NETO por día usando calculateMetrics
            dailyPerformance.forEach((dayData, idx) => {
                if (!dayData) {
                    console.error('❌ dayData undefined en índice:', idx);
                    return;
                }
                if (dayData.operations && dayData.operations.length > 0) {
                    try {
                        const dayMetrics = calculateMetrics(dayData.operations, accountId);
                        const grossPL = dayMetrics.totalWin + dayMetrics.totalLoss;
                        dayData.pl = grossPL - dayMetrics.totalFees; // P&L NETO
                        dayData.trades = dayMetrics.totalTrades;
                        dayData.wins = dayMetrics.winningTrades;
                        dayData.losses = dayMetrics.losingTrades;
                    } catch (error) {
                        console.error('❌ Error calculando métricas del día:', error);
                        dayData.pl = 0;
                    }
                } else {
                    dayData.pl = 0;
                }
            });

            let initialBalanceForPercent = 0;
            if (displayCurrency === '%') {
                if (accountId === 'all') {
                    initialBalanceForPercent = DB.accounts.reduce((sum, acc) => sum + convertCurrency(acc.initialBalance, acc.currency, targetCurrency), 0);
                } else {
                    const account = DB.accounts.find(a => a.id === accountId);
                    if (account) initialBalanceForPercent = convertCurrency(account.initialBalance, account.currency, targetCurrency);
                }
            }

            daysOfWeek.forEach((dayName, index) => {
                const dayData = dailyPerformance[index];
                if (dayData.trades === 0) return; // No mostrar días sin operaciones

                const winRate = (dayData.wins + dayData.losses) > 0 ? (dayData.wins / (dayData.wins + dayData.losses)) * 100 : 0;
                let plDisplay;
                if (displayCurrency === '%') {
                    plDisplay = initialBalanceForPercent !== 0 ? ((dayData.pl / initialBalanceForPercent) * 100).toFixed(2) + '%' : '0.00%';
                } else {
                    plDisplay = formatCurrency(dayData.pl, targetCurrency, targetCurrency);
                }
                const plClass = dayData.pl > 0 ? 'text-positive' : (dayData.pl < 0 ? 'text-negative' : 'text-neutral');

                const row = document.createElement('tr');
                row.dataset.dayIndex = index; // Guardar el índice del día
                row.innerHTML = `
                    <td>${dayName}</td>
                    <td class="${plClass}">${plDisplay}</td>
                    <td>${dayData.trades}</td>
                    <td class="text-green">${winRate.toFixed(1)}%</td>
                `;
                // NUEVO: Añadir listener para abrir modal
                row.addEventListener('click', () => openAnalyticsDetailModal('dayOfWeek', index, dayName));
                tbody.appendChild(row);
            });
        }

        function populateAnalyticsMonthlyPerformance(operations, accountId) {
            console.log(`📅 [populateAnalyticsMonthlyPerformance] Calculando rendimiento mensual para ${operations.length} operaciones`);
            
            const tbody = document.getElementById('analytics-monthly-performance');
            if (!tbody) return;
            tbody.innerHTML = '';
            const currencySelect = document.getElementById('analytics-currency-select');
            const displayCurrency = currencySelect ? currencySelect.value : 'USD';
            const targetCurrency = displayCurrency === '%' ? DB.settings.defaultCurrency : displayCurrency;

            const monthlyPerformance = {};

            // Debug: Ver todas las fechas
            console.log(`📅 [DEBUG] Fechas de operaciones:`, operations.map(op => op.date).sort());

            // Agrupar operaciones por mes
            operations.forEach(op => {
                // Manejar tanto fechas "YYYY-MM-DD" como "YYYY-MM-DDTHH:MM:SS.000Z"
                let dateStr = op.date;
                if (typeof dateStr === 'string' && dateStr.includes('T')) {
                    // Ya tiene hora, usar directamente
                    dateStr = dateStr;
                } else {
                    // Solo tiene fecha, agregar hora UTC
                    dateStr = dateStr + 'T00:00:00Z';
                }
                
                const opDate = new Date(dateStr);
                
                // Validar fecha
                if (isNaN(opDate.getTime())) {
                    console.warn(`⚠️ Fecha inválida en operación ${op.id}: "${op.date}"`);
                    return; // Saltar esta operación
                }
                
                const monthKey = `${opDate.getUTCFullYear()}-${String(opDate.getUTCMonth() + 1).padStart(2, '0')}`;
                
                console.log(`📅 [DEBUG] Op ${op.id}: fecha="${op.date}", monthKey="${monthKey}", pl=${op.pl}`);
                
                if (!monthlyPerformance[monthKey]) {
                    monthlyPerformance[monthKey] = { 
                        operations: [], 
                        year: opDate.getUTCFullYear(), 
                        monthIndex: opDate.getUTCMonth() 
                    };
                }
                
                monthlyPerformance[monthKey].operations.push(op);
            });
            
            // Para cada mes, usar calculateMetrics() para obtener valores consistentes
            Object.keys(monthlyPerformance).forEach(monthKey => {
                const monthData = monthlyPerformance[monthKey];
                const monthOps = monthData.operations;
                
                console.log(`📅 [Mes ${monthKey}] Calculando para ${monthOps.length} operaciones`);
                
                // Usar la MISMA función que Analytics para consistencia
                const monthMetrics = calculateMetrics(monthOps, accountId);
                
                // P/L NETO (Bruto - Fees)
                const grossPL = monthMetrics.totalWin + monthMetrics.totalLoss;
                const netPL = grossPL - monthMetrics.totalFees;
                
                console.log(`📅 [Mes ${monthKey}] Bruto: ${grossPL}, Fees: ${monthMetrics.totalFees}, Neto: ${netPL}`);
                
                monthData.pl = netPL;
                monthData.trades = monthMetrics.totalTrades;
                monthData.wins = monthMetrics.winningTrades;
                monthData.losses = monthMetrics.losingTrades;
            });

            let initialBalanceForPercent = 0;
            if (displayCurrency === '%') {
                 if (accountId === 'all') {
                    initialBalanceForPercent = DB.accounts.reduce((sum, acc) => sum + convertCurrency(acc.initialBalance, acc.currency, targetCurrency), 0);
                } else {
                    const account = DB.accounts.find(a => a.id === accountId);
                    if (account) initialBalanceForPercent = convertCurrency(account.initialBalance, account.currency, targetCurrency);
                }
            }

            const sortedMonths = Object.keys(monthlyPerformance).sort().reverse();
            console.log(`📅 [TABLA] Meses a renderizar:`, sortedMonths);
            
            sortedMonths.forEach(monthKey => {
                const monthData = monthlyPerformance[monthKey];
                const winRate = (monthData.wins + monthData.losses) > 0 ? (monthData.wins / (monthData.wins + monthData.losses)) * 100 : 0;
                let plDisplay;
                 if (displayCurrency === '%') {
                    plDisplay = initialBalanceForPercent !== 0 ? ((monthData.pl / initialBalanceForPercent) * 100).toFixed(2) + '%' : '0.00%';
                } else {
                    plDisplay = formatCurrency(monthData.pl, targetCurrency, targetCurrency);
                }
                const plClass = monthData.pl > 0 ? 'text-positive' : (monthData.pl < 0 ? 'text-negative' : 'text-neutral');
                const fullMonthNames = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'];
                const monthLabel = `${fullMonthNames[monthData.monthIndex]} ${monthData.year}`;

                console.log(`📅 [TABLA] Renderizando fila: ${monthLabel} - P/L: ${plDisplay} - Trades: ${monthData.trades}`);

                const row = document.createElement('tr');
                row.dataset.monthKey = monthKey; // Guardar la clave del mes
                row.innerHTML = `
                    <td>${monthLabel}</td>
                    <td class="${plClass}">${plDisplay}</td>
                    <td>${monthData.trades}</td>
                    <td class="text-green">${winRate.toFixed(1)}%</td>
                `;
                // NUEVO: Añadir listener para abrir modal
                row.addEventListener('click', () => openAnalyticsDetailModal('month', monthKey, monthLabel));
                tbody.appendChild(row);
                
                console.log(`✅ [TABLA] Fila añadida para ${monthLabel}`);
            });
             if (Object.keys(monthlyPerformance).length === 0) {
                tbody.innerHTML = '<tr><td colspan="4" class="text-center text-text-secondary py-3">No hay datos</td></tr>';
            }
        }

        // --- Rendimiento de la Semana (últimas semanas) ---
        function populateAnalyticsWeeklyPerformance(operations, accountId) {
            const tbody = document.getElementById('analytics-weekly-performance');
            if (!tbody) return;
            tbody.innerHTML = '';
            const currencySelect = document.getElementById('analytics-currency-select');
            const displayCurrency = currencySelect ? currencySelect.value : 'USD';
            const targetCurrency = displayCurrency === '%' ? DB.settings.defaultCurrency : displayCurrency;

            const weeklyPerformance = {};

            // Agrupar operaciones por semana (ISO week)
            operations.forEach(op => {
                const opDate = new Date(op.date + 'T00:00:00Z');
                if (isNaN(opDate.getTime())) return;

                // Obtener el lunes de esa semana
                const day = opDate.getUTCDay();
                const diff = opDate.getUTCDate() - day + (day === 0 ? -6 : 1);
                const monday = new Date(opDate);
                monday.setUTCDate(diff);
                monday.setUTCHours(0, 0, 0, 0);
                
                const weekKey = monday.toISOString().slice(0, 10);

                if (!weeklyPerformance[weekKey]) {
                    weeklyPerformance[weekKey] = { operations: [], monday: new Date(monday) };
                }
                weeklyPerformance[weekKey].operations.push(op);
            });

            // Calcular métricas para cada semana
            Object.keys(weeklyPerformance).forEach(weekKey => {
                const weekData = weeklyPerformance[weekKey];
                const weekOps = weekData.operations;
                const weekMetrics = calculateMetrics(weekOps, accountId);
                const grossPL = weekMetrics.totalWin + weekMetrics.totalLoss;
                weekData.pl = grossPL - weekMetrics.totalFees;
                weekData.trades = weekMetrics.totalTrades;
                weekData.wins = weekMetrics.winningTrades;
                weekData.losses = weekMetrics.losingTrades;
            });

            let initialBalanceForPercent = 0;
            if (displayCurrency === '%') {
                if (accountId === 'all') {
                    initialBalanceForPercent = DB.accounts.reduce((sum, acc) => sum + convertCurrency(acc.initialBalance, acc.currency, targetCurrency), 0);
                } else {
                    const account = DB.accounts.find(a => a.id === accountId);
                    if (account) initialBalanceForPercent = convertCurrency(account.initialBalance, account.currency, targetCurrency);
                }
            }

            const sortedWeeks = Object.keys(weeklyPerformance).sort().reverse();
            
            sortedWeeks.forEach(weekKey => {
                const weekData = weeklyPerformance[weekKey];
                const winRate = (weekData.wins + weekData.losses) > 0 ? (weekData.wins / (weekData.wins + weekData.losses)) * 100 : 0;
                let plDisplay;
                if (displayCurrency === '%') {
                    plDisplay = initialBalanceForPercent !== 0 ? ((weekData.pl / initialBalanceForPercent) * 100).toFixed(2) + '%' : '0.00%';
                } else {
                    plDisplay = formatCurrency(weekData.pl, targetCurrency, targetCurrency);
                }
                const plClass = weekData.pl > 0 ? 'text-positive' : (weekData.pl < 0 ? 'text-negative' : 'text-neutral');
                
                const monday = weekData.monday;
                const sunday = new Date(monday);
                sunday.setUTCDate(monday.getUTCDate() + 6);
                
                // Formatear fechas como DD-MM-YY
                const formatShortDate = (date) => {
                    const d = new Date(date);
                    const day = String(d.getUTCDate()).padStart(2, '0');
                    const month = String(d.getUTCMonth() + 1).padStart(2, '0');
                    const year = String(d.getUTCFullYear()).slice(-2);
                    return `${day}-${month}-${year}`;
                };
                
                const weekLabel = `${formatShortDate(monday)} al ${formatShortDate(sunday)}`;

                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${weekLabel}</td>
                    <td class="${plClass}">${plDisplay}</td>
                    <td>${weekData.trades}</td>
                    <td class="text-green">${winRate.toFixed(1)}%</td>
                `;
                row.addEventListener('click', () => openAnalyticsDetailModal('week', { startDate: weekKey, endDate: sunday.toISOString().slice(0, 10) }, weekLabel));
                tbody.appendChild(row);
            });

            if (Object.keys(weeklyPerformance).length === 0) {
                tbody.innerHTML = '<tr><td colspan="4" class="text-center text-text-secondary py-3">No hay datos</td></tr>';
            }
        }

        // --- Rendimiento por Trimestre ---
        function populateAnalyticsQuarterlyPerformance(operations, accountId) {
            const tbody = document.getElementById('analytics-quarterly-performance');
            if (!tbody) return;
            tbody.innerHTML = '';
            const currencySelect = document.getElementById('analytics-currency-select');
            const displayCurrency = currencySelect ? currencySelect.value : 'USD';
            const targetCurrency = displayCurrency === '%' ? DB.settings.defaultCurrency : displayCurrency;

            const quarterlyPerformance = {};

            // Agrupar operaciones por trimestre
            operations.forEach(op => {
                const opDate = new Date(op.date + 'T00:00:00Z');
                if (isNaN(opDate.getTime())) return;

                const year = opDate.getUTCFullYear();
                const month = opDate.getUTCMonth();
                const quarter = Math.floor(month / 3) + 1;
                const quarterKey = `${year}-Q${quarter}`;

                if (!quarterlyPerformance[quarterKey]) {
                    quarterlyPerformance[quarterKey] = { operations: [], year, quarter };
                }
                quarterlyPerformance[quarterKey].operations.push(op);
            });

            // Calcular métricas para cada trimestre
            Object.keys(quarterlyPerformance).forEach(quarterKey => {
                const quarterData = quarterlyPerformance[quarterKey];
                const quarterOps = quarterData.operations;
                const quarterMetrics = calculateMetrics(quarterOps, accountId);
                const grossPL = quarterMetrics.totalWin + quarterMetrics.totalLoss;
                quarterData.pl = grossPL - quarterMetrics.totalFees;
                quarterData.trades = quarterMetrics.totalTrades;
                quarterData.wins = quarterMetrics.winningTrades;
                quarterData.losses = quarterMetrics.losingTrades;
            });

            let initialBalanceForPercent = 0;
            if (displayCurrency === '%') {
                if (accountId === 'all') {
                    initialBalanceForPercent = DB.accounts.reduce((sum, acc) => sum + convertCurrency(acc.initialBalance, acc.currency, targetCurrency), 0);
                } else {
                    const account = DB.accounts.find(a => a.id === accountId);
                    if (account) initialBalanceForPercent = convertCurrency(account.initialBalance, account.currency, targetCurrency);
                }
            }

            const sortedQuarters = Object.keys(quarterlyPerformance).sort().reverse();
            
            sortedQuarters.forEach(quarterKey => {
                const quarterData = quarterlyPerformance[quarterKey];
                const winRate = (quarterData.wins + quarterData.losses) > 0 ? (quarterData.wins / (quarterData.wins + quarterData.losses)) * 100 : 0;
                let plDisplay;
                if (displayCurrency === '%') {
                    plDisplay = initialBalanceForPercent !== 0 ? ((quarterData.pl / initialBalanceForPercent) * 100).toFixed(2) + '%' : '0.00%';
                } else {
                    plDisplay = formatCurrency(quarterData.pl, targetCurrency, targetCurrency);
                }
                const plClass = quarterData.pl > 0 ? 'text-positive' : (quarterData.pl < 0 ? 'text-negative' : 'text-neutral');
                
                const quarterNames = {
                    1: 'Q1 (Ene-Mar)',
                    2: 'Q2 (Abr-Jun)',
                    3: 'Q3 (Jul-Sep)',
                    4: 'Q4 (Oct-Dic)'
                };
                const quarterLabel = `${quarterNames[quarterData.quarter]} ${quarterData.year}`;

                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${quarterLabel}</td>
                    <td class="${plClass}">${plDisplay}</td>
                    <td>${quarterData.trades}</td>
                    <td class="text-green">${winRate.toFixed(1)}%</td>
                `;
                
                // Añadir listener para abrir modal con detalles del trimestre
                row.addEventListener('click', () => openAnalyticsDetailModal('quarter', quarterKey, quarterLabel));
                
                tbody.appendChild(row);
            });

            if (Object.keys(quarterlyPerformance).length === 0) {
                tbody.innerHTML = '<tr><td colspan="4" class="text-center text-text-secondary py-3">No hay datos</td></tr>';
            }
        }

        // --- NUEVO: Funciones para el Modal de Detalles de Analytics ---
        function openAnalyticsDetailModal(type, value, titleLabel, accountOverride = null) {
            const modal = document.getElementById('analytics-detail-modal');
            document.getElementById('analytics-detail-title').textContent = `Análisis de ${titleLabel}`;

            // 1. Filtrar las operaciones
            let periodOperations = [];
            // Si se proporciona accountOverride, usarlo; si no, usar el selector de analytics
            const selectedAccount = accountOverride || document.getElementById('analytics-account-select').value;
            
            // Para análisis de día específico, usar todas las operaciones sin filtro global
            // Para otros tipos, usar el filtro global
            let sourceOps;
            if (type === 'date') {
                sourceOps = DB.operations; // Usar todas las operaciones sin filtro global para análisis de día
            } else {
                sourceOps = applyDateFilterToData(DB.operations); // Usar operaciones ya filtradas por fecha global
            }
            
            if (selectedAccount !== 'all') {
                sourceOps = sourceOps.filter(op => op.accountId === selectedAccount);
            }

            if (type === 'month') {
                const [year, month] = value.split('-');
                periodOperations = sourceOps.filter(op => op.date.startsWith(value));
            } else if (type === 'quarter') {
                // value es "YYYY-Q1", "YYYY-Q2", etc.
                const [year, quarterStr] = value.split('-Q');
                const quarter = parseInt(quarterStr);
                const startMonth = (quarter - 1) * 3;
                const endMonth = startMonth + 2;
                
                periodOperations = sourceOps.filter(op => {
                    const opDate = new Date(op.date + 'T00:00:00Z');
                    const opYear = opDate.getUTCFullYear();
                    const opMonth = opDate.getUTCMonth();
                    return opYear === parseInt(year) && opMonth >= startMonth && opMonth <= endMonth;
                });
            } else if (type === 'week') {
                // value es un objeto con { startDate, endDate }
                const startDate = new Date(value.startDate + 'T00:00:00Z');
                const endDate = new Date(value.endDate + 'T00:00:00Z');
                periodOperations = sourceOps.filter(op => {
                    const opDate = new Date(op.date + 'T00:00:00Z');
                    return opDate >= startDate && opDate <= endDate;
                });
            } else if (type === 'dayOfWeek') {
                periodOperations = sourceOps.filter(op => new Date(op.date + 'T00:00:00Z').getUTCDay() === value);
            } else if (type === 'date') {
                // Filtrar por fecha exacta (YYYY-MM-DD)
                periodOperations = sourceOps.filter(op => op.date === value);
                console.log(`[openAnalyticsDetailModal] Análisis de día ${value}:`);
                console.log(`[openAnalyticsDetailModal] - Total operaciones en DB: ${DB.operations.length}`);
                console.log(`[openAnalyticsDetailModal] - Operaciones después filtro cuenta: ${sourceOps.length}`);
                console.log(`[openAnalyticsDetailModal] - Operaciones para la fecha ${value}: ${periodOperations.length}`);
                if (periodOperations.length > 0) {
                    console.log(`[openAnalyticsDetailModal] - Primera operación:`, periodOperations[0]);
                }
                // Verificar fechas disponibles
                const availableDates = [...new Set(DB.operations.map(op => op.date))].sort();
                console.log(`[openAnalyticsDetailModal] - Fechas disponibles:`, availableDates.slice(0, 10), '...');
            }

            // 2. Calcular Métricas para el período
            const currencySelect = document.getElementById('analytics-currency-select');
            const displayCurrency = currencySelect ? currencySelect.value : 'USD';
            const metrics = calculateMetrics(periodOperations, selectedAccount);
            const advancedMetrics = calculateAdvancedMetrics(periodOperations, selectedAccount);
            const extraMetrics = calculateExtraAnalytics(periodOperations, selectedAccount);

            // AHORA calculateMetrics devuelve P/L BRUTO + totalFees por separado
            const grossPL = metrics.totalWin + metrics.totalLoss;
            const totalFees = metrics.totalFees;
            const netPL = grossPL - totalFees;
            
            const avgFee = metrics.totalTrades > 0 ? totalFees / metrics.totalTrades : 0;

            // 3. Poblar el modal
            const plEl = document.getElementById('analytics-detail-pl');
            plEl.textContent = formatCurrency(grossPL, DB.settings.defaultCurrency, displayCurrency);
            plEl.className = `text-3xl font-bold ${grossPL >= 0 ? 'text-positive' : 'text-negative'}`;
            document.getElementById('analytics-detail-winrate').textContent = `${metrics.winRate.toFixed(1)}%`;
            document.getElementById('analytics-detail-pf').textContent = isFinite(metrics.profitFactor) ? metrics.profitFactor.toFixed(2) : "∞";
            document.getElementById('analytics-detail-trades').textContent = metrics.totalTrades;

            // Mostrar comisiones
            document.getElementById('analytics-detail-fees').textContent = formatCurrency(totalFees, DB.settings.defaultCurrency, displayCurrency);

            const netPlEl = document.getElementById('analytics-detail-net-pl');
            netPlEl.textContent = formatCurrency(netPL, DB.settings.defaultCurrency, displayCurrency);
            netPlEl.className = `font-bold ${netPL >= 0 ? 'text-green' : 'text-red'}`;

            document.getElementById('analytics-detail-avg-win').textContent = formatCurrency(advancedMetrics.avgWin, DB.settings.defaultCurrency, displayCurrency);
            document.getElementById('analytics-detail-avg-loss').textContent = formatCurrency(advancedMetrics.avgLoss, DB.settings.defaultCurrency, displayCurrency);
            document.getElementById('analytics-detail-avg-fee').textContent = formatCurrency(avgFee, DB.settings.defaultCurrency, displayCurrency);
            document.getElementById('analytics-detail-largest-win').textContent = formatCurrency(advancedMetrics.largestWin, DB.settings.defaultCurrency, displayCurrency);
            document.getElementById('analytics-detail-largest-loss').textContent = formatCurrency(advancedMetrics.largestLoss, DB.settings.defaultCurrency, displayCurrency);

            const wLRatioEl = document.getElementById('analytics-detail-w-l-ratio');
            wLRatioEl.textContent = isFinite(extraMetrics.avgWLRatio) ? extraMetrics.avgWLRatio.toFixed(2) : '∞';
            wLRatioEl.className = `font-semibold ${extraMetrics.avgWLRatio >= 1 ? 'text-green' : 'text-negative'}`;

            document.getElementById('analytics-detail-drawdown').textContent = formatCurrency(extraMetrics.maxDrawdownValue, extraMetrics.currencyForDD, displayCurrency);

            // Calcular R:R Promedio
            const avgRR = extraMetrics.avgWLRatio || 0;
            document.getElementById('analytics-detail-rr').textContent = isFinite(avgRR) ? avgRR.toFixed(2) : '∞';

            // Mostrar/ocultar tabs y calcular métricas del día/mes
            const tabsContainer = document.getElementById('analytics-detail-tabs-container');
            const metricasTab = document.getElementById('analytics-metricas-tab');
            const notasTab = document.getElementById('analytics-notas-tab');
            
            if (type === 'date') {
                // Mostrar tabs para análisis de día
                tabsContainer.style.display = 'block';
                if (metricasTab) metricasTab.textContent = 'Métricas del Día';
                if (notasTab) notasTab.textContent = 'Notas del Día';
                
                // Mostrar gráficas específicas del día
                const daySpecificCharts = document.getElementById('day-specific-charts-metrics');
                if (daySpecificCharts) daySpecificCharts.style.display = 'grid';
                
                // Activar el tab de "General" por defecto para análisis de día
                setTimeout(() => {
                    const generalTabBtn = document.querySelector('.analytics-detail-tab[data-target="general"]');
                    if (generalTabBtn) {
                        generalTabBtn.click();
                    }
                }, 100);
                
                // CALCULAR MÉTRICAS DEL DÍA
                
                // 1. Eficiencia del Día = (P/L Neto / Capital Total Arriesgado) × 100
                const totalRisked = periodOperations.reduce((sum, op) => sum + Math.abs(op.pl), 0);
                const efficiency = totalRisked > 0 ? (netPL / totalRisked) * 100 : 0;
                const efficiencyEl = document.getElementById('day-metric-efficiency');
                efficiencyEl.textContent = `${efficiency.toFixed(1)}%`;
                efficiencyEl.className = `text-lg font-bold ${efficiency >= 0 ? 'text-positive' : 'text-negative'}`;
                
                // 2. Duración Total Operando
                let firstTime = '23:59', lastTime = '00:00';
                periodOperations.forEach(op => {
                    const entryTime = op.entryTime || '00:00';
                    const exitTime = op.exitTime || entryTime;
                    if (entryTime < firstTime) firstTime = entryTime;
                    if (exitTime > lastTime) lastTime = exitTime;
                });
                
                const [h1, m1] = firstTime.split(':').map(Number);
                const [h2, m2] = lastTime.split(':').map(Number);
                const totalMinutes = (h2 * 60 + m2) - (h1 * 60 + m1);
                const hours = Math.floor(totalMinutes / 60);
                const minutes = totalMinutes % 60;
                document.getElementById('day-metric-duration').textContent = `${hours}h ${minutes}m`;
                
                // 3. Mejor Hora del Día (más P/L)
                const hourlyPL = {};
                periodOperations.forEach(op => {
                    const hour = (op.entryTime || '00:00').substring(0, 2);
                    if (!hourlyPL[hour]) hourlyPL[hour] = 0;
                    hourlyPL[hour] += op.pl;
                });
                
                let bestHour = '--', bestPL = -Infinity;
                let worstHour = '--', worstPL = Infinity;
                Object.keys(hourlyPL).forEach(hour => {
                    if (hourlyPL[hour] > bestPL) {
                        bestPL = hourlyPL[hour];
                        bestHour = `${hour}:00`;
                    }
                    if (hourlyPL[hour] < worstPL) {
                        worstPL = hourlyPL[hour];
                        worstHour = `${hour}:00`;
                    }
                });
                
                document.getElementById('day-metric-best-hour').textContent = bestHour;
                document.getElementById('day-metric-worst-hour').textContent = worstHour;
                
                // Inicializar event listeners de tabs
                initAnalyticsDetailTabs()
            } else if (type === 'month') {
                // Mostrar tabs para análisis de mes
                tabsContainer.style.display = 'block';
                if (metricasTab) metricasTab.textContent = 'Métricas del Mes';
                if (notasTab) notasTab.textContent = 'Notas del Mes';
                
                // Ocultar gráficas específicas del día
                const daySpecificCharts = document.getElementById('day-specific-charts-metrics');
                if (daySpecificCharts) daySpecificCharts.style.display = 'none';
                
                // Activar el tab de "General" por defecto para análisis de mes
                setTimeout(() => {
                    const generalTabBtn = document.querySelector('.analytics-detail-tab[data-target="general"]');
                    if (generalTabBtn) {
                        generalTabBtn.click();
                    }
                }, 100);
                
                // CALCULAR MÉTRICAS DEL MES
                
                // 1. Eficiencia del Mes = (P/L Neto / Capital Total Arriesgado) × 100
                const totalRisked = periodOperations.reduce((sum, op) => sum + Math.abs(op.pl), 0);
                const efficiency = totalRisked > 0 ? (netPL / totalRisked) * 100 : 0;
                const efficiencyEl = document.getElementById('day-metric-efficiency');
                if (efficiencyEl) {
                    efficiencyEl.textContent = `${efficiency.toFixed(1)}%`;
                    efficiencyEl.className = `text-lg font-bold ${efficiency >= 0 ? 'text-positive' : 'text-negative'}`;
                }
                
                // 2. Días operados en el mes
                const uniqueDays = [...new Set(periodOperations.map(op => op.date))].length;
                const durationEl = document.getElementById('day-metric-duration');
                if (durationEl) {
                    durationEl.textContent = `${uniqueDays} días`;
                }
                
                // 3. Mejor día del mes (por P/L)
                const dailyPL = {};
                periodOperations.forEach(op => {
                    const date = op.date;
                    if (!dailyPL[date]) dailyPL[date] = 0;
                    dailyPL[date] += op.pl || 0;
                });
                
                let bestDay = '--:--', bestDayPL = -Infinity;
                let worstDay = '--:--', worstDayPL = Infinity;
                Object.keys(dailyPL).forEach(date => {
                    if (dailyPL[date] > bestDayPL) {
                        bestDayPL = dailyPL[date];
                        const d = new Date(date);
                        bestDay = `${d.getDate()}/${d.getMonth() + 1}`;
                    }
                    if (dailyPL[date] < worstDayPL) {
                        worstDayPL = dailyPL[date];
                        const d = new Date(date);
                        worstDay = `${d.getDate()}/${d.getMonth() + 1}`;
                    }
                });
                
                const bestHourEl = document.getElementById('day-metric-best-hour');
                const worstHourEl = document.getElementById('day-metric-worst-hour');
                if (bestHourEl) bestHourEl.textContent = bestDay;
                if (worstHourEl) worstHourEl.textContent = worstDay;
                
                // Inicializar event listeners de tabs
                initAnalyticsDetailTabs();
            } else if (type === 'week') {
                // Mostrar tabs para análisis de semana
                tabsContainer.style.display = 'block';
                if (metricasTab) metricasTab.textContent = 'Métricas de la Semana';
                if (notasTab) notasTab.textContent = 'Notas de la Semana';
                
                // Ocultar gráficas específicas del día
                const daySpecificCharts = document.getElementById('day-specific-charts-metrics');
                if (daySpecificCharts) daySpecificCharts.style.display = 'none';
                
                // Activar el tab de "General" por defecto para análisis de semana
                setTimeout(() => {
                    const generalTabBtn = document.querySelector('.analytics-detail-tab[data-target="general"]');
                    if (generalTabBtn) {
                        generalTabBtn.click();
                    }
                }, 100);
                
                // CALCULAR MÉTRICAS DE LA SEMANA
                
                // 1. Eficiencia de la Semana = (P/L Neto / Capital Total Arriesgado) × 100
                const totalRisked = periodOperations.reduce((sum, op) => sum + Math.abs(op.pl), 0);
                const efficiency = totalRisked > 0 ? (netPL / totalRisked) * 100 : 0;
                const efficiencyEl = document.getElementById('day-metric-efficiency');
                if (efficiencyEl) {
                    efficiencyEl.textContent = `${efficiency.toFixed(1)}%`;
                    efficiencyEl.className = `text-lg font-bold ${efficiency >= 0 ? 'text-positive' : 'text-negative'}`;
                }
                
                // 2. Días operados en la semana
                const uniqueDaysWeek = [...new Set(periodOperations.map(op => op.date))].length;
                const durationEl = document.getElementById('day-metric-duration');
                if (durationEl) {
                    durationEl.textContent = `${uniqueDaysWeek} días`;
                }
                
                // 3. Mejor día de la semana (por P/L)
                const dailyPLWeek = {};
                periodOperations.forEach(op => {
                    const date = op.date;
                    if (!dailyPLWeek[date]) dailyPLWeek[date] = 0;
                    dailyPLWeek[date] += op.pl || 0;
                });
                
                let bestDayWeek = '--:--', bestDayPLWeek = -Infinity;
                let worstDayWeek = '--:--', worstDayPLWeek = Infinity;
                Object.keys(dailyPLWeek).forEach(date => {
                    if (dailyPLWeek[date] > bestDayPLWeek) {
                        bestDayPLWeek = dailyPLWeek[date];
                        const d = new Date(date);
                        bestDayWeek = `${d.getDate()}/${d.getMonth() + 1}`;
                    }
                    if (dailyPLWeek[date] < worstDayPLWeek) {
                        worstDayPLWeek = dailyPLWeek[date];
                        const d = new Date(date);
                        worstDayWeek = `${d.getDate()}/${d.getMonth() + 1}`;
                    }
                });
                
                const bestHourElWeek = document.getElementById('day-metric-best-hour');
                const worstHourElWeek = document.getElementById('day-metric-worst-hour');
                if (bestHourElWeek) bestHourElWeek.textContent = bestDayWeek;
                if (worstHourElWeek) worstHourElWeek.textContent = worstDayWeek;
                
                // Inicializar event listeners de tabs
                initAnalyticsDetailTabs();
            } else if (type === 'quarter') {
                // Mostrar tabs para análisis de trimestre
                tabsContainer.style.display = 'block';
                if (metricasTab) metricasTab.textContent = 'Métricas del Trimestre';
                if (notasTab) notasTab.textContent = 'Notas del Trimestre';
                
                // Ocultar gráficas específicas del día
                const daySpecificCharts = document.getElementById('day-specific-charts-metrics');
                if (daySpecificCharts) daySpecificCharts.style.display = 'none';
                
                // Activar el tab de "General" por defecto para análisis de trimestre
                setTimeout(() => {
                    const generalTabBtn = document.querySelector('.analytics-detail-tab[data-target="general"]');
                    if (generalTabBtn) {
                        generalTabBtn.click();
                    }
                }, 100);
                
                // CALCULAR MÉTRICAS DEL TRIMESTRE
                
                // 1. Días operados en el trimestre
                const uniqueDaysQuarter = [...new Set(periodOperations.map(op => op.date))].length;
                const daysTradedEl = document.getElementById('quarter-metric-days-traded');
                if (daysTradedEl) daysTradedEl.textContent = uniqueDaysQuarter;
                
                // 2. Racha máxima de victorias y derrotas
                let currentWinStreak = 0, maxWinStreak = 0;
                let currentLossStreak = 0, maxLossStreak = 0;
                const sortedOps = [...periodOperations].sort((a, b) => new Date(a.date) - new Date(b.date));
                
                sortedOps.forEach(op => {
                    const isWin = op.result === 'win' || (!op.result && op.pl > 0);
                    if (isWin) {
                        currentWinStreak++;
                        currentLossStreak = 0;
                        maxWinStreak = Math.max(maxWinStreak, currentWinStreak);
                    } else if (op.result === 'loss' || (!op.result && op.pl < 0)) {
                        currentLossStreak++;
                        currentWinStreak = 0;
                        maxLossStreak = Math.max(maxLossStreak, currentLossStreak);
                    }
                });
                
                const maxStreakEl = document.getElementById('quarter-metric-max-streak');
                const maxLossStreakEl = document.getElementById('quarter-metric-max-loss-streak');
                if (maxStreakEl) maxStreakEl.textContent = maxWinStreak;
                if (maxLossStreakEl) maxLossStreakEl.textContent = maxLossStreak;
                
                // 3. Promedio por día operado
                const avgPerDayQuarter = uniqueDaysQuarter > 0 ? netPL / uniqueDaysQuarter : 0;
                const avgPerDayEl = document.getElementById('quarter-metric-avg-per-day');
                if (avgPerDayEl) {
                    avgPerDayEl.textContent = formatCurrency(avgPerDayQuarter, displayCurrency, displayCurrency);
                    avgPerDayEl.className = `text-lg font-bold ${avgPerDayQuarter >= 0 ? 'text-positive' : 'text-negative'}`;
                }
                
                // 4. Factor de Recuperación (Profit / Max Drawdown)
                let peak = 0, maxDD = 0, runningPL = 0;
                sortedOps.forEach(op => {
                    runningPL += op.pl || 0;
                    peak = Math.max(peak, runningPL);
                    const dd = peak - runningPL;
                    maxDD = Math.max(maxDD, dd);
                });
                
                const recoveryFactor = maxDD > 0 ? netPL / maxDD : netPL > 0 ? 999 : 0;
                const recoveryFactorEl = document.getElementById('quarter-metric-recovery-factor');
                if (recoveryFactorEl) {
                    recoveryFactorEl.textContent = recoveryFactor >= 999 ? '∞' : recoveryFactor.toFixed(2);
                }
                
                // Inicializar event listeners de tabs
                initAnalyticsDetailTabs();
            } else {
                // Ocultar tabs para otros análisis
                tabsContainer.style.display = 'none';
            }

            // 4. Renderizar Gráficos
            updateDashboardRadarChart(periodOperations, selectedAccount, 'analytics-detail-radar-chart');
            updateInstrumentPerformanceChart(periodOperations, 'analytics-detail-instrument-chart');
            updateTypePerformanceChart(periodOperations, 'analytics-detail-long-short-chart');
            updateAnalyticsDetailPnLEvolutionChart(periodOperations, displayCurrency);

            // Renderizar gráficas según el tipo de análisis
            const dayChartsContainer = document.getElementById('day-charts-container');
            const monthChartsContainer = document.getElementById('month-charts-container');
            const weekChartsContainer = document.getElementById('week-charts-container');
            const quarterChartsContainer = document.getElementById('quarter-charts-container');
            
            if (type === 'date') {
                // Guardar la fecha actual en el modal para las notas
                modal.dataset.currentDate = value;
                modal.dataset.analysisType = 'date';
                
                // Mostrar contenedor de gráficas del día
                if (dayChartsContainer) dayChartsContainer.style.display = 'block';
                if (monthChartsContainer) monthChartsContainer.style.display = 'none';
                if (weekChartsContainer) weekChartsContainer.style.display = 'none';
                if (quarterChartsContainer) quarterChartsContainer.style.display = 'none';
                
                // Renderizar gráficas del día
                updateComparisonChart(periodOperations, value, selectedAccount, displayCurrency);
                updateSessionChart(periodOperations, displayCurrency);
                updateTimeOfDayChart(periodOperations, displayCurrency);
                updateDistributionChart(periodOperations, displayCurrency);
                updateWinRateHourChart(periodOperations);
                updateInstrumentPLChart(periodOperations, displayCurrency);
                
                // Calcular métricas avanzadas
                calculateDayMetrics(periodOperations, displayCurrency);
                
                // Cargar notas del día
                loadDailyNotes(value);
            } else if (type === 'month') {
                // Guardar el mes actual en el modal para las notas
                modal.dataset.currentMonth = value;
                modal.dataset.analysisType = 'month';
                
                // Mostrar contenedor de gráficas del mes
                if (dayChartsContainer) dayChartsContainer.style.display = 'none';
                if (monthChartsContainer) monthChartsContainer.style.display = 'block';
                
                // Renderizar gráficas del mes
                updateMonthlyWeeklyPLChart(periodOperations, value, displayCurrency);
                updateMonthlyWinRateChart(periodOperations, value);
                updateMonthlyWeekdayPLChart(periodOperations, displayCurrency);
                updateMonthlyTopInstrumentsChart(periodOperations, displayCurrency);
                updateMonthlyOperationsChart(periodOperations, value);
                updateMonthlyDistributionChart(periodOperations, displayCurrency);
                
                // Cargar notas del mes
                loadMonthlyNotes(value);
            } else if (type === 'week') {
                // Guardar la semana actual en el modal para las notas
                modal.dataset.currentWeek = `${value.startDate}_${value.endDate}`;
                modal.dataset.analysisType = 'week';
                
                // Mostrar contenedor de gráficas de la semana
                if (dayChartsContainer) dayChartsContainer.style.display = 'none';
                if (monthChartsContainer) monthChartsContainer.style.display = 'none';
                if (weekChartsContainer) weekChartsContainer.style.display = 'block';
                
                // Renderizar gráficas de la semana
                updateWeeklyDailyPLChart(periodOperations, displayCurrency);
                updateWeeklyDailyWinRateChart(periodOperations);
                updateWeeklyComparisonChart(periodOperations, value, displayCurrency);
                updateWeeklySessionChart(periodOperations, displayCurrency);
                updateWeeklyTopInstrumentsChart(periodOperations, displayCurrency);
                updateWeeklyHourlyPLChart(periodOperations, displayCurrency);
                
                // Cargar notas de la semana
                loadWeeklyNotes(value.startDate, value.endDate);
            } else if (type === 'quarter') {
                // Guardar el trimestre actual en el modal para las notas
                modal.dataset.currentQuarter = value;
                modal.dataset.analysisType = 'quarter';
                
                // Mostrar contenedor de gráficas del trimestre
                if (dayChartsContainer) dayChartsContainer.style.display = 'none';
                if (monthChartsContainer) monthChartsContainer.style.display = 'none';
                if (weekChartsContainer) weekChartsContainer.style.display = 'none';
                if (quarterChartsContainer) quarterChartsContainer.style.display = 'block';
                
                // Renderizar gráficas del trimestre
                updateQuarterlyMonthlyPLChart(periodOperations, displayCurrency);
                updateQuarterlyMonthlyWinRateChart(periodOperations);
                updateQuarterlyOperationsVolumeChart(periodOperations);
                updateQuarterlyTopInstrumentsChart(periodOperations, displayCurrency);
                updateQuarterlySessionPerformanceChart(periodOperations, displayCurrency);
                updateQuarterlyWinLossDistributionChart(periodOperations, displayCurrency);
                
                // Cargar notas del trimestre
                loadQuarterlyNotes(value);
            } else {
                // Ocultar todos los contenedores para otros tipos de análisis
                if (dayChartsContainer) dayChartsContainer.style.display = 'none';
                if (monthChartsContainer) monthChartsContainer.style.display = 'none';
                if (weekChartsContainer) weekChartsContainer.style.display = 'none';
                if (quarterChartsContainer) quarterChartsContainer.style.display = 'none';
            }


            // 5. Poblar tabla de operaciones
            const tableBody = document.getElementById('analytics-detail-table-body');
            tableBody.innerHTML = '';
            periodOperations.sort((a,b) => new Date(b.date) - new Date(a.date)).forEach(op => {
                const plClass = op.pl >= 0 ? 'text-positive' : 'text-negative';
                const precision = getInstrumentPrecision(op.instrument);
                
                // Fila principal de la operación
                const mainRow = `
                    <tr class="cursor-pointer ${op.hasPartials ? 'font-semibold bg-surface-light' : ''}" data-id="${op.id}">
                        <td>${formatDate(op.date)}</td>
                        <td>${op.instrument}${op.hasPartials ? ` <span class="text-xs text-gray-400">(${op.partials.length} parcial${op.partials.length > 1 ? 'es' : ''})</span>` : ''}</td>
                        <td class="${op.type === 'buy' ? 'text-positive' : 'text-negative'}">${op.type === 'buy' ? 'Long' : 'Short'}</td>
                        <td>${op.entry !== null ? op.entry.toFixed(precision) : '-'}</td>
                        <td>${op.exit !== null ? op.exit.toFixed(precision) : '-'}</td>
                        <td>${op.volume}</td>
                        <td class="${plClass}">${formatCurrency(op.pl, op.currency, op.currency)}</td>
                    </tr>
                `;
                
                tableBody.innerHTML += mainRow;
                
                // Si tiene parciales, agregar filas adicionales (ocultas inicialmente, se pueden expandir)
                if (op.hasPartials && op.partials && op.partials.length > 0) {
                    op.partials.forEach((partial, index) => {
                        const partialPlClass = partial.pl >= 0 ? 'text-positive' : 'text-negative';
                        const partialRow = `
                            <tr class="text-sm text-gray-400 bg-background" data-parent-id="${op.id}">
                                <td class="pl-6">↳ Cierre ${index + 1}</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>${partial.price.toFixed(precision)}</td>
                                <td>${partial.volume}</td>
                                <td class="${partialPlClass}">${formatCurrency(partial.pl, op.currency, op.currency)}</td>
                            </tr>
                        `;
                        tableBody.innerHTML += partialRow;
                    });
                }
            });

            tableBody.querySelectorAll('tr').forEach(row => {
                row.addEventListener('click', () => {
                    const opId = row.dataset.id;
                    if(opId) {
                        closeAnalyticsDetailModal();
                        showOperationDetailPage(opId);
                    }
                });
            });

            // 6. Mostrar el modal
            modal.style.display = 'block';
            document.body.style.overflow = 'hidden';
        }

        function initAnalyticsDetailTabs() {
            document.querySelectorAll('.analytics-detail-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    const targetTab = tab.dataset.target;
                    
                    // Remover active de todos los tabs
                    document.querySelectorAll('.analytics-detail-tab').forEach(t => t.classList.remove('active'));
                    
                    // Agregar active al tab clickeado
                    tab.classList.add('active');
                    
                    // Ocultar todos los contenidos de tabs
                    document.querySelectorAll('.analytics-detail-tab-content').forEach(content => {
                        content.style.display = 'none';
                    });
                    
                    // Mostrar el contenido del tab seleccionado
                    const targetContent = document.getElementById(`analytics-detail-tab-${targetTab}`);
                    if (targetContent) {
                        targetContent.style.display = 'block';
                    }
                });
            });
        }

        window.initOperationDetailTabs = function() {
            document.querySelectorAll('.operation-detail-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    const targetTab = tab.dataset.target;
                    
                    // Remover active de todos los tabs
                    document.querySelectorAll('.operation-detail-tab').forEach(t => t.classList.remove('active'));
                    
                    // Agregar active al tab clickeado
                    tab.classList.add('active');
                    
                    // Ocultar todos los contenidos de tabs
                    document.querySelectorAll('.operation-detail-tab-content').forEach(content => {
                        content.style.display = 'none';
                    });
                    
                    // Mostrar el contenido del tab seleccionado
                    const targetContent = document.getElementById(`operation-detail-tab-${targetTab}`);
                    if (targetContent) {
                        targetContent.style.display = 'block';
                        
                        // Si es el tab de métricas, renderizar los gráficos
                        if (targetTab === 'metricas' && currentOperationForMetrics) {
                            setTimeout(() => {
                                updateOperationMetricsAndCharts(currentOperationForMetrics);
                            }, 50);
                        }
                    }
                });
            });
        }

        function closeAnalyticsDetailModal() {
            const modal = document.getElementById('analytics-detail-modal');
            modal.style.display = 'none';
            document.body.style.overflow = 'auto';
        }

        // Variable global para el gráfico de evolución del P&L
        let analyticsDetailPnLEvolutionChart = null;

        function updateAnalyticsDetailPnLEvolutionChart(operations, displayCurrency) {
            const ctx = document.getElementById('analytics-detail-pnl-evolution-chart')?.getContext('2d');
            if (!ctx) return;

            // Destruir gráfico existente
            if (analyticsDetailPnLEvolutionChart) {
                analyticsDetailPnLEvolutionChart.destroy();
            }

            // Agrupar operaciones por ID y calcular P&L acumulado
            const groupedOps = {};
            operations.forEach(op => {
                const opId = op.id;
                if (!groupedOps[opId]) {
                    groupedOps[opId] = {
                        id: opId,
                        totalPL: 0,
                        date: op.date,
                        entryTime: op.entryTime || '00:00',
                        currency: op.currency
                    };
                }
                groupedOps[opId].totalPL += op.pl;
                
                // Usar la fecha/hora más temprana como referencia
                const currentTime = op.entryTime || '00:00';
                if (currentTime < groupedOps[opId].entryTime) {
                    groupedOps[opId].entryTime = currentTime;
                }
            });

            const uniqueTradeGroups = Object.values(groupedOps);
            
            // Ordenar por fecha y hora
            uniqueTradeGroups.sort((a, b) => {
                const dateTimeA = new Date(a.date + 'T' + a.entryTime);
                const dateTimeB = new Date(b.date + 'T' + b.entryTime);
                return dateTimeA - dateTimeB;
            });

            // Calcular P&L acumulado
            let cumulativePL = 0;
            const dataPoints = [];
            const labels = [];

            uniqueTradeGroups.forEach((group, index) => {
                let plInDisplayCurrency = group.totalPL;
                if (group.currency !== displayCurrency && displayCurrency !== '%') {
                    plInDisplayCurrency = convertCurrency(group.totalPL, group.currency, displayCurrency);
                }
                
                cumulativePL += plInDisplayCurrency;
                dataPoints.push(cumulativePL);
                labels.push(`Trade ${index + 1} (${group.entryTime})`);
            });

            // Crear el gráfico
            analyticsDetailPnLEvolutionChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: `P&L Acumulado (${displayCurrency})`,
                        data: dataPoints,
                        borderColor: '#00ff41',
                        backgroundColor: 'rgba(0, 255, 65, 0.15)',
                        fill: true,
                        tension: 0.3,
                        pointBackgroundColor: dataPoints.map(val => val >= 0 ? '#00ff41' : '#ef4444'),
                        pointBorderColor: dataPoints.map(val => val >= 0 ? '#00cc33' : '#dc2626'),
                        pointRadius: 4,
                        pointHoverRadius: 6
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            labels: {
                                color: '#a0a0a0'
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleColor: '#ffffff',
                            bodyColor: '#ffffff',
                            callbacks: {
                                label: function(context) {
                                    const value = context.raw;
                                    return `P&L Acumulado: ${formatCurrency(value, displayCurrency, displayCurrency)}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            ticks: {
                                color: '#a0a0a0',
                                maxTicksLimit: 10
                            }
                        },
                        y: {
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            ticks: {
                                color: '#a0a0a0',
                                callback: function(value) {
                                    return formatCurrency(value, displayCurrency, displayCurrency);
                                }
                            }
                        }
                    }
                }
            });
        }

        // --- NUEVAS GRÁFICAS DE ANÁLISIS DEL DÍA ---
        
        let comparisonChart = null;
        function updateComparisonChart(operations, dateStr, accountId, displayCurrency) {
            const ctx = document.getElementById('analytics-detail-comparison-chart')?.getContext('2d');
            if (!ctx) return;

            if (comparisonChart) {
                comparisonChart.destroy();
            }

            // Calcular P/L del día
            const dayMetrics = calculateMetrics(operations, accountId);
            const dayGrossPL = dayMetrics.totalWin + dayMetrics.totalLoss;
            const dayNetPL = dayGrossPL - dayMetrics.totalFees;

            // Calcular P/L promedio (últimos 30 días)
            const thirtyDaysAgo = new Date(dateStr);
            thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
            const last30DaysOps = DB.operations.filter(op => {
                const opDate = new Date(op.date);
                return opDate >= thirtyDaysAgo && opDate < new Date(dateStr) && (accountId === 'all' || op.accountId === accountId);
            });
            
            const dailyPLs = {};
            last30DaysOps.forEach(op => {
                if (!dailyPLs[op.date]) dailyPLs[op.date] = 0;
                dailyPLs[op.date] += op.pl;
            });
            
            const avgDailyPL = Object.keys(dailyPLs).length > 0 
                ? Object.values(dailyPLs).reduce((sum, pl) => sum + pl, 0) / Object.keys(dailyPLs).length 
                : 0;

            // Mejor día del mes
            const bestDayPL = Object.keys(dailyPLs).length > 0 
                ? Math.max(...Object.values(dailyPLs)) 
                : 0;

            comparisonChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['Hoy', 'Promedio (30d)', 'Mejor Día (30d)'],
                    datasets: [{
                        label: 'P/L Neto',
                        data: [dayNetPL, avgDailyPL, bestDayPL],
                        backgroundColor: [
                            dayNetPL >= 0 ? 'rgba(57, 255, 20, 0.8)' : 'rgba(255, 68, 68, 0.8)',
                            avgDailyPL >= 0 ? 'rgba(57, 255, 20, 0.8)' : 'rgba(255, 68, 68, 0.8)',
                            bestDayPL >= 0 ? 'rgba(57, 255, 20, 0.8)' : 'rgba(255, 68, 68, 0.8)'
                        ],
                        borderColor: [
                            dayNetPL >= 0 ? '#39FF14' : '#FF4444',
                            avgDailyPL >= 0 ? '#39FF14' : '#FF4444',
                            bestDayPL >= 0 ? '#39FF14' : '#FF4444'
                        ],
                        borderWidth: 2
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.9)',
                            titleColor: '#39FF14',
                            bodyColor: '#ffffff',
                            callbacks: {
                                label: (context) => formatCurrency(context.raw, displayCurrency, displayCurrency)
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { 
                                color: '#a0a0a0',
                                callback: (value) => formatCurrency(value, displayCurrency, displayCurrency)
                            }
                        },
                        y: {
                            grid: { display: false },
                            ticks: { color: '#ffffff', font: { size: 12, weight: 'bold' } }
                        }
                    }
                }
            });
        }

        let sessionChart = null;
        function updateSessionChart(operations, displayCurrency) {
            const ctx = document.getElementById('analytics-detail-session-chart')?.getContext('2d');
            if (!ctx) return;

            if (sessionChart) {
                sessionChart.destroy();
            }

            // Definir sesiones (UTC)
            const sessions = {
                'Asia': { start: 0, end: 8 },
                'Londres': { start: 8, end: 16 },
                'NY': { start: 13, end: 21 },
                'Overlap': { start: 13, end: 16 }
            };

            const sessionPL = { 'Asia': 0, 'Londres': 0, 'NY': 0, 'Overlap': 0 };

            operations.forEach(op => {
                const entryTime = op.entryTime || '00:00';
                const hour = parseInt(entryTime.split(':')[0]);
                
                Object.keys(sessions).forEach(session => {
                    const { start, end } = sessions[session];
                    if (hour >= start && hour < end) {
                        sessionPL[session] += op.pl;
                    }
                });
            });

            const labels = Object.keys(sessionPL);
            const data = Object.values(sessionPL);

            sessionChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'P/L por Sesión',
                        data: data,
                        backgroundColor: data.map(val => val >= 0 ? 'rgba(57, 255, 20, 0.8)' : 'rgba(255, 68, 68, 0.8)'),
                        borderColor: data.map(val => val >= 0 ? '#39FF14' : '#FF4444'),
                        borderWidth: 2
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.9)',
                            titleColor: '#39FF14',
                            bodyColor: '#ffffff',
                            callbacks: {
                                label: (context) => formatCurrency(context.raw, displayCurrency, displayCurrency)
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { 
                                color: '#a0a0a0',
                                callback: (value) => formatCurrency(value, displayCurrency, displayCurrency)
                            }
                        },
                        y: {
                            grid: { display: false },
                            ticks: { color: '#ffffff', font: { size: 12, weight: 'bold' } }
                        }
                    }
                }
            });
        }

        let timeOfDayChart = null;
        function updateTimeOfDayChart(operations, displayCurrency) {
            const ctx = document.getElementById('analytics-detail-timeofday-chart')?.getContext('2d');
            if (!ctx) return;

            if (timeOfDayChart) {
                timeOfDayChart.destroy();
            }

            // Definir momentos del día
            const periods = {
                'Mañana (06-12h)': { start: 6, end: 12 },
                'Mediodía (12-15h)': { start: 12, end: 15 },
                'Tarde (15-18h)': { start: 15, end: 18 },
                'Noche (18-00h)': { start: 18, end: 24 }
            };

            const periodPL = {
                'Mañana (06-12h)': 0,
                'Mediodía (12-15h)': 0,
                'Tarde (15-18h)': 0,
                'Noche (18-00h)': 0
            };

            operations.forEach(op => {
                const entryTime = op.entryTime || '00:00';
                const hour = parseInt(entryTime.split(':')[0]);
                
                Object.keys(periods).forEach(period => {
                    const { start, end } = periods[period];
                    if (hour >= start && hour < end) {
                        periodPL[period] += op.pl;
                    }
                });
            });

            const labels = Object.keys(periodPL);
            const data = Object.values(periodPL);

            timeOfDayChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'P/L por Momento',
                        data: data,
                        backgroundColor: data.map(val => val >= 0 ? 'rgba(57, 255, 20, 0.8)' : 'rgba(255, 68, 68, 0.8)'),
                        borderColor: data.map(val => val >= 0 ? '#39FF14' : '#FF4444'),
                        borderWidth: 2
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.9)',
                            titleColor: '#39FF14',
                            bodyColor: '#ffffff',
                            callbacks: {
                                label: (context) => formatCurrency(context.raw, displayCurrency, displayCurrency)
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { 
                                color: '#a0a0a0',
                                callback: (value) => formatCurrency(value, displayCurrency, displayCurrency)
                            }
                        },
                        y: {
                            grid: { display: false },
                            ticks: { color: '#ffffff', font: { size: 11, weight: 'bold' } }
                        }
                    }
                }
            });
        }

        let distributionChart = null;
        function updateDistributionChart(operations, displayCurrency) {
            const ctx = document.getElementById('analytics-detail-distribution-chart')?.getContext('2d');
            if (!ctx) return;

            if (distributionChart) {
                distributionChart.destroy();
            }

            let winCount = 0, lossCount = 0, breakevenCount = 0;
            let winPL = 0, lossPL = 0;

            operations.forEach(op => {
                if (op.pl > 0) {
                    winCount++;
                    winPL += op.pl;
                } else if (op.pl < 0) {
                    lossCount++;
                    lossPL += op.pl;
                } else {
                    breakevenCount++;
                }
            });

            const labels = [
                `Ganadores (${winCount})`,
                `Perdedores (${lossCount})`,
                `Breakeven (${breakevenCount})`
            ];
            const data = [winPL, lossPL, 0];

            distributionChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'P/L Total',
                        data: data,
                        backgroundColor: [
                            'rgba(57, 255, 20, 0.8)',
                            'rgba(255, 68, 68, 0.8)',
                            'rgba(128, 128, 128, 0.8)'
                        ],
                        borderColor: ['#39FF14', '#FF4444', '#808080'],
                        borderWidth: 2
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.9)',
                            titleColor: '#39FF14',
                            bodyColor: '#ffffff',
                            callbacks: {
                                label: (context) => formatCurrency(context.raw, displayCurrency, displayCurrency)
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { 
                                color: '#a0a0a0',
                                callback: (value) => formatCurrency(value, displayCurrency, displayCurrency)
                            }
                        },
                        y: {
                            grid: { display: false },
                            ticks: { color: '#ffffff', font: { size: 11, weight: 'bold' } }
                        }
                    }
                }
            });
        }

        // Gráfica: Win Rate por Hora
        let winRateHourChart = null;
        function updateWinRateHourChart(operations) {
            const ctx = document.getElementById('analytics-detail-winrate-hour-chart')?.getContext('2d');
            if (!ctx) return;

            if (winRateHourChart) {
                winRateHourChart.destroy();
            }

            // Agrupar por hora
            const hourStats = {};
            for (let i = 0; i < 24; i++) {
                hourStats[i] = { wins: 0, losses: 0, total: 0 };
            }

            operations.forEach(op => {
                const exitDate = op.exit_time || op.exit_date;
                if (!exitDate) return;
                
                const date = new Date(exitDate);
                const hour = date.getHours();
                
                hourStats[hour].total++;
                if (op.pl > 0) {
                    hourStats[hour].wins++;
                } else if (op.pl < 0) {
                    hourStats[hour].losses++;
                }
            });

            const labels = [];
            const data = [];
            const colors = [];

            for (let i = 0; i < 24; i++) {
                if (hourStats[i].total > 0) {
                    const winRate = (hourStats[i].wins / hourStats[i].total) * 100;
                    labels.push(`${i}:00`);
                    data.push(winRate);
                    colors.push(winRate >= 50 ? 'rgba(57, 255, 20, 0.8)' : 'rgba(255, 68, 68, 0.8)');
                }
            }

            winRateHourChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Win Rate %',
                        data: data,
                        backgroundColor: colors,
                        borderColor: colors.map(c => c.replace('0.8', '1')),
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.9)',
                            titleColor: '#39FF14',
                            bodyColor: '#ffffff',
                            callbacks: {
                                label: (context) => {
                                    const hour = parseInt(context.label.split(':')[0]);
                                    const stats = hourStats[hour];
                                    return [
                                        `Win Rate: ${context.raw.toFixed(1)}%`,
                                        `Trades: ${stats.total} (${stats.wins}W/${stats.losses}L)`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: { display: false },
                            ticks: { color: '#a0a0a0' }
                        },
                        y: {
                            beginAtZero: true,
                            max: 100,
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { 
                                color: '#ffffff',
                                callback: (value) => value + '%'
                            }
                        }
                    }
                }
            });
        }

        // Gráfica: P/L por Instrumento
        let instrumentPLChart = null;
        function updateInstrumentPLChart(operations, displayCurrency) {
            const ctx = document.getElementById('analytics-detail-instrument-pl-chart')?.getContext('2d');
            if (!ctx) return;

            if (instrumentPLChart) {
                instrumentPLChart.destroy();
            }

            // Agrupar por instrumento
            const instrumentStats = {};
            operations.forEach(op => {
                const symbol = op.symbol || 'Unknown';
                if (!instrumentStats[symbol]) {
                    instrumentStats[symbol] = 0;
                }
                instrumentStats[symbol] += op.pl || 0;
            });

            // Ordenar por P/L
            const sorted = Object.entries(instrumentStats)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 10); // Top 10

            const labels = sorted.map(([symbol]) => symbol);
            const data = sorted.map(([, pl]) => pl);
            const colors = data.map(pl => pl >= 0 ? 'rgba(57, 255, 20, 0.8)' : 'rgba(255, 68, 68, 0.8)');

            instrumentPLChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'P/L',
                        data: data,
                        backgroundColor: colors,
                        borderColor: colors.map(c => c.replace('0.8', '1')),
                        borderWidth: 2
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.9)',
                            titleColor: '#39FF14',
                            bodyColor: '#ffffff',
                            callbacks: {
                                label: (context) => formatCurrency(context.raw, displayCurrency, displayCurrency)
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { 
                                color: '#a0a0a0',
                                callback: (value) => formatCurrency(value, displayCurrency, displayCurrency)
                            }
                        },
                        y: {
                            grid: { display: false },
                            ticks: { color: '#ffffff', font: { size: 11, weight: 'bold' } }
                        }
                    }
                }
            });
        }

        // Calcular Métricas Avanzadas
        function calculateDayMetrics(operations, displayCurrency) {
            if (!operations || operations.length === 0) {
                return {
                    avgWin: 0,
                    avgLoss: 0,
                    avgPLPerTrade: 0,
                    tradesPerHour: 0,
                    worstTrade: 0,
                    maxDrawdown: 0,
                    expectancy: 0
                };
            }

            // Calcular avgWin y avgLoss
            const winningTrades = operations.filter(op => (op.pl || 0) > 0);
            const losingTrades = operations.filter(op => (op.pl || 0) < 0);
            
            const avgWin = winningTrades.length > 0 
                ? winningTrades.reduce((sum, op) => sum + (op.pl || 0), 0) / winningTrades.length 
                : 0;
            
            const avgLoss = losingTrades.length > 0 
                ? losingTrades.reduce((sum, op) => sum + (op.pl || 0), 0) / losingTrades.length 
                : 0;
            
            const totalPL = operations.reduce((sum, op) => sum + (op.pl || 0), 0);
            const avgPLPerTrade = totalPL / operations.length;

            // 1. Velocidad de Ejecución (trades por hora)
            const firstOp = operations.reduce((earliest, op) => {
                const date = new Date(op.entry_time || op.entry_date || op.date);
                return date < new Date(earliest.entry_time || earliest.entry_date || earliest.date) ? op : earliest;
            });
            
            const lastOp = operations.reduce((latest, op) => {
                const date = new Date(op.exit_time || op.exit_date || op.date);
                return date > new Date(latest.exit_time || latest.exit_date || latest.date) ? op : latest;
            });
            
            const firstTime = new Date(firstOp.entry_time || firstOp.entry_date || firstOp.date);
            const lastTime = new Date(lastOp.exit_time || lastOp.exit_date || lastOp.date);
            const hoursDiff = Math.max(1, (lastTime - firstTime) / (1000 * 60 * 60));
            const tradesPerHour = (operations.length / hoursDiff).toFixed(1);
            
            const executionSpeedEl = document.getElementById('day-metric-execution-speed');
            if (executionSpeedEl) executionSpeedEl.textContent = `${tradesPerHour} op/h`;

            // 2. Peor Trade
            const worstTrade = Math.min(...operations.map(op => op.pl || 0));
            const worstTradeEl = document.getElementById('day-metric-worst-trade');
            if (worstTradeEl) worstTradeEl.textContent = formatCurrency(worstTrade, displayCurrency, displayCurrency);

            // 3. Drawdown Intradía (máxima caída desde el pico)
            let peak = 0;
            let maxDD = 0;
            let cumulative = 0;
            
            [...operations].sort((a, b) => {
                const dateA = new Date(a.exit_time || a.exit_date || a.date);
                const dateB = new Date(b.exit_time || b.exit_date || b.date);
                return dateA - dateB;
            }).forEach(op => {
                cumulative += op.pl || 0;
                if (cumulative > peak) {
                    peak = cumulative;
                }
                const dd = peak - cumulative;
                if (dd > maxDD) {
                    maxDD = dd;
                }
            });
            
            const intradayDDEl = document.getElementById('day-metric-intraday-dd');
            if (intradayDDEl) intradayDDEl.textContent = formatCurrency(-maxDD, displayCurrency, displayCurrency);

            // 4. Expectativa (ganancia promedio por operación)
            const expectancyEl = document.getElementById('day-metric-expectancy');
            if (expectancyEl) {
                expectancyEl.textContent = formatCurrency(avgPLPerTrade, displayCurrency, displayCurrency);
                expectancyEl.className = `text-2xl font-bold ${avgPLPerTrade >= 0 ? 'text-green' : 'text-red'}`;
            }

            return {
                avgWin,
                avgLoss,
                avgPLPerTrade,
                tradesPerHour: parseFloat(tradesPerHour),
                worstTrade,
                maxDrawdown: -maxDD,
                expectancy: avgPLPerTrade
            };
        }

        // ===== GRÁFICAS MENSUALES =====
        
        // Función auxiliar para obtener número de semana del mes
        function getWeekOfMonth(date) {
            const d = new Date(date);
            const firstDay = new Date(d.getFullYear(), d.getMonth(), 1);
            const dayOfMonth = d.getDate();
            const firstDayOfWeek = firstDay.getDay();
            return Math.ceil((dayOfMonth + firstDayOfWeek) / 7);
        }

        // Gráfica 1: P/L por Semana del Mes
        let monthlyWeeklyPLChart = null;
        function updateMonthlyWeeklyPLChart(operations, monthKey, displayCurrency) {
            const ctx = document.getElementById('month-weekly-pl-chart')?.getContext('2d');
            if (!ctx) return;

            if (monthlyWeeklyPLChart) {
                monthlyWeeklyPLChart.destroy();
            }

            // Agrupar por semana
            const weeklyStats = {};
            operations.forEach(op => {
                const week = getWeekOfMonth(op.date);
                if (!weeklyStats[week]) weeklyStats[week] = 0;
                weeklyStats[week] += op.pl || 0;
            });

            const weeks = Object.keys(weeklyStats).sort((a, b) => a - b);
            const labels = weeks.map(w => `Semana ${w}`);
            const data = weeks.map(w => weeklyStats[w]);
            const colors = data.map(pl => pl >= 0 ? 'rgba(57, 255, 20, 0.8)' : 'rgba(255, 68, 68, 0.8)');

            monthlyWeeklyPLChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'P/L',
                        data: data,
                        backgroundColor: colors,
                        borderColor: colors.map(c => c.replace('0.8', '1')),
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.9)',
                            titleColor: '#39FF14',
                            bodyColor: '#ffffff',
                            callbacks: {
                                label: (context) => `P/L: ${formatCurrency(context.raw, displayCurrency, displayCurrency)}`
                            }
                        }
                    },
                    scales: {
                        x: { grid: { display: false }, ticks: { color: '#a0a0a0' } },
                        y: {
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { 
                                color: '#ffffff',
                                callback: (value) => formatCurrency(value, displayCurrency, displayCurrency)
                            }
                        }
                    }
                }
            });
        }

        // Gráfica 2: Win Rate por Semana
        let monthlyWinRateChart = null;
        function updateMonthlyWinRateChart(operations, monthKey) {
            const ctx = document.getElementById('month-weekly-winrate-chart')?.getContext('2d');
            if (!ctx) return;

            if (monthlyWinRateChart) {
                monthlyWinRateChart.destroy();
            }

            // Agrupar por semana
            const weeklyStats = {};
            operations.forEach(op => {
                const week = getWeekOfMonth(op.date);
                if (!weeklyStats[week]) weeklyStats[week] = { wins: 0, losses: 0, total: 0 };
                weeklyStats[week].total++;
                if ((op.pl || 0) > 0) weeklyStats[week].wins++;
                else if ((op.pl || 0) < 0) weeklyStats[week].losses++;
            });

            const weeks = Object.keys(weeklyStats).sort((a, b) => a - b);
            const labels = weeks.map(w => `Semana ${w}`);
            const data = weeks.map(w => {
                const stats = weeklyStats[w];
                return stats.total > 0 ? (stats.wins / stats.total) * 100 : 0;
            });
            const colors = data.map(wr => wr >= 50 ? 'rgba(57, 255, 20, 0.8)' : 'rgba(255, 68, 68, 0.8)');

            monthlyWinRateChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Win Rate %',
                        data: data,
                        backgroundColor: colors,
                        borderColor: colors.map(c => c.replace('0.8', '1')),
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.9)',
                            titleColor: '#39FF14',
                            bodyColor: '#ffffff',
                            callbacks: {
                                label: (context) => {
                                    const week = weeks[context.dataIndex];
                                    const stats = weeklyStats[week];
                                    return [
                                        `Win Rate: ${context.raw.toFixed(1)}%`,
                                        `Trades: ${stats.total} (${stats.wins}W/${stats.losses}L)`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        x: { grid: { display: false }, ticks: { color: '#a0a0a0' } },
                        y: {
                            beginAtZero: true,
                            max: 100,
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { 
                                color: '#ffffff',
                                callback: (value) => value + '%'
                            }
                        }
                    }
                }
            });
        }

        // Gráfica 3: P/L por Día de la Semana
        let monthlyWeekdayPLChart = null;
        function updateMonthlyWeekdayPLChart(operations, displayCurrency) {
            const ctx = document.getElementById('month-weekday-pl-chart')?.getContext('2d');
            if (!ctx) return;

            if (monthlyWeekdayPLChart) {
                monthlyWeekdayPLChart.destroy();
            }

            const weekdays = ['Domingo', 'Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sábado'];
            const weekdayStats = Array(7).fill(0);

            operations.forEach(op => {
                const day = new Date(op.date).getDay();
                weekdayStats[day] += op.pl || 0;
            });

            const colors = weekdayStats.map(pl => pl >= 0 ? 'rgba(57, 255, 20, 0.8)' : 'rgba(255, 68, 68, 0.8)');

            monthlyWeekdayPLChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: weekdays,
                    datasets: [{
                        label: 'P/L',
                        data: weekdayStats,
                        backgroundColor: colors,
                        borderColor: colors.map(c => c.replace('0.8', '1')),
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.9)',
                            titleColor: '#39FF14',
                            bodyColor: '#ffffff',
                            callbacks: {
                                label: (context) => `P/L: ${formatCurrency(context.raw, displayCurrency, displayCurrency)}`
                            }
                        }
                    },
                    scales: {
                        x: { grid: { display: false }, ticks: { color: '#a0a0a0' } },
                        y: {
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { 
                                color: '#ffffff',
                                callback: (value) => formatCurrency(value, displayCurrency, displayCurrency)
                            }
                        }
                    }
                }
            });
        }

        // Gráfica 4: Top 10 Instrumentos del Mes
        let monthlyTopInstrumentsChart = null;
        function updateMonthlyTopInstrumentsChart(operations, displayCurrency) {
            const ctx = document.getElementById('month-top-instruments-chart')?.getContext('2d');
            if (!ctx) return;

            if (monthlyTopInstrumentsChart) {
                monthlyTopInstrumentsChart.destroy();
            }

            // Agrupar por instrumento
            const instrumentStats = {};
            operations.forEach(op => {
                const symbol = op.symbol || 'Unknown';
                if (!instrumentStats[symbol]) {
                    instrumentStats[symbol] = { pl: 0, trades: 0 };
                }
                instrumentStats[symbol].pl += op.pl || 0;
                instrumentStats[symbol].trades++;
            });

            // Ordenar por P/L y tomar top 10
            const sorted = Object.entries(instrumentStats)
                .sort(([,a], [,b]) => b.pl - a.pl)
                .slice(0, 10);

            const labels = sorted.map(([symbol]) => symbol);
            const data = sorted.map(([, stats]) => stats.pl);
            const colors = data.map(pl => pl >= 0 ? 'rgba(57, 255, 20, 0.8)' : 'rgba(255, 68, 68, 0.8)');

            monthlyTopInstrumentsChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'P/L',
                        data: data,
                        backgroundColor: colors,
                        borderColor: colors.map(c => c.replace('0.8', '1')),
                        borderWidth: 2
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.9)',
                            titleColor: '#39FF14',
                            bodyColor: '#ffffff',
                            callbacks: {
                                label: (context) => {
                                    const [symbol] = sorted[context.dataIndex];
                                    const stats = instrumentStats[symbol];
                                    return [
                                        `P/L: ${formatCurrency(context.raw, displayCurrency, displayCurrency)}`,
                                        `Trades: ${stats.trades}`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { 
                                color: '#a0a0a0',
                                callback: (value) => formatCurrency(value, displayCurrency, displayCurrency)
                            }
                        },
                        y: {
                            grid: { display: false },
                            ticks: { color: '#ffffff', font: { size: 10, weight: 'bold' } }
                        }
                    }
                }
            });
        }

        // Gráfica 5: Operaciones por Semana
        let monthlyOperationsChart = null;
        function updateMonthlyOperationsChart(operations, monthKey) {
            const ctx = document.getElementById('month-operations-chart')?.getContext('2d');
            if (!ctx) return;

            if (monthlyOperationsChart) {
                monthlyOperationsChart.destroy();
            }

            // Agrupar por semana
            const weeklyOps = {};
            operations.forEach(op => {
                const week = getWeekOfMonth(op.date);
                if (!weeklyOps[week]) weeklyOps[week] = 0;
                weeklyOps[week]++;
            });

            const weeks = Object.keys(weeklyOps).sort((a, b) => a - b);
            const labels = weeks.map(w => `Semana ${w}`);
            const data = weeks.map(w => weeklyOps[w]);

            monthlyOperationsChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Operaciones',
                        data: data,
                        backgroundColor: 'rgba(57, 255, 20, 0.8)',
                        borderColor: 'rgba(57, 255, 20, 1)',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.9)',
                            titleColor: '#39FF14',
                            bodyColor: '#ffffff',
                            callbacks: {
                                label: (context) => `Operaciones: ${context.raw}`
                            }
                        }
                    },
                    scales: {
                        x: { grid: { display: false }, ticks: { color: '#a0a0a0' } },
                        y: {
                            beginAtZero: true,
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { 
                                color: '#ffffff',
                                stepSize: 1
                            }
                        }
                    }
                }
            });
        }

        // Gráfica 6: Distribución de Resultados
        let monthlyDistributionChart = null;
        function updateMonthlyDistributionChart(operations, displayCurrency) {
            const ctx = document.getElementById('month-distribution-chart')?.getContext('2d');
            if (!ctx) return;

            if (monthlyDistributionChart) {
                monthlyDistributionChart.destroy();
            }

            // Definir rangos de P/L
            const ranges = [
                { min: -Infinity, max: -500, label: '< -$500' },
                { min: -500, max: -100, label: '-$500 a -$100' },
                { min: -100, max: -50, label: '-$100 a -$50' },
                { min: -50, max: 0, label: '-$50 a $0' },
                { min: 0, max: 50, label: '$0 a $50' },
                { min: 50, max: 100, label: '$50 a $100' },
                { min: 100, max: 500, label: '$100 a $500' },
                { min: 500, max: Infinity, label: '> $500' }
            ];

            const distribution = ranges.map(r => ({ ...r, count: 0 }));

            operations.forEach(op => {
                const pl = op.pl || 0;
                const range = distribution.find(r => pl >= r.min && pl < r.max);
                if (range) range.count++;
            });

            const labels = distribution.map(r => r.label);
            const data = distribution.map(r => r.count);
            const colors = distribution.map(r => r.min < 0 ? 'rgba(255, 68, 68, 0.8)' : 'rgba(57, 255, 20, 0.8)');

            monthlyDistributionChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Operaciones',
                        data: data,
                        backgroundColor: colors,
                        borderColor: colors.map(c => c.replace('0.8', '1')),
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.9)',
                            titleColor: '#39FF14',
                            bodyColor: '#ffffff',
                            callbacks: {
                                label: (context) => `Operaciones: ${context.raw}`
                            }
                        }
                    },
                    scales: {
                        x: { 
                            grid: { display: false }, 
                            ticks: { 
                                color: '#a0a0a0',
                                font: { size: 9 },
                                maxRotation: 45,
                                minRotation: 45
                            } 
                        },
                        y: {
                            beginAtZero: true,
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { 
                                color: '#ffffff',
                                stepSize: 1
                            }
                        }
                    }
                }
            });
        }

        // Cargar notas del día
        async function loadDailyNotes(dateStr) {
            try {
                const notesEditor = document.getElementById('analytics-detail-notes-editor');
                if (!notesEditor) return;

                // Buscar carpeta Daily Journal
                const dailyJournalFolder = DB.notebookFolders?.find(f => f.name === 'Daily Journal');
                
                if (!dailyJournalFolder) {
                    console.log('📁 No existe carpeta Daily Journal aún');
                    notesEditor.innerHTML = '';
                    updateCharCountAnalytics();
                    return;
                }

                // Buscar nota en memoria
                const existingNote = DB.notebookNotes?.find(n => 
                    n.folder_id === dailyJournalFolder.id && 
                    (n.title.includes(dateStr) || (n.metadata && n.metadata.dateKey === dateStr))
                );

                if (existingNote && existingNote.content) {
                    console.log('📝 Cargando nota existente:', existingNote.title);
                    notesEditor.innerHTML = existingNote.content;
                    updateCharCountAnalytics();
                } else {
                    console.log('📝 No hay notas para este día');
                    notesEditor.innerHTML = '';
                    updateCharCountAnalytics();
                }
            } catch (error) {
                console.error('Error al cargar notas del día:', error);
            }
        }

        // Guardar notas del día
        async function saveDailyNotes(dateStr, content) {
            try {
                if (!currentUser || !currentUser.id) {
                    showNotification('❌ Debes iniciar sesión para guardar notas', 'error');
                    return;
                }

                console.log('📝 Buscando carpeta Daily Journal...');
                
                // Buscar carpeta "Daily Journal" primero en memoria
                let dailyJournalFolder = DB.notebookFolders?.find(f => f.name === 'Daily Journal');
                
                // Si no está en memoria, buscar en IndexedDB
                if (!dailyJournalFolder) {
                    console.log('📂 No encontrada en memoria, buscando en IndexedDB...');
                    const allFolders = await dexieDB.notebookFolders.toArray();
                    dailyJournalFolder = allFolders.find(f => f.name === 'Daily Journal' && f.user_id === currentUser.id);
                    
                    if (dailyJournalFolder) {
                        console.log('✅ Carpeta encontrada en IndexedDB');
                        // Agregar a memoria
                        DB.notebookFolders = DB.notebookFolders || [];
                        DB.notebookFolders.push(dailyJournalFolder);
                    }
                }
                
                // Si aún no existe, crearla
                if (!dailyJournalFolder) {
                    console.log('📁 Creando nueva carpeta Daily Journal...');
                    dailyJournalFolder = {
                        id: 'folder_dailyjournal_' + Date.now(),
                        user_id: currentUser.id,
                        name: 'Daily Journal',
                        icon: '📔',
                        created_at: new Date().toISOString()
                    };
                    
                    await dexieDB.notebookFolders.add(dailyJournalFolder);
                    await supabase.from('notebook_folders').insert([dailyJournalFolder]);
                    
                    DB.notebookFolders = DB.notebookFolders || [];
                    DB.notebookFolders.push(dailyJournalFolder);
                    console.log('✅ Carpeta Daily Journal creada correctamente');
                }

                const noteTitle = `Análisis del Día - ${dateStr}`;
                console.log('🔍 Buscando nota existente para:', dateStr);

                // Buscar nota existente para esta fecha
                let existingNote = DB.notebookNotes?.find(n => 
                    n.folder_id === dailyJournalFolder.id && 
                    (n.title.includes(dateStr) || (n.metadata && n.metadata.dateKey === dateStr))
                );

                if (existingNote) {
                    // Actualizar nota existente
                    console.log('📝 Actualizando nota existente:', existingNote.title);
                    existingNote.content = content;
                    existingNote.updated_at = new Date().toISOString();
                    
                    await dexieDB.notebookNotes.put(existingNote);
                    await supabase.from('notebook_notes').update({
                        content: content,
                        updated_at: existingNote.updated_at
                    }).eq('id', existingNote.id);
                } else {
                    // Crear nueva nota
                    console.log('📝 Creando nueva nota para:', dateStr);
                    const newNote = {
                        id: 'note_analytics_' + dateStr.replace(/\-/g, '') + '_' + Date.now(),
                        user_id: currentUser.id,
                        folder_id: dailyJournalFolder.id,
                        title: noteTitle,
                        content: content,
                        created_at: new Date().toISOString(),
                        updated_at: new Date().toISOString(),
                        is_pinned: false,
                        metadata: {
                            dateKey: dateStr,
                            source: 'analytics_detail'
                        }
                    };
                    
                    await dexieDB.notebookNotes.add(newNote);
                    await supabase.from('notebook_notes').insert([newNote]);
                    
                    DB.notebookNotes = DB.notebookNotes || [];
                    DB.notebookNotes.unshift(newNote);
                    
                    console.log('✅ Nueva nota creada en Daily Journal');
                }

                // Actualizar UI del Notebook
                if (window.notebookNotesUpdated) {
                    window.notebookNotesUpdated();
                }

                showNotification('✅ Nota guardada en Daily Journal', 'success');
                console.log('✅ Nota sincronizada correctamente');
                
            } catch (error) {
                console.error('Error al guardar notas:', error);
                showNotification('❌ Error: ' + error.message, 'error');
            }
        }

        // Guardar notas del mes
        async function saveMonthlyNotes(monthStr, content) {
            try {
                if (!currentUser || !currentUser.id) {
                    showNotification('❌ Debes iniciar sesión para guardar notas', 'error');
                    return;
                }

                console.log('📝 Buscando carpeta Análisis del Mes...');
                
                // Buscar carpeta "Análisis del Mes" primero en memoria
                let monthAnalysisFolder = DB.notebookFolders?.find(f => f.name === 'Análisis del Mes');
                
                // Si no está en memoria, buscar en IndexedDB
                if (!monthAnalysisFolder) {
                    console.log('📂 No encontrada en memoria, buscando en IndexedDB...');
                    const allFolders = await dexieDB.notebookFolders.toArray();
                    monthAnalysisFolder = allFolders.find(f => f.name === 'Análisis del Mes' && f.user_id === currentUser.id);
                    
                    if (monthAnalysisFolder) {
                        console.log('✅ Carpeta encontrada en IndexedDB');
                        // Agregar a memoria
                        DB.notebookFolders = DB.notebookFolders || [];
                        DB.notebookFolders.push(monthAnalysisFolder);
                    }
                }
                
                // Si aún no existe, crearla
                if (!monthAnalysisFolder) {
                    console.log('📁 Creando nueva carpeta Análisis del Mes...');
                    monthAnalysisFolder = {
                        id: 'folder_monthanalysis_' + Date.now(),
                        user_id: currentUser.id,
                        name: 'Análisis del Mes',
                        icon: '�',
                        created_at: new Date().toISOString()
                    };
                    
                    await dexieDB.notebookFolders.add(monthAnalysisFolder);
                    await supabase.from('notebook_folders').insert([monthAnalysisFolder]);
                    
                    DB.notebookFolders = DB.notebookFolders || [];
                    DB.notebookFolders.push(monthAnalysisFolder);
                    console.log('✅ Carpeta Análisis del Mes creada correctamente');
                }

                // Formato: "Enero 2026" del string "2026-01"
                const [year, month] = monthStr.split('-');
                const monthNames = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'];
                const monthName = monthNames[parseInt(month) - 1];
                const noteTitle = `${monthName} ${year}`;
                
                console.log('🔍 Buscando nota existente para:', noteTitle);

                // Buscar nota existente para este mes
                let existingNote = DB.notebookNotes?.find(n => 
                    n.folder_id === monthAnalysisFolder.id && 
                    (n.title === noteTitle || (n.metadata && n.metadata.monthKey === monthStr))
                );

                if (existingNote) {
                    // Actualizar nota existente
                    console.log('📝 Actualizando nota existente:', existingNote.title);
                    existingNote.content = content;
                    existingNote.updated_at = new Date().toISOString();
                    
                    await dexieDB.notebookNotes.put(existingNote);
                    await supabase.from('notebook_notes').update({
                        content: content,
                        updated_at: existingNote.updated_at
                    }).eq('id', existingNote.id);
                } else {
                    // Crear nueva nota
                    console.log('📝 Creando nueva nota para:', noteTitle);
                    const newNote = {
                        id: 'note_month_' + monthStr.replace(/\-/g, '') + '_' + Date.now(),
                        user_id: currentUser.id,
                        folder_id: monthAnalysisFolder.id,
                        title: noteTitle,
                        content: content,
                        created_at: new Date().toISOString(),
                        updated_at: new Date().toISOString(),
                        is_pinned: false,
                        metadata: {
                            monthKey: monthStr,
                            source: 'analytics_month'
                        }
                    };
                    
                    await dexieDB.notebookNotes.add(newNote);
                    await supabase.from('notebook_notes').insert([newNote]);
                    
                    DB.notebookNotes = DB.notebookNotes || [];
                    DB.notebookNotes.unshift(newNote);
                    
                    console.log('✅ Nueva nota creada en Análisis del Mes');
                }

                // Actualizar UI del Notebook
                if (window.notebookNotesUpdated) {
                    window.notebookNotesUpdated();
                }

                showNotification('✅ Nota guardada en Análisis del Mes', 'success');
                console.log('✅ Nota sincronizada correctamente');
                
            } catch (error) {
                console.error('Error al guardar notas del mes:', error);
                showNotification('❌ Error: ' + error.message, 'error');
            }
        }

        // Cargar notas del mes
        async function loadMonthlyNotes(monthStr) {
            try {
                const notesEditor = document.getElementById('analytics-detail-notes-editor');
                if (!notesEditor) return;

                // Buscar carpeta Análisis del Mes
                const monthAnalysisFolder = DB.notebookFolders?.find(f => f.name === 'Análisis del Mes');
                
                if (!monthAnalysisFolder) {
                    console.log('📁 No existe carpeta Análisis del Mes aún');
                    notesEditor.innerHTML = '';
                    updateCharCountAnalytics();
                    return;
                }

                // Formato del título
                const [year, month] = monthStr.split('-');
                const monthNames = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'];
                const monthName = monthNames[parseInt(month) - 1];
                const noteTitle = `${monthName} ${year}`;

                // Buscar nota en memoria
                const existingNote = DB.notebookNotes?.find(n => 
                    n.folder_id === monthAnalysisFolder.id && 
                    (n.title === noteTitle || (n.metadata && n.metadata.monthKey === monthStr))
                );

                if (existingNote && existingNote.content) {
                    console.log('📝 Cargando nota existente:', existingNote.title);
                    notesEditor.innerHTML = existingNote.content;
                    updateCharCountAnalytics();
                } else {
                    console.log('📝 No hay notas para este mes');
                    notesEditor.innerHTML = '';
                    updateCharCountAnalytics();
                }
            } catch (error) {
                console.error('Error al cargar notas del mes:', error);
            }
        }

        // ===== GRÁFICAS SEMANALES =====
        
        // Gráfica 1: P/L por Día de la Semana
        let weeklyDailyPLChart = null;
        function updateWeeklyDailyPLChart(operations, displayCurrency) {
            const ctx = document.getElementById('week-daily-pl-chart')?.getContext('2d');
            if (!ctx) return;

            if (weeklyDailyPLChart) {
                weeklyDailyPLChart.destroy();
            }

            // Agrupar por día de la semana
            const weekdays = ['Domingo', 'Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sábado'];
            const dailyPL = Array(7).fill(0);

            operations.forEach(op => {
                const day = new Date(op.date).getDay();
                dailyPL[day] += op.pl || 0;
            });

            const colors = dailyPL.map(pl => pl >= 0 ? 'rgba(57, 255, 20, 0.8)' : 'rgba(255, 68, 68, 0.8)');

            weeklyDailyPLChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: weekdays,
                    datasets: [{
                        label: 'P/L',
                        data: dailyPL,
                        backgroundColor: colors,
                        borderColor: colors.map(c => c.replace('0.8', '1')),
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.9)',
                            titleColor: '#39FF14',
                            bodyColor: '#ffffff',
                            callbacks: {
                                label: (context) => `P/L: ${formatCurrency(context.raw, displayCurrency, displayCurrency)}`
                            }
                        }
                    },
                    scales: {
                        x: { grid: { display: false }, ticks: { color: '#a0a0a0' } },
                        y: {
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { 
                                color: '#ffffff',
                                callback: (value) => formatCurrency(value, displayCurrency, displayCurrency)
                            }
                        }
                    }
                }
            });
        }

        // Gráfica 2: Win Rate por Día
        let weeklyDailyWinRateChart = null;
        function updateWeeklyDailyWinRateChart(operations) {
            const ctx = document.getElementById('week-daily-winrate-chart')?.getContext('2d');
            if (!ctx) return;

            if (weeklyDailyWinRateChart) {
                weeklyDailyWinRateChart.destroy();
            }

            const weekdays = ['Domingo', 'Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sábado'];
            const dailyStats = Array(7).fill(null).map(() => ({ wins: 0, losses: 0, total: 0 }));

            operations.forEach(op => {
                const day = new Date(op.date).getDay();
                dailyStats[day].total++;
                if ((op.pl || 0) > 0) dailyStats[day].wins++;
                else if ((op.pl || 0) < 0) dailyStats[day].losses++;
            });

            const winRates = dailyStats.map(stats => 
                stats.total > 0 ? (stats.wins / stats.total) * 100 : 0
            );
            const colors = winRates.map(wr => wr >= 50 ? 'rgba(57, 255, 20, 0.8)' : 'rgba(255, 68, 68, 0.8)');

            weeklyDailyWinRateChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: weekdays,
                    datasets: [{
                        label: 'Win Rate %',
                        data: winRates,
                        backgroundColor: colors,
                        borderColor: colors.map(c => c.replace('0.8', '1')),
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.9)',
                            titleColor: '#39FF14',
                            bodyColor: '#ffffff',
                            callbacks: {
                                label: (context) => {
                                    const stats = dailyStats[context.dataIndex];
                                    return [
                                        `Win Rate: ${context.raw.toFixed(1)}%`,
                                        `Trades: ${stats.total} (${stats.wins}W/${stats.losses}L)`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        x: { grid: { display: false }, ticks: { color: '#a0a0a0' } },
                        y: {
                            beginAtZero: true,
                            max: 100,
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { 
                                color: '#ffffff',
                                callback: (value) => value + '%'
                            }
                        }
                    }
                }
            });
        }

        // Gráfica 3: Comparativa con Semanas Anteriores
        let weeklyComparisonChart = null;
        function updateWeeklyComparisonChart(operations, weekValue, displayCurrency) {
            const ctx = document.getElementById('week-comparison-chart')?.getContext('2d');
            if (!ctx) return;

            if (weeklyComparisonChart) {
                weeklyComparisonChart.destroy();
            }

            // Calcular P/L de esta semana
            const thisWeekPL = operations.reduce((sum, op) => sum + (op.pl || 0), 0);

            // Obtener últimas 4 semanas (simulado - necesitarías implementar lógica real)
            const labels = ['Hace 4 sem', 'Hace 3 sem', 'Hace 2 sem', 'Hace 1 sem', 'Esta semana'];
            const data = [0, 0, 0, 0, thisWeekPL]; // Las anteriores serían 0 o calcularías real

            const colors = data.map(pl => pl >= 0 ? 'rgba(57, 255, 20, 0.8)' : 'rgba(255, 68, 68, 0.8)');
            colors[4] = 'rgba(57, 255, 20, 1)'; // Destacar esta semana

            weeklyComparisonChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'P/L',
                        data: data,
                        backgroundColor: colors,
                        borderColor: colors.map(c => c.replace('0.8', '1')),
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.9)',
                            titleColor: '#39FF14',
                            bodyColor: '#ffffff',
                            callbacks: {
                                label: (context) => `P/L: ${formatCurrency(context.raw, displayCurrency, displayCurrency)}`
                            }
                        }
                    },
                    scales: {
                        x: { grid: { display: false }, ticks: { color: '#a0a0a0' } },
                        y: {
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { 
                                color: '#ffffff',
                                callback: (value) => formatCurrency(value, displayCurrency, displayCurrency)
                            }
                        }
                    }
                }
            });
        }

        // Gráfica 4: P/L por Sesión de Mercado
        let weeklySessionChart = null;
        function updateWeeklySessionChart(operations, displayCurrency) {
            const ctx = document.getElementById('week-session-chart')?.getContext('2d');
            if (!ctx) return;

            if (weeklySessionChart) {
                weeklySessionChart.destroy();
            }

            const sessions = { 'Asiática': 0, 'Europea': 0, 'Americana': 0 };

            operations.forEach(op => {
                const hour = parseInt((op.entryTime || '00:00').split(':')[0]);
                if (hour >= 0 && hour < 8) sessions['Asiática'] += op.pl || 0;
                else if (hour >= 8 && hour < 15) sessions['Europea'] += op.pl || 0;
                else sessions['Americana'] += op.pl || 0;
            });

            const labels = Object.keys(sessions);
            const data = Object.values(sessions);
            const colors = data.map(pl => pl >= 0 ? 'rgba(57, 255, 20, 0.8)' : 'rgba(255, 68, 68, 0.8)');

            weeklySessionChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'P/L',
                        data: data,
                        backgroundColor: colors,
                        borderColor: colors.map(c => c.replace('0.8', '1')),
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.9)',
                            titleColor: '#39FF14',
                            bodyColor: '#ffffff',
                            callbacks: {
                                label: (context) => `P/L: ${formatCurrency(context.raw, displayCurrency, displayCurrency)}`
                            }
                        }
                    },
                    scales: {
                        x: { grid: { display: false }, ticks: { color: '#a0a0a0' } },
                        y: {
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { 
                                color: '#ffffff',
                                callback: (value) => formatCurrency(value, displayCurrency, displayCurrency)
                            }
                        }
                    }
                }
            });
        }

        // Gráfica 5: Top 10 Instrumentos de la Semana
        let weeklyTopInstrumentsChart = null;
        function updateWeeklyTopInstrumentsChart(operations, displayCurrency) {
            const ctx = document.getElementById('week-top-instruments-chart')?.getContext('2d');
            if (!ctx) return;

            if (weeklyTopInstrumentsChart) {
                weeklyTopInstrumentsChart.destroy();
            }

            const instrumentStats = {};
            operations.forEach(op => {
                const symbol = op.symbol || 'Unknown';
                if (!instrumentStats[symbol]) {
                    instrumentStats[symbol] = { pl: 0, trades: 0 };
                }
                instrumentStats[symbol].pl += op.pl || 0;
                instrumentStats[symbol].trades++;
            });

            const sorted = Object.entries(instrumentStats)
                .sort(([,a], [,b]) => b.pl - a.pl)
                .slice(0, 10);

            const labels = sorted.map(([symbol]) => symbol);
            const data = sorted.map(([, stats]) => stats.pl);
            const colors = data.map(pl => pl >= 0 ? 'rgba(57, 255, 20, 0.8)' : 'rgba(255, 68, 68, 0.8)');

            weeklyTopInstrumentsChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'P/L',
                        data: data,
                        backgroundColor: colors,
                        borderColor: colors.map(c => c.replace('0.8', '1')),
                        borderWidth: 2
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.9)',
                            titleColor: '#39FF14',
                            bodyColor: '#ffffff',
                            callbacks: {
                                label: (context) => {
                                    const [symbol] = sorted[context.dataIndex];
                                    const stats = instrumentStats[symbol];
                                    return [
                                        `P/L: ${formatCurrency(context.raw, displayCurrency, displayCurrency)}`,
                                        `Trades: ${stats.trades}`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { 
                                color: '#a0a0a0',
                                callback: (value) => formatCurrency(value, displayCurrency, displayCurrency)
                            }
                        },
                        y: {
                            grid: { display: false },
                            ticks: { color: '#ffffff', font: { size: 10, weight: 'bold' } }
                        }
                    }
                }
            });
        }

        // Gráfica 6: P/L por Hora del Día
        let weeklyHourlyPLChart = null;
        function updateWeeklyHourlyPLChart(operations, displayCurrency) {
            const ctx = document.getElementById('week-hourly-pl-chart')?.getContext('2d');
            if (!ctx) return;

            if (weeklyHourlyPLChart) {
                weeklyHourlyPLChart.destroy();
            }

            const hourlyPL = Array(24).fill(0);

            operations.forEach(op => {
                const hour = parseInt((op.entryTime || '00:00').split(':')[0]);
                if (hour >= 0 && hour < 24) {
                    hourlyPL[hour] += op.pl || 0;
                }
            });

            const labels = Array.from({length: 24}, (_, i) => `${i}:00`);
            const colors = hourlyPL.map(pl => pl >= 0 ? 'rgba(57, 255, 20, 0.8)' : 'rgba(255, 68, 68, 0.8)');

            weeklyHourlyPLChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'P/L',
                        data: hourlyPL,
                        backgroundColor: colors,
                        borderColor: colors.map(c => c.replace('0.8', '1')),
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.9)',
                            titleColor: '#39FF14',
                            bodyColor: '#ffffff',
                            callbacks: {
                                label: (context) => `P/L: ${formatCurrency(context.raw, displayCurrency, displayCurrency)}`
                            }
                        }
                    },
                    scales: {
                        x: { 
                            grid: { display: false }, 
                            ticks: { 
                                color: '#a0a0a0',
                                maxRotation: 90,
                                minRotation: 45,
                                font: { size: 9 }
                            } 
                        },
                        y: {
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { 
                                color: '#ffffff',
                                callback: (value) => formatCurrency(value, displayCurrency, displayCurrency)
                            }
                        }
                    }
                }
            });
        }

        // ========== FUNCIONES PARA GRÁFICAS DEL TRIMESTRE ==========

        // Gráfica 1: P/L por Mes del Trimestre
        let quarterlyMonthlyPLChart = null;
        function updateQuarterlyMonthlyPLChart(operations, displayCurrency) {
            const ctx = document.getElementById('quarter-monthly-pl-chart')?.getContext('2d');
            if (!ctx) return;

            if (quarterlyMonthlyPLChart) {
                quarterlyMonthlyPLChart.destroy();
            }

            // Agrupar operaciones por mes
            const monthlyPL = {};
            operations.forEach(op => {
                const date = new Date(op.date);
                const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                if (!monthlyPL[monthKey]) monthlyPL[monthKey] = 0;
                monthlyPL[monthKey] += op.pl || 0;
            });

            const months = Object.keys(monthlyPL).sort();
            const monthNames = months.map(m => {
                const [year, month] = m.split('-');
                const date = new Date(year, parseInt(month) - 1);
                return date.toLocaleDateString('es-ES', { month: 'short', year: 'numeric' });
            });
            const plValues = months.map(m => monthlyPL[m]);
            const colors = plValues.map(pl => pl >= 0 ? 'rgba(57, 255, 20, 0.8)' : 'rgba(255, 68, 68, 0.8)');

            quarterlyMonthlyPLChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: monthNames,
                    datasets: [{
                        label: 'P/L Mensual',
                        data: plValues,
                        backgroundColor: colors,
                        borderColor: colors.map(c => c.replace('0.8', '1')),
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.9)',
                            titleColor: '#39FF14',
                            bodyColor: '#ffffff',
                            callbacks: {
                                label: (context) => `P/L: ${formatCurrency(context.raw, displayCurrency, displayCurrency)}`
                            }
                        }
                    },
                    scales: {
                        x: { grid: { display: false }, ticks: { color: '#a0a0a0' } },
                        y: {
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { 
                                color: '#ffffff',
                                callback: (value) => formatCurrency(value, displayCurrency, displayCurrency)
                            }
                        }
                    }
                }
            });
        }

        // Gráfica 2: Win Rate por Mes
        let quarterlyMonthlyWinRateChart = null;
        function updateQuarterlyMonthlyWinRateChart(operations) {
            const ctx = document.getElementById('quarter-monthly-winrate-chart')?.getContext('2d');
            if (!ctx) return;

            if (quarterlyMonthlyWinRateChart) {
                quarterlyMonthlyWinRateChart.destroy();
            }

            const monthlyStats = {};
            operations.forEach(op => {
                const date = new Date(op.date);
                const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                if (!monthlyStats[monthKey]) {
                    monthlyStats[monthKey] = { wins: 0, total: 0 };
                }
                monthlyStats[monthKey].total++;
                const isWin = op.result === 'win' || (!op.result && op.pl > 0);
                if (isWin) monthlyStats[monthKey].wins++;
            });

            const months = Object.keys(monthlyStats).sort();
            const monthNames = months.map(m => {
                const [year, month] = m.split('-');
                const date = new Date(year, parseInt(month) - 1);
                return date.toLocaleDateString('es-ES', { month: 'short', year: 'numeric' });
            });
            const winRates = months.map(m => (monthlyStats[m].wins / monthlyStats[m].total) * 100);
            const colors = winRates.map(wr => wr >= 50 ? 'rgba(57, 255, 20, 0.8)' : 'rgba(255, 68, 68, 0.8)');

            quarterlyMonthlyWinRateChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: monthNames,
                    datasets: [{
                        label: 'Win Rate (%)',
                        data: winRates,
                        backgroundColor: colors,
                        borderColor: colors.map(c => c.replace('0.8', '1')),
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.9)',
                            titleColor: '#39FF14',
                            bodyColor: '#ffffff',
                            callbacks: {
                                label: (context) => `Win Rate: ${context.raw.toFixed(1)}%`
                            }
                        }
                    },
                    scales: {
                        x: { grid: { display: false }, ticks: { color: '#a0a0a0' } },
                        y: {
                            min: 0,
                            max: 100,
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { 
                                color: '#ffffff',
                                callback: (value) => value + '%'
                            }
                        }
                    }
                }
            });
        }

        // Gráfica 3: Volumen de Operaciones por Mes
        let quarterlyOperationsVolumeChart = null;
        function updateQuarterlyOperationsVolumeChart(operations) {
            const ctx = document.getElementById('quarter-operations-volume-chart')?.getContext('2d');
            if (!ctx) return;

            if (quarterlyOperationsVolumeChart) {
                quarterlyOperationsVolumeChart.destroy();
            }

            const monthlyCount = {};
            operations.forEach(op => {
                const date = new Date(op.date);
                const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                if (!monthlyCount[monthKey]) monthlyCount[monthKey] = 0;
                monthlyCount[monthKey]++;
            });

            const months = Object.keys(monthlyCount).sort();
            const monthNames = months.map(m => {
                const [year, month] = m.split('-');
                const date = new Date(year, parseInt(month) - 1);
                return date.toLocaleDateString('es-ES', { month: 'short', year: 'numeric' });
            });
            const counts = months.map(m => monthlyCount[m]);

            quarterlyOperationsVolumeChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: monthNames,
                    datasets: [{
                        label: 'Número de Operaciones',
                        data: counts,
                        backgroundColor: 'rgba(0, 123, 255, 0.8)',
                        borderColor: 'rgba(0, 123, 255, 1)',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.9)',
                            titleColor: '#39FF14',
                            bodyColor: '#ffffff',
                            callbacks: {
                                label: (context) => `Operaciones: ${context.raw}`
                            }
                        }
                    },
                    scales: {
                        x: { grid: { display: false }, ticks: { color: '#a0a0a0' } },
                        y: {
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { 
                                color: '#ffffff',
                                stepSize: 1
                            }
                        }
                    }
                }
            });
        }

        // Gráfica 4: Top 5 Mejores Instrumentos
        let quarterlyTopInstrumentsChart = null;
        function updateQuarterlyTopInstrumentsChart(operations, displayCurrency) {
            const ctx = document.getElementById('quarter-top-instruments-chart')?.getContext('2d');
            if (!ctx) return;

            if (quarterlyTopInstrumentsChart) {
                quarterlyTopInstrumentsChart.destroy();
            }

            const instrumentPL = {};
            operations.forEach(op => {
                const instrument = op.instrument || 'Desconocido';
                if (!instrumentPL[instrument]) instrumentPL[instrument] = 0;
                instrumentPL[instrument] += op.pl || 0;
            });

            const sortedInstruments = Object.entries(instrumentPL)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5);

            const labels = sortedInstruments.map(([inst, _]) => inst);
            const values = sortedInstruments.map(([_, pl]) => pl);
            const colors = values.map(pl => pl >= 0 ? 'rgba(57, 255, 20, 0.8)' : 'rgba(255, 68, 68, 0.8)');

            quarterlyTopInstrumentsChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'P/L',
                        data: values,
                        backgroundColor: colors,
                        borderColor: colors.map(c => c.replace('0.8', '1')),
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: 'y',
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.9)',
                            titleColor: '#39FF14',
                            bodyColor: '#ffffff',
                            callbacks: {
                                label: (context) => `P/L: ${formatCurrency(context.raw, displayCurrency, displayCurrency)}`
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { 
                                color: '#ffffff',
                                callback: (value) => formatCurrency(value, displayCurrency, displayCurrency)
                            }
                        },
                        y: { grid: { display: false }, ticks: { color: '#a0a0a0' } }
                    }
                }
            });
        }

        // Gráfica 5: Performance por Sesión de Mercado
        let quarterlySessionPerformanceChart = null;
        function updateQuarterlySessionPerformanceChart(operations, displayCurrency) {
            const ctx = document.getElementById('quarter-session-performance-chart')?.getContext('2d');
            if (!ctx) return;

            if (quarterlySessionPerformanceChart) {
                quarterlySessionPerformanceChart.destroy();
            }

            const sessions = { Asia: 0, Europa: 0, America: 0 };

            operations.forEach(op => {
                if (op.entryTime) {
                    const hour = parseInt(op.entryTime.split(':')[0]);
                    let session = 'America';
                    if (hour >= 0 && hour < 8) session = 'Asia';
                    else if (hour >= 8 && hour < 16) session = 'Europa';
                    sessions[session] += op.pl || 0;
                }
            });

            const labels = ['Asia (00-08h)', 'Europa (08-16h)', 'América (16-00h)'];
            const values = [sessions.Asia, sessions.Europa, sessions.America];
            const colors = values.map(pl => pl >= 0 ? 'rgba(57, 255, 20, 0.8)' : 'rgba(255, 68, 68, 0.8)');

            quarterlySessionPerformanceChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'P/L',
                        data: values,
                        backgroundColor: colors,
                        borderColor: colors.map(c => c.replace('0.8', '1')),
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.9)',
                            titleColor: '#39FF14',
                            bodyColor: '#ffffff',
                            callbacks: {
                                label: (context) => `P/L: ${formatCurrency(context.raw, displayCurrency, displayCurrency)}`
                            }
                        }
                    },
                    scales: {
                        x: { grid: { display: false }, ticks: { color: '#a0a0a0' } },
                        y: {
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { 
                                color: '#ffffff',
                                callback: (value) => formatCurrency(value, displayCurrency, displayCurrency)
                            }
                        }
                    }
                }
            });
        }

        // Gráfica 6: Distribución Wins vs Losses
        let quarterlyWinLossDistributionChart = null;
        function updateQuarterlyWinLossDistributionChart(operations, displayCurrency) {
            const ctx = document.getElementById('quarter-win-loss-distribution-chart')?.getContext('2d');
            if (!ctx) return;

            if (quarterlyWinLossDistributionChart) {
                quarterlyWinLossDistributionChart.destroy();
            }

            let totalWins = 0, totalLosses = 0, totalBreakeven = 0;
            let avgWin = 0, avgLoss = 0;
            let winCount = 0, lossCount = 0;

            operations.forEach(op => {
                const isWin = op.result === 'win' || (!op.result && op.pl > 0);
                const isLoss = op.result === 'loss' || (!op.result && op.pl < 0);
                
                if (isWin) {
                    totalWins += op.pl || 0;
                    winCount++;
                } else if (isLoss) {
                    totalLosses += Math.abs(op.pl || 0);
                    lossCount++;
                } else {
                    totalBreakeven++;
                }
            });

            avgWin = winCount > 0 ? totalWins / winCount : 0;
            avgLoss = lossCount > 0 ? totalLosses / lossCount : 0;

            const labels = ['Promedio Win', 'Promedio Loss', 'Total Wins', 'Total Losses'];
            const values = [avgWin, avgLoss, totalWins, totalLosses];
            const colors = [
                'rgba(57, 255, 20, 0.8)',
                'rgba(255, 68, 68, 0.8)',
                'rgba(57, 255, 20, 0.6)',
                'rgba(255, 68, 68, 0.6)'
            ];

            quarterlyWinLossDistributionChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Monto',
                        data: values,
                        backgroundColor: colors,
                        borderColor: colors.map(c => c.replace(/0\.[68]/, '1')),
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.9)',
                            titleColor: '#39FF14',
                            bodyColor: '#ffffff',
                            callbacks: {
                                label: (context) => `${context.label}: ${formatCurrency(context.raw, displayCurrency, displayCurrency)}`
                            }
                        }
                    },
                    scales: {
                        x: { grid: { display: false }, ticks: { color: '#a0a0a0' } },
                        y: {
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { 
                                color: '#ffffff',
                                callback: (value) => formatCurrency(value, displayCurrency, displayCurrency)
                            }
                        }
                    }
                }
            });
        }

        // ===== FUNCIONES PARA NOTAS SEMANALES =====
        
        async function saveWeeklyNotes(startDate, endDate, content) {
            try {
                if (!currentUser) {
                    console.error('No hay usuario autenticado');
                    showNotification('⚠️ Debes iniciar sesión para guardar notas', 'warning');
                    return;
                }

                console.log('📝 Guardando notas de la semana:', startDate, 'al', endDate);

                // Buscar carpeta "Análisis de la Semana"
                let weekAnalysisFolder = DB.notebookFolders?.find(f => f.name === 'Análisis de la Semana');

                // Si no está en memoria, buscar en IndexedDB
                if (!weekAnalysisFolder) {
                    const allFolders = await dexieDB.notebookFolders.toArray();
                    weekAnalysisFolder = allFolders.find(f => f.name === 'Análisis de la Semana' && f.user_id === currentUser.id);

                    if (weekAnalysisFolder) {
                        DB.notebookFolders = DB.notebookFolders || [];
                        DB.notebookFolders.push(weekAnalysisFolder);
                    }
                }

                // Si aún no existe, crearla
                if (!weekAnalysisFolder) {
                    weekAnalysisFolder = {
                        id: 'folder_weekanalysis_' + Date.now(),
                        user_id: currentUser.id,
                        name: 'Análisis de la Semana',
                        icon: '📁',
                        created_at: new Date().toISOString()
                    };

                    await dexieDB.notebookFolders.add(weekAnalysisFolder);
                    await supabase.from('notebook_folders').insert([weekAnalysisFolder]);

                    DB.notebookFolders = DB.notebookFolders || [];
                    DB.notebookFolders.push(weekAnalysisFolder);
                }

                const weekKey = `${startDate}_${endDate}`;
                const noteTitle = `Semana ${startDate} al ${endDate}`;

                // Buscar nota existente
                let existingNote = DB.notebookNotes.find(n => 
                    n.folder_id === weekAnalysisFolder.id && 
                    (n.title === noteTitle || (n.metadata && n.metadata.weekKey === weekKey))
                );

                if (existingNote) {
                    existingNote.content = content;
                    existingNote.updated_at = new Date().toISOString();
                    await dexieDB.notebookNotes.put(existingNote);
                    await supabase.from('notebook_notes').update({ content, updated_at: existingNote.updated_at }).eq('id', existingNote.id);
                } else {
                    const newNote = {
                        id: 'note_week_' + Date.now(),
                        user_id: currentUser.id,
                        folder_id: weekAnalysisFolder.id,
                        title: noteTitle,
                        content: content,
                        created_at: new Date().toISOString(),
                        updated_at: new Date().toISOString(),
                        is_pinned: false,
                        metadata: { weekKey: weekKey, source: 'analytics_week' }
                    };

                    await dexieDB.notebookNotes.add(newNote);
                    await supabase.from('notebook_notes').insert([newNote]);
                    DB.notebookNotes.push(newNote);
                }

                showNotification('✅ Nota guardada en Análisis de la Semana', 'success');
            } catch (error) {
                console.error('Error al guardar notas de la semana:', error);
                showNotification('❌ Error al guardar notas', 'error');
            }
        }

        async function loadWeeklyNotes(startDate, endDate) {
            try {
                const notesEditor = document.getElementById('analytics-detail-notes-editor');
                if (!notesEditor) return;

                const weekKey = `${startDate}_${endDate}`;
                const noteTitle = `Semana ${startDate} al ${endDate}`;

                // Buscar carpeta Análisis de la Semana
                const weekAnalysisFolder = DB.notebookFolders?.find(f => f.name === 'Análisis de la Semana');

                if (!weekAnalysisFolder) {
                    notesEditor.innerHTML = '';
                    updateCharCountAnalytics();
                    return;
                }

                const existingNote = DB.notebookNotes.find(n => 
                    n.folder_id === weekAnalysisFolder.id && 
                    (n.title === noteTitle || (n.metadata && n.metadata.weekKey === weekKey))
                );

                if (existingNote && existingNote.content) {
                    notesEditor.innerHTML = existingNote.content;
                    updateCharCountAnalytics();
                } else {
                    notesEditor.innerHTML = '';
                    updateCharCountAnalytics();
                }
            } catch (error) {
                console.error('Error al cargar notas de la semana:', error);
            }
        }

        // ===== FUNCIONES PARA NOTAS DEL TRIMESTRE =====
        
        async function saveQuarterlyNotes(quarter, content) {
            try {
                if (!currentUser) {
                    console.error('No hay usuario autenticado');
                    showNotification('⚠️ Debes iniciar sesión para guardar notas', 'warning');
                    return;
                }

                console.log('📝 Guardando notas del trimestre:', quarter);

                // Buscar carpeta "Análisis de Trimestre"
                let quarterAnalysisFolder = DB.notebookFolders?.find(f => f.name === 'Análisis de Trimestre');

                // Si no está en memoria, buscar en IndexedDB
                if (!quarterAnalysisFolder) {
                    const allFolders = await dexieDB.notebookFolders.toArray();
                    quarterAnalysisFolder = allFolders.find(f => f.name === 'Análisis de Trimestre' && f.user_id === currentUser.id);

                    if (quarterAnalysisFolder) {
                        DB.notebookFolders = DB.notebookFolders || [];
                        DB.notebookFolders.push(quarterAnalysisFolder);
                    }
                }

                // Si aún no existe, crearla
                if (!quarterAnalysisFolder) {
                    quarterAnalysisFolder = {
                        id: 'folder_quarteranalysis_' + Date.now(),
                        user_id: currentUser.id,
                        name: 'Análisis de Trimestre',
                        icon: '📁',
                        created_at: new Date().toISOString()
                    };

                    await dexieDB.notebookFolders.add(quarterAnalysisFolder);
                    await supabase.from('notebook_folders').insert([quarterAnalysisFolder]);

                    DB.notebookFolders = DB.notebookFolders || [];
                    DB.notebookFolders.push(quarterAnalysisFolder);
                }

                const noteTitle = `Trimestre ${quarter}`;

                // Buscar nota existente
                let existingNote = DB.notebookNotes.find(n => 
                    n.folder_id === quarterAnalysisFolder.id && 
                    (n.title === noteTitle || (n.metadata && n.metadata.quarter === quarter))
                );

                if (existingNote) {
                    existingNote.content = content;
                    existingNote.updated_at = new Date().toISOString();
                    await dexieDB.notebookNotes.put(existingNote);
                    await supabase.from('notebook_notes').update({ content, updated_at: existingNote.updated_at }).eq('id', existingNote.id);
                } else {
                    const newNote = {
                        id: 'note_quarter_' + Date.now(),
                        user_id: currentUser.id,
                        folder_id: quarterAnalysisFolder.id,
                        title: noteTitle,
                        content: content,
                        created_at: new Date().toISOString(),
                        updated_at: new Date().toISOString(),
                        is_pinned: false,
                        metadata: { quarter: quarter, source: 'analytics_quarter' }
                    };

                    await dexieDB.notebookNotes.add(newNote);
                    await supabase.from('notebook_notes').insert([newNote]);
                    DB.notebookNotes.push(newNote);
                }

                showNotification('✅ Nota guardada en Análisis de Trimestre', 'success');
            } catch (error) {
                console.error('Error al guardar notas del trimestre:', error);
                showNotification('❌ Error al guardar notas', 'error');
            }
        }

        async function loadQuarterlyNotes(quarter) {
            try {
                const notesEditor = document.getElementById('analytics-detail-notes-editor');
                if (!notesEditor) return;

                const noteTitle = `Trimestre ${quarter}`;

                // Buscar carpeta Análisis de Trimestre
                const quarterAnalysisFolder = DB.notebookFolders?.find(f => f.name === 'Análisis de Trimestre');

                if (!quarterAnalysisFolder) {
                    notesEditor.innerHTML = '';
                    updateCharCountAnalytics();
                    return;
                }

                const existingNote = DB.notebookNotes.find(n => 
                    n.folder_id === quarterAnalysisFolder.id && 
                    (n.title === noteTitle || (n.metadata && n.metadata.quarter === quarter))
                );

                if (existingNote && existingNote.content) {
                    notesEditor.innerHTML = existingNote.content;
                    updateCharCountAnalytics();
                } else {
                    notesEditor.innerHTML = '';
                    updateCharCountAnalytics();
                }
            } catch (error) {
                console.error('Error al cargar notas del trimestre:', error);
            }
        }

        // ========== NUEVO DASHBOARD - FUNCIONES ==========
        
        let newDashboardCharts = {
            netPlGauge: null,
            winRateGauge: null,
            profitFactorGauge: null,
            cumulativeChart: null,
            dailyPlChart: null,
            radarChart: null
        };
        
        // Función principal para refrescar el nuevo dashboard
        function refreshNewDashboard() {
            console.log('🔄 refreshNewDashboard() iniciado');
            
            if (!document.getElementById('dashboard') || !document.getElementById('dashboard').classList.contains('active')) {
                console.log('⚠️ Nuevo Dashboard no está activo, cancelando refresh');
                return;
            }
            
            const accountSelect = document.getElementById('new-dashboard-account-select');
            const currencySelect = document.getElementById('new-dashboard-currency-select');
            
            if (!accountSelect || !currencySelect) {
                console.log('⚠️ Selectores del nuevo dashboard no encontrados');
                return;
            }
            
            const selectedAccount = accountSelect.value;
            const displayCurrency = currencySelect.value;
            
            console.log('📊 Nuevo Dashboard - Cuenta seleccionada:', selectedAccount);
            console.log('💱 Nuevo Dashboard - Moneda:', displayCurrency);
            
            // Aplicar filtro de fecha global primero
            let operations = applyDateFilterToData(DB.operations);
            console.log('📅 Después de filtro de fecha:', operations.length, 'operaciones');
            
            // Aplicar filtro de cuenta
            if (selectedAccount !== 'all') {
                operations = operations.filter(op => op.accountId === selectedAccount);
                console.log('👤 Después de filtro de cuenta:', operations.length, 'operaciones');
            }
            
            const metrics = calculateMetrics(operations, selectedAccount);
            const dayWinStats = calculateDayWinStats(operations); // NUEVO
            const grossPL = metrics.totalWin + metrics.totalLoss;
            const netPL = grossPL - metrics.totalFees;
            
            console.log('💰 P/L Bruto:', grossPL, '| P/L Neto:', netPL, '| Comisiones:', metrics.totalFees);
            
            // Agregar estadísticas de días a las métricas
            metrics.winDays = dayWinStats.winningDays;
            metrics.loseDays = dayWinStats.losingDays;
            
            // Actualizar métricas
            updateNewDashboardMetrics(metrics, netPL, displayCurrency);
            
            // Actualizar gráficas
            updateNewDashboardGauges(metrics, netPL);
            updateNewDashboardCumulativeChart(operations, displayCurrency);
            updateNewDashboardDailyPLChart(operations, displayCurrency);
            updateNewDashboardRadarChart(operations, selectedAccount);
            updateNewDashboardCalendar(operations); // Ya recibe las operaciones filtradas
            updateNewDashboardRecentOps(operations, displayCurrency);
            updateInstrumentPerformanceChart(operations, 'new-dash-instrument-chart');
            updateDayPerformanceChart(operations, 'new-dash-day-chart');
            
            console.log('✅ Nuevo Dashboard actualizado con', operations.length, 'operaciones');
        }
        
        // Actualizar tabla de operaciones recientes
        function updateNewDashboardRecentOps(operations, currency) {
            const tbody = document.getElementById('new-dash-recent-ops');
            if (!tbody) return;
            
            tbody.innerHTML = '';
            
            // Obtener las últimas 10 operaciones
            const recentOps = [...operations]
                .sort((a, b) => new Date(b.date) - new Date(a.date))
                .slice(0, 10);
            
            if (recentOps.length === 0) {
                tbody.innerHTML = '<tr><td colspan="3" class="text-center text-text-secondary py-4">No hay operaciones recientes</td></tr>';
                return;
            }
            
            recentOps.forEach(op => {
                const netPL = (op.pl || 0) - (op.fees || 0);
                const isProfit = netPL > 0;
                const date = new Date(op.date);
                const formattedDate = `${date.getDate()}/${date.getMonth() + 1}/${date.getFullYear()}`;
                
                const row = document.createElement('tr');
                row.className = 'border-b border-border hover:bg-surface-light cursor-pointer transition-colors';
                row.innerHTML = `
                    <td class="py-2 text-text-secondary">${formattedDate}</td>
                    <td class="py-2 text-white font-medium">${op.instrument || 'N/A'}</td>
                    <td class="py-2 text-right font-bold ${isProfit ? 'text-green' : 'text-red'}">${formatCurrency(netPL, DB.settings.defaultCurrency, currency)}</td>
                `;
                
                // Click para abrir página de detalles de la operación
                row.addEventListener('click', () => {
                    if (typeof showOperationDetailPage === 'function') {
                        showOperationDetailPage(op.id);
                    }
                });
                
                tbody.appendChild(row);
            });
        }
        
        // Actualizar todas las métricas
        function updateNewDashboardMetrics(metrics, netPL, currency) {
            const netPlEl = document.getElementById('new-dash-net-pl');
            if (netPlEl) {
                netPlEl.textContent = formatCurrency(netPL, DB.settings.defaultCurrency, currency);
                netPlEl.className = `text-xl font-bold hide-amount mb-1 ${netPL >= 0 ? 'text-green' : 'text-red'}`;
            }
            
            const totalTradesEl = document.getElementById('new-dash-total-trades');
            if (totalTradesEl) totalTradesEl.textContent = `${metrics.totalTrades} trades`;
            
            // Comisiones (NUEVO)
            const comisionesEl = document.getElementById('new-dash-comisiones');
            if (comisionesEl) {
                comisionesEl.textContent = formatCurrency(metrics.totalFees || 0, DB.settings.defaultCurrency, currency);
            }
            const comisionesCountEl = document.getElementById('new-dash-comisiones-count');
            if (comisionesCountEl) comisionesCountEl.textContent = `${metrics.totalTrades} fees`;
            
            const winRateEl = document.getElementById('new-dash-win-rate');
            if (winRateEl) winRateEl.textContent = `${metrics.winRate.toFixed(2)}%`;
            
            const winsEl = document.getElementById('new-dash-wins');
            if (winsEl) winsEl.textContent = metrics.winningTrades;
            
            const lossesEl = document.getElementById('new-dash-losses');
            if (lossesEl) lossesEl.textContent = metrics.losingTrades;
            
            // Day Win (NUEVO)
            const dayWinRateEl = document.getElementById('new-dash-day-win-rate');
            const totalDays = (metrics.winDays || 0) + (metrics.loseDays || 0);
            const dayWinRate = totalDays > 0 ? ((metrics.winDays || 0) / totalDays) * 100 : 0;
            if (dayWinRateEl) dayWinRateEl.textContent = `${dayWinRate.toFixed(2)}%`;
            
            const dayWinsEl = document.getElementById('new-dash-day-wins');
            if (dayWinsEl) dayWinsEl.textContent = metrics.winDays || 0;
            
            const dayLossesEl = document.getElementById('new-dash-day-losses');
            if (dayLossesEl) dayLossesEl.textContent = metrics.loseDays || 0;
            
            const profitFactorEl = document.getElementById('new-dash-profit-factor');
            if (profitFactorEl) {
                profitFactorEl.textContent = isFinite(metrics.profitFactor) ? metrics.profitFactor.toFixed(2) : '∞';
            }
            
            const avgWin = metrics.winningTrades > 0 ? metrics.totalWin / metrics.winningTrades : 0;
            const avgLoss = metrics.losingTrades > 0 ? Math.abs(metrics.totalLoss) / metrics.losingTrades : 0;
            const ratio = avgLoss > 0 ? avgWin / avgLoss : 0;
            
            const avgRatioEl = document.getElementById('new-dash-avg-ratio');
            if (avgRatioEl) avgRatioEl.textContent = ratio.toFixed(2);
            
            const avgWinEl = document.getElementById('new-dash-avg-win');
            if (avgWinEl) avgWinEl.textContent = formatCurrency(avgWin, DB.settings.defaultCurrency, currency);
            
            const avgLossEl = document.getElementById('new-dash-avg-loss');
            if (avgLossEl) avgLossEl.textContent = formatCurrency(-avgLoss, DB.settings.defaultCurrency, currency);
            
            // Update progress bars
            const totalRange = avgWin + avgLoss;
            const winPercent = totalRange > 0 ? (avgWin / totalRange) * 100 : 50;
            const lossPercent = 100 - winPercent;
            
            const winBarEl = document.getElementById('new-dash-win-bar');
            if (winBarEl) winBarEl.style.width = `${winPercent}%`;
            
            const lossBarEl = document.getElementById('new-dash-loss-bar');
            if (lossBarEl) lossBarEl.style.width = `${lossPercent}%`;
        }
        
        // Actualizar todos los gauge charts
        function updateNewDashboardGauges(metrics, netPL) {
            // Net P/L Gauge
            updateNewDashboardNetPLGauge(netPL);
            
            // Comisiones Gauge (NUEVO)
            updateNewDashboardComisionesGauge(metrics.totalFees || 0);
            
            // Win Rate Gauge
            updateNewDashboardWinRateGauge(metrics.winRate);
            
            // Day Win Gauge (NUEVO)
            updateNewDashboardDayWinGauge(metrics.winDays || 0, metrics.loseDays || 0);
            
            // Profit Factor Gauge
            updateNewDashboardProfitFactorGauge(metrics.profitFactor);
        }
        
        // Gauge para Net P/L
        function updateNewDashboardNetPLGauge(netPL) {
            const canvas = document.getElementById('new-dash-net-pl-gauge');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            
            if (newDashboardCharts.netPlGauge) {
                newDashboardCharts.netPlGauge.destroy();
            }
            
            const maxValue = Math.max(Math.abs(netPL) * 1.5, 1000);
            const normalizedValue = Math.min(Math.abs(netPL), maxValue);
            const percentage = (normalizedValue / maxValue) * 100;
            
            newDashboardCharts.netPlGauge = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    datasets: [{
                        data: [percentage, 100 - percentage],
                        backgroundColor: [
                            netPL >= 0 ? 'rgba(57, 255, 20, 0.8)' : 'rgba(255, 65, 54, 0.8)',
                            'rgba(42, 42, 42, 0.3)'
                        ],
                        borderWidth: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    circumference: 180,
                    rotation: -90,
                    cutout: '75%',
                    plugins: {
                        legend: { display: false },
                        tooltip: { enabled: false }
                    }
                }
            });
        }
        
        // Gauge para Win Rate
        function updateNewDashboardWinRateGauge(winRate) {
            const canvas = document.getElementById('new-dash-win-rate-gauge');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            
            if (newDashboardCharts.winRateGauge) {
                newDashboardCharts.winRateGauge.destroy();
            }
            
            newDashboardCharts.winRateGauge = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    datasets: [{
                        data: [winRate, 100 - winRate],
                        backgroundColor: [
                            winRate >= 50 ? 'rgba(57, 255, 20, 0.8)' : 'rgba(234, 179, 8, 0.8)',
                            'rgba(42, 42, 42, 0.3)'
                        ],
                        borderWidth: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    circumference: 180,
                    rotation: -90,
                    cutout: '75%',
                    plugins: {
                        legend: { display: false },
                        tooltip: { enabled: false }
                    }
                }
            });
        }
        
        // Gauge para Comisiones (NUEVO)
        function updateNewDashboardComisionesGauge(totalFees) {
            const canvas = document.getElementById('new-dash-comisiones-gauge');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            
            if (newDashboardCharts.comisionesGauge) {
                newDashboardCharts.comisionesGauge.destroy();
            }
            
            const maxValue = Math.max(Math.abs(totalFees) * 1.5, 100);
            const normalizedValue = Math.min(Math.abs(totalFees), maxValue);
            const percentage = (normalizedValue / maxValue) * 100;
            
            newDashboardCharts.comisionesGauge = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    datasets: [{
                        data: [percentage, 100 - percentage],
                        backgroundColor: [
                            'rgba(255, 65, 54, 0.8)',
                            'rgba(42, 42, 42, 0.3)'
                        ],
                        borderWidth: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    circumference: 180,
                    rotation: -90,
                    cutout: '75%',
                    plugins: {
                        legend: { display: false },
                        tooltip: { enabled: false }
                    }
                }
            });
        }
        
        // Gauge para Day Win (NUEVO)
        function updateNewDashboardDayWinGauge(winDays, loseDays) {
            const canvas = document.getElementById('new-dash-day-win-gauge');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            
            if (newDashboardCharts.dayWinGauge) {
                newDashboardCharts.dayWinGauge.destroy();
            }
            
            const totalDays = winDays + loseDays;
            const dayWinRate = totalDays > 0 ? (winDays / totalDays) * 100 : 0;
            
            newDashboardCharts.dayWinGauge = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    datasets: [{
                        data: [dayWinRate, 100 - dayWinRate],
                        backgroundColor: [
                            dayWinRate >= 50 ? 'rgba(57, 255, 20, 0.8)' : 'rgba(234, 179, 8, 0.8)',
                            'rgba(42, 42, 42, 0.3)'
                        ],
                        borderWidth: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    circumference: 180,
                    rotation: -90,
                    cutout: '75%',
                    plugins: {
                        legend: { display: false },
                        tooltip: { enabled: false }
                    }
                }
            });
        }
        
        // Gauge para Profit Factor
        function updateNewDashboardProfitFactorGauge(profitFactor) {
            const canvas = document.getElementById('new-dash-profit-factor-gauge');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            
            if (newDashboardCharts.profitFactorGauge) {
                newDashboardCharts.profitFactorGauge.destroy();
            }
            
            const normalizedPF = Math.min(profitFactor, 3);
            const percentage = (normalizedPF / 3) * 100;
            
            let color;
            if (profitFactor >= 2) color = 'rgba(57, 255, 20, 0.8)';
            else if (profitFactor >= 1) color = 'rgba(234, 179, 8, 0.8)';
            else color = 'rgba(255, 65, 54, 0.8)';
            
            newDashboardCharts.profitFactorGauge = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    datasets: [{
                        data: [percentage, 100 - percentage],
                        backgroundColor: [color, 'rgba(42, 42, 42, 0.3)'],
                        borderWidth: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    circumference: 180,
                    rotation: -90,
                    cutout: '75%',
                    plugins: {
                        legend: { display: false },
                        tooltip: { enabled: false }
                    }
                }
            });
        }
        
        // Daily Net Cumulative P&L Chart (Réplica exacta de Analytics)
        function updateNewDashboardCumulativeChart(operations, currency) {
            const canvas = document.getElementById('new-dash-cumulative-chart');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            
            if (newDashboardCharts.cumulativeChart) {
                newDashboardCharts.cumulativeChart.destroy();
            }
            
            const displayCurrency = currency;
            const targetCurrency = displayCurrency === '%' ? DB.settings.defaultCurrency : displayCurrency;
            
            // Ordenar operaciones por fecha
            const sorted = [...operations].sort((a, b) => new Date(a.date) - new Date(b.date));
            
            let cumulative = 0;
            const labels = [];
            const data = [];
            
            sorted.forEach(op => {
                let plConverted = op.pl;
                if (op.currency !== targetCurrency) {
                    plConverted = convertCurrency(op.pl, op.currency, targetCurrency);
                }
                cumulative += plConverted;
                labels.push(op.date);
                data.push(cumulative);
            });
            
            if (data.length === 0) {
                labels.push(new Date().toISOString().split('T')[0]);
                data.push(0);
            }
            
            newDashboardCharts.cumulativeChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels,
                    datasets: [{
                        data,
                        borderColor: '#39ff14',
                        backgroundColor: 'rgba(57, 255, 20, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 0,
                        pointHoverRadius: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: (ctx) => `P&L: ${formatCurrency(ctx.raw, targetCurrency, displayCurrency)}`
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: { color: '#2a2a2a', display: true },
                            ticks: { color: '#a0a0a0', maxTicksLimit: 8 }
                        },
                        y: {
                            grid: { color: '#2a2a2a' },
                            ticks: {
                                color: '#a0a0a0',
                                callback: (val) => formatCurrency(val, targetCurrency, displayCurrency)
                            }
                        }
                    }
                }
            });
        }
        
        // Net Daily P&L Chart (Réplica exacta de Analytics)
        function updateNewDashboardDailyPLChart(operations, currency) {
            const canvas = document.getElementById('new-dash-daily-pl-chart');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            
            if (newDashboardCharts.dailyPlChart) {
                newDashboardCharts.dailyPlChart.destroy();
            }
            
            const displayCurrency = currency;
            const targetCurrency = displayCurrency === '%' ? DB.settings.defaultCurrency : displayCurrency;
            
            // Agrupar por fecha
            const dailyPL = {};
            operations.forEach(op => {
                const date = op.date;
                if (!dailyPL[date]) dailyPL[date] = 0;
                
                let plConverted = op.pl;
                if (op.currency !== targetCurrency) {
                    plConverted = convertCurrency(op.pl, op.currency, targetCurrency);
                }
                dailyPL[date] += plConverted;
            });
            
            const sorted = Object.keys(dailyPL).sort();
            const labels = sorted;
            const data = sorted.map(date => dailyPL[date]);
            
            if (data.length === 0) {
                labels.push(new Date().toISOString().split('T')[0]);
                data.push(0);
            }
            
            newDashboardCharts.dailyPlChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels,
                    datasets: [{
                        label: 'P&L Diario',
                        data,
                        backgroundColor: data.map(val => val >= 0 ? 'rgba(57, 255, 20, 0.8)' : 'rgba(255, 65, 54, 0.8)'),
                        borderColor: data.map(val => val >= 0 ? '#39ff14' : '#ff4136'),
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (ctx) => `P&L: ${formatCurrency(ctx.raw, targetCurrency, displayCurrency)}`
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: { display: false },
                            ticks: { color: '#a0a0a0', maxTicksLimit: 10 }
                        },
                        y: {
                            grid: { color: '#2a2a2a' },
                            ticks: {
                                color: '#a0a0a0',
                                callback: (val) => formatCurrency(val, targetCurrency, displayCurrency)
                            }
                        }
                    }
                }
            });
        }
        
        // Radar Chart (Puntuación de Rendimiento)
        function updateNewDashboardRadarChart(operations, accountId) {
            console.log('🎯 [RADAR] updateNewDashboardRadarChart llamado con', operations.length, 'operaciones');
            
            const canvas = document.getElementById('new-dash-radar-chart');
            if (!canvas) {
                console.error('❌ [RADAR] Canvas new-dash-radar-chart no encontrado');
                return;
            }
            
            // SIEMPRE destruir el chart anterior si existe
            if (newDashboardCharts.radarChart) {
                console.log('🔄 [RADAR] Destruyendo chart anterior...');
                try {
                    newDashboardCharts.radarChart.destroy();
                } catch (e) {
                    console.warn('⚠️ [RADAR] Error al destruir chart:', e);
                }
                newDashboardCharts.radarChart = null;
            }
            
            const ctx = canvas.getContext('2d');
            
            const metrics = calculateMetrics(operations, accountId);
            
            const winRateScore = Math.min(metrics.winRate, 100);
            const profitFactorScore = Math.min((metrics.profitFactor / 3) * 100, 100);
            console.log('🎯 [RADAR] Llamando calculateConsistencyScore...');
            const consistency = calculateConsistencyScore(operations);
            console.log('🎯 [RADAR] Consistencia calculada:', consistency);
            const riskReward = calculateRiskRewardScore(operations);
            const avgWinLoss = calculateAvgWinLossScore(operations);
            
            // Validar y REDONDEAR valores para evitar problemas de precisión
            const validatedData = [
                Math.round((isNaN(winRateScore) || !isFinite(winRateScore) ? 0 : winRateScore) * 10) / 10,
                Math.round((isNaN(profitFactorScore) || !isFinite(profitFactorScore) ? 0 : profitFactorScore) * 10) / 10,
                Math.round((isNaN(consistency) || !isFinite(consistency) ? 0 : consistency) * 10) / 10,
                Math.round((isNaN(riskReward) || !isFinite(riskReward) ? 0 : riskReward) * 10) / 10,
                Math.round((isNaN(avgWinLoss) || !isFinite(avgWinLoss) ? 0 : avgWinLoss) * 10) / 10
            ];
            
            console.log('🎯 [RADAR] Scores validados:', validatedData);
            console.log('✅ [RADAR] Valor de Consistencia (posición 2):', validatedData[2]);
            
            // Reorganizar datos para poner Consistencia primero (evitar problemas de renderizado)
            const reorderedData = [
                validatedData[2], // Consistencia
                validatedData[0], // Win Rate
                validatedData[1], // Profit Factor
                validatedData[3], // R:R
                validatedData[4]  // Avg W/L
            ];
            
            console.log('🎯 [RADAR] Datos reorganizados (Consistencia primero):', reorderedData);
            
            // CREAR chart nuevo SIEMPRE
            newDashboardCharts.radarChart = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: ['Consistencia', 'Win Rate', 'Profit Factor', 'R:R', 'Avg W/L'],
                    datasets: [{
                        label: 'Rendimiento',
                        data: reorderedData,
                        borderColor: '#39ff14',
                        backgroundColor: 'rgba(57, 255, 20, 0.2)',
                        borderWidth: 2,
                        pointBackgroundColor: '#39ff14',
                        pointBorderColor: '#fff',
                        pointHoverBackgroundColor: '#fff',
                        pointHoverBorderColor: '#39ff14',
                        pointRadius: 4,
                        pointHoverRadius: 5
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        r: {
                            min: 0,
                            max: 100,
                            ticks: {
                                stepSize: 20,
                                color: '#a0a0a0',
                                backdropColor: 'transparent',
                                font: { size: 9 },
                                display: true
                            },
                            grid: { 
                                color: '#2a2a2a',
                                circular: true
                            },
                            angleLines: {
                                color: '#2a2a2a'
                            },
                            pointLabels: {
                                color: '#ffffff',
                                font: { size: 10, weight: 'bold' }
                            }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return context.label + ': ' + context.parsed.r.toFixed(1) + '%';
                                }
                            }
                        }
                    }
                }
            });
            
            // Forzar resize después de crear el chart (solución para problemas de renderizado)
            setTimeout(() => {
                if (newDashboardCharts.radarChart) {
                    newDashboardCharts.radarChart.resize();
                    console.log('✅ [RADAR] Chart resized');
                }
            }, 100);
        }
        
        // Helper functions for radar chart scores
        function calculateConsistencyScore(operations) {
            console.log('🔍 [CONSISTENCY] Calculando consistencia para', operations.length, 'operaciones');
            
            if (operations.length < 5) {
                console.log('⚠️ [CONSISTENCY] Menos de 5 operaciones, retornando 50');
                return 50;
            }
            
            const dailyPL = {};
            operations.forEach(op => {
                const date = op.date.includes('T') ? op.date.split('T')[0] : op.date;
                if (!dailyPL[date]) dailyPL[date] = 0;
                
                // CORREGIDO: Manejar correctamente pl/pnl y valores nulos
                const plValue = op.pl ?? op.pnl ?? 0;
                const feeValue = op.fees ?? op.fee ?? 0;
                const validPL = typeof plValue === 'number' && !isNaN(plValue) ? plValue : 0;
                const validFees = typeof feeValue === 'number' && !isNaN(feeValue) ? feeValue : 0;
                
                dailyPL[date] += validPL - validFees;
            });
            
            const values = Object.values(dailyPL);
            console.log('📊 [CONSISTENCY] Días únicos:', values.length);
            console.log('📊 [CONSISTENCY] P&L diario:', values.slice(0, 5), '...');
            
            if (values.length < 2) {
                console.log('⚠️ [CONSISTENCY] Menos de 2 días, retornando 50');
                return 50;
            }
            
            const avg = values.reduce((sum, v) => sum + v, 0) / values.length;
            const variance = values.reduce((sum, v) => sum + Math.pow(v - avg, 2), 0) / values.length;
            const stdDev = Math.sqrt(variance);
            
            console.log('📊 [CONSISTENCY] Avg P&L:', avg.toFixed(2), 'StdDev:', stdDev.toFixed(2));
            
            // Coeficiente de variación mejorado
            if (Math.abs(avg) < 0.01) {
                // Si el promedio es ~0, usar win rate diario como proxy
                const winningDays = values.filter(v => v > 0).length;
                const score = (winningDays / values.length) * 100;
                console.log('📊 [CONSISTENCY] Avg ~0, usando winrate diario:', score.toFixed(1) + '%');
                return score;
            }
            
            const coefficientOfVariation = stdDev / Math.abs(avg);
            console.log('📊 [CONSISTENCY] Coeficiente de Variación:', coefficientOfVariation.toFixed(2));
            
            // Escala mejorada de consistencia adaptada al trading real
            // En trading, CV de 1.0-2.0 es normal, CV < 1.0 es excelente, CV > 3.0 es muy inconsistente
            let score = 0;
            if (coefficientOfVariation < 0.3) {
                // Extremadamente consistente (raro en trading)
                score = 95 + (0.3 - coefficientOfVariation) * 16.67; // 95-100
            } else if (coefficientOfVariation < 0.8) {
                // Muy consistente
                score = 80 + (0.8 - coefficientOfVariation) * 30; // 80-95
            } else if (coefficientOfVariation < 1.5) {
                // Consistencia buena (normal en trading)
                score = 60 + (1.5 - coefficientOfVariation) * 28.57; // 60-80
            } else if (coefficientOfVariation < 2.5) {
                // Consistencia regular
                score = 35 + (2.5 - coefficientOfVariation) * 25; // 35-60
            } else if (coefficientOfVariation < 4.0) {
                // Baja consistencia
                score = 10 + (4.0 - coefficientOfVariation) * 16.67; // 10-35
            } else {
                // Muy inconsistente
                score = Math.max(0, 10 - (coefficientOfVariation - 4.0) * 2.5);
            }
            
            score = Math.max(0, Math.min(100, score));
            console.log('✅ [CONSISTENCY] Score final:', score.toFixed(1) + '%');
            
            return score;
        }
        
        function calculateRiskRewardScore(operations) {
            const wins = operations.filter(op => {
                const pl = op.pl ?? op.pnl ?? 0;
                return pl > 0;
            });
            const losses = operations.filter(op => {
                const pl = op.pl ?? op.pnl ?? 0;
                return pl < 0;
            });
            
            if (losses.length === 0) return 100;
            if (wins.length === 0) return 0;
            
            const avgWin = wins.reduce((sum, op) => sum + (op.pl ?? op.pnl ?? 0), 0) / wins.length;
            const avgLoss = Math.abs(losses.reduce((sum, op) => sum + (op.pl ?? op.pnl ?? 0), 0) / losses.length);
            
            if (avgLoss === 0) return 100;
            
            const ratio = avgWin / avgLoss;
            return Math.min((ratio / 3) * 100, 100);
        }
        
        function calculateAvgWinLossScore(operations) {
            const metrics = calculateMetrics(operations);
            const avgWin = metrics.winningTrades > 0 ? metrics.totalWin / metrics.winningTrades : 0;
            const avgLoss = metrics.losingTrades > 0 ? Math.abs(metrics.totalLoss) / metrics.losingTrades : 1;
            
            if (avgLoss === 0) return 100;
            
            const ratio = avgWin / avgLoss;
            return Math.min((ratio / 2) * 100, 100);
        }
        
        // Calendario mensual compacto
        let newDashboardCalendarState = {
            currentYear: new Date().getFullYear(),
            currentMonth: new Date().getMonth(),
            filteredOperations: [] // Guardar operaciones filtradas
        };
        
        function updateNewDashboardCalendar(operations) {
            const grid = document.getElementById('new-dash-calendar-grid');
            if (!grid) return;
            
            // Guardar operaciones filtradas en el estado para que prev/next las usen
            newDashboardCalendarState.filteredOperations = operations;
            
            renderNewDashboardCalendar(newDashboardCalendarState.currentYear, newDashboardCalendarState.currentMonth, operations);
            
            // Event listeners para navegación
            const prevBtn = document.getElementById('new-dash-cal-prev');
            const nextBtn = document.getElementById('new-dash-cal-next');
            
            if (prevBtn) {
                prevBtn.onclick = () => {
                    newDashboardCalendarState.currentMonth--;
                    if (newDashboardCalendarState.currentMonth < 0) {
                        newDashboardCalendarState.currentMonth = 11;
                        newDashboardCalendarState.currentYear--;
                    }
                    // Usar las operaciones filtradas guardadas en el estado
                    renderNewDashboardCalendar(newDashboardCalendarState.currentYear, newDashboardCalendarState.currentMonth, newDashboardCalendarState.filteredOperations);
                };
            }
            
            if (nextBtn) {
                nextBtn.onclick = () => {
                    newDashboardCalendarState.currentMonth++;
                    if (newDashboardCalendarState.currentMonth > 11) {
                        newDashboardCalendarState.currentMonth = 0;
                        newDashboardCalendarState.currentYear++;
                    }
                    // Usar las operaciones filtradas guardadas en el estado
                    renderNewDashboardCalendar(newDashboardCalendarState.currentYear, newDashboardCalendarState.currentMonth, newDashboardCalendarState.filteredOperations);
                };
            }
        }
        
        // Renderizar Calendario Mensual (MEJORADO - Réplica exacta del Calendario principal)
        function renderNewDashboardCalendar(year, month, operations) {
            const grid = document.getElementById('new-dash-calendar-grid');
            const monthNameEl = document.getElementById('new-dash-cal-month');
            if (!grid) return;
            
            const monthNames = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 
                               'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'];
            
            if (monthNameEl) {
                monthNameEl.textContent = `${monthNames[month]} ${year}`;
            }
            
            grid.innerHTML = '';
            
            const firstDayOfMonth = new Date(Date.UTC(year, month, 1));
            const lastDayOfMonth = new Date(Date.UTC(year, month + 1, 0));
            const baseCurrencyForCalc = document.getElementById('new-dashboard-currency-select')?.value || 'USD';
            const selectedAccount = document.getElementById('new-dashboard-account-select')?.value || 'all';
            
            // Agrupar operaciones
            const groupedOps = {};
            operations.forEach(op => {
                const opId = op.id;
                if (!groupedOps[opId]) {
                    groupedOps[opId] = {
                        id: opId,
                        totalPL: 0,
                        date: op.date,
                        currency: op.currency
                    };
                }
                groupedOps[opId].totalPL += (op.pl || 0) - (op.fees || 0);
            });
            
            // Agrupar por día y semana
            const dailyData = {};
            const weeklyData = {};
            
            Object.values(groupedOps).forEach(group => {
                const opDate = new Date(group.date + 'T00:00:00Z');
                if (opDate.getUTCFullYear() !== year || opDate.getUTCMonth() !== month) return;
                
                const day = opDate.getUTCDate();
                const weekNumber = getWeekNumber(opDate);
                
                if (!dailyData[day]) dailyData[day] = { operations: [], totalPL: 0, count: 0 };
                if (!weeklyData[weekNumber]) weeklyData[weekNumber] = { operations: [], totalPL: 0, count: 0, weekNumber: weekNumber };

                let pl = group.totalPL;
                if (group.currency !== baseCurrencyForCalc && baseCurrencyForCalc !== '%') {
                    pl = convertCurrency(pl, group.currency, baseCurrencyForCalc);
                }
                dailyData[day].operations.push(group); 
                dailyData[day].totalPL += pl; 
                dailyData[day].count++;
                weeklyData[weekNumber].operations.push(group); 
                weeklyData[weekNumber].totalPL += pl; 
                weeklyData[weekNumber].count++;
            });

            const daysInMonth = lastDayOfMonth.getUTCDate();
            const firstDayOfWeekIndex = firstDayOfMonth.getUTCDay();
            let weekCounter = 1;

            // Días vacíos antes del primer día del mes
            for (let i = 0; i < firstDayOfWeekIndex; i++) {
                grid.innerHTML += `<div class="calendar-day empty"></div>`;
            }

            // Renderizar días del mes
            for (let day = 1; day <= daysInMonth; day++) {
                const currentDate = new Date(Date.UTC(year, month, day));
                const dayOfWeekIndex = currentDate.getUTCDay();
                const dayData = dailyData[day];
                let cellHTML = `<div class="calendar-day `;

                if (dayData) {
                    const isProfit = dayData.totalPL > 0; 
                    const isLoss = dayData.totalPL < 0;
                    cellHTML += isProfit ? 'profit' : (isLoss ? 'loss' : '');
                    cellHTML += ` clickable" data-day="${day}" data-date="${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}">`;
                    cellHTML += `<div class="day-number">${day}</div>`;
                    
                    const formattedPL = formatCurrency(dayData.totalPL, baseCurrencyForCalc, baseCurrencyForCalc);
                    cellHTML += `<div class="day-profit ${isProfit ? 'positive' : (isLoss ? 'negative' : '')}">${formattedPL}</div>`;
                    cellHTML += `<div class="day-trades">${dayData.count} op.</div>`;
                } else {
                    cellHTML += `" data-day="${day}">`;
                    cellHTML += `<div class="day-number text-text-secondary">${day}</div>`;
                }
                cellHTML += `</div>`;
                grid.innerHTML += cellHTML;

                // Agregar resumen semanal al final de cada semana
                if (dayOfWeekIndex === 6) {
                    const weekNumber = getWeekNumber(currentDate);
                    const weekData = weeklyData[weekNumber] || { totalPL: 0, count: 0, weekNumber: weekNumber };
                    const isWeekProfit = weekData.totalPL > 0; 
                    const isWeekLoss = weekData.totalPL < 0;
                    const formattedWeekPL = formatCurrency(weekData.totalPL, baseCurrencyForCalc, baseCurrencyForCalc);
                    
                    grid.innerHTML += `<div class="week-summary" style="background-color: var(--surface); border: 1px solid var(--surface-light)">
                                          <div class="font-bold text-sm">Sem ${weekCounter}</div>
                                          <div class="text-lg font-semibold ${isWeekProfit ? 'text-positive' : (isWeekLoss ? 'text-negative' : '')}">${formattedWeekPL}</div>
                                          <div class="text-xs text-text-secondary">${weekData.count} trades</div>
                                       </div>`;
                    weekCounter++;
                }
            }

            // Completar última semana si no termina en sábado
            if (lastDayOfMonth.getUTCDay() !== 6) {
                for (let i = lastDayOfMonth.getUTCDay() + 1; i <= 6; i++) {
                    grid.innerHTML += `<div class="calendar-day empty"></div>`;
                }
                const weekNumber = getWeekNumber(lastDayOfMonth);
                const weekData = weeklyData[weekNumber] || { totalPL: 0, count: 0, weekNumber: weekNumber };
                const isWeekProfit = weekData.totalPL > 0; 
                const isWeekLoss = weekData.totalPL < 0;
                const formattedWeekPL = formatCurrency(weekData.totalPL, baseCurrencyForCalc, baseCurrencyForCalc);
                
                grid.innerHTML += `<div class="week-summary" style="background-color: var(--surface); border: 1px solid var(--surface-light)">
                                      <div class="font-bold text-sm">Sem ${weekCounter}</div>
                                      <div class="text-lg font-semibold ${isWeekProfit ? 'text-positive' : (isWeekLoss ? 'text-negative' : '')}">${formattedWeekPL}</div>
                                      <div class="text-xs text-text-secondary">${weekData.count} trades</div>
                                   </div>`;
            }
            
            // Agregar event listeners para clics en los días
            setTimeout(() => {
                const dayElements = grid.querySelectorAll('.calendar-day.clickable');
                dayElements.forEach(dayEl => {
                    dayEl.addEventListener('click', () => {
                        const dateStr = dayEl.dataset.date;
                        if (!dateStr) return;
                        
                        const opsForDay = operations.filter(op => op.date === dateStr);
                        if (opsForDay.length === 0) return;
                        
                        // Abrir el modal de Análisis del Día con métricas completas
                        if (typeof openAnalyticsDetailModal === 'function') {
                            // Formatear la fecha para el título
                            const dateObj = new Date(dateStr + 'T12:00:00');
                            const dayNames = ['Domingo', 'Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sábado'];
                            const dayName = dayNames[dateObj.getDay()];
                            const formattedTitle = `${dayName} ${dateStr}`;
                            
                            // Obtener la cuenta seleccionada del dashboard
                            const accountSelect = document.getElementById('new-dashboard-account-select');
                            const dashboardAccount = accountSelect ? accountSelect.value : 'all';
                            
                            // Pasar la cuenta del dashboard como accountOverride
                            openAnalyticsDetailModal('date', dateStr, formattedTitle, dashboardAccount);
                        }
                    });
                });
            }, 100);
        }

        // ========== FUNCIONES PARA EDITOR RICO DE ANALYTICS ==========
        
        // Formatear texto en el editor de analytics
        function formatTextAnalytics(command, value = null) {
            document.execCommand(command, false, value);
            const editor = document.getElementById('analytics-detail-notes-editor');
            if (editor) editor.focus();
            updateCharCountAnalytics();
        }

        // Insertar imagen en analytics
        function insertImageAnalytics() {
            const input = document.getElementById('analytics-notes-image-input');
            if (input) input.click();
        }

        // Insertar enlace en analytics
        function insertLinkAnalytics() {
            const url = prompt('Ingresa la URL:');
            if (url) {
                document.execCommand('createLink', false, url);
            }
        }

        // Actualizar contador de caracteres
        function updateCharCountAnalytics() {
            const editor = document.getElementById('analytics-detail-notes-editor');
            const counter = document.getElementById('analytics-editor-char-count');
            if (editor && counter) {
                const text = editor.innerText || '';
                counter.textContent = `${text.length} caracteres`;
            }
        }

        // Manejo de selección de imagen para analytics
        document.addEventListener('DOMContentLoaded', () => {
            const imageInput = document.getElementById('analytics-notes-image-input');
            if (imageInput) {
                imageInput.addEventListener('change', function(e) {
                    const file = e.target.files[0];
                    if (file && file.type.startsWith('image/')) {
                        const reader = new FileReader();
                        reader.onload = function(event) {
                            const img = `<img src="${event.target.result}" style="max-width: 100%; height: auto; margin: 10px 0; border-radius: 8px;" />`;
                            document.execCommand('insertHTML', false, img);
                            const editor = document.getElementById('analytics-detail-notes-editor');
                            if (editor) editor.focus();
                            updateCharCountAnalytics();
                        };
                        reader.readAsDataURL(file);
                    }
                    e.target.value = '';
                });
            }

            // Event listener para contador de caracteres
            const editor = document.getElementById('analytics-detail-notes-editor');
            if (editor) {
                editor.addEventListener('input', updateCharCountAnalytics);
                editor.addEventListener('paste', () => setTimeout(updateCharCountAnalytics, 100));
            }
        });

        // Variables para grabación de voz en analytics
        let analyticsMediaRecorder = null;
        let analyticsAudioChunks = [];

        // Función para descargar nota
        function downloadAnalyticsNote() {
            const editor = document.getElementById('analytics-detail-notes-editor');
            const modal = document.getElementById('analytics-detail-modal');
            const dateStr = modal.dataset.currentDate || 'nota';
            
            if (editor) {
                const content = editor.innerHTML;
                const blob = new Blob([content], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `nota-${dateStr}.html`;
                a.click();
                URL.revokeObjectURL(url);
            }
        }

        // --- FIN de Funciones para el Modal de Detalles de Analytics ---

        function initFinances() {
            document.getElementById('add-finance-entry-btn').addEventListener('click', () => toggleAddFinanceEntryForm());
            document.getElementById('finance-cancel-btn').addEventListener('click', () => toggleAddFinanceEntryForm());
            document.getElementById('finance-save-btn').addEventListener('click', saveFinanceEntry);
            document.getElementById('finances-table-body').addEventListener('click', handleFinancesTableClick);

            // Event listener para mostrar/ocultar banco cuando es retiro y categoría cuando es gasto
            const movementTypeSelect = document.getElementById('finance-movement-type');
            const bankContainer = document.getElementById('finance-bank-container');
            const categoryContainer = document.getElementById('finance-category-container');
            if (movementTypeSelect && bankContainer && categoryContainer) {
                movementTypeSelect.addEventListener('change', (e) => {
                    const type = e.target.value;
                    // Mostrar banco si es retiro
                    if (type === 'retiro') {
                        bankContainer.style.display = 'block';
                        categoryContainer.style.display = 'none';
                    } 
                    // Mostrar categoría si es gasto
                    else if (type === 'gasto') {
                        bankContainer.style.display = 'none';
                        categoryContainer.style.display = 'block';
                    }
                    // Ocultar ambos si es ingreso
                    else {
                        bankContainer.style.display = 'none';
                        categoryContainer.style.display = 'none';
                    }
                });
            }

            // Event listeners para TrackerBank
            const bankToggle = document.getElementById('trackerbank-bank-account-toggle');
            const bankSelect = document.getElementById('trackerbank-bank-select');
            const bankSection = document.getElementById('trackerbank-bank-account-section');
            const bankNameDisplay = document.getElementById('trackerbank-bank-name-display');
            
            if (bankToggle && bankSelect && bankSection) {
                bankToggle.addEventListener('change', (e) => {
                    if (e.target.checked) {
                        console.log('🏦 Activando cuenta corriente...');
                        bankSelect.style.display = 'inline-block';
                        bankSection.style.display = 'block';
                        const selectedBank = bankSelect.value;
                        console.log('Banco seleccionado:', selectedBank);
                        
                        // Obtener todas las finanzas y filtrar retiros
                        const allFinances = DB.finances || [];
                        console.log('Total finanzas en DB:', allFinances.length);
                        
                        // Mostrar muestra de finanzas para debugging
                        if (allFinances.length > 0) {
                            console.log('📊 Muestra de finanzas:', allFinances.slice(0, 3));
                        }
                        
                        // Filtrar retiros con múltiples criterios
                        const withdrawals = allFinances.filter(f => {
                            if (f.movementType === 'retiro') return true;
                            const desc = (f.description || f.notes || '').toLowerCase();
                            if (desc.includes('retiro') || desc.includes('withdrawal')) return true;
                            if (f.accountType === 'personal' && f.amount > 0) return true;
                            return false;
                        });
                        
                        console.log('Total retiros encontrados:', withdrawals);
                        renderTrackerBankAccountEvolution(withdrawals, selectedBank);
                    } else {
                        console.log('🏦 Desactivando cuenta corriente...');
                        bankSelect.style.display = 'none';
                        bankSection.style.display = 'none';
                    }
                });
                
                bankSelect.addEventListener('change', (e) => {
                    const selectedBank = e.target.value;
                    const bankName = selectedBank === 'wise' ? 'Wise' : 'Revolut';
                    console.log('Cambiando a banco:', bankName);
                    bankNameDisplay.textContent = bankName;
                    
                    const allFinances = DB.finances || [];
                    const withdrawals = allFinances.filter(f => {
                        if (f.movementType === 'retiro') return true;
                        const desc = (f.description || f.notes || '').toLowerCase();
                        if (desc.includes('retiro') || desc.includes('withdrawal')) return true;
                        if (f.accountType === 'personal' && f.amount > 0) return true;
                        return false;
                    });
                    
                    renderTrackerBankAccountEvolution(withdrawals, selectedBank);
                });
            }

            // Event listeners para modal de retiro
            const withdrawalModal = document.getElementById('withdrawal-detail-modal');
            const closeModalBtn = document.getElementById('close-withdrawal-detail-modal');
            const closeDetailBtn = document.getElementById('withdrawal-detail-close-btn');
            
            if (closeModalBtn) {
                closeModalBtn.addEventListener('click', () => {
                    withdrawalModal.style.display = 'none';
                });
            }
            
            if (closeDetailBtn) {
                closeDetailBtn.addEventListener('click', () => {
                    withdrawalModal.style.display = 'none';
                });
            }
            
            // Cerrar modal al hacer clic fuera
            if (withdrawalModal) {
                withdrawalModal.addEventListener('click', (e) => {
                    if (e.target === withdrawalModal) {
                        withdrawalModal.style.display = 'none';
                    }
                });
            }
            
            // Event listeners para modal de gastos
            const expenseModal = document.getElementById('expense-detail-modal');
            const closeExpenseModalBtn = document.getElementById('close-expense-detail-modal');
            const closeExpenseDetailBtn = document.getElementById('expense-detail-close-btn');
            
            if (closeExpenseModalBtn) {
                closeExpenseModalBtn.addEventListener('click', () => {
                    expenseModal.style.display = 'none';
                });
            }
            
            if (closeExpenseDetailBtn) {
                closeExpenseDetailBtn.addEventListener('click', () => {
                    expenseModal.style.display = 'none';
                });
            }
            
            // Cerrar modal de gastos al hacer clic fuera
            if (expenseModal) {
                expenseModal.addEventListener('click', (e) => {
                    if (e.target === expenseModal) {
                        expenseModal.style.display = 'none';
                    }
                });
            }

            // Inicializar pestañas de Finanzas
            const tabDashboard = document.getElementById('finances-tab-dashboard');
            const tabCapitalPropio = document.getElementById('finances-tab-capital-propio');
            const tabFunded = document.getElementById('finances-tab-funded');
            const tabMovements = document.getElementById('finances-tab-movements');
            const tabCalendar = document.getElementById('finances-tab-calendar');
            
            const viewDashboard = document.getElementById('finances-view-dashboard');
            const viewCapitalPropio = document.getElementById('finances-view-capital-propio');
            const viewFunded = document.getElementById('finances-view-funded');
            const viewMovements = document.getElementById('finances-view-movements');
            const viewCalendar = document.getElementById('finances-view-calendar');
            const viewTrackerBank = document.getElementById('finances-view-trackerbank');

            // Función para cambiar de pestaña
            function switchFinancesTab(tabElement, viewElement) {
                // Desactivar todas las tabs
                document.querySelectorAll('.finances-tab').forEach(t => {
                    t.classList.remove('active');
                    t.style.color = 'var(--text-secondary)';
                    t.style.borderBottomColor = 'transparent';
                    t.style.fontWeight = 'normal';
                });
                
                // Activar tab actual
                tabElement.classList.add('active');
                tabElement.style.color = 'var(--text)';
                tabElement.style.borderBottomColor = 'var(--primary)';
                tabElement.style.fontWeight = '600';
                
                // Ocultar todas las vistas
                [viewDashboard, viewCapitalPropio, viewFunded, viewMovements, viewCalendar, viewTrackerBank].forEach(v => {
                    if (v) v.classList.add('hidden');
                });
                
                // Mostrar vista actual
                if (viewElement) viewElement.classList.remove('hidden');
                
                // Actualizar datos de la vista
                updateFinancesView(viewElement.id);
            }

            // Event listeners para cada pestaña
            const tabTrackerBank = document.getElementById('finances-tab-trackerbank');
            if (tabDashboard) tabDashboard.addEventListener('click', () => switchFinancesTab(tabDashboard, viewDashboard));
            if (tabCapitalPropio) tabCapitalPropio.addEventListener('click', () => switchFinancesTab(tabCapitalPropio, viewCapitalPropio));
            if (tabFunded) tabFunded.addEventListener('click', () => switchFinancesTab(tabFunded, viewFunded));
            if (tabMovements) tabMovements.addEventListener('click', () => switchFinancesTab(tabMovements, viewMovements));
            if (tabCalendar) tabCalendar.addEventListener('click', () => switchFinancesTab(tabCalendar, viewCalendar));
            if (tabTrackerBank) tabTrackerBank.addEventListener('click', () => switchFinancesTab(tabTrackerBank, viewTrackerBank));

            // Event listeners para pestañas de filtro de evolución
            const evolutionFilterButtons = document.querySelectorAll('.trackerbank-evolution-filter');
            evolutionFilterButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    // Desactivar todos los botones
                    evolutionFilterButtons.forEach(b => {
                        b.classList.remove('active');
                        b.style.background = 'var(--surface)';
                        b.style.color = 'var(--text)';
                        b.style.border = '1px solid var(--border)';
                    });
                    
                    // Activar botón actual
                    this.classList.add('active');
                    this.style.background = 'var(--primary)';
                    this.style.color = 'white';
                    this.style.border = 'none';
                    
                    // Renderizar chart con el filtro seleccionado
                    const filter = this.getAttribute('data-filter');
                    const allOps = applyDateFilterToData(DB.operations);
                    const allFinances = applyDateFilterToData(DB.finances);
                    renderTrackerBankEvolutionChart(allOps, allFinances, filter);
                });
            });

            console.log('✅ Event listeners de pestañas de finanzas configurados');
            
            // Poblar selectores de cuentas en Capital Propio y Funded
            populateCapitalPropioAccountSelect();
            populateFundedAccountSelect();
            populateNewDashboardAccountSelect();
            
            // Event listeners para selectores de cuentas
            const capitalPropioAccountSelect = document.getElementById('capital-propio-account-select');
            const fundedAccountSelect = document.getElementById('funded-account-select');
            
            if (capitalPropioAccountSelect) {
                capitalPropioAccountSelect.addEventListener('change', function() {
                    updateCapitalPropioAccountLogo(this.value);
                    updateFinancesView('finances-view-capital-propio');
                });
            }
            
            if (fundedAccountSelect) {
                fundedAccountSelect.addEventListener('change', function() {
                    updateFundedAccountLogo(this.value);
                    updateFinancesView('finances-view-funded');
                });
            }
            
            // Inicializar la vista del Dashboard al cargar (con delay para asegurar que DB esté cargado)
            setTimeout(() => {
                console.log('🔄 Inicializando dashboard de finanzas...');
                updateFinancesView('finances-view-dashboard');
            }, 500);

            // Inicializar calendario financiero
            initFinancialCalendar();

            const toggleButton = document.getElementById('toggle-hide-amounts-finances');
            const toggleIcon = document.getElementById('toggle-hide-amounts-finances-icon');
            const financesSection = document.getElementById('finances');

            const applyStreamerMode = (active) => {
                if (active) {
                    financesSection.classList.add('streamer-mode-active');
                    toggleIcon.classList.remove('fa-eye-slash');
                    toggleIcon.classList.add('fa-eye');
                    toggleButton.setAttribute('aria-pressed', 'true');
                    toggleButton.title = "Mostrar importes";
                } else {
                    financesSection.classList.remove('streamer-mode-active');
                    toggleIcon.classList.remove('fa-eye');
                    toggleIcon.classList.add('fa-eye-slash');
                    toggleButton.setAttribute('aria-pressed', 'false');
                    toggleButton.title = "Ocultar importes (stream)";
                }
            };

            let isStreamerModeActive = localStorage.getItem('streamerModeFinancesActive') === 'true';
            applyStreamerMode(isStreamerModeActive);

            toggleButton.addEventListener('click', () => {
                isStreamerModeActive = !isStreamerModeActive;
                localStorage.setItem('streamerModeFinancesActive', isStreamerModeActive);
                applyStreamerMode(isStreamerModeActive);
            });

            // ===== EDITOR DE NOTAS AVANZADAS PARA FINANZAS =====
            
            // Abrir editor de notas de finanzas
            document.getElementById('edit-finance-notes-btn').addEventListener('click', function() {
                const modal = document.getElementById('finance-notes-editor-modal');
                const editor = document.getElementById('finance-notes-editor');
                const hiddenInput = document.getElementById('finance-notes-hidden');
                
                // Cargar notas existentes
                editor.innerHTML = hiddenInput.value || '';
                
                modal.style.display = 'flex';
                modal.classList.remove('hidden');
                document.body.style.overflow = 'hidden';
                
                updateFinanceEditorCharCount();
            });

            // Cerrar editor de finanzas
            function closeFinanceNotesEditor() {
                const modal = document.getElementById('finance-notes-editor-modal');
                modal.style.display = 'none';
                modal.classList.add('hidden');
                document.body.style.overflow = '';
            }

            document.getElementById('close-finance-editor-btn').addEventListener('click', closeFinanceNotesEditor);
            document.getElementById('finance-editor-cancel-btn').addEventListener('click', closeFinanceNotesEditor);

            // Cerrar al hacer clic fuera del modal
            document.getElementById('finance-notes-editor-modal').addEventListener('click', function(e) {
                if (e.target === this) {
                    closeFinanceNotesEditor();
                }
            });

            // Actualizar contador de caracteres
            function updateFinanceEditorCharCount() {
                const editor = document.getElementById('finance-notes-editor');
                const counter = document.getElementById('finance-editor-char-count');
                const text = editor.innerText || editor.textContent || '';
                counter.textContent = `${text.length} caracteres`;
            }

            document.getElementById('finance-notes-editor').addEventListener('input', updateFinanceEditorCharCount);

            // Funciones de formato
            window.formatFinanceText = function(command, value = null) {
                document.execCommand(command, false, value);
                document.getElementById('finance-notes-editor').focus();
            };

            window.insertFinanceLink = function() {
                const url = prompt('Ingresa la URL:');
                if (url) {
                    document.execCommand('createLink', false, url);
                }
            };

            // Guardar notas de finanzas
            document.getElementById('finance-editor-save-btn').addEventListener('click', function() {
                const editor = document.getElementById('finance-notes-editor');
                const notes = editor.innerHTML;
                const hiddenInput = document.getElementById('finance-notes-hidden');
                const display = document.getElementById('finance-notes-display');
                
                hiddenInput.value = notes;
                
                if (notes.trim()) {
                    display.innerHTML = notes;
                } else {
                    display.innerHTML = '<p class="text-text-secondary italic">Sin descripción. Usa el editor avanzado para añadir notas detalladas.</p>';
                }
                
                closeFinanceNotesEditor();
            });

            // Nota de voz para finanzas
            let financeMediaRecorder;
            let financeAudioChunks = [];
            let isFinanceRecording = false;

            document.getElementById('finance-voice-note-btn').addEventListener('click', async function() {
                if (!isFinanceRecording) {
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        financeMediaRecorder = new MediaRecorder(stream);
                        financeAudioChunks = [];

                        financeMediaRecorder.ondataavailable = (event) => {
                            financeAudioChunks.push(event.data);
                        };

                        financeMediaRecorder.onstop = () => {
                            const audioBlob = new Blob(financeAudioChunks, { type: 'audio/webm' });
                            const audioUrl = URL.createObjectURL(audioBlob);
                            
                            const editor = document.getElementById('finance-notes-editor');
                            const audioHTML = `<div style="margin: 10px 0; padding: 10px; background: rgba(57, 255, 20, 0.1); border-left: 3px solid #39ff14; border-radius: 4px;">
                                <p style="margin: 0 0 5px 0; font-weight: bold; color: #39ff14;">🎤 Nota de Voz</p>
                                <audio controls style="width: 100%; max-width: 400px;">
                                    <source src="${audioUrl}" type="audio/webm">
                                </audio>
                            </div>`;
                            
                            editor.innerHTML += audioHTML;
                            updateFinanceEditorCharCount();

                            stream.getTracks().forEach(track => track.stop());
                        };

                        financeMediaRecorder.start();
                        isFinanceRecording = true;

                        this.innerHTML = '<i class="fas fa-stop-circle text-red"></i><span class="ml-2">Detener Grabación</span>';
                        this.classList.add('bg-red', 'text-white');

                    } catch (err) {
                        console.error('Error al acceder al micrófono:', err);
                        alert('No se pudo acceder al micrófono. Verifica los permisos del navegador.');
                    }
                } else {
                    if (financeMediaRecorder && financeMediaRecorder.state !== 'inactive') {
                        financeMediaRecorder.stop();
                        isFinanceRecording = false;

                        this.innerHTML = '<i class="fas fa-microphone"></i><span class="ml-2">Nota de Voz</span>';
                        this.classList.remove('bg-red', 'text-white');
                    }
                }
            });

            // ===== GRÁFICO EN PANTALLA COMPLETA =====
            
            let fullscreenChart = null;

            document.getElementById('expand-evolution-chart-btn').addEventListener('click', function() {
                const modal = document.getElementById('evolution-chart-fullscreen');
                modal.style.display = 'flex';
                modal.classList.remove('hidden');
                document.body.style.overflow = 'hidden';

                // Crear gráfico en pantalla completa
                setTimeout(() => {
                    renderEvolutionChartFullscreen();
                }, 100);
            });

            document.getElementById('close-evolution-fullscreen-btn').addEventListener('click', function() {
                const modal = document.getElementById('evolution-chart-fullscreen');
                modal.style.display = 'none';
                modal.classList.add('hidden');
                document.body.style.overflow = '';

                // Destruir gráfico
                if (fullscreenChart) {
                    fullscreenChart.destroy();
                    fullscreenChart = null;
                }
            });

            function renderEvolutionChartFullscreen() {
                const canvas = document.getElementById('finances-evolution-chart-fullscreen');
                if (!canvas) return;

                const ctx = canvas.getContext('2d');

                // Destruir gráfico existente
                if (fullscreenChart) {
                    fullscreenChart.destroy();
                }

                // Obtener datos del gráfico principal
                const entries = [...DB.financeEntries].sort((a, b) => new Date(a.date) - new Date(b.date));
                
                if (entries.length === 0) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.font = '20px Arial';
                    ctx.fillStyle = '#8b949e';
                    ctx.textAlign = 'center';
                    ctx.fillText('No hay datos para mostrar', canvas.width / 2, canvas.height / 2);
                    return;
                }

                let cumulativeBalance = 0;
                const labels = [];
                const data = [];

                entries.forEach(entry => {
                    cumulativeBalance += entry.amount;
                    labels.push(new Date(entry.date).toLocaleDateString('es-ES', { day: '2-digit', month: 'short', year: 'numeric' }));
                    data.push(cumulativeBalance);
                });

                fullscreenChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Balance Acumulado',
                            data: data,
                            borderColor: '#39FF14',
                            backgroundColor: 'rgba(57, 255, 20, 0.1)',
                            borderWidth: 3,
                            fill: true,
                            tension: 0.4,
                            pointRadius: 6,
                            pointHoverRadius: 8,
                            pointBackgroundColor: '#39FF14',
                            pointBorderColor: '#fff',
                            pointBorderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        plugins: {
                            legend: { 
                                display: true,
                                labels: {
                                    color: '#fff',
                                    font: { size: 14 }
                                }
                            },
                            tooltip: {
                                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                                titleColor: '#fff',
                                bodyColor: '#fff',
                                borderColor: '#39FF14',
                                borderWidth: 1,
                                callbacks: {
                                    label: (context) => `Balance: $${context.parsed.y.toFixed(2)}`
                                }
                            }
                        },
                        scales: {
                            x: {
                                grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                ticks: { 
                                    color: '#8b949e',
                                    font: { size: 12 }
                                }
                            },
                            y: {
                                grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                ticks: { 
                                    color: '#8b949e',
                                    font: { size: 12 },
                                    callback: (value) => `$${value.toFixed(0)}`
                                }
                            }
                        }
                    }
                });
            }

            refreshFinancesView();
        }

        function toggleAddFinanceEntryForm(entryToEdit = null) {
            const formContainer = document.getElementById('add-finance-entry-form');
            const isVisible = formContainer.style.display === 'block';

            if (!isVisible) {
                formContainer.style.display = 'block';
                document.getElementById('add-finance-entry-btn').textContent = 'Ocultar Formulario';
                formContainer.querySelector('form').reset();

                if (entryToEdit) {
                    formContainer.querySelector('h3').textContent = 'Editar Movimiento';
                    document.getElementById('finance-date').value = entryToEdit.date;
                    document.getElementById('finance-amount').value = entryToEdit.amount;
                    document.getElementById('finance-currency').value = entryToEdit.currency;
                    document.getElementById('finance-account-type').value = entryToEdit.accountType || 'personal';
                    document.getElementById('finance-movement-type').value = entryToEdit.movementType || 'gasto';
                    document.getElementById('finance-description').value = entryToEdit.description || '';
                    
                    // Mostrar selector de banco si es retiro
                    const bankContainer = document.getElementById('finance-bank-container');
                    const categoryContainer = document.getElementById('finance-category-container');
                    
                    if (entryToEdit.movementType === 'retiro') {
                        bankContainer.style.display = 'block';
                        categoryContainer.style.display = 'none';
                        document.getElementById('finance-bank').value = entryToEdit.bank || 'revolut';
                    } else if (entryToEdit.movementType === 'gasto') {
                        bankContainer.style.display = 'none';
                        categoryContainer.style.display = 'block';
                        document.getElementById('finance-category').value = entryToEdit.category || 'otros';
                    } else {
                        bankContainer.style.display = 'none';
                        categoryContainer.style.display = 'none';
                    }
                    
                    // Cargar notas en el campo oculto y display
                    const hiddenNotes = document.getElementById('finance-notes-hidden');
                    const displayNotes = document.getElementById('finance-notes-display');
                    hiddenNotes.value = entryToEdit.notes || '';
                    if (entryToEdit.notes && entryToEdit.notes.trim()) {
                        displayNotes.innerHTML = entryToEdit.notes;
                    } else {
                        displayNotes.innerHTML = '<p class="text-text-secondary italic">Sin descripción. Usa el editor avanzado para añadir notas detalladas.</p>';
                    }
                    
                    formContainer.dataset.editingId = entryToEdit.id;
                } else {
                    formContainer.querySelector('h3').textContent = 'Nuevo Movimiento Financiero';
                    document.getElementById('finance-date').value = getLocalDateString(new Date());
                    document.getElementById('finance-currency').value = DB.settings.defaultCurrency;
                    document.getElementById('finance-account-type').value = 'capital-propio';
                    document.getElementById('finance-movement-type').value = 'gasto';
                    document.getElementById('finance-description').value = '';
                    
                    // Limpiar notas
                    document.getElementById('finance-notes-hidden').value = '';
                    document.getElementById('finance-notes-display').innerHTML = '<p class="text-text-secondary italic">Sin descripción. Usa el editor avanzado para añadir notas detalladas.</p>';
                    
                    delete formContainer.dataset.editingId;
                }
                formContainer.scrollIntoView({ behavior: 'smooth' });
            } else {
                formContainer.style.display = 'none';
                document.getElementById('add-finance-entry-btn').innerHTML = '<i class="fas fa-plus mr-2"></i>Añadir Movimiento';
                delete formContainer.dataset.editingId;
            }
        }

        async function saveFinanceEntry() {
            showLoading(true);
            const formContainer = document.getElementById('add-finance-entry-form');
            const editingId = formContainer.dataset.editingId;

            const date = document.getElementById('finance-date').value;
            const amount = parseFloat(document.getElementById('finance-amount').value);
            const currency = document.getElementById('finance-currency').value;
            const accountType = document.getElementById('finance-account-type').value;
            const movementType = document.getElementById('finance-movement-type').value;
            const description = document.getElementById('finance-description').value.trim();
            const notes = document.getElementById('finance-notes-hidden').value.trim();
            // Si es retiro, obtener banco (o usar revolut por defecto)
            const bank = movementType === 'retiro' ? (document.getElementById('finance-bank').value || 'revolut') : null;
            // Si es gasto, obtener categoría (o usar 'otros' por defecto)
            const category = movementType === 'gasto' ? (document.getElementById('finance-category').value || 'otros') : null;

            if (!date || isNaN(amount)) {
                alert('Por favor, complete los campos obligatorios (Fecha y Monto).');
                showLoading(false);
                return;
            }

            const entryData = { date, amount, currency, accountType, movementType, description, notes, bank, category };

            try {
                // GUARDAR PRIMERO LOCALMENTE (siempre funciona)
                if (editingId) {
                    await dexieDB.finances.update(parseInt(editingId), entryData);
                    const index = DB.finances.findIndex(f => f.id === parseInt(editingId));
                    if (index !== -1) {
                        DB.finances[index] = { ...DB.finances[index], ...entryData };
                    }
                    console.log('✅ Movimiento financiero actualizado localmente');
                } else {
                    const newId = await dexieDB.finances.add(entryData);
                    entryData.id = newId;
                    DB.finances.push(entryData);
                    console.log('✅ Movimiento financiero guardado localmente');
                }

                // SINCRONIZACIÓN AUTOMÁTICA CON SUPABASE (en segundo plano)
                if (currentUser) {
                    saveFinanceToSupabase(entryData).then(() => {
                        console.log('✅ Movimiento financiero guardado exitosamente');
                        showSyncNotification('💾 Movimiento guardado y sincronizado automáticamente', 'success');
                    }).catch((supabaseError) => {
                        console.error('❌ Error de sincronización automática:', supabaseError);
                        addToSyncQueue(entryData, 'finance');
                        showSyncNotification('💾 Movimiento guardado (se sincronizará automáticamente)', 'info');
                    });
                } else {
                    showSyncNotification('💾 Movimiento guardado localmente', 'warning');
                }

                // Actualizar vistas inmediatamente con datos locales
                toggleAddFinanceEntryForm();
                refreshFinancesView();

                // Mensaje de confirmación inmediato
                showSyncNotification('✅ Movimiento financiero guardado exitosamente', 'success');

            } catch (e) {
                console.error("Error saving finance entry:", e);
                alert("Error al guardar el movimiento financiero.");
            } finally {
                showLoading(false);
            }
        }

        async function handleFinancesTableClick(event) {
            const button = event.target.closest('button');
            if (!button) return;

            const entryId = parseInt(button.dataset.id);
            if (isNaN(entryId)) return;

            if (button.classList.contains('edit-finance-btn')) {
                const entry = DB.finances.find(f => f.id === entryId);
                if (entry) toggleAddFinanceEntryForm(entry);
            } else if (button.classList.contains('delete-finance-btn')) {
                if (confirm('¿Estás seguro de que deseas eliminar este movimiento?')) {
                    showLoading(true);
                    try {
                        const entry = DB.finances.find(f => f.id === entryId);
                        await dexieDB.finances.delete(entryId);

                        // Eliminar de Supabase si tiene supabase_id
                        if (entry && entry.supabase_id) {
                            await deleteFinanceFromSupabase(entry.supabase_id);
                        }

                        DB.finances = DB.finances.filter(f => f.id !== entryId);
                        refreshFinancesView();
                    } catch (e) {
                        console.error("Error deleting finance entry:", e);
                        alert("Error al eliminar el movimiento.");
                    } finally {
                        showLoading(false);
                    }
                }
            }
        }

        function refreshFinancesView() {
            if (!document.getElementById('finances').classList.contains('active')) return;

            const filteredFinances = applyDateFilterToData(DB.finances);
            const filteredOperations = applyDateFilterToData(DB.operations);

            updateFinancePageSummary(filteredFinances, filteredOperations);
            renderFinancesTable(filteredFinances);
            updateFinancesEvolutionChart(filteredFinances);
            updateFinancesCashflowChart(filteredFinances, filteredOperations);
            updateFinancesProfitExpensesChart(filteredFinances, filteredOperations);
            renderFinancialCalendar(filteredFinances, filteredOperations);
        }

        function updateFinancePageSummary(financeEntries, tradeOperations) {
            const targetCurrency = DB.settings.defaultCurrency;

            let totalIncome = 0;
            let totalExpenses = 0;
            financeEntries.forEach(entry => {
                let amount = convertCurrency(entry.amount, entry.currency, targetCurrency);
                if (amount > 0) totalIncome += amount;
                else totalExpenses += amount;
            });
            const netBalance = totalIncome + totalExpenses;
            const tradingMetrics = calculateMetrics(tradeOperations, 'all');

            const tradingPLEl = document.getElementById('finance-trading-pl');
            tradingPLEl.textContent = formatCurrency(tradingMetrics.totalWin + tradingMetrics.totalLoss, targetCurrency, targetCurrency);
            tradingPLEl.className = `text-xl font-bold ${(tradingMetrics.totalWin + tradingMetrics.totalLoss) >= 0 ? 'text-positive' : 'text-negative'}`;

            document.getElementById('finance-win-rate').textContent = `${tradingMetrics.winRate.toFixed(1)}%`;

            document.getElementById('finance-total-income').textContent = formatCurrency(totalIncome, targetCurrency, targetCurrency);
            document.getElementById('finance-total-expenses').textContent = formatCurrency(totalExpenses, targetCurrency, targetCurrency);
            const netBalanceEl = document.getElementById('finance-net-balance');
            netBalanceEl.textContent = formatCurrency(netBalance, targetCurrency, targetCurrency);
            netBalanceEl.className = `text-xl font-bold ${netBalance >= 0 ? 'text-green' : 'text-negative'}`;
        }


        function renderFinancesTable(entries) {
            const tableBody = document.getElementById('finances-table-body');
            tableBody.innerHTML = '';

            const sortedEntries = [...entries].sort((a, b) => new Date(b.date) - new Date(a.date));

            if (sortedEntries.length === 0) {
                 tableBody.innerHTML = '<tr><td colspan="5" class="text-center text-text-secondary py-4">No hay movimientos en el período seleccionado.</td></tr>';
                 return;
            }

            sortedEntries.forEach(entry => {
                const amountClass = entry.amount >= 0 ? 'text-positive' : 'text-negative';
                const row = `
                    <tr>
                        <td>${formatDate(entry.date)}</td>
                        <td>${entry.notes}</td>
                        <td class="${amountClass} font-semibold hide-amount">${formatCurrency(entry.amount, entry.currency, entry.currency)}</td>
                        <td>${entry.currency}</td>
                        <td class="flex items-center justify-center space-x-2">
                            <button class="text-white edit-finance-btn" data-id="${entry.id}" title="Editar"><i class="fas fa-edit"></i></button>
                            <button class="text-red delete-finance-btn" data-id="${entry.id}" title="Eliminar"><i class="fas fa-trash"></i></button>
                        </td>
                    </tr>
                `;
                tableBody.innerHTML += row;
            });
        }

        // Calendario Financiero
        let currentFinancialCalendarDate = new Date();
        
        function initFinancialCalendar() {
            const prevBtn = document.getElementById('finances-calendar-prev');
            const nextBtn = document.getElementById('finances-calendar-next');
            
            if (prevBtn) {
                prevBtn.addEventListener('click', () => {
                    currentFinancialCalendarDate.setMonth(currentFinancialCalendarDate.getMonth() - 1);
                    renderFinancialCalendar(applyDateFilterToData(DB.finances), applyDateFilterToData(DB.operations));
                });
            }
            
            if (nextBtn) {
                nextBtn.addEventListener('click', () => {
                    currentFinancialCalendarDate.setMonth(currentFinancialCalendarDate.getMonth() + 1);
                    renderFinancialCalendar(applyDateFilterToData(DB.finances), applyDateFilterToData(DB.operations));
                });
            }
        }
        
        // ========================================
        // FUNCIÓN PARA ACTUALIZAR TRACKERBANK
        // ========================================
        function updateTrackerBankView(allFinances, allOperations) {
            console.log('🏦 Actualizando TrackerBank...');
            console.log('Total finanzas recibidas:', allFinances.length);
            
            // Obtener todas las cuentas funded
            const fundedAccounts = DB.fundedAccounts || [];
            
            // Calcular P/L total de trading (operaciones)
            const totalPL = allOperations.reduce((sum, op) => sum + (op.pl || 0), 0);
            
            // Separar movimientos por tipo (múltiples criterios de detección)
            const withdrawals = allFinances.filter(f => {
                // Criterio 1: Tiene movementType === 'retiro'
                if (f.movementType === 'retiro') return true;
                
                // Criterio 2: La descripción contiene palabras clave de retiro
                const desc = (f.description || f.notes || '').toLowerCase();
                if (desc.includes('retiro') || desc.includes('withdrawal') || desc.includes('transferencia')) {
                    console.log('🔍 Retiro detectado por descripción:', f);
                    return true;
                }
                
                // Criterio 3: accountType es 'personal' (podría ser retiro a cuenta personal)
                if (f.accountType === 'personal' && f.amount > 0) {
                    console.log('🔍 Posible retiro detectado (cuenta personal):', f);
                    return true;
                }
                
                return false;
            });
            
            const expenses = allFinances.filter(f => {
                // No es retiro y es gasto
                const isWithdrawal = withdrawals.some(w => w.id === f.id);
                if (isWithdrawal) return false;
                
                return f.movementType === 'gasto' || f.amount < 0;
            });
            
            const incomes = allFinances.filter(f => {
                // No es retiro ni gasto
                const isWithdrawal = withdrawals.some(w => w.id === f.id);
                const isExpense = expenses.some(e => e.id === f.id);
                if (isWithdrawal || isExpense) return false;
                
                return f.movementType === 'ingreso' || (f.amount > 0 && f.movementType !== 'retiro');
            });
            
            console.log('📊 Clasificación de movimientos:');
            console.log('  - Retiros:', withdrawals.length);
            console.log('  - Gastos:', expenses.length);
            console.log('  - Ingresos:', incomes.length);
            
            if (withdrawals.length > 0) {
                console.log('📋 Muestra de retiros:', withdrawals.slice(0, 3));
            }
            
            // Calcular totales
            const totalWithdrawn = withdrawals.reduce((sum, w) => sum + Math.abs(w.amount), 0);
            const totalExpenses = expenses.reduce((sum, e) => sum + Math.abs(e.amount), 0);
            const totalIncome = incomes.reduce((sum, i) => sum + (i.amount), 0);
            
            // Total generado = P/L de trading
            const totalGenerated = totalPL;
            
            // Obtener todas las cuentas de trading
            const allAccounts = DB.accounts || [];
            
            console.log('📋 DEBUG - Todas las cuentas disponibles:', allAccounts.length);
            console.log('📋 DEBUG - Cuentas funded:', allAccounts.filter(a => a.accountType === 'funded').map(a => ({name: a.name, id: a.id, type: a.accountType})));
            allAccounts.forEach(acc => {
                console.log(`  📍 Cuenta: ${acc.name} | ID: ${acc.id} | Type: ${acc.accountType || 'no-type'} | Balance: ${acc.balance || 0}`);
            });
            
            // Calcular balance total de cuentas de capital propio
            // Son capital propio todas las cuentas que NO tienen accountType === 'funded'
            const ownCapitalAccountsBalance = allAccounts
                .filter(acc => {
                    const isFunded = acc.accountType === 'funded';
                    const isOwnCapital = !isFunded;
                    console.log(`  ${isOwnCapital ? '✅' : '❌'} Cuenta ${acc.name}: ${isOwnCapital ? 'SI' : 'NO'} es capital propio (type: ${acc.accountType || 'undefined'})`);
                    return isOwnCapital;
                })
                .reduce((sum, acc) => {
                    const accBalance = acc.balance || 0;
                    console.log(`  💳 Cuenta ${acc.name}: ${formatCurrency(accBalance, acc.currency || DB.settings.defaultCurrency)}`);
                    return sum + accBalance;
                }, 0);
            
            console.log('💰 Balance total de cuentas de capital propio:', formatCurrency(ownCapitalAccountsBalance, DB.settings.defaultCurrency));
            
            // En cuenta de trading = Total generado - Retiros - Gastos (sin incluir balance de cuentas)
            const inTradingFromPL = totalGenerated - totalWithdrawn - totalExpenses;
            
            // Balances de finanzas de capital propio
            const ownCapitalFinancesBalance = allFinances
                .filter(f => f.accountType === 'capital-propio')
                .reduce((sum, f) => sum + f.amount, 0);
                
            const fundedBalance = fundedAccounts.reduce((sum, acc) => {
                return sum + (acc.balance || 0);
            }, 0);
            
            // Balance total de capital propio = Balance de cuentas + Balance de finanzas
            const totalOwnCapital = ownCapitalAccountsBalance + ownCapitalFinancesBalance;
            
            console.log('📊 Resumen TrackerBank:');
            console.log('  - En Trading (P/L): ' + formatCurrency(inTradingFromPL, DB.settings.defaultCurrency));
            console.log('  - Balance Cuentas Propias: ' + formatCurrency(ownCapitalAccountsBalance, DB.settings.defaultCurrency));
            console.log('  - Balance Finanzas Propio: ' + formatCurrency(ownCapitalFinancesBalance, DB.settings.defaultCurrency));
            console.log('  - Total Capital Propio: ' + formatCurrency(totalOwnCapital, DB.settings.defaultCurrency));
            
            // Actualizar métricas principales
            document.getElementById('trackerbank-total-generated').textContent = formatCurrency(totalGenerated, DB.settings.defaultCurrency);
            document.getElementById('trackerbank-in-trading').textContent = formatCurrency(inTradingFromPL, DB.settings.defaultCurrency);
            document.getElementById('trackerbank-withdrawn').textContent = formatCurrency(totalWithdrawn, DB.settings.defaultCurrency);
            document.getElementById('trackerbank-total-expenses').textContent = formatCurrency(totalExpenses, DB.settings.defaultCurrency);
            document.getElementById('trackerbank-own-capital').textContent = formatCurrency(totalOwnCapital, DB.settings.defaultCurrency);
            document.getElementById('trackerbank-funded-capital').textContent = formatCurrency(fundedBalance, DB.settings.defaultCurrency);
            
            // Calcular tasas
            const withdrawalRate = totalGenerated > 0 ? ((totalWithdrawn / totalGenerated) * 100).toFixed(1) : 0;
            const tradingRate = totalGenerated > 0 ? ((inTradingFromPL / totalGenerated) * 100).toFixed(1) : 0;
            const expenseRate = totalGenerated > 0 ? ((totalExpenses / totalGenerated) * 100).toFixed(1) : 0;
            const efficiency = totalGenerated > 0 ? (((totalGenerated - totalExpenses) / totalGenerated) * 100).toFixed(1) : 0;
            
            document.getElementById('trackerbank-withdrawal-rate').textContent = withdrawalRate + '%';
            document.getElementById('trackerbank-trading-rate').textContent = tradingRate + '%';
            document.getElementById('trackerbank-expense-rate').textContent = expenseRate + '%';
            document.getElementById('trackerbank-efficiency').textContent = efficiency + '%';
            
            // Renderizar gráfico de evolución
            renderTrackerBankEvolutionChart(allOperations, allFinances);
            
            // Renderizar gráfico de volumen (barras)
            renderTrackerBankVolumeChart(totalIncome, totalExpenses, totalWithdrawn);
            
            // Renderizar gráfico de distribución (donut) - AHORA CON 4 SEGMENTOS
            renderTrackerBankDistributionChart(inTradingFromPL, totalWithdrawn, totalOwnCapital, totalExpenses);
            
            // Renderizar gráfico de categorías de gastos
            renderTrackerBankExpensesCategoryChart(expenses);
            
            // Renderizar gráfico de flujo de caja
            renderTrackerBankCashflowChart(allOperations, allFinances);
            
            // Renderizar tabla de retiros
            renderTrackerBankWithdrawalsTable(withdrawals);
            
            // Renderizar tabla de gastos
            renderTrackerBankExpensesTable(expenses);
            
            // Calcular proyecciones
            calculateTrackerBankProjections(allOperations);
            
            // Calcular métricas históricas
            calculateTrackerBankHistoricalMetrics(allOperations);
            
            console.log('✅ TrackerBank actualizado');
        }
        
        let currentEvolutionFilter = 'all';
        
        function renderTrackerBankEvolutionChart(operations, finances, filter = 'all') {
            const ctx = document.getElementById('trackerbank-evolution-chart');
            if (!ctx) return;
            
            currentEvolutionFilter = filter;
            
            console.log('📊 renderTrackerBankEvolutionChart - Filtro:', filter);
            console.log('📊 Total operaciones:', operations.length);
            
            // Destruir chart anterior si existe
            if (trackerbankEvolutionChart) {
                trackerbankEvolutionChart.destroy();
            }
            
            // Separar operaciones por tipo de cuenta
            const ownCapitalOps = operations.filter(op => {
                const acc = DB.accounts.find(a => a.id === op.accountId);
                if (!acc) return false;
                // Es capital propio si NO tiene accountType 'funded'
                return !acc.accountType || acc.accountType !== 'funded';
            });
            
            const fundedOps = operations.filter(op => {
                const acc = DB.accounts.find(a => a.id === op.accountId);
                return acc && acc.accountType === 'funded';
            });
            
            console.log('💼 Operaciones capital propio:', ownCapitalOps.length);
            console.log('🏆 Operaciones funded:', fundedOps.length);
            
            // Calcular balance acumulado para capital propio
            const ownCapitalData = {};
            const ownGainsData = {};
            let runningOwnBalance = 0;
            
            const allAccounts = DB.accounts || [];
            // Solo incluir cuentas de capital propio (no funded)
            const ownAccountsInitialBalance = allAccounts
                .filter(acc => !acc.accountType || acc.accountType !== 'funded')
                .reduce((sum, acc) => sum + (acc.initialBalance || 0), 0);
            
            console.log('💰 Balance inicial capital propio:', ownAccountsInitialBalance);
            runningOwnBalance = ownAccountsInitialBalance;
            
            [...ownCapitalOps].sort((a, b) => new Date(a.date) - new Date(b.date)).forEach(op => {
                const gain = op.pl || 0;
                runningOwnBalance += gain;
                ownCapitalData[op.date] = runningOwnBalance;
                ownGainsData[op.date] = (ownGainsData[op.date] || 0) + gain;
            });
            
            console.log('📊 Datos de capital propio:', Object.keys(ownCapitalData).length, 'fechas');
            console.log('📊 Muestra de datos:', Object.entries(ownCapitalData).slice(0, 3));
            
            // Calcular balance acumulado para funded
            const fundedData = {};
            const fundedGainsData = {};
            let runningFundedBalance = 0;
            
            const fundedAccounts = DB.fundedAccounts || [];
            const fundedInitialBalance = fundedAccounts
                .filter(acc => acc.status === 'live' || acc.status === 'historical')
                .reduce((sum, acc) => sum + (acc.balance || 0), 0);
            
            runningFundedBalance = fundedInitialBalance;
            
            [...fundedOps].sort((a, b) => new Date(a.date) - new Date(b.date)).forEach(op => {
                const gain = op.pl || 0;
                runningFundedBalance += gain;
                fundedData[op.date] = runningFundedBalance;
                fundedGainsData[op.date] = (fundedGainsData[op.date] || 0) + gain;
            });
            
            // Combinar todas las fechas
            const allDates = [...new Set([
                ...Object.keys(ownCapitalData),
                ...Object.keys(fundedData)
            ])].sort();
            
            // Preparar datasets según el filtro
            let datasets = [];
            
            if (filter === 'all') {
                // Total: Balance capital propio + Balance funded
                const totalData = allDates.map(date => {
                    const own = ownCapitalData[date] || runningOwnBalance;
                    const funded = fundedData[date] || runningFundedBalance;
                    return own + funded;
                });
                
                datasets.push({
                    label: 'Balance Total (Capital + Funded)',
                    data: totalData,
                    borderColor: '#39FF14',
                    backgroundColor: 'rgba(57, 255, 20, 0.1)',
                    borderWidth: 3,
                    fill: true,
                    tension: 0.4,
                    pointRadius: 2,
                    pointHoverRadius: 6
                });
            } else if (filter === 'own-balance-gains') {
                // Balance de capital propio + ganancias acumuladas
                const data = allDates.map(date => ownCapitalData[date] || runningOwnBalance);
                
                datasets.push({
                    label: 'Capital Propio + Ganancias',
                    data: data,
                    borderColor: '#3b82f6',
                    backgroundColor: 'rgba(59, 130, 246, 0.1)',
                    borderWidth: 3,
                    fill: true,
                    tension: 0.4,
                    pointRadius: 2,
                    pointHoverRadius: 6
                });
            } else if (filter === 'own-gains') {
                // Solo ganancias de capital propio (acumuladas)
                let accum = 0;
                const data = allDates.map(date => {
                    if (ownGainsData[date]) accum += ownGainsData[date];
                    return accum;
                });
                
                datasets.push({
                    label: 'Solo Ganancias Capital Propio',
                    data: data,
                    borderColor: '#8b5cf6',
                    backgroundColor: 'rgba(139, 92, 246, 0.1)',
                    borderWidth: 3,
                    fill: true,
                    tension: 0.4,
                    pointRadius: 2,
                    pointHoverRadius: 6
                });
            } else if (filter === 'funded-balance-gains') {
                // Balance funded + ganancias
                const data = allDates.map(date => fundedData[date] || runningFundedBalance);
                
                datasets.push({
                    label: 'Funded Balance + Ganancias',
                    data: data,
                    borderColor: '#f59e0b',
                    backgroundColor: 'rgba(245, 158, 11, 0.1)',
                    borderWidth: 3,
                    fill: true,
                    tension: 0.4,
                    pointRadius: 2,
                    pointHoverRadius: 6
                });
            } else if (filter === 'funded-gains') {
                // Solo ganancias de funded (acumuladas)
                let accum = 0;
                const data = allDates.map(date => {
                    if (fundedGainsData[date]) accum += fundedGainsData[date];
                    return accum;
                });
                
                datasets.push({
                    label: 'Solo Ganancias Funded',
                    data: data,
                    borderColor: '#ec4899',
                    backgroundColor: 'rgba(236, 72, 153, 0.1)',
                    borderWidth: 3,
                    fill: true,
                    tension: 0.4,
                    pointRadius: 2,
                    pointHoverRadius: 6
                });
            }
            
            trackerbankEvolutionChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: allDates,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: true },
                        tooltip: {
                            callbacks: {
                                label: (context) => formatCurrency(context.parsed.y, DB.settings.defaultCurrency)
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: (value) => formatCurrency(value, DB.settings.defaultCurrency)
                            }
                        }
                    }
                }
            });
        }
        
        function renderTrackerBankVolumeChart(income, expenses, withdrawals) {
            const ctx = document.getElementById('trackerbank-volume-chart');
            if (!ctx) return;
            
            trackerbankVolumeChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['Ingresos', 'Gastos', 'Retiros'],
                    datasets: [{
                        label: 'Volumen',
                        data: [income, expenses, withdrawals],
                        backgroundColor: [
                            '#00FF00',
                            'rgba(239, 68, 68, 0.7)',
                            'rgba(59, 130, 246, 0.7)'
                        ],
                        borderColor: [
                            '#39FF14',
                            '#ef4444',
                            '#3b82f6'
                        ],
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (context) => formatCurrency(context.parsed.y, DB.settings.defaultCurrency)
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: (value) => formatCurrency(value, DB.settings.defaultCurrency)
                            }
                        }
                    }
                }
            });
        }
        
        function renderTrackerBankDistributionChart(inTrading, withdrawn, ownCapital, expenses) {
            const ctx = document.getElementById('trackerbank-distribution-chart');
            if (!ctx) return;
            
            trackerbankDistributionChart = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: ['En Trading (P/L)', 'Retirado', 'Capital Propio', 'Gastado'],
                    datasets: [{
                        data: [inTrading, withdrawn, ownCapital, expenses],
                        backgroundColor: [
                            '#00FF00',
                            'rgba(59, 130, 246, 0.7)',
                            'rgba(168, 85, 247, 0.7)',
                            'rgba(239, 68, 68, 0.7)'
                        ],
                        borderColor: [
                            '#39FF14',
                            '#3b82f6',
                            '#a855f7',
                            '#ef4444'
                        ],
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { position: 'bottom' },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const label = context.label || '';
                                    const value = formatCurrency(context.parsed, DB.settings.defaultCurrency);
                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                    const percentage = ((context.parsed / total) * 100).toFixed(1);
                                    return `${label}: ${value} (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });
        }
        
        function renderTrackerBankExpensesCategoryChart(expenses) {
            const ctx = document.getElementById('trackerbank-expenses-category-chart');
            if (!ctx) return;
            
            // Categorizar gastos usando el campo category o detectando por descripción
            const categories = {
                'Plataformas': 0,
                'Educación': 0,
                'Herramientas': 0,
                'Servicios': 0,
                'Otros': 0
            };
            
            expenses.forEach(expense => {
                const amount = Math.abs(expense.amount);
                
                // Prioridad 1: Usar el campo category si existe
                if (expense.category) {
                    const cat = expense.category.toLowerCase();
                    if (cat === 'plataforma') {
                        categories['Plataformas'] += amount;
                    } else if (cat === 'educacion') {
                        categories['Educación'] += amount;
                    } else if (cat === 'herramientas') {
                        categories['Herramientas'] += amount;
                    } else if (cat === 'servicios') {
                        categories['Servicios'] += amount;
                    } else {
                        categories['Otros'] += amount;
                    }
                    return;
                }
                
                // Prioridad 2: Detectar por descripción (para gastos antiguos)
                const desc = (expense.description || '').toLowerCase();
                if (desc.includes('tradingview') || desc.includes('ninjatrader') || desc.includes('plataforma')) {
                    categories['Plataformas'] += amount;
                } else if (desc.includes('curso') || desc.includes('educación') || desc.includes('educacion') || desc.includes('formación')) {
                    categories['Educación'] += amount;
                } else if (desc.includes('vps') || desc.includes('servidor') || desc.includes('hosting')) {
                    categories['Servicios'] += amount;
                } else if (desc.includes('indicador') || desc.includes('software') || desc.includes('herramienta')) {
                    categories['Herramientas'] += amount;
                } else {
                    categories['Otros'] += amount;
                }
            });
            
            const labels = Object.keys(categories);
            const data = Object.values(categories);
            
            trackerbankExpensesCategoryChart = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: [
                            'rgba(239, 68, 68, 0.7)',
                            'rgba(249, 115, 22, 0.7)',
                            'rgba(234, 179, 8, 0.7)',
                            'rgba(168, 85, 247, 0.7)',
                            'rgba(107, 114, 128, 0.7)'
                        ],
                        borderColor: '#1a1a1a',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { position: 'bottom' },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const label = context.label || '';
                                    const value = formatCurrency(context.parsed, DB.settings.defaultCurrency);
                                    return `${label}: ${value}`;
                                }
                            }
                        }
                    }
                }
            });
        }
        
        function renderTrackerBankWithdrawalsTable(withdrawals) {
            const tbody = document.getElementById('trackerbank-withdrawals-table');
            if (!tbody) return;
            
            if (withdrawals.length === 0) {
                tbody.innerHTML = '<tr><td colspan="4" class="text-center text-text-secondary py-4">No hay retiros registrados</td></tr>';
                return;
            }
            
            let accumulated = 0;
            const rows = withdrawals
                .sort((a, b) => new Date(b.date) - new Date(a.date))
                .slice(0, 10) // Últimos 10 retiros
                .map(w => {
                    accumulated += Math.abs(w.amount);
                    const bankIcon = w.bank === 'wise' ? '🟢' : '🟣';
                    const bankName = w.bank === 'wise' ? 'Wise' : 'Revolut';
                    return `
                        <tr class="hover:bg-surface-light transition-colors" data-withdrawal-id="${w.id}" onclick="showWithdrawalDetail(${w.id})">
                            <td>${formatDate(w.date)}</td>
                            <td class="text-blue font-semibold hide-amount">${formatCurrency(Math.abs(w.amount), w.currency)}</td>
                            <td>${bankIcon} ${bankName}</td>
                            <td class="hide-amount">${formatCurrency(accumulated, w.currency)}</td>
                        </tr>
                    `;
                }).join('');
            
            tbody.innerHTML = rows;
        }
        
        function renderTrackerBankExpensesTable(expenses) {
            const tbody = document.getElementById('trackerbank-expenses-table');
            if (!tbody) return;
            
            if (expenses.length === 0) {
                tbody.innerHTML = '<tr><td colspan="4" class="text-center text-text-secondary py-4">No hay gastos registrados</td></tr>';
                return;
            }
            
            // Mapeo de categorías a emojis
            const categoryIcons = {
                'plataforma': '🖥️',
                'educacion': '🎓',
                'herramientas': '🛠️',
                'servicios': '💼',
                'otros': '📄'
            };
            
            const categoryNames = {
                'plataforma': 'Plataforma',
                'educacion': 'Educación',
                'herramientas': 'Herramientas',
                'servicios': 'Servicios',
                'otros': 'Otros'
            };
            
            const rows = expenses
                .sort((a, b) => new Date(b.date) - new Date(a.date))
                .slice(0, 10) // Últimos 10 gastos
                .map(e => {
                    // Detectar categoría
                    let category = e.category || 'otros';
                    const desc = (e.description || '').toLowerCase();
                    
                    if (!e.category) {
                        if (desc.includes('broker') || desc.includes('prop') || desc.includes('funded')) category = 'plataforma';
                        else if (desc.includes('curso') || desc.includes('mentoria') || desc.includes('libro')) category = 'educacion';
                        else if (desc.includes('vps') || desc.includes('software') || desc.includes('tool')) category = 'herramientas';
                        else if (desc.includes('hosting') || desc.includes('api') || desc.includes('suscripcion')) category = 'servicios';
                    }
                    
                    const icon = categoryIcons[category] || '📄';
                    const catName = categoryNames[category] || 'Otros';
                    
                    return `
                        <tr class="hover:bg-surface-light transition-colors" data-expense-id="${e.id}" onclick="showExpenseDetail(${e.id})">
                            <td>${formatDate(e.date)}</td>
                            <td class="text-sm">${e.description || 'Sin descripción'}</td>
                            <td class="text-sm"><span title="${catName}">${icon}</span> ${catName}</td>
                            <td class="text-red font-semibold hide-amount">${formatCurrency(Math.abs(e.amount), e.currency)}</td>
                        </tr>
                    `;
                }).join('');
            
            tbody.innerHTML = rows;
        }
        
        function calculateTrackerBankProjections(operations) {
            // Calcular promedio mensual de los últimos 3 meses
            const now = new Date();
            const threeMonthsAgo = new Date(now.getFullYear(), now.getMonth() - 3, 1);
            
            const recentOps = operations.filter(op => new Date(op.date) >= threeMonthsAgo);
            const totalPL = recentOps.reduce((sum, op) => sum + (op.pl || 0), 0);
            const avgMonthly = totalPL / 3;
            
            document.getElementById('trackerbank-avg-monthly').textContent = formatCurrency(avgMonthly, DB.settings.defaultCurrency);
            document.getElementById('trackerbank-proj-3months').textContent = formatCurrency(avgMonthly * 3, DB.settings.defaultCurrency);
            document.getElementById('trackerbank-proj-6months').textContent = formatCurrency(avgMonthly * 6, DB.settings.defaultCurrency);
            document.getElementById('trackerbank-proj-12months').textContent = formatCurrency(avgMonthly * 12, DB.settings.defaultCurrency);
        }
        
        function calculateTrackerBankHistoricalMetrics(operations) {
            // Agrupar por mes
            const monthlyData = {};
            operations.forEach(op => {
                const date = new Date(op.date);
                const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                if (!monthlyData[monthKey]) monthlyData[monthKey] = 0;
                monthlyData[monthKey] += (op.pl || 0);
            });
            
            const months = Object.keys(monthlyData).sort();
            const values = months.map(m => monthlyData[m]);
            
            if (values.length === 0) {
                document.getElementById('trackerbank-best-month-date').textContent = '-';
                document.getElementById('trackerbank-best-month-amount').textContent = '$0.00';
                document.getElementById('trackerbank-worst-month-date').textContent = '-';
                document.getElementById('trackerbank-worst-month-amount').textContent = '$0.00';
                document.getElementById('trackerbank-positive-streak').textContent = '0 meses';
                return;
            }
            
            const maxValue = Math.max(...values);
            const minValue = Math.min(...values);
            const maxIndex = values.indexOf(maxValue);
            const minIndex = values.indexOf(minValue);
            
            document.getElementById('trackerbank-best-month-date').textContent = months[maxIndex];
            document.getElementById('trackerbank-best-month-amount').textContent = formatCurrency(maxValue, DB.settings.defaultCurrency);
            document.getElementById('trackerbank-worst-month-date').textContent = months[minIndex];
            document.getElementById('trackerbank-worst-month-amount').textContent = formatCurrency(minValue, DB.settings.defaultCurrency);
            
            // Calcular racha positiva
            let streak = 0;
            for (let i = values.length - 1; i >= 0; i--) {
                if (values[i] > 0) streak++;
                else break;
            }
            document.getElementById('trackerbank-positive-streak').textContent = `${streak} ${streak === 1 ? 'mes' : 'meses'}`;
        }
        
        // ========================================
        // FUNCIONES ADICIONALES DE TRACKERBANK
        // ========================================
        
        // Variables globales para gráficos de TrackerBank
        let trackerbankCashflowChart = null;
        let trackerbankBankEvolutionChart = null;
        
        function renderTrackerBankCashflowChart(allOperations, allFinances) {
            const ctx = document.getElementById('trackerbank-cashflow-chart');
            if (!ctx) return;
            
            // Destruir gráfico anterior
            if (trackerbankCashflowChart) {
                trackerbankCashflowChart.destroy();
                trackerbankCashflowChart = null;
            }
            
            // Agrupar por mes
            const monthlyData = {};
            
            // Ingresos de trading
            allOperations.forEach(op => {
                const date = new Date(op.date);
                const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                if (!monthlyData[monthKey]) monthlyData[monthKey] = { income: 0, expenses: 0, withdrawals: 0 };
                if (op.pl > 0) monthlyData[monthKey].income += op.pl;
            });
            
            // Gastos y retiros
            allFinances.forEach(f => {
                const date = new Date(f.date);
                const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                if (!monthlyData[monthKey]) monthlyData[monthKey] = { income: 0, expenses: 0, withdrawals: 0 };
                
                if (f.movementType === 'retiro') {
                    monthlyData[monthKey].withdrawals += Math.abs(f.amount);
                } else if (f.movementType === 'gasto' || f.amount < 0) {
                    monthlyData[monthKey].expenses += Math.abs(f.amount);
                }
            });
            
            const labels = Object.keys(monthlyData).sort();
            const incomeData = labels.map(m => monthlyData[m].income);
            const expensesData = labels.map(m => monthlyData[m].expenses);
            const withdrawalsData = labels.map(m => monthlyData[m].withdrawals);
            
            trackerbankCashflowChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Ingresos Trading',
                            data: incomeData,
                            backgroundColor: '#00FF00',
                            borderColor: '#39FF14',
                            borderWidth: 2
                        },
                        {
                            label: 'Gastos',
                            data: expensesData,
                            backgroundColor: 'rgba(239, 68, 68, 0.7)',
                            borderColor: '#ef4444',
                            borderWidth: 2
                        },
                        {
                            label: 'Retiros',
                            data: withdrawalsData,
                            backgroundColor: 'rgba(59, 130, 246, 0.7)',
                            borderColor: '#3b82f6',
                            borderWidth: 2
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { position: 'top' },
                        tooltip: {
                            callbacks: {
                                label: (context) => `${context.dataset.label}: ${formatCurrency(context.parsed.y, DB.settings.defaultCurrency)}`
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: (value) => formatCurrency(value, DB.settings.defaultCurrency)
                            }
                        }
                    }
                }
            });
        }
        
        function renderTrackerBankAccountEvolution(withdrawals, selectedBank) {
            const ctx = document.getElementById('trackerbank-bank-evolution-chart');
            if (!ctx) return;
            
            console.log('📊 Renderizando evolución de cuenta corriente:', selectedBank);
            console.log('Total retiros disponibles:', withdrawals.length);
            
            // Destruir gráfico anterior
            if (trackerbankBankEvolutionChart) {
                trackerbankBankEvolutionChart.destroy();
                trackerbankBankEvolutionChart = null;
            }
            
            // Filtrar retiros por banco (si no tienen banco, usar el seleccionado por defecto)
            const bankWithdrawals = withdrawals.filter(w => {
                // Si el retiro no tiene banco definido, asignarlo al banco por defecto (revolut)
                if (!w.bank) {
                    return selectedBank === 'revolut';
                }
                return w.bank === selectedBank;
            });
            
            console.log('Retiros filtrados por banco:', bankWithdrawals.length);
            
            if (bankWithdrawals.length === 0) {
                console.log('⚠️ No hay retiros para este banco');
                // Mostrar gráfico vacío pero con mensaje
                trackerbankBankEvolutionChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: ['Sin datos'],
                        datasets: [{
                            label: 'Balance Acumulado',
                            data: [0],
                            borderColor: '#3b82f6',
                            backgroundColor: 'rgba(59, 130, 246, 0.1)',
                            borderWidth: 3,
                            fill: true,
                            tension: 0.4
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: true },
                            tooltip: { enabled: false }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                max: 100,
                                ticks: {
                                    callback: (value) => formatCurrency(value, DB.settings.defaultCurrency)
                                }
                            }
                        }
                    }
                });
                
                // Actualizar balance total a 0
                document.getElementById('trackerbank-bank-balance').textContent = formatCurrency(0, DB.settings.defaultCurrency);
                return;
            }
            
            // Ordenar por fecha y calcular acumulado
            const sorted = [...bankWithdrawals].sort((a, b) => new Date(a.date) - new Date(b.date));
            let accumulated = 0;
            const labels = [];
            const data = [];
            
            sorted.forEach(w => {
                accumulated += Math.abs(w.amount);
                labels.push(formatDate(w.date));
                data.push(accumulated);
            });
            
            console.log('✅ Datos del gráfico:', { labels, data, accumulated });
            
            // Actualizar balance total
            document.getElementById('trackerbank-bank-balance').textContent = formatCurrency(accumulated, DB.settings.defaultCurrency);
            
            trackerbankBankEvolutionChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Balance Acumulado',
                        data: data,
                        borderColor: '#3b82f6',
                        backgroundColor: 'rgba(59, 130, 246, 0.1)',
                        borderWidth: 3,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 4,
                        pointHoverRadius: 7
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: true },
                        tooltip: {
                            callbacks: {
                                label: (context) => formatCurrency(context.parsed.y, DB.settings.defaultCurrency)
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: (value) => formatCurrency(value, DB.settings.defaultCurrency)
                            }
                        }
                    }
                }
            });
        }
        
        // Función para mostrar detalles de retiro en modal
        function showWithdrawalDetail(withdrawalId) {
            const withdrawal = DB.finances.find(f => f.id === withdrawalId);
            if (!withdrawal) return;
            
            const modal = document.getElementById('withdrawal-detail-modal');
            
            // Rellenar datos
            document.getElementById('withdrawal-detail-date').textContent = formatDate(withdrawal.date);
            document.getElementById('withdrawal-detail-amount').textContent = formatCurrency(Math.abs(withdrawal.amount), withdrawal.currency);
            
            const bankIcon = withdrawal.bank === 'wise' ? '🟢' : '🟣';
            const bankName = withdrawal.bank === 'wise' ? 'Wise' : 'Revolut';
            document.getElementById('withdrawal-detail-bank').textContent = `${bankIcon} ${bankName}`;
            document.getElementById('withdrawal-detail-currency').textContent = withdrawal.currency;
            
            document.getElementById('withdrawal-detail-description').textContent = withdrawal.description || 'Sin descripción';
            
            const notesEl = document.getElementById('withdrawal-detail-notes');
            if (withdrawal.notes && withdrawal.notes.trim()) {
                notesEl.innerHTML = withdrawal.notes;
            } else {
                notesEl.innerHTML = '<p class="text-text-secondary italic">Sin notas adicionales</p>';
            }
            
            modal.style.display = 'flex';
        }
        
        function showExpenseDetail(expenseId) {
            const expense = DB.finances.find(f => f.id === expenseId);
            if (!expense) return;
            
            const modal = document.getElementById('expense-detail-modal');
            
            // Rellenar datos
            document.getElementById('expense-detail-date').textContent = formatDate(expense.date);
            document.getElementById('expense-detail-amount').textContent = formatCurrency(Math.abs(expense.amount), expense.currency);
            
            // Detectar categoría
            let category = expense.category || 'otros';
            const desc = (expense.description || '').toLowerCase();
            
            if (!expense.category) {
                if (desc.includes('broker') || desc.includes('prop') || desc.includes('funded')) category = 'plataforma';
                else if (desc.includes('curso') || desc.includes('mentoria') || desc.includes('libro')) category = 'educacion';
                else if (desc.includes('vps') || desc.includes('software') || desc.includes('tool')) category = 'herramientas';
                else if (desc.includes('hosting') || desc.includes('api') || desc.includes('suscripcion')) category = 'servicios';
            }
            
            const categoryIcons = {
                'plataforma': '🖥️',
                'educacion': '🎓',
                'herramientas': '🛠️',
                'servicios': '💼',
                'otros': '📄'
            };
            
            const categoryNames = {
                'plataforma': 'Plataforma',
                'educacion': 'Educación',
                'herramientas': 'Herramientas',
                'servicios': 'Servicios',
                'otros': 'Otros'
            };
            
            const icon = categoryIcons[category] || '📄';
            const catName = categoryNames[category] || 'Otros';
            
            document.getElementById('expense-detail-category').textContent = `${icon} ${catName}`;
            document.getElementById('expense-detail-currency').textContent = expense.currency;
            
            document.getElementById('expense-detail-description').textContent = expense.description || 'Sin descripción';
            
            const notesEl = document.getElementById('expense-detail-notes');
            if (expense.notes && expense.notes.trim()) {
                notesEl.innerHTML = expense.notes;
            } else {
                notesEl.innerHTML = '<p class="text-text-secondary italic">Sin notas adicionales</p>';
            }
            
            modal.style.display = 'flex';
        }
        
        function renderFinancialCalendar(financeEntries, tradeOperations) {
            const container = document.getElementById('finances-calendar-container');
            const monthYearEl = document.getElementById('finances-calendar-month-year');
            
            if (!container || !monthYearEl) return;
            
            const year = currentFinancialCalendarDate.getFullYear();
            const month = currentFinancialCalendarDate.getMonth();
            
            const monthNames = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'];
            monthYearEl.textContent = `${monthNames[month]} ${year}`;
            
            const firstDayOfMonth = new Date(year, month, 1);
            const lastDayOfMonth = new Date(year, month + 1, 0);
            const daysInMonth = lastDayOfMonth.getDate();
            const firstDayOfWeekIndex = firstDayOfMonth.getDay();
            
            const targetCurrency = DB.settings.defaultCurrency;
            
            // Agrupar datos por fecha (SOLO datos reales de DB.finances)
            const dailyData = {};
            
            // Procesar SOLO movimientos financieros reales
            financeEntries.forEach(entry => {
                const date = entry.date;
                if (!dailyData[date]) {
                    dailyData[date] = { income: 0, expenses: 0, hasWithdrawal: false, hasIncome: false, items: [] };
                }
                
                const amount = convertCurrency(entry.amount, entry.currency, targetCurrency);
                
                // Detectar si es retiro o ingreso
                if (entry.type === 'expense' || amount < 0) {
                    dailyData[date].expenses += Math.abs(amount);
                    dailyData[date].hasWithdrawal = true;
                } else if (entry.type === 'income' || amount > 0) {
                    dailyData[date].income += amount;
                    dailyData[date].hasIncome = true;
                }
                
                dailyData[date].items.push({ type: 'finance', ...entry, convertedAmount: amount });
            });
            
            // Crear HTML del calendario (IGUAL que calendario mensual)
            let calendarHTML = `
                <div class="grid grid-cols-8 gap-2 text-center font-bold p-2 mb-2 text-text-secondary text-xs">
                    <div>Dom</div>
                    <div>Lun</div>
                    <div>Mar</div>
                    <div>Mié</div>
                    <div>Jue</div>
                    <div>Vie</div>
                    <div>Sáb</div>
                    <div>Semana</div>
                </div>
                <div class="grid grid-cols-8 gap-2">
            `;
            
            // Celdas vacías antes del primer día
            for (let i = 0; i < firstDayOfWeekIndex; i++) {
                calendarHTML += '<div class="calendar-day empty"></div>';
            }
            
            let weeklyTotals = [];
            let currentWeekTotal = 0;
            let dayOfWeek = firstDayOfWeekIndex;
            let weekCounter = 1;
            
            // Días del mes
            for (let day = 1; day <= daysInMonth; day++) {
                const dateString = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                const data = dailyData[dateString];
                
                let cellClass = 'calendar-day';
                
                if (data) {
                    const totalBalance = data.income - data.expenses;
                    const isProfit = totalBalance > 0;
                    const isLoss = totalBalance < 0;
                    
                    cellClass += isProfit ? ' profit' : (isLoss ? ' loss' : '');
                    
                    // Marcar días con retiros en rojo y con ingresos en verde
                    if (data.hasWithdrawal) {
                        cellClass += ' border-red';
                    } else if (data.hasIncome) {
                        cellClass += ' border-primary';
                    }
                    
                    currentWeekTotal += totalBalance;
                    
                    // Color rojo para gastos, verde para ingresos
                    const amountColor = data.hasWithdrawal ? 'color: #ff3333; font-weight: bold;' : (data.hasIncome ? 'color: #39ff14; font-weight: bold;' : '');
                    
                    calendarHTML += `
                        <div class="${cellClass}" data-day="${day}">
                            <div class="day-number">${day}</div>
                            <div class="day-profit ${isProfit ? 'positive' : (isLoss ? 'negative' : '')}" style="${amountColor}">${formatCurrency(totalBalance, targetCurrency, targetCurrency).replace(/\.\d+/, '')}</div>
                            <div class="day-trades">${data.items.length} mov.</div>
                        </div>
                    `;
                } else {
                    calendarHTML += `
                        <div class="${cellClass}">
                            <div class="day-number text-text-secondary">${day}</div>
                        </div>
                    `;
                }
                
                // Si es sábado o el último día del mes, agregar celda de semana
                dayOfWeek++;
                if (dayOfWeek === 7 || day === daysInMonth) {
                    const weekClass = currentWeekTotal > 0 ? 'text-positive' : currentWeekTotal < 0 ? 'text-negative' : '';
                    calendarHTML += `
                        <div class="week-summary" style="background-color: var(--surface); border: 1px solid var(--border);">
                            <div class="font-bold text-sm">Sem ${weekCounter}</div>
                            <div class="text-lg font-semibold ${weekClass}">${formatCurrency(currentWeekTotal, targetCurrency, targetCurrency).replace(/\.\d+/, '')}</div>
                            <div class="text-xs text-text-secondary">${Math.round(currentWeekTotal)} total</div>
                        </div>
                    `;
                    weeklyTotals.push(currentWeekTotal);
                    currentWeekTotal = 0;
                    dayOfWeek = 0;
                    weekCounter++;
                }
            }
            
            calendarHTML += '</div>';
            container.innerHTML = calendarHTML;
            
            // Renderizar métricas de barras después del calendario
            renderFinancesWeeklyTrendBars(weeklyTotals);
            renderFinancesWeekdayPerformanceBars(dailyData, year, month);
        }

        // Función para renderizar barras de tendencia semanal
        function renderFinancesWeeklyTrendBars(weeklyTotals) {
            const container = document.getElementById('finances-weekly-trend-bars');
            if (!container || !weeklyTotals || weeklyTotals.length === 0) return;

            const maxAbsValue = Math.max(...weeklyTotals.map(v => Math.abs(v)), 1);
            const targetCurrency = DB.settings.defaultCurrency;

            let html = '';
            weeklyTotals.forEach((total, index) => {
                const isPositive = total >= 0;
                const percentage = (Math.abs(total) / maxAbsValue) * 100;
                const displayValue = formatCurrency(total, targetCurrency, targetCurrency).replace(/\.\d+/, '');

                html += `
                    <div class="metric-bar-container">
                        <div class="metric-bar-label">Sem ${index + 1}</div>
                        <div class="metric-bar-wrapper">
                            <div class="metric-bar-fill ${isPositive ? 'positive' : 'negative'}" style="width: ${percentage}%">
                                <div class="metric-bar-value ${percentage < 20 ? 'outside' : ''}">${displayValue}</div>
                            </div>
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html || '<p class="text-sm text-text-secondary italic">Sin datos para mostrar</p>';
        }

        // Función para renderizar barras de rendimiento por día de la semana
        function renderFinancesWeekdayPerformanceBars(dailyData, year, month) {
            const container = document.getElementById('finances-weekday-performance-bars');
            if (!container) return;

            const weekdayNames = ['Domingo', 'Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sábado'];
            const weekdayTotals = [0, 0, 0, 0, 0, 0, 0];
            const weekdayCounts = [0, 0, 0, 0, 0, 0, 0];

            // Calcular totales por día de la semana
            Object.keys(dailyData).forEach(dateString => {
                const date = new Date(dateString + 'T00:00:00');
                const dayOfWeek = date.getDay();
                const data = dailyData[dateString];
                const totalBalance = data.income - data.expenses;
                
                weekdayTotals[dayOfWeek] += totalBalance;
                weekdayCounts[dayOfWeek]++;
            });

            // Calcular promedios
            const weekdayAverages = weekdayTotals.map((total, index) => 
                weekdayCounts[index] > 0 ? total / weekdayCounts[index] : 0
            );

            const maxAbsValue = Math.max(...weekdayAverages.map(v => Math.abs(v)), 1);
            const targetCurrency = DB.settings.defaultCurrency;

            let html = '';
            weekdayNames.forEach((name, index) => {
                const avg = weekdayAverages[index];
                const isPositive = avg >= 0;
                const percentage = (Math.abs(avg) / maxAbsValue) * 100;
                const displayValue = formatCurrency(avg, targetCurrency, targetCurrency).replace(/\.\d+/, '');
                const count = weekdayCounts[index];

                html += `
                    <div class="metric-bar-container">
                        <div class="metric-bar-label">${name.substring(0, 3)}</div>
                        <div class="metric-bar-wrapper">
                            <div class="metric-bar-fill ${isPositive ? 'positive' : 'negative'}" style="width: ${percentage}%">
                                <div class="metric-bar-value ${percentage < 20 ? 'outside' : ''}">${displayValue} ${count > 0 ? `(${count})` : ''}</div>
                            </div>
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html || '<p class="text-sm text-text-secondary italic">Sin datos para mostrar</p>';
        }

        let currentCalendarDate = new Date();

        function initCalendar() {
            updateAccountSelect('calendar-account-select');
            updateCalendar();
            
            const prevBtn = document.getElementById('prev-month');
            if (prevBtn) {
                prevBtn.addEventListener('click', () => { 
                    currentCalendarDate.setMonth(currentCalendarDate.getMonth() - 1); 
                    updateCalendar(); 
                });
            }
            
            const nextBtn = document.getElementById('next-month');
            if (nextBtn) {
                nextBtn.addEventListener('click', () => { 
                    currentCalendarDate.setMonth(currentCalendarDate.getMonth() + 1); 
                    updateCalendar(); 
                });
            }
            
            const accountSelect = document.getElementById('calendar-account-select');
            if (accountSelect) {
                accountSelect.addEventListener('change', function() {
                    const selectedAccount = this.value;
                    syncAccountSelection(selectedAccount);
                    updateCalendar();
                });
            }
            
            // Selectores de moneda y vista del calendario
            const currencySelect = document.getElementById('calendar-currency-select');
            if (currencySelect) {
                currencySelect.addEventListener('change', updateCalendar);
            }
            
            const viewSelect = document.getElementById('calendar-view-select');
            if (viewSelect) {
                viewSelect.addEventListener('change', toggleCalendarView);
            }

            // Botón de filtros
            const filtersBtn = document.getElementById('calendar-filters-btn');
            if (filtersBtn) {
                filtersBtn.addEventListener('click', () => {
                    document.getElementById('operations-filters-sidebar').classList.add('active');
                    document.getElementById('filters-overlay').classList.add('active');
                });
            }

            // Botón de descarga
            const downloadBtn = document.getElementById('calendar-download-btn');
            if (downloadBtn) {
                downloadBtn.addEventListener('click', () => downloadSectionPDF('calendar', 'Calendario'));
            }
        }

        function toggleCalendarView() {
            updateCalendar();
        }

        function getWeekNumber(date) {
            const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
            const dayNum = d.getUTCDay() || 7;
            d.setUTCDate(d.getUTCDate() + 4 - dayNum);
            const yearStart = new Date(Date.UTC(d.getUTCFullYear(),0,1));
            return Math.ceil((((d - yearStart) / 86400000) + 1)/7);
        }

        async function renderYearlyView(year, operations) {
            const yearlyContainer = document.getElementById('yearly-calendar-view');
            yearlyContainer.innerHTML = ''; // Clear previous content

            const dailyPnl = {};
            operations.forEach(op => {
                const date = op.date;
                if (!dailyPnl[date]) {
                    dailyPnl[date] = { pl: 0, ops: [] };
                }
                dailyPnl[date].pl += op.pl;
                dailyPnl[date].ops.push(op);
            });

            const monthNames = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'];
            const weekDays = ['D', 'L', 'M', 'X', 'J', 'V', 'S'];

            for (let month = 0; month < 12; month++) {
                const monthContainer = document.createElement('div');
                monthContainer.className = 'mini-calendar';

                const header = document.createElement('div');
                header.className = 'mini-calendar-header';
                header.textContent = `${monthNames[month]} ${year}`;
                
                // Add "Open" button to mini-calendar header
                const openBtn = document.createElement('button');
                openBtn.className = 'mini-calendar-open-btn';
                openBtn.textContent = 'Abrir';
                openBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    // Set the calendar to this specific month
                    currentCalendarDate = new Date(year, month, 1);
                    // Switch to monthly view
                    document.getElementById('calendar-view-select').value = 'monthly';
                    // Update the calendar
                    updateCalendar();
                });
                header.appendChild(openBtn);
                
                monthContainer.appendChild(header);

                const grid = document.createElement('div');
                grid.className = 'mini-calendar-grid';

                weekDays.forEach(day => {
                    const dayEl = document.createElement('div');
                    dayEl.className = 'mini-calendar-weekday';
                    dayEl.textContent = day;
                    grid.appendChild(dayEl);
                });

                const firstDay = new Date(year, month, 1).getDay();
                const daysInMonth = new Date(year, month + 1, 0).getDate();

                for (let i = 0; i < firstDay; i++) {
                    grid.appendChild(document.createElement('div'));
                }

                for (let day = 1; day <= daysInMonth; day++) {
                    const dayCell = document.createElement('div');
                    dayCell.className = 'mini-calendar-day';
                    dayCell.textContent = day;

                    const dateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                    if (dailyPnl[dateStr]) {
                        dayCell.classList.add('operated');
                        if (dailyPnl[dateStr].pl > 0) {
                            dayCell.classList.add('profit');
                        } else if (dailyPnl[dateStr].pl < 0) {
                            dayCell.classList.add('loss');
                        }

                                                dayCell.addEventListener('click', () => {
                                                    const dateKeyYYYYMMDD = dateStr;
                                                    const titleLabel = `Día: ${formatDate(dateKeyYYYYMMDD)}`;
                                                    const calendarSelectedAccount = document.getElementById('calendar-account-select').value;
                                                    openAnalyticsDetailModal('date', dateKeyYYYYMMDD, titleLabel, calendarSelectedAccount);
                                                });                    }
                    grid.appendChild(dayCell);
                }
                monthContainer.appendChild(grid);
                yearlyContainer.appendChild(monthContainer);
            }
        }

        updateCalendar = async function () {
            console.log('🔄 updateCalendar() iniciado');
            
            if (!document.getElementById('calendar').classList.contains('active')) {
                console.log('⚠️ Calendar no está activo, cancelando refresh');
                return;
            }

            const accountSelect = document.getElementById('calendar-account-select');
            const currencySelect = document.getElementById('calendar-currency-select');
            const viewSelect = document.getElementById('calendar-view-select');
            
            if (!accountSelect || !currencySelect || !viewSelect) return;
            
            const selectedAccount = accountSelect.value;
            const currencyMode = currencySelect.value;
            const viewMode = viewSelect.value;
            const year = currentCalendarDate.getFullYear();
            const month = currentCalendarDate.getMonth();

            console.log('📊 Calendar - Cuenta seleccionada:', selectedAccount);
            console.log('📅 Calendar - Filtro de fecha:', globalDateFilter);

            const monthlyView = document.getElementById('monthly-calendar-view');
            const yearlyView = document.getElementById('yearly-calendar-view');
            const monthNav = document.getElementById('calendar-month-navigation');
            const monthlySummary = document.querySelector('#calendar > .mt-8');
            const weeklyTrend = document.querySelector('#calendar > .mt-8 + .mt-8');

            if (viewMode === 'general') {
                monthlyView.style.display = 'none';
                monthNav.style.display = 'none';
                if(monthlySummary) monthlySummary.style.display = 'none';
                if(weeklyTrend) weeklyTrend.style.display = 'none';
                yearlyView.style.display = 'grid';
                yearlyView.classList.remove('hidden');

                // Aplicar filtro de fecha global
                let allOps = applyDateFilterToData(DB.operations);
                console.log('📅 Después de filtro de fecha (yearly):', allOps.length, 'operaciones');
                
                if (selectedAccount !== 'all') {
                    allOps = allOps.filter(op => op.accountId === selectedAccount);
                    console.log('👤 Después de filtro de cuenta (yearly):', allOps.length, 'operaciones');
                }
                
                // Aplicar filtros personalizados de calendario
                allOps = applyCalendarFilters(allOps);

                await renderYearlyView(year, allOps);
                return;
            }

            // Show monthly view if not 'general'
            monthlyView.style.display = 'block';
            monthNav.style.display = 'flex';
            if(monthlySummary) monthlySummary.style.display = 'block';
            if(weeklyTrend) weeklyTrend.style.display = 'block';
            yearlyView.style.display = 'none';
            yearlyView.classList.add('hidden');

            const firstDayOfMonth = new Date(Date.UTC(year, month, 1));
            const lastDayOfMonth = new Date(Date.UTC(year, month + 1, 0));

            const monthNames = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'];
            document.getElementById('current-month').textContent = `${monthNames[month]} ${year}`;

            // Aplicar filtro de fecha global primero
            let filteredOps = applyDateFilterToData(DB.operations);
            console.log('📅 Después de filtro de fecha (monthly):', filteredOps.length, 'operaciones');
            
            // Luego filtrar por mes y cuenta
            let monthOperations = filteredOps.filter(op => {
                const opDate = new Date(op.date + 'T00:00:00Z');
                return opDate.getUTCMonth() === month && opDate.getUTCFullYear() === year && (selectedAccount === 'all' || op.accountId === selectedAccount);
            });
            
            // Aplicar filtros personalizados de calendario
            monthOperations = applyCalendarFilters(monthOperations);
            
            console.log('📊 Calendar - Operaciones del mes:', monthOperations.length);

            const dailyData = {}; const weeklyData = {};
            let baseCurrencyForCalc = DB.settings.defaultCurrency;
            let initialBalanceForPercent = 0;

            if (selectedAccount !== 'all') {
                const account = DB.accounts.find(a => a.id === selectedAccount);
                if (account) {
                    baseCurrencyForCalc = account.currency;
                    initialBalanceForPercent = account.initialBalance;
                }
            } else {
                initialBalanceForPercent = DB.accounts.reduce((sum, acc) => {
                    return sum + convertCurrency(acc.initialBalance, acc.currency, DB.settings.defaultCurrency);
                }, 0);
                baseCurrencyForCalc = DB.settings.defaultCurrency;
            }

            // Agrupar operaciones por ID antes de procesar
            const groupedOps = {};
            monthOperations.forEach(op => {
                const opId = op.id;
                if (!groupedOps[opId]) {
                    groupedOps[opId] = {
                        id: opId,
                        operations: [],
                        totalPL: 0,
                        date: op.date,
                        currency: op.currency
                    };
                }
                groupedOps[opId].operations.push(op);
                groupedOps[opId].totalPL += op.pl;
            });

            const uniqueTradeGroups = Object.values(groupedOps);

            uniqueTradeGroups.forEach(group => {
                const date = new Date(group.date + 'T00:00:00Z');
                const day = date.getUTCDate();
                const weekNumber = getWeekNumber(date);
                if (!dailyData[day]) dailyData[day] = { operations: [], totalPL: 0, count: 0 };
                if (!weeklyData[weekNumber]) weeklyData[weekNumber] = { operations: [], totalPL: 0, count: 0, weekNumber: weekNumber };

                let pl = group.totalPL;
                if (group.currency !== baseCurrencyForCalc) {
                    pl = convertCurrency(pl, group.currency, baseCurrencyForCalc);
                }
                dailyData[day].operations.push(group); dailyData[day].totalPL += pl; dailyData[day].count++;
                weeklyData[weekNumber].operations.push(group); weeklyData[weekNumber].totalPL += pl; weeklyData[weekNumber].count++;
            });

            const grid = document.getElementById('calendar-grid'); grid.innerHTML = '';
            const daysInMonth = lastDayOfMonth.getUTCDate();
            const firstDayOfWeekIndex = firstDayOfMonth.getUTCDay();

            let weekCounter = 1; // Contador secuencial de semanas del mes

            for (let i = 0; i < firstDayOfWeekIndex; i++) {
                grid.innerHTML += `<div class="calendar-day empty"></div>`;
            }

            for (let day = 1; day <= daysInMonth; day++) {
                const currentDate = new Date(Date.UTC(year, month, day));
                const dayOfWeekIndex = currentDate.getUTCDay();
                const dayData = dailyData[day];
                let cellHTML = `<div class="calendar-day `;

                if (dayData) {
                    const isProfit = dayData.totalPL > 0; const isLoss = dayData.totalPL < 0;
                    cellHTML += isProfit ? 'profit' : (isLoss ? 'loss' : '');
                    cellHTML += `" data-day="${day}">`;
                    cellHTML += `<div class="day-number">${day}</div>`;
                    let formattedPL;
                    if (currencyMode === '%') {
                        const percentage = initialBalanceForPercent > 0 ? (dayData.totalPL / initialBalanceForPercent) * 100 : 0;
                        formattedPL = percentage.toFixed(2) + '%';
                    } else {
                        formattedPL = formatCurrency(dayData.totalPL, baseCurrencyForCalc, currencyMode);
                    }
                    cellHTML += `<div class="day-profit ${isProfit ? 'positive' : (isLoss ? 'negative' : '')}">${formattedPL}</div>`;
                    cellHTML += `<div class="day-trades">${dayData.count} op.</div>`;
                } else {
                    cellHTML += `" data-day="${day}">`;
                    cellHTML += `<div class="day-number text-text-secondary">${day}</div>`;
                }
                cellHTML += `</div>`;
                grid.innerHTML += cellHTML;

                if (dayOfWeekIndex === 6) {
                    const weekNumber = getWeekNumber(currentDate);
                    const weekData = weeklyData[weekNumber] || { totalPL: 0, count: 0, weekNumber: weekNumber };
                    const isWeekProfit = weekData.totalPL > 0; const isWeekLoss = weekData.totalPL < 0;
                    let formattedWeekPL;
                    if (currencyMode === '%') {
                        const percentage = initialBalanceForPercent > 0 ? (weekData.totalPL / initialBalanceForPercent) * 100 : 0;
                        formattedWeekPL = percentage.toFixed(2) + '%';
                    } else {
                        formattedWeekPL = formatCurrency(weekData.totalPL, baseCurrencyForCalc, currencyMode);
                    }
                    grid.innerHTML += `<div class="week-summary" style="background-color: var(--surface); border: 1px solid var(--surface-light)">
                                          <div class="font-bold text-sm">Sem ${weekCounter}</div>
                                          <div class="text-lg font-semibold ${isWeekProfit ? 'text-positive' : (isWeekLoss ? 'text-negative' : '')}">${formattedWeekPL}</div>
                                          <div class="text-xs text-text-secondary">${weekData.count} trades</div>
                                       </div>`;
                    weekCounter++;
                }
            }

            if (lastDayOfMonth.getUTCDay() !== 6) {
                for (let i = lastDayOfMonth.getUTCDay() + 1; i <= 6; i++) {
                    grid.innerHTML += `<div class="calendar-day empty"></div>`;
                }
                const weekNumber = getWeekNumber(lastDayOfMonth);
                const weekData = weeklyData[weekNumber] || { totalPL: 0, count: 0, weekNumber: weekNumber };
                const isWeekProfit = weekData.totalPL > 0; const isWeekLoss = weekData.totalPL < 0;

                let formattedWeekPL;
                if (currencyMode === '%') {
                    const percentage = initialBalanceForPercent > 0 ? (weekData.totalPL / initialBalanceForPercent) * 100 : 0;
                    formattedWeekPL = percentage.toFixed(2) + '%';
                } else {
                    formattedWeekPL = formatCurrency(weekData.totalPL, baseCurrencyForCalc, currencyMode);
                }
                grid.innerHTML += `<div class="week-summary" style="background-color: var(--surface); border: 1px solid var(--surface-light)">
                                      <div class="font-bold text-sm">Sem ${weekCounter}</div>
                                      <div class="text-lg font-semibold ${isWeekProfit ? 'text-positive' : (isWeekLoss ? 'text-negative' : '')}">${formattedWeekPL}</div>
                                      <div class="text-xs text-text-secondary">${weekData.count} trades</div>
                                   </div>`;
            }

            grid.querySelectorAll('.calendar-day:not(.empty)').forEach(cell => {
                const dayHasData = dailyData[parseInt(cell.dataset.day)];
                if (dayHasData) {
                    cell.onclick = () => {
                        const day = parseInt(cell.dataset.day, 10); if (isNaN(day)) return;
                        const dateKeyYYYYMMDD = getLocalDateString(new Date(year, month, day));
                        const allOpsForDay = DB.operations.filter(op => op.date === dateKeyYYYYMMDD && (selectedAccount === 'all' || op.accountId === selectedAccount));
                        
                        if (allOpsForDay.length === 0) return;
                        
                        // Abrir el modal de Análisis del Día con métricas completas
                        if (typeof openAnalyticsDetailModal === 'function') {
                            // Formatear la fecha para el título
                            const dateObj = new Date(dateKeyYYYYMMDD + 'T12:00:00');
                            const dayNames = ['Domingo', 'Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sábado'];
                            const dayName = dayNames[dateObj.getDay()];
                            const formattedTitle = `${dayName} ${dateKeyYYYYMMDD}`;
                            openAnalyticsDetailModal('date', dateKeyYYYYMMDD, formattedTitle);
                        }
                    };
                }
            });

            updateMonthSummary(monthOperations, baseCurrencyForCalc);
            
            // Actualizar todas las gráficas de calendario
            updateCalendarWeeklyTrendChart(weeklyData, baseCurrencyForCalc, initialBalanceForPercent);
            updateCalendarMonthlyWeeksChart(monthOperations, baseCurrencyForCalc, initialBalanceForPercent);
            updateCalendarDailyPLChart(monthOperations, baseCurrencyForCalc, initialBalanceForPercent);
            updateCalendarDailyWinRateChart(monthOperations);
        };


        function updateMonthSummary(operations, baseCurrency) {
            let totalPL = 0; let tradingDays = 0; let winDays = 0; let loseDays = 0; const dailyPL = {};
            const currencyMode = document.getElementById('calendar-currency-select') ? document.getElementById('calendar-currency-select').value : 'USD';

            // Agrupar operaciones por ID primero
            const groupedOps = {};
            operations.forEach(op => {
                const opId = op.id;
                if (!groupedOps[opId]) {
                    groupedOps[opId] = {
                        id: opId,
                        totalPL: 0,
                        date: op.date,
                        currency: op.currency
                    };
                }
                groupedOps[opId].totalPL += op.pl;
            });

            // Calcular P&L diario basado en operaciones agrupadas
            Object.values(groupedOps).forEach(group => {
                const date = group.date;
                if (!dailyPL[date]) dailyPL[date] = 0;
                let pl = group.totalPL;
                if (group.currency !== baseCurrency) pl = convertCurrency(pl, group.currency, baseCurrency);
                dailyPL[date] += pl;
                totalPL += pl;
            });
            
            Object.values(dailyPL).forEach(dayPL => { tradingDays++; if (dayPL > 0) winDays++; else if (dayPL < 0) loseDays++; });

            let initialBalanceForPercent = 0;
            const selectedAccount = document.getElementById('calendar-account-select').value;
            if (currencyMode === '%') {
                if (selectedAccount !== 'all') {
                    const account = DB.accounts.find(a => a.id === selectedAccount);
                    if (account) initialBalanceForPercent = convertCurrency(account.initialBalance, account.currency, baseCurrency);
                } else {
                    initialBalanceForPercent = DB.accounts.reduce((sum, acc) => sum + convertCurrency(acc.initialBalance, acc.currency, baseCurrency), 0);
                }
            }

            let plDisplay;
            if (currencyMode === '%') {
                plDisplay = initialBalanceForPercent > 0 ? ((totalPL / initialBalanceForPercent) * 100).toFixed(2) + '%' : '0.00%';
            } else {
                plDisplay = formatCurrency(totalPL, baseCurrency, currencyMode);
            }
            const monthlyPlEl = document.getElementById('monthly-pl');
            monthlyPlEl.textContent = plDisplay;
            monthlyPlEl.className = `text-2xl font-bold ${totalPL >= 0 ? 'text-green' : 'text-negative'}`;

            document.getElementById('monthly-trading-days').textContent = tradingDays;
            document.getElementById('monthly-winning-days').textContent = winDays;
            document.getElementById('monthly-losing-days').textContent = loseDays;
        }

        function getWeekNumber(date) {
            const d = new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()));
            d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
            const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
            return Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
        }

        // NUEVA FUNCIÓN: Crear movimiento financiero automático para cuentas de Capital Propio
        async function createFinanceMovementFromOperation(operation, account) {
            try {
                // Calcular P/L neto (P/L - fees)
                const netPL = operation.pl - (operation.fees || 0);
                
                // Crear movimiento financiero
                const financeMovement = {
                    id: generateId(),
                    date: operation.date,
                    amount: netPL,
                    currency: operation.currency,
                    notes: `Trading - ${operation.instrument} ${operation.type === 'buy' ? 'Long' : 'Short'}`,
                    accountType: 'capital', // Capital Propio
                    accountId: operation.accountId,
                    operationId: operation.id, // Vincular con la operación
                    created_at: new Date().toISOString()
                };
                
                // Guardar localmente
                await dexieDB.finances.add(financeMovement);
                if (!DB.finances) DB.finances = [];
                DB.finances.push(financeMovement);
                
                console.log('💰 Movimiento financiero creado automáticamente:', financeMovement);
                
                // Sincronizar con Supabase si hay usuario
                if (currentUser && currentUser.id) {
                    const { error } = await supabase.from('finances').insert([{
                        ...financeMovement,
                        user_id: currentUser.id
                    }]);
                    
                    if (error) {
                        console.error('❌ Error al sincronizar movimiento financiero:', error);
                    } else {
                        console.log('✅ Movimiento financiero sincronizado con Supabase');
                    }
                }
            } catch (error) {
                console.error('❌ Error creando movimiento financiero:', error);
            }
        }

        // ============================================
        // FUNCIÓN PARA CALCULAR MAE/MFE ESTIMADOS
        // ============================================
        /**
         * Calcula estimaciones inteligentes de MAE (Maximum Adverse Excursion) y MFE (Maximum Favorable Excursion)
         * basándose en el resultado y P/L de la operación.
         *
         * @param {Object} operation - Objeto de operación con pl, result, entry, exit, volume
         * @returns {Object} - { mae: number, mfe: number }
         */
        function calculateEstimatedMAEMFE(operation) {
            const pl = parseFloat(operation.pl) || 0;
            const result = operation.result;
            const entry = parseFloat(operation.entry) || 0;
            const exit = parseFloat(operation.exit) || 0;
            const volume = parseFloat(operation.volume) || 1;

            let mae = 0; // Maximum Adverse Excursion (peor punto en contra)
            let mfe = 0; // Maximum Favorable Excursion (mejor punto a favor)

            // Para calcular MAE/MFE realistas sin datos intratrade, hacemos estimaciones basadas en estudios de trading:
            // - Trades ganadores típicamente tienen un drawdown del 20-40% del profit final
            // - Trades perdedores típicamente tuvieron un MFE del 10-30% del riesgo antes de revertir

            if (result === 'win') {
                // TRADE GANADOR
                mfe = Math.abs(pl); // El MFE es al menos el P/L final

                // Estimación de MAE: típicamente un trade ganador tiene un drawdown del 25-35% del profit final
                // Usamos 30% como estimación conservadora
                const estimatedDrawdownPercent = 0.30;
                mae = -Math.abs(pl) * estimatedDrawdownPercent;

            } else if (result === 'loss') {
                // TRADE PERDEDOR
                mae = pl; // El MAE es el P/L final (negativo)

                // Estimación de MFE: típicamente un trade perdedor llegó al 15-25% a favor antes de revertir
                // Usamos 20% como estimación
                const estimatedFavorablePercent = 0.20;
                mfe = Math.abs(pl) * estimatedFavorablePercent;

            } else {
                // BREAKEVEN
                mae = 0;
                mfe = 0;
            }

            // Asegurar que los valores sean números válidos
            mae = isFinite(mae) ? mae : 0;
            mfe = isFinite(mfe) ? mfe : 0;

            return {
                mae: parseFloat(mae.toFixed(2)),
                mfe: parseFloat(mfe.toFixed(2))
            };
        }

        // Función global para guardar operaciones
        async function saveOperation() {
            console.log('🔍 INICIO: saveOperation ejecutándose...');
            showLoading(true);

            const formContainer = document.getElementById('add-operation-form');
            const editingId = formContainer.dataset.editingId;

            const date = document.getElementById('op-date').value;
            const accountId = document.getElementById('op-account').value;
            const instrument = document.getElementById('op-instrument').value.toUpperCase().trim();
            const type = document.getElementById('op-type').value;
            const entry = parseFloat(document.getElementById('op-entry').value);
            const exit = parseFloat(document.getElementById('op-exit').value);
            const entryTime = document.getElementById('op-entry-time').value;
            const exitTime = document.getElementById('op-exit-time').value;
            const volume = parseFloat(document.getElementById('op-volume').value);
            const currency = document.getElementById('op-currency').value;
            const notes = document.getElementById('op-notes').value.trim();
            
            // Detectar automáticamente la sesión basada en la hora de entrada (SIEMPRE)
            const session = detectTradingSession(entryTime) || '';
            console.log(`🕐 Sesión detectada automáticamente: ${session} (hora entrada: ${entryTime})`);
            
            const setupId = document.getElementById('op-setup').value.trim();
            console.log('🔍 Setup ID capturado:', setupId, '| Valor del select:', document.getElementById('op-setup').value);
            const manualPLValue = document.getElementById('op-manual-pl').value;
            const fees = parseFloat(document.getElementById('op-fees').value) || 0;

            const isWinSelected = document.getElementById('op-win-btn').dataset.selected === 'true';
            const isLossSelected = document.getElementById('op-loss-btn').dataset.selected === 'true';

            let result;
            let finalPL;
            let manualPLInputVal = null;

            if (!date || !accountId || !instrument || isNaN(volume) || volume <= 0) {
                alert('Por favor, complete todos los campos obligatorios (Fecha, Cuenta, Instrumento, Volumen > 0).');
                showLoading(false); return;
            }

            if (manualPLValue.trim() !== "") {
                manualPLInputVal = parseFloat(manualPLValue);
                if (isNaN(manualPLInputVal)) {
                    alert('P&L Manual no es un número válido.');
                    showLoading(false); return;
                }
                finalPL = manualPLInputVal;
                if (manualPLInputVal > 0) result = 'win';
                else if (manualPLInputVal < 0) result = 'loss';
                else result = 'breakeven';
            } else {
                if (isNaN(entry) || isNaN(exit)) {
                    alert('Por favor, ingrese precios de Entrada y Salida válidos, o ingrese un P&L Manual.');
                    showLoading(false); return;
                }
                if (entry !== exit && !isWinSelected && !isLossSelected) {
                    alert('Por favor, seleccione si la operación fue Ganancia o Pérdida, o ingrese un P&L Manual.');
                    showLoading(false); return;
                }

                if (entry === exit) {
                    result = 'breakeven';
                    finalPL = 0;
                } else {
                    result = isWinSelected ? 'win' : 'loss';
                    if (type === 'buy') finalPL = (exit - entry) * volume;
                    else finalPL = (entry - exit) * volume;

                    if ((result === 'win' && finalPL <= 0) || (result === 'loss' && finalPL >= 0)) {
                        if (!confirm(`El P&L calculado (${finalPL.toFixed(2)} ${currency}) no coincide con el resultado ('${result}') seleccionado. Si continúa, se guardará con el resultado '${result}' y el P&L calculado. ¿Desea continuar?`)) {
                            showLoading(false); return;
                        }
                    }
                }
            }
            finalPL = parseFloat(finalPL.toFixed(5));
            
            // Capturar nota de voz si existe
            const voiceData = document.getElementById('op-voice-data').value;

            let operationData = {
                id: editingId || generateId(),
                date, accountId, instrument, type,
                entry: isNaN(entry) ? null : entry,
                exit: isNaN(exit) ? null : exit,
                entryTime, exitTime,
                volume,
                result, pl: finalPL,
                fees: fees,
                currency, notes,
                voiceNote: voiceData || null,
                imageDatas: [...currentEditingOpImages],
                manualPL: manualPLInputVal,
                session: session,
                setupId: setupId || null,
                setupUsed: setupId || null
            };

            // Calcular MAE/MFE estimados
            const maemfe = calculateEstimatedMAEMFE(operationData);
            operationData.mae = maemfe.mae;
            operationData.mfe = maemfe.mfe;

            console.log('💾 Datos de operación a guardar:', {setupId: operationData.setupId, setupUsed: operationData.setupUsed, mae: operationData.mae, mfe: operationData.mfe, allData: operationData});

            try {
                // GUARDAR PRIMERO LOCALMENTE (siempre funciona)
                if (editingId) {
                    await dexieDB.operations.update(editingId, operationData);
                    const index = DB.operations.findIndex(op => op.id === editingId);
                    if (index !== -1) {
                        DB.operations[index] = { ...DB.operations[index], ...operationData };
                        // IMPORTANTE: También actualizar en dexieDB para evitar que desaparezca
                        await dexieDB.operations.update(editingId, operationData);
                    }
                    console.log('✅ Operación actualizada localmente y en dexieDB');
                } else {
                    await dexieDB.operations.add(operationData);
                    DB.operations.push(operationData);
                    console.log('✅ Operación guardada localmente');
                }

                console.log('🔍 LLEGANDO A SINCRONIZACIÓN...');
                // SINCRONIZACIÓN AUTOMÁTICA EN SEGUNDO PLANO (invisible para el usuario)
                console.log('🔍 currentUser:', currentUser);
                console.log('🔍 ¿Usuario existe?', !!currentUser);
                console.log('🔍 currentUser.id:', currentUser?.id);
                console.log('🔍 operationData:', operationData);
                
                if (currentUser && currentUser.id) {
                    console.log('🔍 Iniciando guardado en Supabase...');
                    console.log('🔍 Operación a guardar:', {
                        id: operationData.id,
                        user_id: currentUser.id,
                        account_id: operationData.accountId,
                        instrument: operationData.instrument
                    });
                    
                    // Intentar guardar automáticamente sin bloquear la UI
                    saveOperationToSupabase(operationData).then((result) => {
                        console.log('✅ Operación sincronizada con Supabase:', result);
                        showSyncNotification('💾 Operación guardada y sincronizada', 'success');
                    }).catch((supabaseError) => {
                        console.error('❌ Error de sincronización automática:', supabaseError);
                        console.error('❌ Detalles del error:', supabaseError.message, supabaseError.stack);
                        // Guardar en cola de pendientes para reintento posterior
                        addToSyncQueue(operationData, 'operation');
                        showSyncNotification('💾 Operación guardada localmente (pendiente de sincronizar)', 'warning');
                    });
                } else {
                    // Usuario no autenticado - solo local
                    console.log('⚠️ NO HAY USUARIO O NO TIENE ID - no se guarda en Supabase');
                    console.log('⚠️ currentUser completo:', JSON.stringify(currentUser));
                    showSyncNotification('💾 Operación guardada localmente', 'info');
                }

                // Actualizar vistas inmediatamente con datos locales
                updateAccountBalances();
                
                // NUEVO: Si la cuenta es de Capital Propio, crear movimiento financiero automático
                const account = DB.accounts.find(acc => acc.id === operationData.accountId);
                if (account && account.accountType === 'personal') {
                    await createFinanceMovementFromOperation(operationData, account);
                }
                
                toggleAddOperationForm();
                refreshAllViews();
                
                // Actualizar Chartbook explícitamente para mostrar nuevos trades
                if (typeof window.refreshChartbook === 'function') {
                    window.refreshChartbook();
                }

                // Mensaje de confirmación inmediato
                showSyncNotification('✅ Operación guardada exitosamente', 'success');

            } catch (e) {
                console.error("Error saving operation:", e);
                alert("Error al guardar la operación.");
            } finally {
                showLoading(false);
            }
        }

        // === Inject user-provided summary metrics (one-time UI update) ===
        document.addEventListener('DOMContentLoaded', function() {
            try {
                // Values provided by the user
                const provided = {
                    accountDetailPL: '$2,468.43',
                    winRate: '63%',
                    profitFactor: '3.06',
                    totalTrades: '83',
                    totalCommissions: '$11.27'
                };

                const setIfExists = (id, value) => {
                    const el = document.getElementById(id);
                    if (el) el.textContent = value;
                };

                setIfExists('account-detail-pl', provided.accountDetailPL);
                setIfExists('finance-trading-pl', provided.accountDetailPL);
                setIfExists('finance-win-rate', provided.winRate);
                setIfExists('account-detail-pf', provided.profitFactor);
                setIfExists('account-detail-trades', provided.totalTrades);
                setIfExists('finance-total-expenses', provided.totalCommissions);
            } catch (e) {
                console.error('Error applying provided summary metrics:', e);
            }
        });

        function initOperations() {
            updateAccountSelect('op-account');
            updateAccountSelect('filter-account');

            document.getElementById('add-operation-btn').addEventListener('click', () => toggleAddOperationForm());
            document.getElementById('op-cancel').addEventListener('click', () => toggleAddOperationForm());
            document.getElementById('op-save').addEventListener('click', saveOperation);
            document.getElementById('filter-account').addEventListener('change', function() {
                const selectedAccount = this.value;
                syncAccountSelection(selectedAccount);
                refreshOperationsTable();
            });
            document.getElementById('filter-instrument').addEventListener('input', refreshOperationsTable);

            // NUEVO: Listener para ordenar la tabla
            document.querySelector('#operations-table-render thead').addEventListener('click', (event) => {
                const header = event.target.closest('th');
                if (!header || !header.dataset.sort) return;

                const column = header.dataset.sort;
                if (operationSortState.column === column) {
                    operationSortState.order = operationSortState.order === 'asc' ? 'desc' : 'asc';
                } else {
                    operationSortState.column = column;
                    operationSortState.order = 'desc';
                }
                refreshOperationsTable();
            });

            const winBtn = document.getElementById('op-win-btn');
            const lossBtn = document.getElementById('op-loss-btn');
            winBtn.addEventListener('click', function () {
                winBtn.classList.add('bg-green'); lossBtn.classList.remove('bg-red');
                winBtn.classList.remove('bg-surface-light'); lossBtn.classList.add('bg-surface-light');
                winBtn.dataset.selected = 'true'; lossBtn.dataset.selected = 'false';
            });
            lossBtn.addEventListener('click', function () {
                lossBtn.classList.add('bg-red'); winBtn.classList.remove('bg-green');
                lossBtn.classList.remove('bg-surface-light'); winBtn.classList.add('bg-surface-light');
                winBtn.dataset.selected = 'false'; lossBtn.dataset.selected = 'true';
            });

            const priceInputs = ['op-entry', 'op-exit', 'op-volume', 'op-type', 'op-manual-pl'];
            priceInputs.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.addEventListener('input', autoSelectWinLoss);
                    element.addEventListener('change', autoSelectWinLoss);
                }
            });

            // Auto-detectar sesión basada en hora de entrada
            document.getElementById('op-entry-time').addEventListener('change', autoDetectTradingSession);
            document.getElementById('op-entry-time').addEventListener('blur', autoDetectTradingSession);

            // === Event Listeners para Preferencias ===
            // Botón de guardar preferencias
            const savePreferencesBtn = document.getElementById('save-preferences-btn');
            if (savePreferencesBtn) {
                savePreferencesBtn.addEventListener('click', async function() {
                    this.disabled = true;
                    this.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>Guardando...';
                    
                    const success = await savePreferences();
                    
                    if (success) {
                        this.innerHTML = '<i class="fas fa-check mr-2"></i>Guardado';
                        setTimeout(() => {
                            this.innerHTML = '<i class="fas fa-save mr-2"></i>Guardar Preferencias';
                            this.disabled = false;
                        }, 2000);
                    } else {
                        this.innerHTML = '<i class="fas fa-save mr-2"></i>Guardar Preferencias';
                        this.disabled = false;
                    }
                });
            }

            // Guardar automáticamente cuando cambian los valores
            const autoSavePreferenceFields = [
                'config-show-tooltips',
                'config-animations', 
                'config-timezone',
                'config-date-format',
                'config-currency',
                'notif-weekly-summary',
                'notif-goals',
                'notif-updates'
            ];

            autoSavePreferenceFields.forEach(fieldId => {
                const field = document.getElementById(fieldId);
                if (field) {
                    field.addEventListener('change', async function() {
                        console.log(`💾 Auto-guardando preferencia: ${fieldId}`);
                        await savePreferences();
                    });
                }
            });

            // Cargar preferencias al cargar la página
            setTimeout(() => {
                loadPreferences();
            }, 500);

            document.getElementById('op-manual-pl').addEventListener('input', function () {
                if (this.value.trim() !== "") {
                    const manualPLValue = parseFloat(this.value);
                    if (!isNaN(manualPLValue)) {
                        if (manualPLValue > 0) document.getElementById('op-win-btn').click();
                        else if (manualPLValue < 0) document.getElementById('op-loss-btn').click();
                        else {
                            const winBtn = document.getElementById('op-win-btn');
                            const lossBtn = document.getElementById('op-loss-btn');
                            winBtn.classList.remove('bg-green'); lossBtn.classList.remove('bg-red');
                            winBtn.classList.add('bg-surface-light'); lossBtn.classList.add('bg-surface-light');
                            winBtn.dataset.selected = 'false'; lossBtn.dataset.selected = 'false';
                        }
                    }
                } else {
                    autoSelectWinLoss();
                }
            });

            document.getElementById('op-image').addEventListener('change', handleOpImageSelection);
            document.getElementById('operations-table-render').addEventListener('click', handleOperationsTableClick);
            
            // Inicializar grabadora de voz para notas
            initVoiceRecorder();
            
            // === Event Listeners para las nuevas vistas de operaciones ===
            // Tabs de vistas
            document.querySelectorAll('.operations-view-tab').forEach(tab => {
                tab.addEventListener('click', function() {
                    const viewName = this.dataset.view;
                    window.switchOperationsView(viewName);
                });
            });
            
            // Controles de Heatmap
            const heatmapMetric = document.getElementById('heatmap-metric');
            const heatmapPeriod = document.getElementById('heatmap-period');
            if (heatmapMetric) heatmapMetric.addEventListener('change', window.renderHeatmap);
            if (heatmapPeriod) heatmapPeriod.addEventListener('change', window.renderHeatmap);
            
            // Controles de Instrumento
            const instrumentSort = document.getElementById('instrument-sort');
            const instrumentSearch = document.getElementById('instrument-search');
            if (instrumentSort) instrumentSort.addEventListener('change', window.renderInstrumentView);
            if (instrumentSearch) {
                instrumentSearch.addEventListener('input', debounce(window.renderInstrumentView, 300));
            }
            
            // Controles de Setup
            const setupSort = document.getElementById('setup-sort');
            if (setupSort) setupSort.addEventListener('change', window.renderSetupView);
            
            refreshOperationsTable();
        }

        // Debounce helper para búsqueda
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // ============================================
        // SISTEMA DE GRABACIÓN DE VOZ PARA NOTAS
        // ============================================
        let mediaRecorder = null;
        let audioChunks = [];
        let isRecording = false;

        function initVoiceRecorder() {
            const recordBtn = document.getElementById('op-voice-record-btn');
            if (!recordBtn) return;

            recordBtn.addEventListener('click', async function() {
                if (!isRecording) {
                    await startVoiceRecording();
                } else {
                    stopVoiceRecording();
                }
            });
        }

        async function startVoiceRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);
                audioChunks = [];
                
                mediaRecorder.addEventListener('dataavailable', event => {
                    audioChunks.push(event.data);
                });

                mediaRecorder.addEventListener('stop', () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        const base64Audio = reader.result;
                        document.getElementById('op-voice-data').value = base64Audio;
                        
                        // Mostrar reproductor
                        const playback = document.getElementById('op-voice-playback');
                        playback.src = base64Audio;
                        playback.style.display = 'block';
                    };
                    reader.readAsDataURL(audioBlob);
                    
                    // Detener todas las pistas de audio
                    stream.getTracks().forEach(track => track.stop());
                });

                mediaRecorder.start();
                isRecording = true;
                
                // Actualizar UI
                const recordBtn = document.getElementById('op-voice-record-btn');
                recordBtn.innerHTML = '<i class="fas fa-stop"></i> Detener Grabación';
                recordBtn.style.background = '#FF0000';
                recordBtn.style.color = 'white';
                
                document.getElementById('op-voice-status').textContent = 'Grabando...';
                
            } catch (error) {
                console.error('Error al acceder al micrófono:', error);
                alert('No se pudo acceder al micrófono. Verifica los permisos.');
            }
        }

        function stopVoiceRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                
                // Restaurar UI
                const recordBtn = document.getElementById('op-voice-record-btn');
                recordBtn.innerHTML = '<i class="fas fa-microphone"></i> Grabar Nota de Voz';
                recordBtn.style.background = '#39FF14';
                recordBtn.style.color = 'black';
                
                document.getElementById('op-voice-status').textContent = 'Nota de voz guardada';
            }
        }


        function handleOpImageSelection(event) {
            const files = event.target.files;
            const MAX_IMAGES = 5;

            for (let i = 0; i < files.length; i++) {
                if (currentEditingOpImages.length >= MAX_IMAGES) {
                    alert(`Puedes adjuntar un máximo de ${MAX_IMAGES} imágenes.`);
                    break;
                }
                const file = files[i];
                if (!['image/png', 'image/jpeg', 'image/jpg'].includes(file.type)) {
                    alert('Formato de imagen no válido. Por favor, selecciona PNG, JPG o JPEG.');
                    continue;
                }
                const maxSizeMB = 2;
                if (file.size > maxSizeMB * 1024 * 1024) {
                    alert(`La imagen "${file.name}" es demasiado grande (Máx: ${maxSizeMB}MB).`);
                    continue;
                }

                const reader = new FileReader();
                reader.onload = function (e) {
                    if (currentEditingOpImages.length < MAX_IMAGES) {
                        currentEditingOpImages.push(e.target.result);
                        renderOpImagePreviews();
                    }
                }
                reader.onerror = function () { alert(`Error al leer la imagen "${file.name}".`); }
                reader.readAsDataURL(file);
            }
            event.target.value = null;
        }

        function renderOpImagePreviews() {
            const container = document.getElementById('op-image-previews-container');
            container.innerHTML = '';
            currentEditingOpImages.forEach((imageDataUrl, index) => {
                const previewItem = document.createElement('div');
                previewItem.className = 'op-image-preview-item h-20 w-full';
                previewItem.innerHTML = `
                    <img src="${imageDataUrl}" alt="Preview ${index + 1}" class="object-cover h-full w-full">
                    <button type="button" class="op-image-remove-btn" data-index="${index}">&times;</button>
                `;
                container.appendChild(previewItem);
            });

            container.querySelectorAll('.op-image-remove-btn').forEach(button => {
                button.addEventListener('click', function () {
                    const indexToRemove = parseInt(this.dataset.index);
                    currentEditingOpImages.splice(indexToRemove, 1);
                    renderOpImagePreviews();
                });
            });
        }


        function autoSelectWinLoss() {
            const entryPrice = parseFloat(document.getElementById('op-entry').value);
            const exitPrice = parseFloat(document.getElementById('op-exit').value);
            const type = document.getElementById('op-type').value;
            const manualPL = document.getElementById('op-manual-pl').value;

            if (manualPL.trim() !== "") return;

            const winBtn = document.getElementById('op-win-btn');
            const lossBtn = document.getElementById('op-loss-btn');

            if (isNaN(entryPrice) || isNaN(exitPrice) || entryPrice === 0 || exitPrice === 0) {
                winBtn.classList.remove('bg-green'); lossBtn.classList.remove('bg-red');
                winBtn.classList.add('bg-surface-light'); lossBtn.classList.add('bg-surface-light');
                winBtn.dataset.selected = 'false'; lossBtn.dataset.selected = 'false';
                return;
            }

            let isWin = false;
            if (type === 'buy' && exitPrice > entryPrice) isWin = true;
            else if (type === 'sell' && entryPrice > exitPrice) isWin = true;

            if (entryPrice === exitPrice) {
                winBtn.classList.remove('bg-green'); lossBtn.classList.remove('bg-red');
                winBtn.classList.add('bg-surface-light'); lossBtn.classList.add('bg-surface-light');
                winBtn.dataset.selected = 'false'; lossBtn.dataset.selected = 'false';
                return;
            }

            if (isWin) winBtn.click();
            else lossBtn.click();
        }

        // Función para detectar sesión automáticamente basada en la hora
        function autoDetectTradingSession() {
            const entryTimeInput = document.getElementById('op-entry-time');
            const sessionSelect = document.getElementById('op-session');
            
            if (!entryTimeInput.value) {
                // Si no hay hora, limpiar la sesión
                sessionSelect.disabled = false;
                sessionSelect.value = '';
                sessionSelect.disabled = true;
                return;
            }
            
            const time = entryTimeInput.value; // formato "HH:MM"
            const detectedSession = detectTradingSession(time);
            
            // Habilitar temporalmente para actualizar el valor
            sessionSelect.disabled = false;
            sessionSelect.value = detectedSession || '';
            sessionSelect.disabled = true;
            
            console.log(`🕐 Sesión auto-detectada: ${detectedSession} (hora: ${time})`);
        }

        function toggleAddOperationForm(operationToEdit = null) {
            const formContainer = document.getElementById('add-operation-form');
            const isVisible = formContainer.style.display === 'block';
            const imageInput = document.getElementById('op-image');
            const manualPLInput = document.getElementById('op-manual-pl');
            currentEditingOpImages = [];

            if (!isVisible) {
                formContainer.style.display = 'block';
                document.getElementById('add-operation-btn').textContent = 'Ocultar Formulario';
                document.getElementById('operation-details-form').reset();

                // Populate setup dropdown usando la función centralizada
                if (typeof window.updateAllSetupDropdowns === 'function') {
                    window.updateAllSetupDropdowns();
                } else {
                    // Fallback si la función no está disponible
                    const setupSelect = document.getElementById('op-setup');
                    setupSelect.innerHTML = '<option value="">Ninguno</option>';
                    if (DB.setups && DB.setups.length > 0) {
                        DB.setups.forEach(setup => {
                            const option = document.createElement('option');
                            option.value = setup.id;
                            option.textContent = setup.name;
                            setupSelect.appendChild(option);
                        });
                    }
                }

                if (operationToEdit) {
                    formContainer.querySelector('h3').textContent = 'Editar Operación';
                    document.getElementById('op-date').value = operationToEdit.date;
                    document.getElementById('op-account').value = operationToEdit.accountId;
                    document.getElementById('op-instrument').value = operationToEdit.instrument;
                    document.getElementById('op-type').value = operationToEdit.type;
                    document.getElementById('op-entry').value = operationToEdit.entry;
                    document.getElementById('op-exit').value = operationToEdit.exit;
                    document.getElementById('op-entry-time').value = operationToEdit.entryTime || '';
                    document.getElementById('op-exit-time').value = operationToEdit.exitTime || '';
                    document.getElementById('op-volume').value = operationToEdit.volume;
                    document.getElementById('op-currency').value = operationToEdit.currency;
                    document.getElementById('op-notes').value = operationToEdit.notes;
                    
                    // Cargar y auto-detectar sesión basada en la hora de entrada
                    const sessionSelect = document.getElementById('op-session');
                    sessionSelect.disabled = false;
                    sessionSelect.value = operationToEdit.session || detectTradingSession(operationToEdit.entryTime) || '';
                    sessionSelect.disabled = true;
                    document.getElementById('op-setup').value = operationToEdit.setupId || operationToEdit.setupUsed || ''; // Cargar campo Setup
                    manualPLInput.value = operationToEdit.manualPL !== null && typeof operationToEdit.manualPL !== 'undefined' ? operationToEdit.manualPL : '';

                    // Cargar nota de voz si existe
                    if (operationToEdit.voiceNote) {
                        document.getElementById('op-voice-data').value = operationToEdit.voiceNote;
                        const playback = document.getElementById('op-voice-playback');
                        playback.src = operationToEdit.voiceNote;
                        playback.style.display = 'block';
                        document.getElementById('op-voice-status').textContent = 'Nota de voz guardada';
                    } else {
                        document.getElementById('op-voice-data').value = '';
                        document.getElementById('op-voice-playback').style.display = 'none';
                        document.getElementById('op-voice-status').textContent = '';
                    }

                    if (operationToEdit.imageDatas && Array.isArray(operationToEdit.imageDatas)) {
                        currentEditingOpImages = [...operationToEdit.imageDatas];
                    }
                    renderOpImagePreviews();
                    imageInput.value = '';

                    if (operationToEdit.result === 'win') document.getElementById('op-win-btn').click();
                    else if (operationToEdit.result === 'loss') document.getElementById('op-loss-btn').click();
                    else {
                        const winBtn = document.getElementById('op-win-btn'); const lossBtn = document.getElementById('op-loss-btn');
                        winBtn.classList.remove('bg-green'); lossBtn.classList.remove('bg-red');
                        winBtn.classList.add('bg-surface-light'); lossBtn.classList.add('bg-surface-light');
                        winBtn.dataset.selected = 'false'; lossBtn.dataset.selected = 'false';
                    }
                    formContainer.dataset.editingId = operationToEdit.id;
                } else {
                    formContainer.querySelector('h3').textContent = 'Nueva Operación';
                    document.getElementById('op-date').value = getLocalDateString(new Date());
                    document.getElementById('op-account').value = DB.accounts.length > 0 ? DB.accounts[0].id : '';
                    document.getElementById('op-currency').value = DB.settings.defaultCurrency;
                    
                    // Limpiar y preparar campo Sesión (se auto-detectará)
                    const sessionSelect = document.getElementById('op-session');
                    sessionSelect.disabled = false;
                    sessionSelect.value = '';
                    sessionSelect.disabled = true;
                    
                    document.getElementById('op-setup').value = ''; // Limpiar campo Setup
                    
                    // Auto-establecer hora de entrada actual y detectar sesión
                    const currentTime = new Date().toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit', hour12: false });
                    document.getElementById('op-entry-time').value = currentTime;
                    autoDetectTradingSession();
                    
                    // Limpiar nota de voz
                    document.getElementById('op-voice-data').value = '';
                    document.getElementById('op-voice-playback').style.display = 'none';
                    document.getElementById('op-voice-status').textContent = '';
                    
                    renderOpImagePreviews();
                    imageInput.value = '';
                    manualPLInput.value = '';
                    const winBtn = document.getElementById('op-win-btn'); const lossBtn = document.getElementById('op-loss-btn');
                    winBtn.classList.remove('bg-green'); lossBtn.classList.remove('bg-red');
                    winBtn.classList.add('bg-surface-light'); lossBtn.classList.add('bg-surface-light');
                    winBtn.dataset.selected = 'false'; lossBtn.dataset.selected = 'false';
                    delete formContainer.dataset.editingId;
                }
                autoSelectWinLoss();
                formContainer.scrollIntoView({ behavior: 'smooth' });
            } else {
                formContainer.style.display = 'none';
                document.getElementById('add-operation-btn').innerHTML = '<i class="fas fa-plus mr-2"></i>Añadir Operación';
                delete formContainer.dataset.editingId;
                currentEditingOpImages = [];
                renderOpImagePreviews();
                imageInput.value = '';
                manualPLInput.value = '';
                document.getElementById('operation-details-form').reset();
            }
        }

        // ============================================
        // FUNCIONES DE MÉTRICAS DE OPERACIONES
        // ============================================

        function updateOperationsMetrics() {
            try {
                // Validar que DB.operations esté inicializado
                if (!DB || !DB.operations) {
                    console.log('DB.operations no está inicializado aún');
                    return;
                }

                // Obtener operaciones filtradas actual
                let operations = [...DB.operations];

                // Aplicar filtros actuales
                const accountFilter = document.getElementById('filter-account')?.value;
                const instrumentFilter = document.getElementById('filter-instrument')?.value?.toLowerCase();

                if (accountFilter && accountFilter !== 'all') {
                    operations = operations.filter(op => op.accountId === accountFilter);
                }

                if (instrumentFilter) {
                    operations = operations.filter(op =>
                        op.instrument && op.instrument.toLowerCase().includes(instrumentFilter)
                    );
                }

                // Aplicar filtro de fecha global
                if (globalDateFilter && globalDateFilter.type !== 'all' && globalDateFilter.startDate && globalDateFilter.endDate) {
                    operations = operations.filter(op => {
                        return op.date >= globalDateFilter.startDate && op.date <= globalDateFilter.endDate;
                    });
                }

                // Aplicar filtros personalizados de Operations
                operations = applyOperationsFilters(operations);

                // Calcular métricas
                const metrics = calculateOperationsMetrics(operations);

                // Actualizar UI
                updateMetricsUI(metrics);

                // Actualizar gráfico de P&L acumulado
                updateCumulativePLChart(operations);

            } catch (error) {
                console.error('Error actualizando métricas:', error);
            }
        }

        function calculateOperationsMetrics(operations) {
            const metrics = {
                totalOperations: 0,
                cumulativePL: 0,
                cumulativePLNet: 0,
                totalFees: 0,
                roi: 0,
                grossWin: 0,
                grossLoss: 0,
                profitFactor: 0,
                wins: 0,
                losses: 0,
                winRate: 0
            };

            if (operations.length === 0) return metrics;

            // AGRUPAR por ID: 1 trade = 1 grupo (parciales juntas)
            const groupedOps = {};
            
            operations.forEach(op => {
                const opId = op.id;
                
                if (!groupedOps[opId]) {
                    groupedOps[opId] = {
                        id: opId,
                        totalPL: 0,
                        totalFees: 0
                    };
                }
                
                // SUMAR P&L de todas las parciales
                groupedOps[opId].totalPL += (op.manualPL || op.pl || 0);
                // Soportar tanto 'fee' como 'fees' (ambos campos existen en diferentes importaciones)
                groupedOps[opId].totalFees += (op.fee || op.fees || 0);
            });

            const uniqueTrades = Object.values(groupedOps);
            metrics.totalOperations = uniqueTrades.length;

            // Calcular métricas por TRADE COMPLETO
            uniqueTrades.forEach(trade => {
                const pl = trade.totalPL;
                const fee = trade.totalFees;
                
                metrics.cumulativePL += pl;
                metrics.totalFees += fee;
                
                // Win/Loss basado en resultado FINAL del trade
                if (pl > 0) {
                    metrics.grossWin += pl;
                    metrics.wins++;
                } else if (pl < 0) {
                    metrics.grossLoss += Math.abs(pl);
                    metrics.losses++;
                }
            });
            
            // P&L neto después de comisiones
            metrics.cumulativePLNet = metrics.cumulativePL - metrics.totalFees;

            // Calcular Profit Factor
            if (metrics.grossLoss > 0) {
                metrics.profitFactor = metrics.grossWin / metrics.grossLoss;
            } else if (metrics.grossWin > 0) {
                metrics.profitFactor = 999; // Infinito (solo ganancias)
            }

            // Calcular Win Rate
            const totalTrades = metrics.wins + metrics.losses;
            if (totalTrades > 0) {
                metrics.winRate = (metrics.wins / totalTrades) * 100;
            }

            // Calcular ROI (necesitamos capital inicial de la cuenta)
            // Por ahora lo dejamos en 0, se puede calcular después con datos de cuenta

            return metrics;
        }

        function updateMetricsUI(metrics) {
            // P&L Bruto Total
            const cumulativePLEl = document.getElementById('ops-cumulative-pl');
            if (cumulativePLEl) {
                cumulativePLEl.textContent = formatCurrency(metrics.cumulativePL);
                cumulativePLEl.className = metrics.cumulativePL >= 0 ?
                    'text-3xl font-bold text-success' :
                    'text-3xl font-bold text-danger';
            }

            // Total Fees
            const totalFeesEl = document.getElementById('ops-total-fees');
            if (totalFeesEl) {
                totalFeesEl.textContent = formatCurrency(metrics.totalFees);
            }

            // P&L Neto (después de comisiones)
            const netPLEl = document.getElementById('ops-net-pl');
            if (netPLEl) {
                netPLEl.textContent = formatCurrency(metrics.cumulativePLNet);
                netPLEl.className = metrics.cumulativePLNet >= 0 ?
                    'font-semibold text-success' :
                    'font-semibold text-danger';
            }

            // Profit Factor
            const pfEl = document.getElementById('ops-profit-factor');
            if (pfEl) {
                pfEl.textContent = metrics.profitFactor.toFixed(2);
                // Color según valor: <1 rojo, 1-2 amarillo, >2 verde
                let pfClass = 'text-3xl font-bold ';
                if (metrics.profitFactor < 1) pfClass += 'text-danger';
                else if (metrics.profitFactor < 2) pfClass += 'text-warning';
                else pfClass += 'text-success';
                pfEl.className = pfClass;
            }

            // Profit Factor Gauge
            const pfGaugeEl = document.getElementById('ops-pf-gauge');
            if (pfGaugeEl) {
                // Escala: 0 = 0%, 1 = 33%, 2 = 66%, 3+ = 100%
                let percentage = 0;
                if (metrics.profitFactor >= 3) percentage = 100;
                else if (metrics.profitFactor >= 2) percentage = 66 + (metrics.profitFactor - 2) * 34;
                else if (metrics.profitFactor >= 1) percentage = 33 + (metrics.profitFactor - 1) * 33;
                else percentage = metrics.profitFactor * 33;

                pfGaugeEl.style.width = Math.min(percentage, 100) + '%';
            }

            // Gross Win
            const grossWinEl = document.getElementById('ops-gross-win');
            if (grossWinEl) {
                grossWinEl.textContent = formatCurrency(metrics.grossWin);
            }

            // Win Rate
            const winRateEl = document.getElementById('ops-win-rate');
            if (winRateEl) {
                winRateEl.textContent = metrics.winRate.toFixed(1) + '%';
            }

            // Win Circle (donut chart)
            const winCircleEl = document.getElementById('ops-win-circle');
            if (winCircleEl) {
                const dashArray = `${metrics.winRate}, 100`;
                winCircleEl.setAttribute('stroke-dasharray', dashArray);

                // Color según win rate: <40% rojo, 40-60% amarillo, >60% verde
                let strokeColor = '#ef4444'; // rojo
                if (metrics.winRate >= 60) strokeColor = '#22c55e'; // verde
                else if (metrics.winRate >= 40) strokeColor = '#eab308'; // amarillo

                winCircleEl.setAttribute('stroke', strokeColor);
            }

            // Win text en el centro del donut
            const winTextEl = document.getElementById('ops-win-text');
            if (winTextEl) {
                winTextEl.textContent = metrics.winRate.toFixed(0) + '%';
            }

            // Total Wins y Losses
            const totalWinsEl = document.getElementById('ops-total-wins');
            if (totalWinsEl) totalWinsEl.textContent = metrics.wins;

            const totalLossesEl = document.getElementById('ops-total-losses');
            if (totalLossesEl) totalLossesEl.textContent = metrics.losses;
        }

        let operationsMetricsChart = null;

        function updateCumulativePLChart(operations) {
            const chartCanvas = document.getElementById('ops-cumulative-chart');
            if (!chartCanvas) {
                console.log('Canvas ops-cumulative-chart no encontrado');
                return;
            }

            // Verificar si Chart.js está disponible
            if (typeof Chart === 'undefined') {
                console.error('Chart.js no está cargado');
                return;
            }

            // Ordenar operaciones por fecha
            const sortedOps = [...operations].sort((a, b) =>
                new Date(a.date) - new Date(b.date)
            );

            // Calcular P&L acumulado
            let cumulative = 0;
            const chartData = sortedOps.map(op => {
                cumulative += op.manualPL || op.pl || 0;
                return {
                    date: op.date,
                    cumulative: cumulative
                };
            });

            // Si no hay datos, mostrar gráfico vacío
            if (chartData.length === 0) {
                chartData.push({ date: new Date().toISOString().split('T')[0], cumulative: 0 });
            }

            // Destruir gráfico anterior si existe
            if (operationsMetricsChart) {
                operationsMetricsChart.destroy();
            }

            // Crear nuevo gráfico
            const ctx = chartCanvas.getContext('2d');
            operationsMetricsChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: chartData.map(d => d.date),
                    datasets: [{
                        label: 'P&L Acumulado',
                        data: chartData.map(d => d.cumulative),
                        borderColor: cumulative >= 0 ? '#10b981' : '#ef4444',
                        backgroundColor: cumulative >= 0 ?
                            'rgba(16, 185, 129, 0.1)' :
                            'rgba(239, 68, 68, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 0,
                        pointHoverRadius: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    return formatCurrency(context.parsed.y);
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            display: false
                        },
                        y: {
                            display: false
                        }
                    },
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    }
                }
            });
        }

        window.refreshAllViews = function refreshAllViews() {
            const activeTabElement = document.querySelector('.nav-tab.active');
            if (!activeTabElement) return;
            const activeTabId = activeTabElement.dataset.target;

            // Actualizar TODOS los selectores de cuentas primero
            const allSelectors = [
                'dashboard-account-select',
                'new-dashboard-account-select',
                'analytics-account-select',
                'equity-account-select',
                'daily-journal-account-select',
                'calendar-account-select',
                'informe-account-select',
                'op-account',
                'filter-account',
                'chartbook-account-select',
                'bingx-account',
                'bitget-account-detail',
                'mexc-account-detail'
            ];
            
            allSelectors.forEach(selectorId => {
                updateAccountSelect(selectorId);
            });

            // Asegurarse de que la sección de detalles de operación se oculte si se cambia de pestaña
            if (activeTabId !== 'operation-detail-page') {
                document.getElementById('operation-detail-page').classList.remove('active');
            }

            if (activeTabId === 'dashboard') refreshNewDashboard();
            else if (activeTabId === 'analytics') refreshAnalytics();
            else if (activeTabId === 'equity-graph') {
                if (typeof refreshEquityGraph === 'function') refreshEquityGraph();
            }
            else if (activeTabId === 'finances') refreshFinancesView();
            else if (activeTabId === 'informe') {
                // Siempre activar y refrescar la subsección de Informes al hacer clic en la sección principal
                const informesTab = document.querySelector('.informe-sub-tab[data-target="informe-informes-content"]');
                const informesContent = document.getElementById('informe-informes-content');
                
                if (informesTab && informesContent) {
                    // Desactivar todas las subsecciones
                    document.querySelectorAll('.informe-sub-tab').forEach(tab => tab.classList.remove('active'));
                    document.querySelectorAll('.informe-sub-section-container').forEach(content => content.classList.remove('active'));
                    
                    // Activar subsección de Informes
                    informesTab.classList.add('active');
                    informesContent.classList.add('active');
                    
                    // Refrescar los datos
                    setTimeout(() => {
                        if (typeof refreshInforme === 'function') {
                            refreshInforme();
                        }
                    }, 50);
                }
            }
            else if (activeTabId === 'calendar') {
                // Ensure calendar is fully rendered when tab is switched to
                setTimeout(() => updateCalendar(), 50);
            }
            else if (activeTabId === 'operations') refreshOperationsTable();
            else if (activeTabId === 'accounts') refreshAccountsView();
            else if (activeTabId === 'chartbook') {
                if (typeof window.refreshChartbook === 'function') {
                    window.refreshChartbook();
                }
            }
            else if (activeTabId === 'playbook') {
                if (typeof refreshPlaybook === 'function') refreshPlaybook();
            }
            // operation-detail-page no se refresca automáticamente desde aquí, solo cuando se invoca directamente

            if (document.getElementById('selected-account-details')?.style.display === 'block' && document.getElementById('selected-account-details').dataset.accountId) {
                showAccountDetails(document.getElementById('selected-account-details').dataset.accountId);
            }
        }

        function refreshActiveInformeSubTab() {
            const activeSubTab = document.querySelector('#informe .informe-sub-tab.active');
            if (!activeSubTab) return;

            const targetId = activeSubTab.dataset.target;
            console.log(`[Informe] Refreshing active sub-tab: ${targetId}`);

            switch (targetId) {
                case 'informe-informes-content':
                    refreshInforme();
                    break;
                case 'informe-metricas-content':
                    refreshMetricas();
                    break;
                case 'informe-metricas-avanzadas-content':
                    refreshMetricasAvanzadas();
                    break;
                case 'informe-simbolos-content':
                    refreshSimbolos();
                    break;
                case 'informe-tiempo-content':
                    refreshTiempo();
                    break;
                case 'informe-graficos-content':
                    if (typeof window.refreshGraficosCharts === 'function') {
                        window.refreshGraficosCharts();
                    }
                    break;
                case 'informe-comisiones-content':
                    if (typeof window.refreshComisiones === 'function') {
                        window.refreshComisiones();
                    }
                    break;
            }
        }

        async function handleOperationsTableClick(event) {
            const target = event.target;
            const buttonElement = target.closest('button');
            if (!buttonElement) {
                return;
            }
            const operationId = buttonElement.dataset.id;
            if (!operationId) return;

            if (buttonElement.classList.contains('delete-op-btn')) {
                // Eliminar directamente sin confirmación
                showLoading(true);
                try {
                    await dexieDB.operations.delete(operationId);
                    // Eliminar de Supabase
                    await deleteOperationFromSupabase(operationId);
                    DB.operations = DB.operations.filter(op => op.id !== operationId);
                    updateAccountBalances();
                    
                    // Refrescar todas las vistas inmediatamente
                    refreshDashboard();
                    refreshAnalytics();
                    refreshAccountsView();
                    
                    // Actualizar Chartbook explícitamente
                    if (typeof window.refreshChartbook === 'function') {
                        window.refreshChartbook();
                    }
                    
                    // Actualizar Equity Graph
                    if (typeof window.refreshEquityGraph === 'function') {
                        window.refreshEquityGraph();
                    }
                    
                    console.log(`✅ Operación ${operationId} eliminada correctamente`);
                } catch (e) {
                    console.error("Error deleting operation:", e); 
                    alert("Error al eliminar la operación.");
                } finally { 
                    showLoading(false); 
                }
            } else if (buttonElement.classList.contains('setup-op-btn')) {
                openAssignSetupModal(operationId);
            } else if (buttonElement.classList.contains('edit-op-btn')) {
                const operationToEdit = DB.operations.find(op => op.id === operationId);
                if (operationToEdit) toggleAddOperationForm(operationToEdit);
            } else if (buttonElement.classList.contains('chart-op-btn')) {
                const operationToChart = DB.operations.find(op => op.id === operationId);
                if (operationToChart) {
                    showOperationDetailPage(operationToChart.id);
                    setTimeout(() => {
                        if (window.showTradingChart) {
                            window.showTradingChart(operationToChart);
                        }
                    }, 500);
                }
            }
        }

        async function refreshOperationsTable() {
            const operationsSection = document.getElementById('operations');
            if (!operationsSection || !operationsSection.classList.contains('active')) {
                return;
            }

            const tableBody = document.getElementById('operations-table');
            const tableHeaders = document.querySelectorAll('#operations-table-render th[data-sort]');
            if (!tableBody) {
                console.error("Operations table body not found during refresh.");
                return;
            }

            const accountFilter = document.getElementById('filter-account').value;
            const instrumentFilter = document.getElementById('filter-instrument').value.toLowerCase().trim();

            tableBody.innerHTML = '';

            // Definir filteredOperations correctamente
            let filteredOperations = applyDateFilterToData(DB.operations);
            
            // Aplicar filtros de cuenta e instrumento (filtros básicos)
            filteredOperations = filteredOperations.filter(op =>
                (accountFilter === 'all' || op.accountId === accountFilter) &&
                (!instrumentFilter || op.instrument.toLowerCase().includes(instrumentFilter))
            );
            
            // 🎯 Aplicar filtros personalizados del sidebar
            filteredOperations = applyOperationsFilters(filteredOperations);

            // Agrupar operaciones por ID en lugar de parentId
            const groupedOps = {};
            filteredOperations.forEach(op => {
                const opId = op.id;
                if (!groupedOps[opId]) {
                    groupedOps[opId] = {
                        mainOp: op,
                        partials: [],
                        totalPL: 0
                    };
                }
                
                // Si es la primera operación de este ID, la tomamos como principal
                // Las siguientes se agregan como parciales
                if (groupedOps[opId].partials.length === 0 && groupedOps[opId].mainOp === op) {
                    // Es la operación principal
                } else {
                    groupedOps[opId].partials.push(op);
                }
                groupedOps[opId].totalPL += op.pl;
            });

            const mainOps = Object.values(groupedOps).map(group => group.mainOp);

            // Ordenar principales
            const sortColumn = operationSortState.column;
            const sortOrder = operationSortState.order;
            mainOps.sort((a, b) => {
                let valA = a[sortColumn];
                let valB = b[sortColumn];
                if (sortColumn === 'accountId') {
                    valA = DB.accounts.find(acc => acc.id === valA)?.name || '';
                    valB = DB.accounts.find(acc => acc.id === valB)?.name || '';
                }
                if (typeof valA === 'string') {
                    valA = valA.toLowerCase();
                    valB = valB.toLowerCase();
                }
                if (valA === null || valA === undefined) return 1;
                if (valB === null || valB === undefined) return -1;
                if (valA < valB) return sortOrder === 'asc' ? -1 : 1;
                if (valA > valB) return sortOrder === 'asc' ? 1 : -1;
                return 0;
            });

            tableHeaders.forEach(th => {
                th.classList.remove('sorted', 'asc', 'desc');
                if (th.dataset.sort === sortColumn) {
                    th.classList.add('sorted', sortOrder);
                }
            });

            mainOps.forEach(op => {
                const account = DB.accounts.find(acc => acc.id === op.accountId);
                const accountName = account ? account.name : 'Desconocida';
                
                // Obtener el nombre del setup si existe
                const setupId = op.setupId || op.setupUsed;
                const setup = setupId ? DB.setups.find(s => s.id === setupId) : null;
                const setupName = setup ? setup.name : '-';
                
                // Obtener el grupo de operaciones para este ID
                const group = groupedOps[op.id];
                const parciales = group.partials;
                const totalPL = group.totalPL;
                
                // Determinar resultado y clase basado en P&L total del grupo
                let resultText, resultClass, plClass;
                if (totalPL > 0) { 
                    resultText = 'Ganancia'; 
                    resultClass = 'text-positive'; 
                    plClass = 'text-positive';
                } else if (totalPL < 0) { 
                    resultText = 'Pérdida'; 
                    resultClass = 'text-negative'; 
                    plClass = 'text-negative';
                } else { 
                    resultText = 'Neutral'; 
                    resultClass = 'text-neutral'; 
                    plClass = 'text-neutral';
                }

                const precision = getInstrumentPrecision(op.instrument);
                const entryDisplay = (typeof op.entry === 'number') ? op.entry.toFixed(precision) : '-';
                
                // Determinar precio y hora de salida
                let exitTime = op.exitTime || '';
                let exitPrice = op.exit; // Usar el exit de la operación (ya calculado correctamente en el import)
                
                // Si la operación tiene parciales guardados (PrimeXBT Interface), usar el exit ya calculado
                // Si tiene parciales del sistema antiguo (groupedOps), buscar el último
                if (!op.hasPartials && parciales.length > 0) {
                    let ultimo = parciales[0];
                    parciales.forEach(p => {
                        const d1 = new Date((ultimo.date || '') + 'T' + (ultimo.exitTime || '23:59:59'));
                        const d2 = new Date((p.date || '') + 'T' + (p.exitTime || '23:59:59'));
                        if (d2 > d1) ultimo = p;
                    });
                    exitTime = ultimo.exitTime || '';
                    exitPrice = ultimo.exit;
                }

                const exitDisplay = (typeof exitPrice === 'number') ? exitPrice.toFixed(precision) : '-';

                const row = tableBody.insertRow();
                row.dataset.id = op.id;
                row.classList.add('cursor-pointer', 'main-operation-row');
                row.onclick = (e) => {
                    // Solo abrir detalles si NO se hizo clic en un botón
                    if (!e.target.closest('button')) {
                        window.showOperationDetailPage(op.id);
                    }
                };
                row.title = "Click para ver detalles";
                row.innerHTML = `
                    <td title="${formatDate(op.date)}">${formatDate(op.date)}</td>
                    <td>${op.entryTime || '-'}</td>
                    <td>${exitTime || '-'}</td>
                    <td title="${accountName}">${accountName}</td>
                    <td title="${op.instrument}">${op.instrument}</td>
                    <td>${op.type === 'buy' ? 'Compra' : 'Venta'}</td>
                    <td>${entryDisplay}</td>
                    <td>${exitDisplay}</td>
                    <td>${op.volume}</td>
                    <td class="${resultClass}">${resultText}</td>
                    <td class="${plClass} hide-amount">${formatCurrency(totalPL, op.currency, op.currency)}</td>
                    <td class="hide-amount">${op.fees ? formatCurrency(op.fees, op.currency, op.currency) : '-'}</td>
                    <td>${op.currency}</td>
                    <td title="${op.session || 'No especificado'}">${op.session || '-'}</td>
                    <td class="text-center">
                        <button class="text-primary setup-op-btn" data-id="${op.id}" title="Asignar Setup">
                            ${setupName !== '-' ? '<i class="fas fa-check-circle"></i>' : '<i class="fas fa-plus-circle"></i>'}
                            <span class="text-xs ml-1">${setupName !== '-' ? setupName : 'Setup'}</span>
                        </button>
                    </td>
                    <td class="text-center space-x-1">
                        <button class="text-white edit-op-btn" data-id="${op.id}" title="Editar"><i class="fas fa-edit"></i></button>
                        <button class="text-red-500 delete-op-btn" data-id="${op.id}" title="Eliminar"><i class="fas fa-trash"></i></button>
                    </td>`;

                // Sub-filas para parciales
                parciales.sort((a, b) => {
                    const d1 = new Date((a.date || '') + 'T' + (a.exitTime || '23:59:59'));
                    const d2 = new Date((b.date || '') + 'T' + (b.exitTime || '23:59:59'));
                    return d1 - d2;
                });
                parciales.forEach(parcial => {
                    const pAccount = DB.accounts.find(acc => acc.id === parcial.accountId);
                    const pAccountName = pAccount ? pAccount.name : 'Desconocida';
                    const pPlClass = parcial.pl > 0 ? 'text-positive' : parcial.pl < 0 ? 'text-negative' : 'text-neutral';
                    let pResultText, pResultClass;
                    if (parcial.result === 'win') { pResultText = 'Ganancia'; pResultClass = 'text-positive'; }
                    else if (parcial.result === 'loss') { pResultText = 'Pérdida'; pResultClass = 'text-negative'; }
                    else { pResultText = 'Neutral'; pResultClass = 'text-neutral'; }
                    const pPrecision = getInstrumentPrecision(parcial.instrument);
                    const pEntryDisplay = parcial.entry !== null ? parcial.entry.toFixed(pPrecision) : '-';
                    const pExitDisplay = parcial.exit !== null ? parcial.exit.toFixed(pPrecision) : '-';
                    const pRow = tableBody.insertRow();
                    pRow.classList.add('parcial-row');
                    pRow.innerHTML = `
                        <td style="padding-left:2em;">${formatDate(parcial.date)}</td>
                        <td>${parcial.entryTime || '-'}</td>
                        <td>${parcial.exitTime || '-'}</td>
                        <td title="${pAccountName}">${pAccountName}</td>
                        <td title="${parcial.instrument}">${parcial.instrument}</td>
                        <td>${parcial.type === 'buy' ? 'Compra' : 'Venta'}</td>
                        <td>${pEntryDisplay}</td>
                        <td>${pExitDisplay}</td>
                        <td>${parcial.volume}</td>
                        <td class="${pResultClass}">${pResultText}</td>
                        <td class="${pPlClass} hide-amount">${formatCurrency(parcial.pl, parcial.currency, parcial.currency)}</td>
                        <td class="hide-amount">${parcial.fees ? formatCurrency(parcial.fees, parcial.currency, parcial.currency) : '-'}</td>
                        <td>${parcial.currency}</td>
                        <td title="${parcial.session || 'No especificado'}">${parcial.session || '-'}</td>
                        <td class="text-center">-</td>
                        <td class="text-center space-x-1">
                            <button class="text-white edit-op-btn" data-id="${parcial.id}" title="Editar"><i class="fas fa-edit"></i></button>
                            <button class="text-red delete-op-btn" data-id="${parcial.id}" title="Eliminar"><i class="fas fa-trash"></i></button>
                        </td>`;
                });
            });


            // Añade un nuevo event listener para las filas principales y parciales después de que se renderizan
            tableBody.querySelectorAll('tr').forEach(row => {
                row.addEventListener('click', (event) => {
                    if (event.target.closest('.edit-op-btn') || event.target.closest('.delete-op-btn') || event.target.closest('.chart-op-btn')) {
                        return;
                    }
                    const operationId = row.dataset.id;
                    if (operationId) {
                        showOperationDetailPage(operationId);
                    }
                });
            });

            // Actualizar métricas de operaciones
            updateOperationsMetrics();
        }


        function getInstrumentPrecision(instrument) {
            if (!instrument) return 5;
            const instUpper = instrument.toUpperCase();
            // BTC con más decimales para mostrar precios completos (ej: 102.092,2)
            if (instUpper.includes('BTC')) return 4;
            if (instUpper.includes('ETH') || instUpper.includes('XAU') || instUpper.includes('XAG') || instUpper.endsWith('USDT')) return 2;
            if (instUpper.includes('JPY')) return 3;
            if (instUpper.includes('DE40') || instUpper.includes('US30') || instUpper.includes('SPX500') || instUpper.includes('NAS100')) return 1;
            return 5;
        }

        // Función global para abrir modal de imágenes (accesible desde social-media.js)
        function openImageModal(imageList, startIndex = 0) {
            console.log('🖼️ [Platform] openImageModal llamada con:', { 
                imageListLength: imageList?.length, 
                startIndex,
                firstItem: imageList?.[0]?.substring(0, 50) + '...',
                firstItemType: typeof imageList?.[0]
            });
            
            if (!imageList || imageList.length === 0) {
                console.error('❌ No hay imágenes para mostrar');
                return;
            }

            // Validar y limpiar URLs de imágenes
            modalImageList = imageList.map(img => {
                console.log('🔍 [Modal] Procesando img:', typeof img, img);
                if (typeof img === 'string') {
                    console.log('  → Es string, longitud:', img.length);
                    return img;
                } else if (img && typeof img === 'object') {
                    const extracted = img.data || img.url || img.src || '';
                    console.log('  → Es object, extraído:', extracted ? extracted.substring(0, 50) + '...' : 'VACÍO');
                    return extracted;
                }
                console.log('  → Tipo desconocido, retornando vacío');
                return '';
            }).filter(url => {
                // Aceptar base64, http, https, o rutas relativas
                const isValid = url && url.length > 0 && (
                    url.startsWith('data:') || 
                    url.startsWith('http://') || 
                    url.startsWith('https://') ||
                    url.startsWith('/')
                );
                console.log('✅❌ [Modal] ¿URL válida?', isValid, '- Preview:', url ? url.substring(0, 40) : 'null');
                return isValid;
            });
            
            console.log('📊 [Modal] URLs finales después de filtro:', modalImageList.length);
            
            if (modalImageList.length === 0) {
                console.error('❌ No hay URLs de imágenes válidas');
                return;
            }
            
            modalImageIndex = Math.min(startIndex, modalImageList.length - 1);

            const modal = document.getElementById('image-modal');
            const modalImg = document.getElementById('modal-image-content');
            const counter = document.getElementById('image-modal-counter');

            if (!modal || !modalImg) {
                console.error('❌ Elementos del modal no encontrados');
                return;
            }

            modalImg.src = modalImageList[modalImageIndex];
            modalImg.classList.remove('fullscreen');
            modal.style.display = "flex";
            
            // Actualizar contador
            if (counter) {
                counter.textContent = `${modalImageIndex + 1} / ${modalImageList.length}`;
            }
            
            console.log('✅ Modal abierto con imagen:', modalImg.src.substring(0, 50) + '...');

            updateModalNavigation();
        }

        // Exportar con alias para evitar conflictos con social-media.js
        window.platformOpenImageModal = openImageModal;

        function closeImageModal() {
            const modal = document.getElementById('image-modal');
            const modalImg = document.getElementById('modal-image-content');
            if (modal) {
                modal.style.display = "none";
                if (modalImg) {
                    modalImg.src = "";
                    modalImg.classList.remove('fullscreen');
                }
                modalImageList = [];
                modalImageIndex = 0;
            }
        }

        function updateModalNavigation() {
            const prevBtn = document.getElementById('image-modal-prev');
            const nextBtn = document.getElementById('image-modal-next');
            const counter = document.getElementById('image-modal-counter');

            if (prevBtn) prevBtn.style.display = (modalImageIndex > 0) ? 'block' : 'none';
            if (nextBtn) nextBtn.style.display = (modalImageIndex < modalImageList.length - 1) ? 'block' : 'none';
            
            // Actualizar contador
            if (counter) {
                counter.textContent = `${modalImageIndex + 1} / ${modalImageList.length}`;
            }
        }
        
        function toggleImageFullscreen() {
            const modal = document.getElementById('image-modal');
            const modalImg = document.getElementById('modal-image-content');
            const fullscreenBtn = document.getElementById('image-modal-fullscreen-btn');

            if (!modal || !modalImg) return;

            // Check if already in fullscreen (API)
            const isFullscreenAPI = document.fullscreenElement || document.webkitFullscreenElement ||
                                document.mozFullScreenElement || document.msFullscreenElement;

            // Check if already in fullscreen (CSS fallback)
            const isFullscreenCSS = modalImg.classList.contains('fullscreen');

            if (isFullscreenAPI || isFullscreenCSS) {
                // Exit fullscreen
                if (isFullscreenAPI) {
                    const exitPromise =
                        document.exitFullscreen ? document.exitFullscreen() :
                        document.webkitExitFullscreen ? document.webkitExitFullscreen() :
                        document.mozCancelFullScreen ? document.mozCancelFullScreen() :
                        document.msExitFullscreen ? document.msExitFullscreen() :
                        null;

                    if (exitPromise && exitPromise.catch) {
                        exitPromise.catch(err => {
                            console.log('Error al salir de fullscreen:', err);
                        });
                    }
                }
                // Siempre remover clase CSS
                modalImg.classList.remove('fullscreen');
                updateFullscreenButton();
            } else {
                // Enter fullscreen - intentar con la API primero
                let fullscreenRequested = false;

                try {
                    if (modal.requestFullscreen) {
                        modal.requestFullscreen().catch(err => {
                            console.log('Fullscreen API falló, usando CSS:', err);
                            modalImg.classList.add('fullscreen');
                            updateFullscreenButton();
                        });
                        fullscreenRequested = true;
                    } else if (modal.webkitRequestFullscreen) {
                        modal.webkitRequestFullscreen();
                        fullscreenRequested = true;
                    } else if (modal.mozRequestFullScreen) {
                        modal.mozRequestFullScreen();
                        fullscreenRequested = true;
                    } else if (modal.msRequestFullscreen) {
                        modal.msRequestFullscreen();
                        fullscreenRequested = true;
                    }
                } catch (err) {
                    console.log('Error al entrar en fullscreen:', err);
                    fullscreenRequested = false;
                }

                // Si no hay soporte de API, usar fallback CSS
                if (!fullscreenRequested) {
                    console.log('Usando fallback CSS para fullscreen');
                    modalImg.classList.add('fullscreen');
                    updateFullscreenButton();
                }
            }
        }

        // Update fullscreen button icon on fullscreen change
        document.addEventListener('fullscreenchange', updateFullscreenButton);
        document.addEventListener('webkitfullscreenchange', updateFullscreenButton);
        document.addEventListener('mozfullscreenchange', updateFullscreenButton);
        document.addEventListener('msfullscreenchange', updateFullscreenButton);

        function updateFullscreenButton() {
            const fullscreenBtn = document.getElementById('image-modal-fullscreen-btn');
            const modalImg = document.getElementById('modal-image-content');
            const icon = fullscreenBtn?.querySelector('i');

            const isFullscreenAPI = document.fullscreenElement || document.webkitFullscreenElement ||
                                document.mozFullScreenElement || document.msFullscreenElement;

            const isFullscreenCSS = modalImg?.classList.contains('fullscreen');

            const isFullscreen = isFullscreenAPI || isFullscreenCSS;

            if (icon) {
                if (isFullscreen) {
                    icon.className = 'fas fa-compress';
                    fullscreenBtn.title = 'Salir de pantalla completa';
                } else {
                    icon.className = 'fas fa-expand';
                    fullscreenBtn.title = 'Pantalla completa';
                }
            }
        }

        function initImageModal() {
            document.getElementById('image-modal-close-btn').addEventListener('click', closeImageModal);

            document.getElementById('image-modal-prev').addEventListener('click', (e) => {
                e.stopPropagation();
                if (modalImageIndex > 0) {
                    modalImageIndex--;
                    document.getElementById('modal-image-content').src = modalImageList[modalImageIndex];
                    updateModalNavigation();
                }
            });

            document.getElementById('image-modal-next').addEventListener('click', (e) => {
                e.stopPropagation();
                if (modalImageIndex < modalImageList.length - 1) {
                    modalImageIndex++;
                    document.getElementById('modal-image-content').src = modalImageList[modalImageIndex];
                    updateModalNavigation();
                }
            });
            
            // Botón de pantalla completa
            document.getElementById('image-modal-fullscreen-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                toggleImageFullscreen();
            });
            
            // Click en la imagen para pantalla completa
            document.getElementById('modal-image-content').addEventListener('click', (e) => {
                e.stopPropagation();
                toggleImageFullscreen();
            });
            
            // Navegación con teclado
            document.addEventListener('keydown', (e) => {
                const modal = document.getElementById('image-modal');
                if (modal && modal.style.display === 'flex') {
                    if (e.key === 'ArrowLeft' && modalImageIndex > 0) {
                        modalImageIndex--;
                        document.getElementById('modal-image-content').src = modalImageList[modalImageIndex];
                        updateModalNavigation();
                    } else if (e.key === 'ArrowRight' && modalImageIndex < modalImageList.length - 1) {
                        modalImageIndex++;
                        document.getElementById('modal-image-content').src = modalImageList[modalImageIndex];
                        updateModalNavigation();
                    } else if (e.key === 'Escape') {
                        closeImageModal();
                    } else if (e.key === 'f' || e.key === 'F') {
                        toggleImageFullscreen();
                    }
                }
            });
        }

        function initAccounts() {
            const toggleButton = document.getElementById('toggle-hide-amounts');
            const toggleIcon = document.getElementById('toggle-hide-amounts-icon');
            const accountsSection = document.getElementById('accounts');

            const applyStreamerMode = (active) => {
                if (active) {
                    if (accountsSection) accountsSection.classList.add('streamer-mode-active');
                    toggleIcon.classList.remove('fa-eye-slash');
                    toggleIcon.classList.add('fa-eye');
                    toggleButton.setAttribute('aria-pressed', 'true');
                    toggleButton.title = "Mostrar importes";
                } else {
                    if (accountsSection) accountsSection.classList.remove('streamer-mode-active');
                    toggleIcon.classList.remove('fa-eye');
                    toggleIcon.classList.add('fa-eye-slash');
                    toggleButton.setAttribute('aria-pressed', 'false');
                    toggleButton.title = "Ocultar importes (stream)";
                }
            };

            // Check localStorage on load
            let isStreamerModeActive = localStorage.getItem('streamerModeActive') === 'true';
            applyStreamerMode(isStreamerModeActive);

            toggleButton.addEventListener('click', () => {
                isStreamerModeActive = !isStreamerModeActive;
                localStorage.setItem('streamerModeActive', isStreamerModeActive);
                applyStreamerMode(isStreamerModeActive);
                // Refresh accounts to apply per-account visibility
                refreshAccountsView();
            });

            const addAccountBtn = document.getElementById('add-account-btn');
            if (addAccountBtn) {
                addAccountBtn.addEventListener('click', () => showBrokerSelectionModal());
            }

            const saveAccountBtn = document.getElementById('acc-save');
            if (saveAccountBtn) {
                saveAccountBtn.addEventListener('click', saveAccount);
            }

            const cancelAccountBtn = document.getElementById('acc-cancel');
            if (cancelAccountBtn) {
                cancelAccountBtn.addEventListener('click', () => toggleAddAccountForm());
            }

            // Nuevos event listeners para modales
            const closeBrokerScreen = document.getElementById('close-broker-screen');
            if (closeBrokerScreen) {
                closeBrokerScreen.addEventListener('click', () => {
                    document.getElementById('broker-selection-screen').style.display = 'none';
                    document.getElementById('accounts-main-container').style.display = 'block';
                });
            }

            const closeBrokerModal = document.getElementById('close-broker-modal');
            if (closeBrokerModal) {
                closeBrokerModal.addEventListener('click', () => {
                    document.getElementById('broker-selection-modal').style.display = 'none';
                });
            }

            const closeAccountModal = document.getElementById('close-account-modal');
            if (closeAccountModal) {
                closeAccountModal.addEventListener('click', () => {
                    document.getElementById('account-config-modal').style.display = 'none';
                });
            }

            const cancelAccountModal = document.getElementById('cancel-account-modal');
            if (cancelAccountModal) {
                cancelAccountModal.addEventListener('click', () => {
                    document.getElementById('account-config-modal').style.display = 'none';
                });
            }

            const saveAccountModal = document.getElementById('save-account-modal');
            if (saveAccountModal) {
                saveAccountModal.addEventListener('click', saveAccountFromModal);
            }

            // Buscador de brokers
            const brokerSearch = document.getElementById('broker-search');
            if (brokerSearch) {
                brokerSearch.addEventListener('input', (e) => {
                    const searchTerm = e.target.value.toLowerCase();
                    const brokerCards = document.querySelectorAll('.broker-card');
                    const brokerListItems = document.querySelectorAll('.broker-list-item');
                    
                    brokerCards.forEach(card => {
                        const brokerName = card.dataset.brokerName.toLowerCase();
                        card.style.display = brokerName.includes(searchTerm) ? 'block' : 'none';
                    });
                    
                    brokerListItems.forEach(item => {
                        const brokerName = item.dataset.brokerName.toLowerCase();
                        item.style.display = brokerName.includes(searchTerm) ? 'flex' : 'none';
                    });
                });
            }
        }

        // Mostrar modal de selección de broker
        function showBrokerSelectionModal() {
            // Ocultar el contenedor de cuentas y mostrar la pantalla de selección
            document.getElementById('accounts-main-container').style.display = 'none';
            document.getElementById('broker-selection-screen').style.display = 'block';
            
            const grid = document.getElementById('broker-grid');
            const allBrokersList = document.getElementById('all-brokers-list');
            
            const favoriteBrokers = [
                { id: 'bitget', name: 'Bitget', logo: 'logos/bitget-logo.png', color: '#00F0FF' },
                { id: 'bingx', name: 'BingX', logo: 'logos/bingx-logo.png', color: '#1E90FF' },
                { id: 'lbank', name: 'LBank', logo: 'logos/lbank-logo.png', color: '#2E5BFF' },
                { id: 'blofin', name: 'BloFin', logo: 'logos/blofin-logo.png', color: '#00C9A7' },
                { id: 'ninjatrader', name: 'NinjaTrader 8', logo: 'logos/ninja-logo.png', color: '#FF6600' },
                { id: 'tradovate', name: 'Tradovate', logo: 'logos/tradovate-logo.png', color: '#0066CC' },
                { id: 'topstepx', name: 'TopStepX', logo: 'logos/topstepx-logo.png', color: '#FF5722' },
                { id: 'meta-trader-4', name: 'MetaTrader 4', logo: 'logos/metatrader 4-logo.png', color: '#1B5E20' },
                { id: 'meta-trader-5', name: 'MetaTrader 5', logo: 'logos/metatrader5-logo.png', color: '#1B5E20' },
                { id: 'primexbt-crypto', name: 'PrimeXBT Crypto', logo: 'logos/primexbt-logo.png', color: '#0066FF' }
            ];

            const otherBrokers = [
                { id: 'bingx', name: 'BingX', logo: 'logos/bingx-logo.png', color: '#1E40AF' },
                { id: 'ninjatrader', name: 'NinjaTrader 8', logo: 'logos/ninja-logo.png', color: '#FF6600' },
                { id: 'tradovate', name: 'Tradovate', logo: 'logos/tradovate-logo.png', color: '#0066CC' },
                { id: 'topstepx', name: 'TopStepX', logo: 'logos/topstepx-logo.png', color: '#FF5722' },
                { id: 'bitget', name: 'Bitget', logo: 'logos/bitget-logo.png', color: '#54FDD5' },
                { id: 'lbank', name: 'LBank', logo: 'logos/lbank-logo.png', color: '#2E5BFF' },
                { id: 'blofin', name: 'BloFin', logo: 'logos/blofin-logo.png', color: '#00C9A7' },
                { id: 'binance', name: 'Binance', logo: 'logos/binance-logo.png', color: '#F3BA2F' },
                { id: 'mexc', name: 'MEXC', logo: 'logos/mexc-logo.png', color: '#00D4AA' },
                { id: 'bitunix', name: 'Bitunix', logo: 'logos/bitunix-logo.png', color: '#FF6B00' },
                { id: 'primexbt-crypto', name: 'PrimeXBT Crypto', logo: 'logos/primexbt-logo.png', color: '#FF6B35' },
                { id: 'primexbt-cfds', name: 'PrimeXBT CFDs', logo: 'logos/primexbt-logo.png', color: '#0066FF' },
                { id: 'meta-trader-4', name: 'MetaTrader 4', logo: 'logos/metatrader 4-logo.png', color: '#1B5E20' },
                { id: 'meta-trader-5', name: 'MetaTrader 5', logo: 'logos/metatrader5-logo.png', color: '#1B5E20' },
                { id: 'ctrader', name: 'cTrader', logo: 'logos/ctrader-logo.png', color: '#00A8E1' },
                { id: 'tradingview', name: 'TradingView', logo: 'logos/tradingview-logo.png', color: '#2962FF' }
            ];

            // Renderizar favoritos
            grid.innerHTML = favoriteBrokers.map(broker => `
                <div class="broker-card cursor-pointer" data-broker-id="${broker.id}" data-broker-name="${broker.name}">
                    <div class="bg-surface hover:bg-surface-light rounded-lg p-6 text-center transition-all border border-border hover:border-primary">
                        <div class="w-16 h-16 rounded-xl mx-auto mb-3 overflow-hidden" style="background-color: ${broker.color};">
                            ${broker.logo ? `<img src="${broker.logo}" alt="${broker.name}" class="w-full h-full object-cover">` : `<div class="w-full h-full flex items-center justify-center text-white font-bold text-xl">${broker.initials || broker.name.substring(0, 2)}</div>`}
                        </div>
                        <p class="text-sm font-medium text-white">${broker.name}</p>
                    </div>
                </div>
            `).join('');
            
            // Agregar event listeners a las tarjetas
            document.querySelectorAll('.broker-card').forEach(card => {
                card.addEventListener('click', function() {
                    const brokerId = this.dataset.brokerId;
                    const brokerName = this.dataset.brokerName;
                    const broker = favoriteBrokers.find(b => b.id === brokerId);
                    if (broker) {
                        selectBroker(broker.id, broker.name, broker.logo, broker.color, broker.initials || '');
                    }
                });
            });

            // Renderizar otros brokers en lista
            allBrokersList.innerHTML = otherBrokers.map(broker => `
                <div class="broker-list-item cursor-pointer hover:bg-surface-light px-4 py-3 flex items-center border-b border-border last:border-b-0 transition-colors" data-broker-id="${broker.id}" data-broker-name="${broker.name}">
                    <div class="w-10 h-10 rounded-lg overflow-hidden mr-3" style="background-color: ${broker.color};">
                        ${broker.logo ? `<img src="${broker.logo}" alt="${broker.name}" class="w-full h-full object-cover">` : `<div class="w-full h-full flex items-center justify-center text-white font-bold text-xs">${broker.initials || broker.name.substring(0, 2)}</div>`}
                    </div>
                    <span class="text-sm font-medium text-white">${broker.name}</span>
                </div>
            `).join('');
            
            // Agregar event listeners a los items de la lista
            document.querySelectorAll('.broker-list-item').forEach(item => {
                item.addEventListener('click', function() {
                    const brokerId = this.dataset.brokerId;
                    const brokerName = this.dataset.brokerName;
                    const broker = otherBrokers.find(b => b.id === brokerId);
                    if (broker) {
                        selectBroker(broker.id, broker.name, broker.logo, broker.color, broker.initials || '');
                    }
                });
            });
            
            // Configurar toggle de Show all brokers
            const showAllBtn = document.getElementById('show-all-brokers-btn');
            if (showAllBtn) {
                // Remover listeners anteriores
                const newBtn = showAllBtn.cloneNode(true);
                showAllBtn.parentNode.replaceChild(newBtn, showAllBtn);
                
                newBtn.addEventListener('click', function() {
                    const list = document.getElementById('all-brokers-list');
                    const icon = this.querySelector('i');
                    if (list.style.display === 'none' || !list.style.display) {
                        list.style.display = 'block';
                        icon.classList.remove('fa-chevron-down');
                        icon.classList.add('fa-chevron-up');
                    } else {
                        list.style.display = 'none';
                        icon.classList.remove('fa-chevron-up');
                        icon.classList.add('fa-chevron-down');
                    }
                });
            }
        }

        // Seleccionar broker y abrir modal de configuración
        function selectBroker(brokerId, brokerName, brokerLogo, brokerColor, brokerInitials) {
            // Cerrar pantalla de selección
            document.getElementById('broker-selection-screen').style.display = 'none';
            document.getElementById('accounts-main-container').style.display = 'block';
            
            const modal = document.getElementById('account-config-modal');
            const logoContainer = document.getElementById('selected-broker-logo');
            
            // Actualizar logo y nombre sin padding
            logoContainer.style.backgroundColor = brokerColor;
            if (brokerLogo) {
                logoContainer.innerHTML = `<img src="${brokerLogo}" alt="${brokerName}" class="w-full h-full object-cover">`;
            } else {
                logoContainer.innerHTML = `<div class="w-full h-full flex items-center justify-center text-white font-bold text-xl">${brokerInitials || brokerName.substring(0, 2)}</div>`;
            }
            
            document.getElementById('selected-broker-name').textContent = brokerName;
            
            // Guardar broker seleccionado
            modal.dataset.selectedBroker = brokerId;
            
            // Mostrar campos de Tradovate si aplica
            const tradovateFields = document.getElementById('tradovate-fields-modal');
            tradovateFields.style.display = brokerId === 'tradovate' ? 'block' : 'none';
            
            // Limpiar formulario
            document.getElementById('acc-name-modal').value = '';
            document.getElementById('acc-balance-modal').value = '';
            document.getElementById('acc-currency-modal').value = 'USD';
            document.getElementById('acc-type-modal').value = 'personal'; // Valor por defecto
            
            modal.style.display = 'flex';
        }

        // Guardar cuenta desde modal
        async function saveAccountFromModal() {
            try {
                showLoading(true);
                const modal = document.getElementById('account-config-modal');
                const brokerId = modal.dataset.selectedBroker;
                const name = document.getElementById('acc-name-modal').value.trim();
                const initialBalance = parseFloat(document.getElementById('acc-balance-modal').value);
                const currency = document.getElementById('acc-currency-modal').value;
                const accountType = document.getElementById('acc-type-modal').value; // Capital Propio o Fondeo
                
                console.log('Guardando cuenta:', { brokerId, name, initialBalance, currency, accountType });
                
                // Capturar credenciales de Tradovate si aplica
                let tradovateCredentials = {};
                if (brokerId === 'tradovate') {
                    tradovateCredentials = {
                        tradovateUsername: document.getElementById('tradovate-username-modal').value.trim(),
                        tradovatePassword: document.getElementById('tradovate-password-modal').value.trim(),
                        tradovateAccountId: document.getElementById('tradovate-account-id-modal').value.trim(),
                        tradovateAutoSync: document.getElementById('tradovate-auto-sync-modal').checked
                    };
                    
                    if (!tradovateCredentials.tradovateUsername || !tradovateCredentials.tradovatePassword || !tradovateCredentials.tradovateAccountId) {
                        showError('Por favor completa todos los campos de Tradovate');
                        showLoading(false);
                        return;
                    }
                }
                
                if (!name || isNaN(initialBalance) || initialBalance <= 0) {
                    showError('Por favor completa todos los campos correctamente');
                    showLoading(false);
                    return;
                }
                
                // Obtener user_id
                const { data: userData, error: userError } = await supabase.auth.getUser();
                if (userError || !userData.user) {
                    showError('Error de autenticación');
                    showLoading(false);
                    return;
                }
                
                const accountData = {
                    id: generateId(),
                    name,
                    initial_balance: initialBalance,
                    balance: initialBalance,
                    currency,
                    platform: brokerId,
                    user_id: userData.user.id,
                    created_at: new Date().toISOString(),
                    updated_at: new Date().toISOString()
                    // NOTA: El campo 'accountType' se guarda en funded_accounts si es tipo 'funded'
                    // pero NO en la tabla accounts porque esa columna no existe ahí
                };
                
                console.log('Datos de cuenta a insertar:', accountData);
                
                const { data, error } = await supabase.from('accounts').insert([accountData]).select().single();
                if (error) {
                    console.error('Error de Supabase:', error);
                    throw error;
                }
                
                console.log('✅ Cuenta creada en Supabase:', data);
                
                // Si es una cuenta "funded", también crearla en la tabla funded_accounts
                if (accountType === 'funded') {
                    console.log('📋 Creando entrada en funded_accounts...');
                    const fundedData = {
                        id: data.id, // Mismo ID que la cuenta principal
                        user_id: userData.user.id,
                        name: name,
                        company: brokerId, // Nombre del broker
                        firm: brokerId, // Nombre de la prop firm
                        type: 'evaluation', // Tipo de cuenta: 'evaluation' o 'live'
                        status: 'active',
                        balance: initialBalance,
                        fee: 0,
                        earnings: 0,
                        withdrawals: 0,
                        withdrawals_count: 0,
                        withdrawals_history: [], // Historial de retiros vacío
                        activation_date: new Date().toISOString().split('T')[0], // Solo la fecha YYYY-MM-DD
                        notes: '',
                        created_at: new Date().toISOString(),
                        updated_at: new Date().toISOString()
                    };
                    
                    const { error: fundedError } = await supabase
                        .from('funded_accounts')
                        .insert([fundedData]);
                    
                    if (fundedError) {
                        console.error('⚠️ Error creando funded_account:', fundedError);
                        // No lanzar error, la cuenta principal ya fue creada
                    } else {
                        console.log('✅ Entrada en funded_accounts creada');
                    }
                }
                
                // Agregar la nueva cuenta a DB.accounts y Dexie
                const newAccount = {
                    id: data.id,
                    name: data.name,
                    currency: data.currency,
                    platform: data.platform,
                    initialBalance: data.initial_balance || data.initialBalance,
                    balance: data.balance || data.initial_balance || data.initialBalance
                };
                
                DB.accounts.push(newAccount);
                
                // Guardar en Dexie
                await dexieDB.accounts.put(newAccount);
                
                console.log('✅ DB.accounts actualizado:', DB.accounts.length, 'cuentas');
                
                // Refrescar selector de cuentas en el header
                refreshAccountSelector();
                
                if (typeof showToast === 'function') {
                    showToast('Éxito', 'Cuenta creada exitosamente', 'success');
                } else {
                    alert('Cuenta creada exitosamente');
                }
                modal.style.display = 'none';
                
                // Refrescar la sección de cuentas si está visible
                const accountsSection = document.getElementById('accounts');
                if (accountsSection && accountsSection.classList.contains('active')) {
                    showSection('accounts');
                }
            } catch (error) {
                console.error('Error al guardar cuenta:', error);
                showError('Error al crear la cuenta: ' + (error.message || JSON.stringify(error)));
            } finally {
                showLoading(false);
            }
        }

        function toggleAddAccountForm(accountToEdit = null) {
            const form = document.getElementById('add-account-form'); const isVisible = form.style.display === 'block';
            if (!isVisible) {
                form.style.display = 'block'; document.getElementById('add-account-btn').textContent = 'Ocultar Formulario';
                if (accountToEdit) { 
                    form.querySelector('h3').textContent = 'Editar Cuenta'; 
                    document.getElementById('acc-name').value = accountToEdit.name; 
                    document.getElementById('acc-balance').value = accountToEdit.initialBalance; 
                    document.getElementById('acc-currency').value = accountToEdit.currency; 
                    document.getElementById('acc-platform').value = accountToEdit.platform;
                    document.getElementById('acc-type').value = accountToEdit.accountType || 'personal'; // Cargar tipo de cuenta
                    form.dataset.editingId = accountToEdit.id;
                    
                    // Mostrar campos de Tradovate si es cuenta Tradovate
                    if (accountToEdit.platform === 'tradovate') {
                        document.getElementById('tradovate-fields').style.display = 'block';
                        if (accountToEdit.tradovateUsername) document.getElementById('tradovate-username').value = accountToEdit.tradovateUsername;
                        if (accountToEdit.tradovatePassword) document.getElementById('tradovate-password').value = accountToEdit.tradovatePassword;
                        if (accountToEdit.tradovateAccountId) document.getElementById('tradovate-account-id').value = accountToEdit.tradovateAccountId;
                        if (accountToEdit.tradovateAutoSync) document.getElementById('tradovate-auto-sync').checked = accountToEdit.tradovateAutoSync;
                    } else {
                        document.getElementById('tradovate-fields').style.display = 'none';
                    }
                }
                else { 
                    form.querySelector('h3').textContent = 'Nueva Cuenta'; 
                    document.getElementById('acc-name').value = ''; 
                    document.getElementById('acc-balance').value = ''; 
                    document.getElementById('acc-currency').value = DB.settings.defaultCurrency; 
                    document.getElementById('acc-platform').value = 'meta-trader-4';
                    document.getElementById('acc-type').value = 'personal'; // Valor por defecto
                    document.getElementById('tradovate-fields').style.display = 'none';
                    delete form.dataset.editingId; 
                }
                form.scrollIntoView({ behavior: 'smooth' });
            } else { form.style.display = 'none'; document.getElementById('add-account-btn').innerHTML = '<i class="fas fa-plus mr-2"></i>Agregar Cuenta'; delete form.dataset.editingId; }
        }
        
        // Listener para mostrar/ocultar campos de Tradovate
        document.getElementById('acc-platform').addEventListener('change', function(e) {
            const tradovateFields = document.getElementById('tradovate-fields');
            if (e.target.value === 'tradovate') {
                tradovateFields.style.display = 'block';
            } else {
                tradovateFields.style.display = 'none';
            }
        });
        async function saveAccount() {
            showLoading(true);
            const form = document.getElementById('add-account-form');
            const editingId = form.dataset.editingId;
            const name = document.getElementById('acc-name').value.trim();
            const initialBalance = parseFloat(document.getElementById('acc-balance').value);
            const currency = document.getElementById('acc-currency').value;
            const platform = document.getElementById('acc-platform').value;
            const accountType = document.getElementById('acc-type').value; // Capital Propio o Fondeo
            
            // Capturar credenciales de Tradovate si aplica
            let tradovateCredentials = {};
            if (platform === 'tradovate') {
                tradovateCredentials = {
                    tradovateUsername: document.getElementById('tradovate-username').value.trim(),
                    tradovatePassword: document.getElementById('tradovate-password').value.trim(),
                    tradovateAccountId: document.getElementById('tradovate-account-id').value.trim(),
                    tradovateAutoSync: document.getElementById('tradovate-auto-sync').checked
                };
                
                if (!tradovateCredentials.tradovateUsername || !tradovateCredentials.tradovatePassword || !tradovateCredentials.tradovateAccountId) {
                    alert('Por favor completa todos los campos de Tradovate (Usuario, Contraseña, Account ID).');
                    showLoading(false);
                    return;
                }
            }
            
            if (!name || isNaN(initialBalance) || initialBalance < 0) { alert('Nombre y balance inicial válido requerido.'); showLoading(false); return; }

            let accountData;
            try {
                if (editingId) {
                    const existingAccount = DB.accounts.find(acc => acc.id === editingId);
                    accountData = { ...existingAccount, name, initialBalance, currency, platform, accountType: accountType, ...tradovateCredentials };
                    accountData.balance = initialBalance;
                    const accountOps = DB.operations.filter(op => op.accountId === editingId);
                    accountOps.forEach(op => {
                        let pl = op.pl;
                        if (op.currency !== accountData.currency) pl = convertCurrency(pl, op.currency, accountData.currency);
                        accountData.balance += pl;
                    });
                    accountData.balance = Math.round(accountData.balance * 100) / 100;
                    await dexieDB.accounts.update(editingId, accountData);
                    const index = DB.accounts.findIndex(acc => acc.id === editingId);
                    if (index !== -1) DB.accounts[index] = accountData;

                    console.log('✅ Cuenta actualizada localmente');

                    // SINCRONIZACIÓN AUTOMÁTICA EN SEGUNDO PLANO (invisible para el usuario)
                    if (currentUser) {
                        saveAccountToSupabase(accountData).then(() => {
                            console.log('✅ Cuenta sincronizada automáticamente');
                            showSyncNotification('💾 Cuenta actualizada exitosamente', 'success');
                        }).catch((supabaseError) => {
                            console.error('❌ Error de sincronización automática:', supabaseError);
                            addToSyncQueue(accountData, 'account');
                            showSyncNotification('💾 Cuenta actualizada exitosamente', 'success');
                        });
                    } else {
                        showSyncNotification('💾 Cuenta actualizada', 'success');
                    }

                } else {
                    accountData = { id: generateId(), name, initialBalance, balance: initialBalance, currency, platform, accountType: accountType, ...tradovateCredentials };
                    console.log('🏦 Creating new account:', accountData);

                    await dexieDB.accounts.add(accountData);
                    console.log('✅ Account added to local DB');

                    DB.accounts.push(accountData);
                    console.log('✅ Account added to memory');

                    // SINCRONIZACIÓN AUTOMÁTICA EN SEGUNDO PLANO (invisible para el usuario)
                    if (currentUser) {
                        saveAccountToSupabase(accountData).then(() => {
                            console.log('✅ Cuenta sincronizada automáticamente');
                            showSyncNotification('💾 Cuenta creada exitosamente', 'success');
                        }).catch((supabaseError) => {
                            console.error('❌ Error de sincronización automática:', supabaseError);
                            addToSyncQueue(accountData, 'account');
                            showSyncNotification('💾 Cuenta creada exitosamente', 'success');
                        });
                    } else {
                        showSyncNotification('💾 Cuenta creada', 'success');
                    }
                }

                // Actualizar vistas inmediatamente con datos locales
                toggleAddAccountForm();
                updateAccountBalances();
                
                // Actualizar TODOS los selectores de cuentas en todas las secciones
                const allSelectors = [
                    'dashboard-account-select',
                    'new-dashboard-account-select',
                    'analytics-account-select',
                    'equity-account-select',
                    'daily-journal-account-select',
                    'calendar-account-select',
                    'informe-account-select',
                    'op-account',
                    'filter-account',
                    'chartbook-account-select',
                    'bingx-account',
                    'bitget-account-detail',
                    'mexc-account-detail'
                ];
                
                allSelectors.forEach(selectorId => {
                    updateAccountSelect(selectorId);
                });
                
                refreshAllViews();

                // Mensaje de confirmación inmediato
                showSyncNotification('✅ Cuenta guardada exitosamente', 'success');

            } catch (e) {
                console.error("Error saving account:", e); alert("Error al guardar la cuenta.");
            } finally { showLoading(false); }
        }

        async function refreshAccountsView() {
            if (!document.getElementById('accounts').classList.contains('active')) return;
            
            // Ocultar panel de detalles al refrescar la vista principal
            const detailsSection = document.getElementById('selected-account-details');
            if (detailsSection) {
                detailsSection.style.display = 'none';
                detailsSection.dataset.accountId = '';
            }
            
            const container = document.getElementById('accounts-container');
            if (!container) return;
            
            console.log('🔄 Refrescando vista de cuentas');
            console.log('📊 Total de cuentas:', DB.accounts.length);
            console.log('📊 Total de operaciones:', DB.operations.length);
            
            container.innerHTML = '';
            const hiddenAccounts = JSON.parse(localStorage.getItem('streamerHiddenAccounts') || '[]');
            DB.accounts.forEach(account => {
                const card = document.createElement('div'); card.classList.add('account-card'); card.dataset.id = account.id;
                const accountOps = DB.operations.filter(op => op.accountId === account.id);
                
                console.log(`📊 Cuenta "${account.name}": ${accountOps.length} operaciones`);
                const winningOps = accountOps.filter(op => op.result === 'win').length;
                const losingOps = accountOps.filter(op => op.result === 'loss').length;
                const winRate = (winningOps + losingOps) > 0 ? (winningOps / (winningOps + losingOps)) * 100 : 0;
                
                // CALCULAR P&L REAL: Suma de todas las operaciones (pl - fees)
                const totalPL = accountOps.reduce((sum, op) => sum + (op.pl || 0), 0);
                const totalFees = accountOps.reduce((sum, op) => sum + (op.fees || 0), 0);
                const pl = totalPL - totalFees;
                const plPercentage = account.initialBalance !== 0 ? (pl / account.initialBalance) * 100 : 0;
                
                // Actualizar balance real de la cuenta basado en operaciones
                const calculatedBalance = account.initialBalance + pl;
                
                console.log(`💰 Cuenta "${account.name}": P&L calculado = ${pl.toFixed(2)} (${accountOps.length} ops)`);
                
                const isHidden = hiddenAccounts.includes(account.id);

                // Obtener logo de la plataforma
                const platformLogo = getPlatformLogo(account.platform);
                const logoHTML = platformLogo.file
                    ? `<img src="${platformLogo.file}" alt="${formatPlatformName(account.platform)}" class="w-16 h-16 object-contain rounded-xl" style="image-rendering: -webkit-optimize-contrast; image-rendering: crisp-edges; width: 64px; height: 64px; max-width: 64px; max-height: 64px;" onerror="this.parentElement.innerHTML='<div class=\\'w-16 h-16 bg-[${platformLogo.color}] rounded-xl flex items-center justify-center text-white font-bold text-lg\\'>${platformLogo.initials}</div>'">`
                    : `<div class="w-16 h-16 bg-[${platformLogo.color}] rounded-xl flex items-center justify-center text-white font-bold text-lg">${platformLogo.initials}</div>`;

                card.innerHTML = `
                    <div class="flex justify-between items-start mb-4">
                        <div class="flex items-center gap-3">
                            <div class="w-16 h-16 rounded-xl flex items-center justify-center overflow-hidden" style="background-color: ${platformLogo.color};">
                                ${logoHTML}
                            </div>
                            <h4 class="text-lg font-semibold">${account.name}</h4>
                        </div>
                        <div class="flex items-center">
                            <div class="mr-2 text-xs text-text-secondary">Streamer</div>
                            <button class="button small toggle-account-stream-btn ${isHidden ? 'active' : ''}" data-id="${account.id}" title="Alternar ocultar importes" aria-pressed="${isHidden ? 'true' : 'false'}">
                                <i class="fas ${isHidden ? 'fa-eye' : 'fa-eye-slash'}"></i>
                            </button>
                            <span class="text-xs bg-surface-light px-2 py-1 rounded text-text-secondary ml-2">${formatPlatformName(account.platform)}</span>
                        </div>
                    </div>
                    <div class="mb-4">
                        <p class="text-sm text-text-secondary">Balance</p>
                        <p class="text-2xl font-semibold ${isHidden && localStorage.getItem('streamerModeActive') === 'true' ? 'hide-amount' : ''}">${formatCurrency(calculatedBalance, account.currency, account.currency)}</p>
                    </div>
                    <div class="grid grid-cols-2 gap-4 mb-3">
                        <div>
                            <p class="text-sm text-text-secondary">P&L</p>
                            <p class="text-lg font-semibold ${pl > 0 ? 'text-positive' : (pl < 0 ? 'text-negative' : '')} ${isHidden && localStorage.getItem('streamerModeActive') === 'true' ? 'hide-amount' : ''}">${formatCurrency(pl, account.currency, account.currency)} (${plPercentage.toFixed(1)}%)</p>
                        </div>
                        <div>
                            <p class="text-sm text-text-secondary">Win Rate</p>
                            <p class="text-lg font-semibold text-green">${winRate.toFixed(0)}%</p>
                        </div>
                    </div>
                    <div class="flex justify-between items-center mt-4">
                        <button class="view-account-btn text-sm" data-id="${account.id}" style="background: var(--primary); color: var(--background); padding: 0.5rem 1rem; border-radius: 0.375rem; font-weight: 600; border: none; transition: all 0.2s ease;">
                            <i class="fas fa-chart-line mr-1"></i> Detalles
                        </button>
                        <div class="space-x-2">
                            <button class="edit-account-btn text-sm text-white" data-id="${account.id}" title="Editar Cuenta">
                                <i class="fas fa-edit"></i>
                            </button>
                            <button class="delete-account-btn text-sm text-red" data-id="${account.id}" title="Eliminar Cuenta">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    </div>
                `;
                container.appendChild(card);
            });

            // Add listeners for per-account streamer toggles
            document.querySelectorAll('.toggle-account-stream-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const accountId = btn.dataset.id;
                    const hiddenAccounts = JSON.parse(localStorage.getItem('streamerHiddenAccounts') || '[]');
                    const isHidden = hiddenAccounts.includes(accountId);
                    if (isHidden) {
                        const idx = hiddenAccounts.indexOf(accountId);
                        hiddenAccounts.splice(idx, 1);
                        btn.classList.remove('active');
                        btn.setAttribute('aria-pressed', 'false');
                        btn.querySelector('i').classList.remove('fa-eye');
                        btn.querySelector('i').classList.add('fa-eye-slash');
                    } else {
                        hiddenAccounts.push(accountId);
                        btn.classList.add('active');
                        btn.setAttribute('aria-pressed', 'true');
                        btn.querySelector('i').classList.remove('fa-eye-slash');
                        btn.querySelector('i').classList.add('fa-eye');
                    }
                    localStorage.setItem('streamerHiddenAccounts', JSON.stringify(hiddenAccounts));
                    refreshAccountsView();
                });
            });

            container.addEventListener('click', async function (event) {
                const targetButton = event.target.closest('button');
                if (!targetButton) return;

                const accountId = targetButton.dataset.id;
                const account = DB.accounts.find(acc => acc.id === accountId);

                if (targetButton.classList.contains('view-account-btn')) {
                    showAccountDetails(accountId);
                } else if (targetButton.classList.contains('edit-account-btn')) {
                    if (account) toggleAddAccountForm(account);
                } else if (targetButton.classList.contains('delete-account-btn')) {
                    const opsCount = DB.operations.filter(op => op.accountId === accountId).length;
                    // Eliminar directamente sin confirmación
                    showLoading(true);
                        try {
                            // Eliminar de base de datos local (IndexedDB)
                            await dexieDB.transaction('rw', dexieDB.accounts, dexieDB.operations, async () => {
                                await dexieDB.accounts.delete(accountId);
                                const opsToDelete = DB.operations.filter(op => op.accountId === accountId).map(op => op.id);
                                if (opsToDelete.length > 0) await dexieDB.operations.bulkDelete(opsToDelete);
                            });

                            // Eliminar de Supabase (esta función ya elimina las operaciones primero)
                            await deleteAccountFromSupabase(accountId);

                            // Actualizar DB en memoria
                            DB.accounts = DB.accounts.filter(a => a.id !== accountId);
                            DB.operations = DB.operations.filter(op => op.accountId !== accountId);

                            // Actualizar interfaz
                            updateAccountBalances();
                            ['dashboard-account-select', 'new-dashboard-account-select', 'analytics-account-select', 'equity-account-select', 'daily-journal-account-select', 'calendar-account-select', 'chartbook-account-select', 'op-account', 'filter-account', 'bingx-account'].forEach(updateAccountSelect);

                            const detailsSection = document.getElementById('selected-account-details');
                            if (detailsSection.style.display === 'block' && detailsSection.dataset.accountId === accountId) {
                                detailsSection.style.display = 'none'; detailsSection.removeAttribute('data-accountId');
                            }
                            
                            // Refrescar vista de cuentas inmediatamente
                            refreshAccountsView();
                            refreshAccountSelector();
                            refreshAllViews();
                            
                            console.log(`✅ Cuenta "${account?.name}" y ${opsCount} operaciones eliminadas correctamente`);
                    }
                    catch (e) {
                        console.error("Error deleting account:", e); 
                        alert(`Error al eliminar la cuenta: ${e.message}`);
                    } finally { 
                        showLoading(false); 
                    }
                }
            });
        }

        let accountDetailRadarChart = null;
        function updateAccountDetailRadarChart(operations, accountId) {
            const ctx = document.getElementById('account-detail-radar-chart')?.getContext('2d');
            if (!ctx) return;
            if (accountDetailRadarChart) accountDetailRadarChart.destroy();

            // This function is essentially the same as updateDashboardRadarChart,
            // but targets the account detail canvas.
            const basicMetrics = calculateMetrics(operations, accountId);
            const advancedMetrics = calculateAdvancedMetrics(operations, accountId);

            let maxDrawdownPercentage = 0;
            const account = DB.accounts.find(a => a.id === accountId);
            if (operations.length > 0 && account) {
                const sortedOps = [...operations].sort((a, b) => new Date(a.date + 'T' + (a.entryTime || '00:00')) - new Date(b.date + 'T' + (b.entryTime || '00:00')));
                let accountInitialBalance = account.initialBalance;

                if (accountInitialBalance > 0) {
                    let peakBalance = accountInitialBalance;
                    let maxDrawdownValue = 0;
                    let currentBalance = accountInitialBalance;
                    sortedOps.forEach(op => {
                        let pl = convertCurrency(op.pl, op.currency, account.currency);
                        currentBalance += pl;
                        if (currentBalance > peakBalance) peakBalance = currentBalance;
                        const drawdown = peakBalance - currentBalance;
                        if (drawdown > maxDrawdownValue) maxDrawdownValue = drawdown;
                    });
                    maxDrawdownPercentage = (maxDrawdownValue / accountInitialBalance) * 100;
                }
            }

            const winRateScore = basicMetrics.winRate || 0;
            const profitFactorScore = Math.min(basicMetrics.profitFactor / 3, 1) * 100;
            const avgWLRatio = advancedMetrics.avgWin && advancedMetrics.avgLoss ? Math.abs(convertCurrency(advancedMetrics.avgWin, DB.settings.defaultCurrency, account.currency) / convertCurrency(advancedMetrics.avgLoss, DB.settings.defaultCurrency, account.currency)) : 0;
            const avgWLRatioScore = Math.min(avgWLRatio / 3, 1) * 100;
            const drawdownScore = Math.max(0, (1 - Math.min(maxDrawdownPercentage / 20, 1)) * 100);

            let consistencyScore = 0;
            if (operations.length > 1) {
                const dailyPL = {};
                operations.forEach(op => {
                    if (!dailyPL[op.date]) dailyPL[op.date] = 0;
                    const plValue = op.pl ?? op.pnl ?? 0;
                    const feeValue = op.fee ?? op.fees ?? 0;
                    const plInAccountCurrency = convertCurrency(plValue, op.currency, account.currency);
                    const feesInAccountCurrency = convertCurrency(feeValue, op.currency, account.currency);
                    dailyPL[op.date] += plInAccountCurrency - feesInAccountCurrency;
                });
                
                const dailyValues = Object.values(dailyPL);
                if (dailyValues.length >= 2) {
                    const avg = dailyValues.reduce((sum, v) => sum + v, 0) / dailyValues.length;
                    const variance = dailyValues.reduce((sum, v) => sum + Math.pow(v - avg, 2), 0) / dailyValues.length;
                    const stdDev = Math.sqrt(variance);
                    
                    if (Math.abs(avg) > 0.01) {
                        const coefficientOfVariation = stdDev / Math.abs(avg);
                        
                        if (coefficientOfVariation < 0.3) {
                            consistencyScore = 95 + (0.3 - coefficientOfVariation) * 16.67;
                        } else if (coefficientOfVariation < 0.8) {
                            consistencyScore = 80 + (0.8 - coefficientOfVariation) * 30;
                        } else if (coefficientOfVariation < 1.5) {
                            consistencyScore = 60 + (1.5 - coefficientOfVariation) * 28.57;
                        } else if (coefficientOfVariation < 2.5) {
                            consistencyScore = 35 + (2.5 - coefficientOfVariation) * 25;
                        } else if (coefficientOfVariation < 4.0) {
                            consistencyScore = 10 + (4.0 - coefficientOfVariation) * 16.67;
                        } else {
                            consistencyScore = Math.max(0, 10 - (coefficientOfVariation - 4.0) * 2.5);
                        }
                        
                        consistencyScore = Math.max(0, Math.min(100, consistencyScore));
                    } else {
                        // Si avg es ~0, usar win rate diario
                        const winningDays = dailyValues.filter(pl => pl > 0).length;
                        consistencyScore = (winningDays / dailyValues.length) * 100;
                    }
                }
            }

            accountDetailRadarChart = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: ['Win %', 'Profit Factor', 'Avg Win/Loss', 'Drawdown Ctrl', 'Consistencia'],
                    datasets: [{
                        label: 'Puntuación',
                        data: [winRateScore, profitFactorScore, avgWLRatioScore, drawdownScore, consistencyScore],
                        fill: true,
                        backgroundColor: 'rgba(57, 255, 20, 0.2)',
                        borderColor: 'rgba(57, 255, 20, 0.8)',
                        pointBackgroundColor: 'var(--primary)',
                        pointBorderColor: '#0a0a0a',
                        pointHoverBackgroundColor: '#FFFFFF',
                        pointHoverBorderColor: 'var(--primary)'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        r: {
                            min: 0,
                            max: 100,
                            angleLines: { color: '#2a2a2a' },
                            grid: { color: '#2a2a2a' },
                            pointLabels: { color: '#FFFFFF', font: { size: 10 } },
                            ticks: { display: false, stepSize: 25 }
                        }
                    },
                    plugins: { legend: { display: false } }
                }
            });
        }


        function showAccountDetails(accountId) {
            const account = DB.accounts.find(acc => acc.id === accountId); if (!account) return;
            document.querySelectorAll('.account-card').forEach(card => card.classList.toggle('selected', card.dataset.id === accountId));
            const detailsSection = document.getElementById('selected-account-details');
            if (!detailsSection) return;
            detailsSection.style.display = 'block'; detailsSection.dataset.accountId = accountId;

            document.getElementById('account-detail-name').textContent = `Detalles de ${account.name}`;

            const operations = DB.operations.filter(op => op.accountId === accountId);
            const sortedOps = [...operations].sort((a, b) => new Date(a.date + 'T' + (a.entryTime || '00:00')) - new Date(b.date + 'T' + (b.entryTime || '00:00')));

            let totalWin = 0, totalLoss = 0, winCount = 0, lossCount = 0;
            let avgWin = 0, avgLoss = 0;

            operations.forEach(op => {
                let pl = op.pl;
                if (op.currency !== account.currency) pl = convertCurrency(pl, op.currency, account.currency);
                if (op.result === 'win') { totalWin += pl; winCount++; }
                else if (op.result === 'loss') { totalLoss += pl; lossCount++; }
            });

            if (winCount > 0) avgWin = totalWin / winCount;
            if (lossCount > 0) avgLoss = totalLoss / lossCount;

            const totalPL = totalWin + totalLoss;
            const winRate = (winCount + lossCount) > 0 ? (winCount / (winCount + lossCount)) * 100 : 0;
            const profitFactor = Math.abs(totalLoss) > 0 ? Math.abs(totalWin / totalLoss) : (totalWin > 0 ? Infinity : 0);
            const avgWLRatio = Math.abs(avgLoss) > 0 ? Math.abs(avgWin / avgLoss) : (avgWin > 0 ? Infinity : 0);

            let peakBalance = account.initialBalance;
            let maxDrawdownValue = 0;
            let currentBalance = account.initialBalance;
            sortedOps.forEach(op => {
                let pl = op.pl;
                if (op.currency !== account.currency) pl = convertCurrency(pl, op.currency, account.currency);
                currentBalance += pl;
                if (currentBalance > peakBalance) peakBalance = currentBalance;
                const drawdown = peakBalance - currentBalance;
                if (drawdown > maxDrawdownValue) maxDrawdownValue = drawdown;
            });
            const maxDrawdownPercentage = account.initialBalance > 0 ? (maxDrawdownValue / account.initialBalance) * 100 : 0;

            let totalDurationMinutes = 0, tradesWithDuration = 0;
            operations.forEach(op => {
                if (op.entryTime && op.exitTime) {
                    try {
                        const startDate = new Date(`1970-01-01T${op.entryTime}`);
                        const endDate = new Date(`1970-01-01T${op.exitTime}`);
                        let duration = (endDate - startDate) / 60000;
                        if (duration < 0) duration += 24 * 60; // Overnight
                        totalDurationMinutes += duration;
                        tradesWithDuration++;
                    } catch (e) { console.warn("Invalid time format for holding time calc", e); }
                }
            });
            let avgHoldTimeText = 'N/A';
            if (tradesWithDuration > 0) {
                const avgMinutes = totalDurationMinutes / tradesWithDuration;
                if (avgMinutes < 1) avgHoldTimeText = `${(avgMinutes * 60).toFixed(0)} seg`;
                else if (avgMinutes < 60) avgHoldTimeText = `${avgMinutes.toFixed(0)} min`;
                else avgHoldTimeText = `${Math.floor(avgMinutes / 60)}h ${Math.round(avgMinutes % 60)}m`;
            }

            let longestWinStreak = 0, currentWinStreak = 0, longestLossStreak = 0, currentLossStreak = 0;
            sortedOps.forEach(op => {
                if (op.result === 'win') { currentWinStreak++; currentLossStreak = 0; longestWinStreak = Math.max(longestWinStreak, currentWinStreak); }
                else if (op.result === 'loss') { currentLossStreak++; currentWinStreak = 0; longestLossStreak = Math.max(longestLossStreak, currentLossStreak); }
                else { currentWinStreak = 0; currentLossStreak = 0; }
            });

            const analyzeTradeType = (trades) => {
                const wins = trades.filter(t => t.result === 'win').length;
                const losses = trades.filter(t => t.result === 'loss').length;
                const totalPL = trades.reduce((sum, t) => sum + (t.currency !== account.currency ? convertCurrency(t.pl, t.currency, account.currency) : t.pl), 0);
                const winRate = (wins + losses) > 0 ? (wins / (wins + losses)) * 100 : 0;
                return { count: trades.length, totalPL, winRate };
            };
            const longStats = analyzeTradeType(operations.filter(op => op.type === 'buy'));
            const shortStats = analyzeTradeType(operations.filter(op => op.type === 'sell'));

            const plEl = document.getElementById('account-detail-pl');
            plEl.textContent = formatCurrency(totalPL, account.currency, account.currency);
            plEl.className = `text-2xl font-bold ${totalPL >= 0 ? 'text-positive' : 'text-negative'}`;
            document.getElementById('account-detail-winrate').textContent = `${winRate.toFixed(1)}%`;
            document.getElementById('account-detail-winrate').className = "text-2xl font-bold text-green";
            document.getElementById('account-detail-trades').textContent = operations.length;
            const pfEl = document.getElementById('account-detail-pf');
            pfEl.textContent = isFinite(profitFactor) ? profitFactor.toFixed(2) : "∞";
            pfEl.className = `text-2xl font-bold ${profitFactor >= 1 ? 'text-green' : 'text-negative'}`;

            document.getElementById('account-detail-drawdown').textContent = `${formatCurrency(maxDrawdownValue, account.currency, account.currency)} (${maxDrawdownPercentage.toFixed(1)}%)`;
            const avgWLRatioEl = document.getElementById('account-detail-avg-w-l-ratio');
            avgWLRatioEl.textContent = isFinite(avgWLRatio) ? avgWLRatio.toFixed(2) : "∞";
            avgWLRatioEl.className = `font-semibold ${avgWLRatio >= 1 ? 'text-green' : 'text-negative'}`;

            document.getElementById('account-detail-win-streak').textContent = longestWinStreak;
            document.getElementById('account-detail-loss-streak').textContent = longestLossStreak;
            document.getElementById('account-detail-hold-time').textContent = avgHoldTimeText;

            const lsBody = document.getElementById('account-long-short-analysis');
            lsBody.innerHTML = `
                <tr>
                    <td>Compras</td><td>${longStats.count}</td>
                    <td class="${longStats.totalPL >= 0 ? 'text-positive' : 'text-negative'}">${formatCurrency(longStats.totalPL, account.currency, account.currency)}</td>
                    <td class="text-green">${longStats.winRate.toFixed(1)}%</td>
                </tr>
                <tr>
                    <td>Ventas</td><td>${shortStats.count}</td>
                    <td class="${shortStats.totalPL >= 0 ? 'text-positive' : 'text-negative'}">${formatCurrency(shortStats.totalPL, account.currency, account.currency)}</td>
                    <td class="text-green">${shortStats.winRate.toFixed(1)}%</td>
                </tr>`;

            const accountDetailTimeRangeContainer = document.getElementById('account-detail-time-range');
            accountDetailTimeRangeContainer.querySelectorAll('.time-range-btn').forEach(btn => btn.classList.remove('active'));
            const allButtonAccountDetail = Array.from(accountDetailTimeRangeContainer.querySelectorAll('.time-range-btn')).find(btn => btn.dataset.range === 'ALL');
            if (allButtonAccountDetail) allButtonAccountDetail.classList.add('active');

            updateAccountDetailChart(account, operations, 'ALL');
            updateAccountDetailRadarChart(operations, accountId); // <-- Nueva llamada
            
            // Actualizar nuevos gráficos para account details
            updateAccountReduccionAcumuladaChart(operations, account, 'ALL');
            updateAccountPnLAcumuladoChart(operations, account, 'ALL');
            updateAccountDailyPnLChart(operations, account);
            updateAccountDailyWinLossChart(operations, account);
            
            updateBestWorstTrades(account, sortedOps);
            detailsSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        function updateBestWorstTrades(account, sortedOperations) {
            const bestTradesBody = document.getElementById('best-trades');
            const worstTradesBody = document.getElementById('worst-trades');
            if (!bestTradesBody || !worstTradesBody) return;
            bestTradesBody.innerHTML = ''; worstTradesBody.innerHTML = '';

            const best5 = [...sortedOperations].sort((a, b) => b.pl - a.pl).filter(op => op.pl > 0).slice(0, 5);
            const worst5 = [...sortedOperations].sort((a, b) => a.pl - b.pl).filter(op => op.pl < 0).slice(0, 5);

            const populateTable = (tbody, ops) => {
                if (ops.length === 0) { tbody.innerHTML = '<tr><td colspan="3" class="text-center text-text-secondary py-4">No hay operaciones</td></tr>'; return; }
                ops.forEach(op => {
                    const plClass = op.pl >= 0 ? 'text-positive' : 'text-negative';
                    const row = tbody.insertRow(); // Insertar la fila
                    row.dataset.id = op.id; // Añadir data-id a la fila
                    row.classList.add('cursor-pointer'); // Añadir clase para hacerla clicable

                    row.innerHTML = `
                        <td>${formatDate(op.date)}</td>
                        <td>${op.instrument}</td>
                        <td class="${plClass}">${formatCurrency(op.pl, op.currency, op.currency)}</td>`;
                });
            };
            populateTable(bestTradesBody, best5);
            populateTable(worstTradesBody, worst5);

            // Añadir event listeners a las tablas de mejores y peores operaciones
            bestTradesBody.querySelectorAll('tr').forEach(row => {
                row.addEventListener('click', () => {
                    const operationId = row.dataset.id;
                    if (operationId) showOperationDetailPage(operationId);
                });
            });
            worstTradesBody.querySelectorAll('tr').forEach(row => {
                row.addEventListener('click', () => {
                    const operationId = row.dataset.id;
                    if (operationId) showOperationDetailPage(operationId);
                });
            });
        }

        async function processCSVFile(file, statusDiv) {
            showLoading(true);
            const csvText = await file.text();
            const parsedData = parseCSV(csvText);

            if (!parsedData.headers || parsedData.rows.length === 0) {
                throw new Error("CSV vacío o formato de cabecera incorrecto.");
            }

            const headerMap = {};
            parsedData.headers.forEach((header, index) => {
                const normalizedHeader = header.toLowerCase().trim().replace(/\s+/g, ' ').replace(/\//g, '');
                headerMap[normalizedHeader] = index;
            });

            const requiredHeaders = ['nombre cuenta', 'id', 'fecha', 'instrumento', 'tipo', 'volumen', 'divisa'];
            for (const reqHeader of requiredHeaders) {
                if (!(reqHeader in headerMap)) {
                    throw new Error(`Cabecera requerida no encontrada en CSV: '${reqHeader}'.`);
                }
            }

            let importedOpsCount = 0;
            let skippedOpsCount = 0;
            const operationsMap = new Map();

            for (const row of parsedData.rows) {
                const opId = row[headerMap['id']];
                if (!opId || opId.trim() === "") {
                    skippedOpsCount++;
                    continue;
                }

                const accountNameFromCsv = row[headerMap['nombre cuenta']];
                const account = DB.accounts.find(acc => acc.name.trim().toLowerCase() === accountNameFromCsv.trim().toLowerCase());
                if (!account) {
                    console.warn(`Cuenta no encontrada: "${accountNameFromCsv}". Operación omitida.`);
                    skippedOpsCount++;
                    continue;
                }

                const dateStr = row[headerMap['fecha']];
                let opDate;
                const cleanDateStr = dateStr.trim();
                if (cleanDateStr.includes('-')) {
                    const parts = cleanDateStr.split('-');
                    if (parts.length === 3 && parts[0].length === 4) {
                        opDate = `${parts[0]}-${parts[1].padStart(2, '0')}-${parts[2].padStart(2, '0')}`;
                    }
                } else if (cleanDateStr.includes('/')) {
                    const parts = cleanDateStr.split('/');
                    if (parts.length === 3) {
                        opDate = `${parts[2]}-${parts[1].padStart(2, '0')}-${parts[0].padStart(2, '0')}`;
                    }
                }

                if (!opDate) {
                    console.warn(`Fecha inválida: "${dateStr}". Operación omitida.`);
                    skippedOpsCount++;
                    continue;
                }

                const instrument = row[headerMap['instrumento']].toUpperCase().trim();
                const type = row[headerMap['tipo']].toLowerCase().trim();
                const entryTime = row[headerMap['hora entrada']] || null;
                const exitTime = row[headerMap['hora salida']] || null;
                const entry = parseFloat(String(row[headerMap['entrada']]).replace(',', '.'));
                const exit = parseFloat(String(row[headerMap['salida']]).replace(',', '.'));
                const volume = parseFloat(String(row[headerMap['volumen']]).replace(',', '.'));
                const currency = row[headerMap['divisa']].toUpperCase().trim();
                const notes = headerMap['notas'] !== undefined ? row[headerMap['notas']] : '';
                const fees = parseFloat(String(row[headerMap['tarifa comision']]).replace(',', '.')) || 0;
                let pl = (headerMap['p&l'] !== undefined && row[headerMap['p&l']] && String(row[headerMap['p&l']]).trim() !== "")
                    ? parseFloat(String(row[headerMap['p&l']]).replace(',', '.'))
                    : (exit - entry) * volume * (type === 'buy' ? 1 : -1);

                if (operationsMap.has(opId)) {
                    const existingOp = operationsMap.get(opId);
                    existingOp.pl += pl;
                    existingOp.volume += volume;
                    existingOp.fees += fees;
                    existingOp.exitTime = exitTime || existingOp.exitTime;
                    existingOp.exit = !isNaN(exit) ? exit : existingOp.exit;
                    existingOp.notes = [existingOp.notes, notes].filter(Boolean).join('; ');
                } else {
                    operationsMap.set(opId, {
                        id: opId,
                        date: opDate,
                        accountId: account.id,
                        instrument,
                        type,
                        entry: isNaN(entry) ? null : entry,
                        exit: isNaN(exit) ? null : exit,
                        entryTime,
                        exitTime,
                        volume,
                        pl,
                        currency,
                        notes,
                        fees,
                        result: '',
                        imageDatas: [],
                        manualPL: null,
                        session: null
                    });
                }
            }

            const newOperations = Array.from(operationsMap.values());
            newOperations.forEach(op => {
                op.result = op.pl > 0 ? 'win' : (op.pl < 0 ? 'loss' : 'breakeven');
                importedOpsCount++;
            });

            if (newOperations.length > 0) {
                await dexieDB.operations.bulkPut(newOperations);

                // Merge new/updated operations into DB.operations
                newOperations.forEach(newOp => {
                    const existingOpIndex = DB.operations.findIndex(op => op.id === newOp.id);
                    if (existingOpIndex !== -1) {
                        DB.operations[existingOpIndex] = newOp;
                    } else {
                        DB.operations.push(newOp);
                    }
                });

                updateAccountBalances();
                refreshAllViews();
            }

            if (statusDiv) {
                statusDiv.textContent = `Importación completada: ${importedOpsCount} operaciones añadidas, ${skippedOpsCount} omitidas.`;
                statusDiv.className = 'mt-2 text-sm text-positive';
            }

            showLoading(false);
        }

        // ===== FUNDED ACCOUNTS =====
        function initFunded() {
            console.log('🏆 Inicializando Funded Accounts...');

            // Lógica para el cambio de pestañas en la sección Funded
            const fundedTabs = document.querySelectorAll('#funded .funded-tab');
            const fundedViews = document.querySelectorAll('#funded .funded-view');

            fundedTabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    // Desactivar todas las pestañas y vistas
                    fundedTabs.forEach(t => {
                        t.classList.remove('active');
                        t.style.color = 'var(--text-secondary)';
                        t.style.borderBottomColor = 'transparent';
                        t.style.fontWeight = 'normal';
                    });
                    fundedViews.forEach(v => {
                        if (v) v.classList.remove('active');
                    });

                    // Activar la pestaña y vista seleccionada
                    tab.classList.add('active');
                    tab.style.color = 'var(--text)';
                    tab.style.borderBottomColor = 'var(--primary)';
                    tab.style.fontWeight = '600';
                    
                    const targetViewId = tab.dataset.target;
                    const targetView = document.getElementById(targetViewId);
                    if (targetView) {
                        targetView.classList.add('active');
                    }
                    
                    // Renderizar métricas si se selecciona esa vista
                    if (targetViewId === 'funded-metrics-view') {
                        setTimeout(() => renderFundedMetrics(), 100);
                    }
                });
            });

            
            // Verificar elementos de pestañas y vistas
            const fundedElements = {
                tabAccounts: document.getElementById('funded-tab-accounts'),
                viewAccounts: document.getElementById('funded-accounts-view'),
                calendarContainer: document.getElementById('funded-calendar-container'),
                calendarMonthYear: document.getElementById('funded-calendar-month-year'),
                calendarPrev: document.getElementById('funded-calendar-prev'),
                calendarNext: document.getElementById('funded-calendar-next')
            };
            
            console.log('🔍 Verificando elementos de Funded:', {
                viewAccounts: !!fundedElements.viewAccounts,
                calendarContainer: !!fundedElements.calendarContainer,
                calendarMonthYear: !!fundedElements.calendarMonthYear,
                calendarPrev: !!fundedElements.calendarPrev,
                calendarNext: !!fundedElements.calendarNext
            });

            // Elementos DOM
            const modal = document.getElementById('funded-account-modal');
            const openBtn = document.getElementById('add-funded-account-btn');
            const closeBtn = document.getElementById('close-funded-modal');
            const cancelBtn = document.getElementById('cancel-funded-account');
            const form = document.getElementById('funded-account-form');
            const companySelect = document.getElementById('funded-company');
            const customCompanyContainer = document.getElementById('funded-custom-company-container');
            const typeSelect = document.getElementById('funded-type');
            const earningsContainer = document.getElementById('funded-earnings-container');
            const withdrawalsContainer = document.getElementById('funded-withdrawals-container');

            let currentFilter = 'all';
            let currentDateFilter = { type: 'all', startDate: null, endDate: null };
            let editingAccountId = null;

            // Abrir modal para nueva cuenta
            if (openBtn) {
                openBtn.addEventListener('click', () => {
                    editingAccountId = null;
                    form.reset();
                    document.getElementById('funded-modal-title').textContent = 'Nueva Cuenta Funded';
                    document.getElementById('funded-type').value = 'evaluation';
                    toggleEarningsFields('evaluation');
                    modal.style.display = 'flex';
                });
            }

            // Cerrar modal
            if (closeBtn) closeBtn.addEventListener('click', () => modal.style.display = 'none');
            if (cancelBtn) cancelBtn.addEventListener('click', () => modal.style.display = 'none');
            if (modal) {
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) modal.style.display = 'none';
                });
            }

            // Mostrar/ocultar empresa personalizada
            if (companySelect) {
                companySelect.addEventListener('change', (e) => {
                    customCompanyContainer.style.display = e.target.value === 'Otra' ? 'block' : 'none';
                });
            }

            // Mostrar/ocultar campos de ganancias según tipo
            if (typeSelect) {
                typeSelect.addEventListener('change', (e) => {
                    toggleEarningsFields(e.target.value);
                });
            }

            function toggleEarningsFields(type) {
                const isLive = type === 'live';
                earningsContainer.style.display = isLive ? 'block' : 'none';
                withdrawalsContainer.style.display = isLive ? 'block' : 'none';
                if (!isLive) {
                    document.getElementById('funded-earnings').value = '';
                    document.getElementById('funded-withdrawals-count').value = '';
                }
            }

            // Guardar cuenta
            if (form) {
                form.addEventListener('submit', async (e) => {
                    e.preventDefault();

                    const companyValue = document.getElementById('funded-company').value;
                    const company = companyValue === 'Otra' 
                        ? document.getElementById('funded-custom-company').value 
                        : companyValue;

                    const account = {
                        id: editingAccountId || generateId(),
                        name: document.getElementById('funded-name').value,
                        company: company,
                        type: document.getElementById('funded-type').value,
                        status: document.getElementById('funded-status').value,
                        fee: parseFloat(document.getElementById('funded-fee').value) || 0,
                        balance: parseFloat(document.getElementById('funded-balance').value) || 0,
                        activationDate: document.getElementById('funded-activation-date').value,
                        earnings: parseFloat(document.getElementById('funded-earnings').value) || 0,
                        withdrawals: parseInt(document.getElementById('funded-withdrawals-count').value) || 0,
                        notes: document.getElementById('funded-notes').value,
                        createdAt: editingAccountId ? DB.fundedAccounts.find(a => a.id === editingAccountId)?.createdAt : new Date().toISOString(),
                        updatedAt: new Date().toISOString()
                    };

                    try {
                        if (editingAccountId) {
                            // Obtener cuenta anterior para comparar
                            const previousAccount = DB.fundedAccounts.find(a => a.id === editingAccountId);
                            
                            const index = DB.fundedAccounts.findIndex(a => a.id === editingAccountId);
                            DB.fundedAccounts[index] = account;
                            await dexieDB.fundedAccounts.put(account);
                            await saveFundedAccountToSupabase(account);
                            
                            // Crear registro histórico si cambió de activo a suspendido
                            if (previousAccount && previousAccount.status === 'active' && account.status === 'suspended') {
                                if (typeof createFundedAccountHistoryRecord === 'function') {
                                    await createFundedAccountHistoryRecord(account, 'suspended');
                                }
                            }
                            
                            showNotification('Cuenta actualizada correctamente', 'success');
                        } else {
                            DB.fundedAccounts.push(account);
                            await dexieDB.fundedAccounts.add(account);
                            await saveFundedAccountToSupabase(account);
                            showNotification('Cuenta creada correctamente', 'success');
                        }

                        modal.style.display = 'none';
                        refreshFunded();
                    } catch (error) {
                        console.error('Error guardando cuenta:', error);
                        showNotification('Error al guardar la cuenta', 'error');
                    }
                });
            }

            // Filtros de estado
            document.querySelectorAll('.funded-filter-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('.funded-filter-btn').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    currentFilter = e.target.dataset.filter;
                    renderAccountsTable();
                });
            });

            // Filtro de fecha
            const dateFilterBtn = document.getElementById('funded-date-filter-btn');
            if (dateFilterBtn) {
                dateFilterBtn.addEventListener('click', () => {
                    const calendar = document.getElementById('calendar-modal');
                    if (calendar) {
                        calendar.style.display = 'flex';
                        calendar.dataset.targetSection = 'funded';
                    }
                });
            }

            // Renderizar tabla de cuentas
            function renderAccountsTable() {
                const tbody = document.getElementById('funded-accounts-table');
                if (!tbody) return;

                console.log('🔍 renderAccountsTable - DB.fundedAccounts:', DB.fundedAccounts);
                console.log('🔍 renderAccountsTable - Total cuentas:', DB.fundedAccounts?.length);

                let accounts = [...DB.fundedAccounts];

                // Aplicar filtro de estado
                if (currentFilter !== 'all') {
                    if (currentFilter === 'evaluation') {
                        accounts = accounts.filter(a => a.type === 'evaluation');
                    } else if (currentFilter === 'live') {
                        accounts = accounts.filter(a => a.type === 'live');
                    } else if (currentFilter === 'active') {
                        accounts = accounts.filter(a => a.status === 'active');
                    } else if (currentFilter === 'suspended') {
                        accounts = accounts.filter(a => a.status === 'suspended');
                    }
                }

                console.log('🔍 Después de filtros - accounts:', accounts);
                accounts.forEach(acc => {
                    console.log(`   ${acc.name}: balance=${acc.balance}, earnings=${acc.earnings}, fee=${acc.fee}, withdrawals=${acc.withdrawals?.length || 0}`);
                });

                // Aplicar filtro de fecha
                if (currentDateFilter.type !== 'all' && currentDateFilter.startDate) {
                    accounts = accounts.filter(a => {
                        const date = new Date(a.activationDate);
                        return date >= new Date(currentDateFilter.startDate) && 
                               date <= new Date(currentDateFilter.endDate);
                    });
                }

                if (accounts.length === 0) {
                    tbody.innerHTML = `
                        <tr>
                            <td colspan="9" class="text-center text-text-secondary py-8">
                                No hay cuentas que coincidan con los filtros
                            </td>
                        </tr>
                    `;
                    return;
                }

                tbody.innerHTML = accounts.map(account => {
                    const beneficio = account.earnings - account.fee;
                    const beneficioClass = beneficio >= 0 ? 'text-green' : 'text-red';
                    const statusBadge = account.status === 'active' 
                        ? '<span class="badge badge-success">Activa</span>' 
                        : '<span class="badge badge-danger">Suspendida</span>';
                    const typeBadge = account.type === 'evaluation' 
                        ? '<span class="badge badge-warning">Evaluación</span>' 
                        : '<span class="badge badge-primary">Live</span>';

                    // Obtener lista de retiros
                    const withdrawals = Array.isArray(account.withdrawals) ? account.withdrawals : [];
                    const withdrawalsCount = withdrawals.length;
                    
                    // Generar HTML de retiros
                    const withdrawalsHTML = withdrawals.length > 0 
                        ? withdrawals.map(w => `
                            <div class="flex justify-between items-center py-2 px-3 bg-surface rounded mb-2">
                                <div class="flex-1">
                                    <span class="text-sm font-semibold text-green">$${parseFloat(w.amount).toFixed(2)}</span>
                                    <span class="text-xs text-text-secondary ml-2">${new Date(w.date).toLocaleDateString('es-ES')}</span>
                                    ${w.notes ? `<span class="text-xs text-text-secondary italic ml-2">- ${w.notes}</span>` : ''}
                                </div>
                                <button onclick="deleteWithdrawal('${account.id}', '${w.id}')" class="text-red hover:text-red-light ml-2" title="Eliminar retiro">
                                    <i class="fas fa-trash text-xs"></i>
                                </button>
                            </div>
                        `).join('')
                        : '<p class="text-xs text-text-secondary text-center py-3">No hay retiros registrados</p>';

                    return `
                        <tr>
                            <td class="font-medium">
                                ${account.name}
                                ${withdrawalsCount > 0 ? `
                                    <button onclick="toggleWithdrawalsRow('${account.id}')" class="ml-2 text-xs text-primary hover:text-secondary" title="Ver retiros">
                                        <i class="fas fa-chevron-down" id="chevron-${account.id}"></i>
                                        <span class="ml-1">(${withdrawalsCount})</span>
                                    </button>
                                ` : ''}
                            </td>
                            <td class="text-center">${typeBadge}</td>
                            <td class="text-center">${statusBadge}</td>
                            <td>${account.company}</td>
                            <td class="text-right text-white font-semibold">$${(account.balance || 0).toFixed(2)}</td>
                            <td class="text-right text-red">$${account.fee.toFixed(2)}</td>
                            <td class="text-right text-green">$${account.earnings.toFixed(2)}</td>
                            <td class="text-right ${beneficioClass} font-bold">$${beneficio.toFixed(2)}</td>
                            <td class="text-center">
                                ${account.type === 'live' ? `
                                    <button onclick="openWithdrawalModal('${account.id}')" class="text-green hover:text-primary" title="Registrar Retiro">
                                        <i class="fas fa-money-bill-wave"></i>
                                    </button>
                                ` : ''}
                                ${account.status === 'active' ? `
                                    <button onclick="suspendFundedAccount('${account.id}')" class="text-yellow-500 hover:text-yellow-300 ml-2" title="Suspender Cuenta">
                                        <i class="fas fa-pause-circle"></i>
                                    </button>
                                ` : `
                                    <button onclick="activateFundedAccount('${account.id}')" class="text-blue-500 hover:text-blue-300 ml-2" title="Reactivar Cuenta">
                                        <i class="fas fa-play-circle"></i>
                                    </button>
                                `}
                                <button onclick="editFundedAccount('${account.id}')" class="text-primary hover:text-primary-light ml-2" title="Editar">
                                    <i class="fas fa-edit"></i>
                                </button>
                                <button onclick="deleteFundedAccount('${account.id}')" class="text-red hover:text-red-light ml-2" title="Eliminar">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </td>
                        </tr>
                        ${withdrawalsCount > 0 ? `
                        <tr id="withdrawals-row-${account.id}" style="display: none;">
                            <td colspan="9" class="bg-surface-light">
                                <div class="p-4">
                                    <h4 class="text-sm font-semibold mb-3 text-primary">
                                        <i class="fas fa-money-bill-wave mr-2"></i>Historial de Retiros (${withdrawalsCount})
                                    </h4>
                                    ${withdrawalsHTML}
                                </div>
                            </td>
                        </tr>
                        ` : ''}
                    `;
                }).join('');
            }

            // Editar cuenta
            window.editFundedAccount = function(id) {
                const account = DB.fundedAccounts.find(a => a.id === id);
                if (!account) return;

                editingAccountId = id;
                document.getElementById('funded-modal-title').textContent = 'Editar Cuenta Funded';
                document.getElementById('funded-account-id').value = account.id;
                document.getElementById('funded-name').value = account.name;
                
                const companySelect = document.getElementById('funded-company');
                const isCustom = !Array.from(companySelect.options).some(opt => opt.value === account.company);
                if (isCustom) {
                    companySelect.value = 'Otra';
                    document.getElementById('funded-custom-company').value = account.company;
                    customCompanyContainer.style.display = 'block';
                } else {
                    companySelect.value = account.company;
                    customCompanyContainer.style.display = 'none';
                }

                document.getElementById('funded-type').value = account.type;
                document.getElementById('funded-status').value = account.status;
                document.getElementById('funded-fee').value = account.fee;
                document.getElementById('funded-balance').value = account.balance || 0;
                document.getElementById('funded-activation-date').value = account.activationDate;
                document.getElementById('funded-earnings').value = account.earnings || '';
                document.getElementById('funded-withdrawals-count').value = account.withdrawals || '';
                document.getElementById('funded-notes').value = account.notes || '';
                
                toggleEarningsFields(account.type);
                modal.style.display = 'flex';
            };

            // Eliminar cuenta
            window.deleteFundedAccount = async function(id) {
                if (!confirm('¿Estás seguro de eliminar esta cuenta? Esta acción no se puede deshacer.')) return;

                try {
                    // Encontrar la cuenta antes de eliminarla
                    const account = DB.fundedAccounts.find(a => a.id === id);
                    
                    // Crear registro histórico antes de eliminar
                    if (account && typeof createFundedAccountHistoryRecord === 'function') {
                        await createFundedAccountHistoryRecord(account, 'deleted');
                    }
                    
                    // Eliminar cuenta
                    DB.fundedAccounts = DB.fundedAccounts.filter(a => a.id !== id);
                    await dexieDB.fundedAccounts.delete(id);
                    await deleteFundedAccountFromSupabase(id);
                    
                    showNotification('Cuenta eliminada y archivada correctamente', 'success');
                    refreshFunded();
                } catch (error) {
                    console.error('Error eliminando cuenta:', error);
                    showNotification('Error al eliminar la cuenta', 'error');
                }
            };

            // Suspender cuenta manualmente
            window.suspendFundedAccount = async function(id) {
                if (!confirm('¿Deseas suspender esta cuenta? Se desactivará automáticamente de todas las secciones.')) return;

                try {
                    const account = DB.fundedAccounts.find(a => a.id === id);
                    if (!account) {
                        showNotification('Cuenta no encontrada', 'error');
                        return;
                    }

                    // Crear registro histórico antes de suspender
                    if (typeof createFundedAccountHistoryRecord === 'function') {
                        await createFundedAccountHistoryRecord(account, 'suspended');
                    }

                    // Actualizar estado a suspendida en funded accounts
                    account.status = 'suspended';
                    account.updatedAt = new Date().toISOString();

                    // Guardar cambios en funded accounts
                    await dexieDB.fundedAccounts.put(account);
                    await saveFundedAccountToSupabase(account);

                    // Buscar y eliminar cuenta vinculada en DB.accounts (por nombre)
                    const linkedAccount = DB.accounts.find(acc => 
                        acc.name && account.name && 
                        acc.name.trim().toLowerCase() === account.name.trim().toLowerCase()
                    );

                    if (linkedAccount) {
                        console.log('🔗 Eliminando cuenta vinculada de DB.accounts:', linkedAccount.name);
                        
                        // Eliminar de DB.accounts
                        DB.accounts = DB.accounts.filter(acc => acc.id !== linkedAccount.id);
                        
                        // Eliminar de IndexedDB
                        await dexieDB.accounts.delete(linkedAccount.id);
                        
                        // Eliminar de Supabase
                        if (typeof currentUser !== 'undefined' && currentUser) {
                            await window.supabase
                                .from('accounts')
                                .delete()
                                .eq('id', linkedAccount.id)
                                .eq('user_id', currentUser.id);
                        }
                        
                        // Refrescar selector de cuentas
                        if (typeof refreshAccountSelector === 'function') {
                            refreshAccountSelector();
                        }
                    }

                    showNotification('Cuenta suspendida y removida de todas las secciones', 'warning');
                    refreshFunded();
                } catch (error) {
                    console.error('Error suspendiendo cuenta:', error);
                    showNotification('Error al suspender la cuenta', 'error');
                }
            };

            // Reactivar cuenta
            window.activateFundedAccount = async function(id) {
                if (!confirm('¿Deseas reactivar esta cuenta? Volverá a aparecer en todas las secciones.')) return;

                try {
                    const account = DB.fundedAccounts.find(a => a.id === id);
                    if (!account) {
                        showNotification('Cuenta no encontrada', 'error');
                        return;
                    }

                    // Actualizar estado a activa
                    account.status = 'active';
                    account.updatedAt = new Date().toISOString();

                    // Guardar cambios en funded accounts
                    await dexieDB.fundedAccounts.put(account);
                    await saveFundedAccountToSupabase(account);

                    // Verificar si ya existe la cuenta vinculada
                    const existingAccount = DB.accounts.find(acc => 
                        acc.name && account.name && 
                        acc.name.trim().toLowerCase() === account.name.trim().toLowerCase()
                    );

                    if (!existingAccount) {
                        console.log('🔗 Recreando cuenta vinculada en DB.accounts:', account.name);
                        
                        // Crear cuenta vinculada en DB.accounts
                        const linkedAccount = {
                            id: generateId(),
                            name: account.name,
                            platform: account.company || 'Funded',
                            initialBalance: account.balance || 0,
                            balance: account.balance || 0,
                            currency: 'USD',
                            accountType: 'funded',
                            fundedAccountId: account.id,
                            createdAt: new Date().toISOString()
                        };

                        // Agregar a DB.accounts
                        DB.accounts.push(linkedAccount);
                        
                        // Guardar en IndexedDB
                        await dexieDB.accounts.add(linkedAccount);
                        
                        // Guardar en Supabase
                        if (typeof saveAccountToSupabase === 'function') {
                            await saveAccountToSupabase(linkedAccount);
                        }
                        
                        // Refrescar selector de cuentas
                        if (typeof refreshAccountSelector === 'function') {
                            refreshAccountSelector();
                        }
                    }

                    showNotification('Cuenta reactivada correctamente', 'success');
                    refreshFunded();
                } catch (error) {
                    console.error('Error reactivando cuenta:', error);
                    showNotification('Error al reactivar la cuenta', 'error');
                }
            };

            // Expandir/contraer fila de retiros
            window.toggleWithdrawalsRow = function(accountId) {
                const row = document.getElementById(`withdrawals-row-${accountId}`);
                const chevron = document.getElementById(`chevron-${accountId}`);
                
                if (!row || !chevron) return;
                
                if (row.style.display === 'none') {
                    row.style.display = 'table-row';
                    chevron.classList.remove('fa-chevron-down');
                    chevron.classList.add('fa-chevron-up');
                } else {
                    row.style.display = 'none';
                    chevron.classList.remove('fa-chevron-up');
                    chevron.classList.add('fa-chevron-down');
                }
            };

            // Eliminar retiro individual
            window.deleteWithdrawal = async function(accountId, withdrawalId) {
                if (!confirm('¿Estás seguro de eliminar este retiro?')) return;

                try {
                    console.log('🗑️ Eliminando retiro:', withdrawalId, 'de cuenta:', accountId);
                    
                    // Buscar la cuenta
                    const account = DB.fundedAccounts.find(a => a.id === accountId);
                    if (!account) {
                        showNotification('Cuenta no encontrada', 'error');
                        return;
                    }

                    // Verificar que withdrawals sea un array
                    if (!Array.isArray(account.withdrawals)) {
                        account.withdrawals = [];
                    }

                    // Buscar el retiro a eliminar
                    const withdrawalIndex = account.withdrawals.findIndex(w => w.id === withdrawalId);
                    if (withdrawalIndex === -1) {
                        showNotification('Retiro no encontrado', 'error');
                        return;
                    }

                    const withdrawalAmount = account.withdrawals[withdrawalIndex].amount;

                    // Eliminar el retiro del array
                    account.withdrawals.splice(withdrawalIndex, 1);

                    // Recalcular earnings (suma de todos los retiros restantes)
                    account.earnings = account.withdrawals.reduce((sum, w) => sum + parseFloat(w.amount || 0), 0);

                    console.log('✅ Retiro eliminado. Nuevos earnings:', account.earnings);
                    console.log('✅ Retiros restantes:', account.withdrawals.length);

                    // Guardar en Supabase
                    await saveFundedAccountToSupabase(account);

                    // Recargar cuentas desde Supabase para sincronizar
                    await loadFundedAccountsFromSupabase();

                    // Refrescar UI
                    refreshFunded();

                    showNotification('Retiro eliminado correctamente', 'success');
                } catch (error) {
                    console.error('❌ Error eliminando retiro:', error);
                    showNotification('Error al eliminar el retiro', 'error');
                }
            };

            // Calcular métricas
            function calculateMetrics(accounts) {
                const evaluations = accounts.filter(a => a.type === 'evaluation').length;
                const inProgress = accounts.filter(a => a.type === 'evaluation' && a.status === 'active').length;
                const liveAccounts = accounts.filter(a => a.type === 'live').length;
                const totalExpenses = accounts.reduce((sum, a) => sum + a.fee, 0);
                const totalEarnings = accounts.reduce((sum, a) => sum + a.earnings, 0);
                const netProfit = totalEarnings - totalExpenses;
                const fundingRatio = evaluations > 0 ? (liveAccounts / evaluations * 100) : 0;
                const roi = totalExpenses > 0 ? (netProfit / totalExpenses * 100) : 0;

                return {
                    evaluations,
                    inProgress,
                    liveAccounts,
                    totalExpenses,
                    totalEarnings,
                    netProfit,
                    fundingRatio,
                    roi
                };
            }

            // Renderizar dashboard
            function renderDashboard() {
                let accounts = [...DB.fundedAccounts];

                // Aplicar filtro de fecha
                if (currentDateFilter.type !== 'all' && currentDateFilter.startDate) {
                    accounts = accounts.filter(a => {
                        const date = new Date(a.activationDate);
                        return date >= new Date(currentDateFilter.startDate) && 
                               date <= new Date(currentDateFilter.endDate);
                    });
                }

                const metrics = calculateMetrics(accounts);

                document.getElementById('funded-evaluations').textContent = metrics.evaluations;
                document.getElementById('funded-in-progress').textContent = metrics.inProgress;
                document.getElementById('funded-live-accounts').textContent = metrics.liveAccounts;
                document.getElementById('funded-ratio').textContent = `${metrics.fundingRatio.toFixed(1)}%`;
                document.getElementById('funded-total-expenses').textContent = `€${metrics.totalExpenses.toFixed(2)}`;
                document.getElementById('funded-total-earnings').textContent = `€${metrics.totalEarnings.toFixed(2)}`;
                
                const netProfitEl = document.getElementById('funded-net-profit');
                netProfitEl.textContent = `€${metrics.netProfit.toFixed(2)}`;
                netProfitEl.className = `text-4xl font-bold ${metrics.netProfit >= 0 ? 'text-green' : 'text-red'}`;

                document.getElementById('funded-roi-display').textContent = `${metrics.roi.toFixed(1)}%`;
                
                // Calculate total balance from active live accounts
                const totalBalance = accounts
                    .filter(a => a.type === 'live' && a.status === 'active')
                    .reduce((sum, a) => sum + (a.balance || 0), 0);
                document.getElementById('funded-total-balance-display').textContent = `€${totalBalance.toFixed(2)}`;

                // Estadísticas calculadas
                // Agrupar por fecha de activación para encontrar mejor/peor día
                const accountsByDate = {};
                accounts.forEach(account => {
                    const date = account.activationDate;
                    if (!accountsByDate[date]) {
                        accountsByDate[date] = {
                            earnings: 0,
                            expenses: 0
                        };
                    }
                    accountsByDate[date].earnings += account.earnings || 0;
                    accountsByDate[date].expenses += account.fee || 0;
                });

                // Mejor día: día con mayores retiros/ganancias
                let bestDay = 0;
                let worstDay = 0;
                Object.values(accountsByDate).forEach(day => {
                    if (day.earnings > bestDay) bestDay = day.earnings;
                    if (day.expenses > worstDay) worstDay = day.expenses;
                });

                // Promedio diario de retiros
                const totalDays = Object.keys(accountsByDate).length || 1;
                const totalEarnings = metrics.totalEarnings;
                const avgDaily = totalEarnings / totalDays;

                // Total de retiros (número de retiros realizados)
                const totalWithdrawals = accounts.reduce((sum, a) => {
                    // Si withdrawals es un array, contar sus elementos
                    if (Array.isArray(a.withdrawals)) {
                        return sum + a.withdrawals.length;
                    }
                    // Si es un número, sumarlo directamente (compatibilidad)
                    return sum + (a.withdrawals || 0);
                }, 0);

                document.getElementById('funded-best-day').textContent = `€${bestDay.toFixed(2)}`;
                document.getElementById('funded-worst-day').textContent = `€${worstDay.toFixed(2)}`;
                document.getElementById('funded-avg-daily').textContent = `€${avgDaily.toFixed(2)}`;
                document.getElementById('funded-withdrawals').textContent = totalWithdrawals;
            }

            // Renderizar análisis por empresa
            function renderCompanyAnalysis() {
                const companies = {};

                DB.fundedAccounts.forEach(account => {
                    if (!companies[account.company]) {
                        companies[account.company] = {
                            name: account.company,
                            count: 0,
                            expenses: 0,
                            earnings: 0,
                            profit: 0,
                            roi: 0
                        };
                    }

                    companies[account.company].count++;
                    companies[account.company].expenses += account.fee;
                    companies[account.company].earnings += account.earnings;
                });

                Object.values(companies).forEach(company => {
                    company.profit = company.earnings - company.expenses;
                    company.roi = company.expenses > 0 ? (company.profit / company.expenses * 100) : 0;
                });

                const companiesArray = Object.values(companies);

                // Top por ROI
                const topRoi = [...companiesArray].sort((a, b) => b.roi - a.roi).slice(0, 3);
                const topRoiContainer = document.getElementById('funded-top-roi');
                if (topRoi.length === 0) {
                    topRoiContainer.innerHTML = '<p class="text-sm text-text-secondary text-center py-8">No hay datos disponibles</p>';
                } else {
                    topRoiContainer.innerHTML = topRoi.map((company, index) => `
                        <div class="flex items-center justify-between p-3 bg-surface rounded">
                            <div class="flex items-center gap-3">
                                <div class="w-8 h-8 rounded-full ${index === 0 ? 'bg-warning' : index === 1 ? 'bg-gray-400' : 'bg-orange-600'} flex items-center justify-center text-white font-bold">
                                    ${index + 1}
                                </div>
                                <div>
                                    <p class="font-medium">${company.name}</p>
                                    <p class="text-xs text-text-secondary">${company.count} cuenta${company.count !== 1 ? 's' : ''}</p>
                                </div>
                            </div>
                            <div class="text-right">
                                <p class="text-lg font-bold ${company.roi >= 0 ? 'text-green' : 'text-red'}">${company.roi.toFixed(1)}%</p>
                                <p class="text-xs text-text-secondary">€${company.profit.toFixed(2)}</p>
                            </div>
                        </div>
                    `).join('');
                }

                // Top por Retiros
                const topWithdrawals = [...companiesArray].sort((a, b) => b.earnings - a.earnings).slice(0, 3);
                const topWithdrawalsContainer = document.getElementById('funded-top-withdrawals');
                if (topWithdrawals.length === 0) {
                    topWithdrawalsContainer.innerHTML = '<p class="text-sm text-text-secondary text-center py-8">No hay datos disponibles</p>';
                } else {
                    topWithdrawalsContainer.innerHTML = topWithdrawals.map((company, index) => `
                        <div class="flex items-center justify-between p-3 bg-surface rounded">
                            <div class="flex items-center gap-3">
                                <div class="w-8 h-8 rounded-full ${index === 0 ? 'bg-green' : index === 1 ? 'bg-gray-400' : 'bg-orange-600'} flex items-center justify-center text-white font-bold">
                                    ${index + 1}
                                </div>
                                <div>
                                    <p class="font-medium">${company.name}</p>
                                    <p class="text-xs text-text-secondary">${company.count} cuenta${company.count !== 1 ? 's' : ''}</p>
                                </div>
                            </div>
                            <div class="text-right">
                                <p class="text-lg font-bold text-green">€${company.earnings.toFixed(2)}</p>
                                <p class="text-xs text-text-secondary">Promedio: €${(company.earnings / company.count).toFixed(2)}</p>
                            </div>
                        </div>
                    `).join('');
                }

                // Tabla de todas las empresas
                const tbody = document.getElementById('funded-companies-table');
                if (companiesArray.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="6" class="text-center text-text-secondary py-8">No hay empresas registradas</td></tr>';
                } else {
                    tbody.innerHTML = companiesArray.map(company => `
                        <tr>
                            <td class="font-medium">${company.name}</td>
                            <td class="text-center">${company.count}</td>
                            <td class="text-right text-red">€${company.expenses.toFixed(2)}</td>
                            <td class="text-right text-green">€${company.earnings.toFixed(2)}</td>
                            <td class="text-right ${company.profit >= 0 ? 'text-green' : 'text-red'} font-bold">€${company.profit.toFixed(2)}</td>
                            <td class="text-right ${company.roi >= 0 ? 'text-green' : 'text-red'} font-bold">${company.roi.toFixed(1)}%</td>
                        </tr>
                    `).join('');
                }
            }

            // Refresh completo
            function refreshFunded() {
                // Actualizar selector primero
                populateFundedAccountSelect();
                
                renderDashboard();
                renderAccountsTable();
                renderCompanyAnalysis();
                renderEvolutionChart();
                renderCuentasView(); // Nueva vista de cuentas
                
                // Actualizar el calendario también
                if (typeof renderFundedCalendar === 'function') {
                    renderFundedCalendar();
                }
            }

            // Gráfico de evolución
            function renderEvolutionChart() {
                const canvas = document.getElementById('funded-evolution-chart');
                if (!canvas) return;

                const ctx = canvas.getContext('2d');

                // Destruir gráfico existente usando Chart.js API
                const existingChart = Chart.getChart(canvas);
                if (existingChart) {
                    existingChart.destroy();
                }
                
                // También limpiar la referencia global
                if (window.fundedEvolutionChart) {
                    window.fundedEvolutionChart = null;
                }

                // Crear dataset basado en fechas de activación
                const sortedAccounts = [...DB.fundedAccounts].sort((a, b) => 
                    new Date(a.activationDate) - new Date(b.activationDate)
                );

                if (sortedAccounts.length === 0) {
                    // Mostrar mensaje cuando no hay datos
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.font = '14px Arial';
                    ctx.fillStyle = '#8b949e';
                    ctx.textAlign = 'center';
                    ctx.fillText('No hay datos para mostrar', canvas.width / 2, canvas.height / 2);
                    return;
                }

                let cumulativeProfit = 0;
                const labels = [];
                const data = [];

                sortedAccounts.forEach(account => {
                    cumulativeProfit += (account.earnings - account.fee);
                    labels.push(new Date(account.activationDate).toLocaleDateString('es-ES', { day: '2-digit', month: 'short' }));
                    data.push(cumulativeProfit);
                });

                window.fundedEvolutionChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Beneficio Acumulado',
                            data: data,
                            borderColor: '#39FF14',
                            backgroundColor: 'rgba(57, 255, 20, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.4,
                            pointRadius: 4,
                            pointHoverRadius: 6,
                            pointBackgroundColor: '#39FF14',
                            pointBorderColor: '#fff',
                            pointBorderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                                titleColor: '#fff',
                                bodyColor: '#fff',
                                borderColor: '#39FF14',
                                borderWidth: 1,
                                callbacks: {
                                    label: (context) => `Beneficio: €${context.parsed.y.toFixed(2)}`
                                }
                            }
                        },
                        scales: {
                            x: {
                                grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                ticks: { color: '#8b949e', maxRotation: 45, minRotation: 0 }
                            },
                            y: {
                                grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                ticks: { 
                                    color: '#8b949e',
                                    callback: (value) => `€${value.toFixed(0)}`
                                }
                            }
                        }
                    }
                });
            }

            // ===== VISTA DE CUENTAS: ANÁLISIS INDIVIDUAL Y COMPARATIVO =====
            
            function renderCuentasView() {
                renderFunnel();
                renderAccountsTimeline();
                renderComparatorSelector();
                renderProfitabilityProjections();
            }

            // 1. Embudo de Conversión
            function renderFunnel() {
                const accounts = DB.fundedAccounts || [];
                
                const totalAccounts = accounts.length;
                const liveAccounts = accounts.filter(a => a.type === 'live').length;
                const activeAccounts = accounts.filter(a => a.type === 'live' && a.status === 'active').length;
                
                const approvalRate = totalAccounts > 0 ? (liveAccounts / totalAccounts * 100) : 0;
                const survivalRate = liveAccounts > 0 ? (activeAccounts / liveAccounts * 100) : 0;
                
                const totalInvestment = accounts.reduce((sum, a) => sum + a.fee, 0);
                const costPerLive = liveAccounts > 0 ? (totalInvestment / liveAccounts) : 0;

                // Actualizar métricas
                document.getElementById('funnel-total').textContent = totalAccounts;
                document.getElementById('funnel-approved').textContent = liveAccounts;
                document.getElementById('funnel-approved-percent').textContent = `${approvalRate.toFixed(1)}% de aprobación`;
                document.getElementById('funnel-active').textContent = activeAccounts;
                document.getElementById('funnel-survival-rate').textContent = `Tasa supervivencia: ${survivalRate.toFixed(1)}%`;
                document.getElementById('funnel-cost-per-live').textContent = `€${costPerLive.toFixed(0)}`;

                // Actualizar barras del embudo
                const totalBar = document.getElementById('funnel-bar-total');
                const approvedBar = document.getElementById('funnel-bar-approved');
                const activeBar = document.getElementById('funnel-bar-active');

                if (totalBar) totalBar.querySelector('span').textContent = `Compradas: ${totalAccounts}`;
                if (approvedBar) {
                    approvedBar.querySelector('span').textContent = `Aprobadas: ${liveAccounts}`;
                    approvedBar.style.width = totalAccounts > 0 ? `${(liveAccounts / totalAccounts) * 100}%` : '0%';
                }
                if (activeBar) {
                    activeBar.querySelector('span').textContent = `Activas: ${activeAccounts}`;
                    activeBar.style.width = totalAccounts > 0 ? `${(activeAccounts / totalAccounts) * 100}%` : '0%';
                }

                // Calcular tiempos promedio
                const evalAccounts = accounts.filter(a => a.type === 'evaluation');
                const avgEvalTime = calculateAverageEvalTime(evalAccounts);
                
                const approvedAccounts = accounts.filter(a => a.type === 'live');
                const avgEvalToLive = calculateAverageEvalToLiveTime(approvedAccounts);

                document.getElementById('avg-eval-time').textContent = `${avgEvalTime} días`;
                document.getElementById('avg-eval-to-live').textContent = `${avgEvalToLive} días`;
            }

            function calculateAverageEvalTime(accounts) {
                if (accounts.length === 0) return 0;
                
                const totalDays = accounts.reduce((sum, account) => {
                    const activationDate = new Date(account.activationDate);
                    const today = new Date();
                    const diffTime = Math.abs(today - activationDate);
                    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                    return sum + diffDays;
                }, 0);
                
                return Math.round(totalDays / accounts.length);
            }

            function calculateAverageEvalToLiveTime(accounts) {
                if (accounts.length === 0) return 0;
                
                // Simulación: asumimos que una cuenta tarda entre 30-60 días en pasar de eval a live
                // En un futuro podrías agregar un campo "approvalDate" a las cuentas
                return 45; // Placeholder
            }

            // 2. Timeline de Cuentas
            function renderAccountsTimeline() {
                const container = document.getElementById('accounts-timeline-container');
                if (!container) return;

                const accounts = DB.fundedAccounts || [];
                
                if (accounts.length === 0) {
                    container.innerHTML = '<p class="text-center text-text-secondary py-8">No hay cuentas para mostrar</p>';
                    return;
                }

                container.innerHTML = accounts.map(account => {
                    const activationDate = new Date(account.activationDate);
                    const today = new Date();
                    const daysActive = Math.ceil((today - activationDate) / (1000 * 60 * 60 * 24));
                    
                    const isLive = account.type === 'live';
                    const isActive = account.status === 'active';
                    
                    // Calcular progreso en la timeline
                    let phase = '';
                    let progress = 0;
                    
                    if (account.type === 'evaluation') {
                        phase = 'En Evaluación';
                        progress = Math.min((daysActive / 30) * 50, 50); // Max 50% si está en eval
                    } else if (account.type === 'live') {
                        phase = isActive ? 'Live - Activa' : 'Live - Suspendida';
                        progress = 100;
                    }

                    return `
                        <div class="p-4 bg-surface-light rounded-lg border border-border">
                            <div class="flex flex-wrap items-center justify-between mb-3">
                                <div>
                                    <h4 class="font-bold text-lg">${account.name}</h4>
                                    <p class="text-sm text-text-secondary">${account.company}</p>
                                </div>
                                <div class="text-right">
                                    <span class="badge ${isLive ? 'badge-primary' : 'badge-warning'}">${phase}</span>
                                    <p class="text-xs text-text-secondary mt-1">${daysActive} días activa</p>
                                </div>
                            </div>

                            <!-- Timeline Visual -->
                            <div class="relative mb-3">
                                <div class="w-full h-3 bg-surface rounded-full overflow-hidden">
                                    <div class="h-full bg-gradient-to-r from-blue via-green to-primary transition-all duration-500" style="width: ${progress}%"></div>
                                </div>
                                <div class="flex justify-between mt-2 text-xs text-text-secondary">
                                    <span>📝 Compra</span>
                                    <span>📚 Evaluación</span>
                                    <span>✅ Aprobación</span>
                                    <span>💰 Retiros</span>
                                </div>
                            </div>

                            <!-- Métricas -->
                            <div class="grid grid-cols-2 md:grid-cols-4 gap-3">
                                <div class="text-center">
                                    <p class="text-xs text-text-secondary">Inversión</p>
                                    <p class="font-bold text-red">€${account.fee.toFixed(2)}</p>
                                </div>
                                <div class="text-center">
                                    <p class="text-xs text-text-secondary">Retiros</p>
                                    <p class="font-bold text-green">€${account.earnings.toFixed(2)}</p>
                                </div>
                                <div class="text-center">
                                    <p class="text-xs text-text-secondary">Balance</p>
                                    <p class="font-bold" style="color: #39FF14;">€${(account.balance || 0).toFixed(2)}</p>
                                </div>
                                <div class="text-center">
                                    <p class="text-xs text-text-secondary">Beneficio</p>
                                    <p class="font-bold ${(account.earnings - account.fee) >= 0 ? 'text-green' : 'text-red'}">€${(account.earnings - account.fee).toFixed(2)}</p>
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');
            }

            // 3. Comparador de Cuentas
            let selectedAccountsForComparison = [];

            function renderComparatorSelector() {
                const container = document.getElementById('comparator-selector');
                if (!container) return;

                const accounts = DB.fundedAccounts || [];
                
                if (accounts.length === 0) {
                    container.innerHTML = '<p class="text-center text-text-secondary col-span-4">No hay cuentas para comparar</p>';
                    return;
                }

                container.innerHTML = accounts.map(account => {
                    const isSelected = selectedAccountsForComparison.includes(account.id);
                    return `
                        <div class="p-3 border rounded-lg cursor-pointer transition-all ${
                            isSelected ? 'bg-primary bg-opacity-20 border-primary' : 'bg-surface border-border hover:border-primary'
                        }" onclick="toggleAccountForComparison('${account.id}')">
                            <div class="flex items-center gap-2">
                                <input type="checkbox" ${isSelected ? 'checked' : ''} class="pointer-events-none">
                                <div class="flex-1">
                                    <p class="font-semibold text-sm">${account.name}</p>
                                    <p class="text-xs text-text-secondary">${account.company}</p>
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');
            }

            window.toggleAccountForComparison = function(accountId) {
                const index = selectedAccountsForComparison.indexOf(accountId);
                
                if (index > -1) {
                    selectedAccountsForComparison.splice(index, 1);
                } else {
                    if (selectedAccountsForComparison.length >= 4) {
                        showNotification('Máximo 4 cuentas para comparar', 'warning');
                        return;
                    }
                    selectedAccountsForComparison.push(accountId);
                }
                
                renderComparatorSelector();
                
                if (selectedAccountsForComparison.length >= 2) {
                    renderComparison();
                } else {
                    document.getElementById('comparator-results').style.display = 'none';
                }
            };

            function renderComparison() {
                const resultsDiv = document.getElementById('comparator-results');
                const tableBody = document.getElementById('comparator-table-body');
                
                if (!resultsDiv || !tableBody) return;
                
                resultsDiv.style.display = 'block';
                
                const selectedAccounts = DB.fundedAccounts.filter(a => 
                    selectedAccountsForComparison.includes(a.id)
                );

                // Actualizar headers
                selectedAccounts.forEach((account, index) => {
                    const header = document.getElementById(`comp-header-${index + 1}`);
                    if (header) {
                        header.textContent = account.name;
                        header.style.display = 'table-cell';
                    }
                });

                // Ocultar headers no usados
                for (let i = selectedAccounts.length + 1; i <= 4; i++) {
                    const header = document.getElementById(`comp-header-${i}`);
                    if (header) header.style.display = 'none';
                }

                // Generar tabla comparativa
                const metrics = [
                    { label: 'Empresa', key: 'company' },
                    { label: 'Tipo', key: 'type', format: (v) => v === 'live' ? 'Live' : 'Evaluación' },
                    { label: 'Estado', key: 'status', format: (v) => v === 'active' ? 'Activa' : 'Suspendida' },
                    { label: 'Capital', key: 'balance', format: (v) => `€${(v || 0).toFixed(2)}` },
                    { label: 'Inversión', key: 'fee', format: (v) => `€${v.toFixed(2)}` },
                    { label: 'Retiros', key: 'earnings', format: (v) => `€${v.toFixed(2)}` },
                    { label: 'Beneficio', key: 'profit', format: (v) => `€${v.toFixed(2)}`, calculate: (a) => a.earnings - a.fee },
                    { label: 'ROI', key: 'roi', format: (v) => `${v.toFixed(1)}%`, calculate: (a) => a.fee > 0 ? ((a.earnings - a.fee) / a.fee * 100) : 0 },
                    { label: 'Días Activa', key: 'daysActive', calculate: (a) => Math.ceil((new Date() - new Date(a.activationDate)) / (1000 * 60 * 60 * 24)) }
                ];

                tableBody.innerHTML = metrics.map(metric => {
                    return `
                        <tr>
                            <td class="font-semibold">${metric.label}</td>
                            ${selectedAccounts.map(account => {
                                let value = metric.calculate ? metric.calculate(account) : account[metric.key];
                                let displayValue = metric.format ? metric.format(value) : value;
                                
                                // Encontrar el mejor valor para resaltar
                                let values = selectedAccounts.map(a => metric.calculate ? metric.calculate(a) : a[metric.key]);
                                let bestValue = Math.max(...values.filter(v => typeof v === 'number'));
                                let isBest = value === bestValue && typeof value === 'number' && metric.key !== 'fee';
                                
                                return `<td class="text-center ${isBest ? 'text-green font-bold' : ''}">${displayValue}</td>`;
                            }).join('')}
                        </tr>
                    `;
                }).join('');

                // Renderizar gráfico comparativo
                renderComparisonChart(selectedAccounts);
            }

            function renderComparisonChart(accounts) {
                const canvas = document.getElementById('comparator-chart');
                if (!canvas) return;

                const ctx = canvas.getContext('2d');

                if (window.comparatorChart) {
                    window.comparatorChart.destroy();
                }

                const colors = ['#39FF14', '#00D4FF', '#FF00FF', '#FFFF00'];

                window.comparatorChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: ['Inversión', 'Retiros', 'Beneficio', 'Capital'],
                        datasets: accounts.map((account, index) => ({
                            label: account.name,
                            data: [
                                account.fee,
                                account.earnings,
                                account.earnings - account.fee,
                                account.balance || 0
                            ],
                            backgroundColor: colors[index],
                            borderColor: colors[index],
                            borderWidth: 1
                        }))
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top',
                                labels: { color: '#fff' }
                            },
                            tooltip: {
                                callbacks: {
                                    label: (context) => `${context.dataset.label}: €${context.parsed.y.toFixed(2)}`
                                }
                            }
                        },
                        scales: {
                            x: {
                                grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                ticks: { color: '#8b949e' }
                            },
                            y: {
                                grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                ticks: {
                                    color: '#8b949e',
                                    callback: (value) => `€${value.toFixed(0)}`
                                }
                            }
                        }
                    }
                });
            }

            // 4. Proyección de Rentabilidad
            function renderProfitabilityProjections() {
                const container = document.getElementById('profitability-projections');
                if (!container) return;

                const accounts = DB.fundedAccounts.filter(a => a.type === 'live' && a.status === 'active');
                
                if (accounts.length === 0) {
                    container.innerHTML = '<p class="text-center text-text-secondary py-8">No hay cuentas live activas para proyectar</p>';
                    return;
                }

                container.innerHTML = accounts.map(account => {
                    const daysActive = Math.ceil((new Date() - new Date(account.activationDate)) / (1000 * 60 * 60 * 24));
                    const dailyAverage = daysActive > 0 ? account.earnings / daysActive : 0;
                    const remainingToBreakEven = account.fee - account.earnings;
                    const daysToBreakEven = dailyAverage > 0 ? Math.ceil(remainingToBreakEven / dailyAverage) : 0;
                    const alreadyProfitable = account.earnings >= account.fee;

                    const progressPercent = Math.min((account.earnings / account.fee) * 100, 100);

                    return `
                        <div class="p-4 bg-surface-light rounded-lg border border-border">
                            <div class="flex flex-wrap items-center justify-between mb-3">
                                <div>
                                    <h4 class="font-bold">${account.name}</h4>
                                    <p class="text-sm text-text-secondary">${account.company}</p>
                                </div>
                                <div class="text-right">
                                    ${alreadyProfitable 
                                        ? '<span class="badge badge-success">✅ Recuperada</span>' 
                                        : `<span class="badge badge-warning">⏳ ${daysToBreakEven} días para recuperar</span>`
                                    }
                                </div>
                            </div>

                            <!-- Barra de Progreso -->
                            <div class="mb-3">
                                <div class="flex justify-between text-sm mb-1">
                                    <span>Progreso de recuperación</span>
                                    <span class="font-semibold">${progressPercent.toFixed(1)}%</span>
                                </div>
                                <div class="w-full h-4 bg-surface rounded-full overflow-hidden">
                                    <div class="h-full ${alreadyProfitable ? 'bg-green' : 'bg-yellow'} transition-all duration-500" style="width: ${progressPercent}%"></div>
                                </div>
                            </div>

                            <!-- Métricas de Proyección -->
                            <div class="grid grid-cols-3 gap-3 text-center">
                                <div>
                                    <p class="text-xs text-text-secondary">Inversión</p>
                                    <p class="font-bold text-red">€${account.fee.toFixed(2)}</p>
                                </div>
                                <div>
                                    <p class="text-xs text-text-secondary">Recuperado</p>
                                    <p class="font-bold text-green">€${account.earnings.toFixed(2)}</p>
                                </div>
                                <div>
                                    <p class="text-xs text-text-secondary">Promedio/día</p>
                                    <p class="font-bold text-primary">€${dailyAverage.toFixed(2)}</p>
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');
            }

            // Manejar cambio de filtro de fecha desde el calendario
            window.applyFundedDateFilter = function(filterData) {
                currentDateFilter = filterData;
                const display = document.getElementById('funded-date-filter-display');
                if (display) {
                    display.textContent = filterData.display || 'Sin filtro de fecha';
                }
                refreshFunded();
            };

            // ===== CALENDARIO FINANCIERO FUNDED =====
            let currentFundedCalendarDate = new Date();

            function renderFundedCalendar() {
                const calendarContainer = fundedElements.calendarContainer;
                const monthYearSpan = fundedElements.calendarMonthYear;
                
                if (!calendarContainer || !monthYearSpan) {
                    console.warn('⚠️ Elementos del calendario no encontrados');
                    return;
                }

                const year = currentFundedCalendarDate.getFullYear();
                const month = currentFundedCalendarDate.getMonth();
                const monthNames = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio',
                    'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'];
                
                monthYearSpan.textContent = `${monthNames[month]} ${year}`;

                // Obtener primer y último día del mes
                const firstDay = new Date(year, month, 1);
                const lastDay = new Date(year, month + 1, 0);
                const daysInMonth = lastDay.getDate();
                const startDayOfWeek = firstDay.getDay();

                // Preparar eventos por fecha
                const eventsByDate = {};
                
                DB.fundedAccounts.forEach(account => {
                    // Gastos (fee en fecha de activación)
                    if (account.activationDate && account.fee > 0) {
                        const dateKey = account.activationDate;
                        if (!eventsByDate[dateKey]) {
                            eventsByDate[dateKey] = { expenses: 0, income: 0, items: [] };
                        }
                        eventsByDate[dateKey].expenses += account.fee;
                        eventsByDate[dateKey].items.push({
                            type: 'expense',
                            amount: account.fee,
                            description: `Gasto: ${account.name}`
                        });
                    }

                    // Ganancias (earnings si es live)
                    if (account.type === 'live' && account.activationDate && account.earnings > 0) {
                        const dateKey = account.activationDate;
                        if (!eventsByDate[dateKey]) {
                            eventsByDate[dateKey] = { expenses: 0, income: 0, items: [] };
                        }
                        eventsByDate[dateKey].income += account.earnings;
                        eventsByDate[dateKey].items.push({
                            type: 'income',
                            amount: account.earnings,
                            description: `Ganancia: ${account.name}`
                        });
                    }

                    // Retiros (withdrawals si es live)
                    if (account.type === 'live' && account.withdrawals && account.withdrawals.length > 0) {
                        account.withdrawals.forEach(withdrawal => {
                            const dateKey = withdrawal.date;
                            if (!eventsByDate[dateKey]) {
                                eventsByDate[dateKey] = { expenses: 0, income: 0, items: [] };
                            }
                            eventsByDate[dateKey].income += withdrawal.amount;
                            eventsByDate[dateKey].items.push({
                                type: 'withdrawal',
                                amount: withdrawal.amount,
                                description: `Retiro: ${account.name}${withdrawal.notes ? ' - ' + withdrawal.notes : ''}`
                            });
                        });
                    }
                });

                // Generar HTML del calendario (IGUAL que calendario de Finanzas)
                let calendarHTML = `
                    <div class="grid grid-cols-8 gap-2 text-center font-bold p-2 mb-2 text-text-secondary text-xs">
                        <div>Dom</div>
                        <div>Lun</div>
                        <div>Mar</div>
                        <div>Mié</div>
                        <div>Jue</div>
                        <div>Vie</div>
                        <div>Sáb</div>
                        <div>Semana</div>
                    </div>
                    <div class="grid grid-cols-8 gap-2">
                `;

                // Días vacíos antes del primer día
                for (let i = 0; i < startDayOfWeek; i++) {
                    calendarHTML += '<div class="calendar-day empty"></div>';
                }

                let weeklyTotals = [];
                let currentWeekTotal = 0;
                let dayOfWeek = startDayOfWeek;
                let weekCounter = 1;

                // Días del mes
                for (let day = 1; day <= daysInMonth; day++) {
                    const dateKey = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                    const dayData = eventsByDate[dateKey];
                    const hasEvents = dayData && (dayData.expenses > 0 || dayData.income > 0);
                    const netAmount = hasEvents ? (dayData.income - dayData.expenses) : 0;

                    let cellClass = 'calendar-day';
                    
                    if (hasEvents) {
                        const isProfit = netAmount > 0;
                        const isLoss = netAmount < 0;
                        cellClass += isProfit ? ' profit' : (isLoss ? ' loss' : '');
                        cellClass += ' border-primary cursor-pointer hover:bg-surface-light';
                        currentWeekTotal += netAmount;
                    }

                    // Color rojo para gastos, verde para ingresos
                    const amountColor = (dayData && dayData.expenses > dayData.income) ? 'color: #ff3333; font-weight: bold;' : ((dayData && dayData.income > 0) ? 'color: #39ff14; font-weight: bold;' : '');
                    
                    calendarHTML += `
                        <div class="${cellClass}" ${hasEvents ? `onclick="showFundedDayDetails('${dateKey}')" data-day="${day}"` : ''}>
                            <div class="day-number">${day}</div>
                            ${hasEvents ? `
                                <div class="day-profit ${netAmount >= 0 ? 'positive' : 'negative'}" style="${amountColor}">
                                    ${formatCurrency(netAmount, 'EUR', 'EUR').replace(/\.\d+/, '')}
                                </div>
                                <div class="day-trades">${dayData.items.length} mov.</div>
                            ` : `<div class="day-number text-text-secondary"></div>`}
                        </div>
                    `;

                    dayOfWeek++;

                    // Si es sábado o el último día del mes, agregar celda de semana
                    if (dayOfWeek % 7 === 0 || day === daysInMonth) {
                        const weekProfitClass = currentWeekTotal > 0 ? 'positive' : (currentWeekTotal < 0 ? 'negative' : '');
                        calendarHTML += `
                            <div class="calendar-week-total">
                                <div class="week-label">Sem ${weekCounter}</div>
                                <div class="week-total ${weekProfitClass}">${formatCurrency(currentWeekTotal, 'EUR', 'EUR').replace(/\.\d+/, '')}</div>
                                <div class="week-trades-count">${currentWeekTotal !== 0 ? 'total' : ''}</div>
                            </div>
                        `;
                        weeklyTotals.push(currentWeekTotal);
                        currentWeekTotal = 0;
                        weekCounter++;
                    }
                }

                calendarHTML += `
                    </div>
                `;

                calendarContainer.innerHTML = calendarHTML;

                // Guardar eventos para el modal
                window.fundedEventsByDate = eventsByDate;
                
                // Renderizar métricas de barras después del calendario
                renderFundedWeeklyTrendBars(weeklyTotals);
                renderFundedWeekdayPerformanceBars(eventsByDate);
            }

            // Función para renderizar barras de tendencia semanal
            function renderFundedWeeklyTrendBars(weeklyTotals) {
                const container = document.getElementById('funded-weekly-trend-bars');
                if (!container || !weeklyTotals || weeklyTotals.length === 0) return;

                const maxAbsValue = Math.max(...weeklyTotals.map(v => Math.abs(v)), 1);

                let html = '';
                weeklyTotals.forEach((total, index) => {
                    const isPositive = total >= 0;
                    const percentage = (Math.abs(total) / maxAbsValue) * 100;
                    const displayValue = formatCurrency(total, 'EUR', 'EUR').replace(/\.\d+/, '');

                    html += `
                        <div class="metric-bar-container">
                            <div class="metric-bar-label">Sem ${index + 1}</div>
                            <div class="metric-bar-wrapper">
                                <div class="metric-bar-fill ${isPositive ? 'positive' : 'negative'}" style="width: ${percentage}%">
                                    <div class="metric-bar-value ${percentage < 20 ? 'outside' : ''}">${displayValue}</div>
                                </div>
                            </div>
                        </div>
                    `;
                });

                container.innerHTML = html || '<p class="text-sm text-text-secondary italic">Sin datos para mostrar</p>';
            }

            // Función para renderizar barras de rendimiento por día de la semana
            function renderFundedWeekdayPerformanceBars(eventsByDate) {
                const container = document.getElementById('funded-weekday-performance-bars');
                if (!container) return;

                const weekdayNames = ['Domingo', 'Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sábado'];
                const weekdayTotals = [0, 0, 0, 0, 0, 0, 0];
                const weekdayCounts = [0, 0, 0, 0, 0, 0, 0];

                // Calcular totales por día de la semana
                Object.keys(eventsByDate).forEach(dateString => {
                    const date = new Date(dateString + 'T00:00:00');
                    const dayOfWeek = date.getDay();
                    const data = eventsByDate[dateString];
                    const totalBalance = data.income - data.expenses;
                    
                    weekdayTotals[dayOfWeek] += totalBalance;
                    weekdayCounts[dayOfWeek]++;
                });

                // Calcular promedios
                const weekdayAverages = weekdayTotals.map((total, index) => 
                    weekdayCounts[index] > 0 ? total / weekdayCounts[index] : 0
                );

                const maxAbsValue = Math.max(...weekdayAverages.map(v => Math.abs(v)), 1);

                let html = '';
                weekdayNames.forEach((name, index) => {
                    const avg = weekdayAverages[index];
                    const isPositive = avg >= 0;
                    const percentage = (Math.abs(avg) / maxAbsValue) * 100;
                    const displayValue = formatCurrency(avg, 'EUR', 'EUR').replace(/\.\d+/, '');
                    const count = weekdayCounts[index];

                    html += `
                        <div class="metric-bar-container">
                            <div class="metric-bar-label">${name.substring(0, 3)}</div>
                            <div class="metric-bar-wrapper">
                                <div class="metric-bar-fill ${isPositive ? 'positive' : 'negative'}" style="width: ${percentage}%">
                                    <div class="metric-bar-value ${percentage < 20 ? 'outside' : ''}">${displayValue} ${count > 0 ? `(${count})` : ''}</div>
                                </div>
                            </div>
                        </div>
                    `;
                });

                container.innerHTML = html || '<p class="text-sm text-text-secondary italic">Sin datos para mostrar</p>';
            }

            // ===== FUNCIÓN PARA RENDERIZAR MÉTRICAS DEL NEGOCIO =====
            function renderFundedMetrics() {
                console.log('📊 Renderizando métricas de Funded...');
                
                // Calcular métricas generales
                const accounts = DB.fundedAccounts || [];
                const liveAccounts = accounts.filter(a => a.type === 'live');
                const evaluationAccounts = accounts.filter(a => a.type === 'evaluation');
                const inProgressAccounts = accounts.filter(a => a.type === 'in-progress');
                
                let totalWithdrawals = 0;
                let totalExpenses = 0;
                
                // Calcular retiros y gastos (CORREGIDO)
                accounts.forEach(account => {
                    // Sumar earnings como retiros totales
                    if (account.type === 'live' && account.earnings) {
                        totalWithdrawals += account.earnings;
                    }
                    // Sumar fees como gastos
                    if (account.fee > 0) {
                        totalExpenses += account.fee;
                    }
                });
                
                const balance = totalWithdrawals - totalExpenses;
                const roi = totalExpenses > 0 ? ((totalWithdrawals / totalExpenses) * 100) : 0;
                const successRate = accounts.length > 0 ? ((liveAccounts.length / accounts.length) * 100) : 0;
                
                // Actualizar métricas principales
                document.getElementById('funded-metrics-roi').textContent = roi.toFixed(1) + '%';
                document.getElementById('funded-metrics-roi').className = `text-2xl font-bold ${roi >= 100 ? 'text-green' : 'text-yellow'}`;
                
                document.getElementById('funded-metrics-balance').textContent = formatCurrency(balance, 'EUR', 'EUR');
                document.getElementById('funded-metrics-balance').className = `text-2xl font-bold ${balance >= 0 ? 'text-green' : 'text-red'}`;
                
                document.getElementById('funded-metrics-success-rate').textContent = successRate.toFixed(1) + '%';
                document.getElementById('funded-metrics-success-rate').className = `text-2xl font-bold ${successRate >= 50 ? 'text-green' : 'text-yellow'}`;
                
                document.getElementById('funded-metrics-total-withdrawals').textContent = formatCurrency(totalWithdrawals, 'EUR', 'EUR');
                
                // Agrupar datos por empresa
                const companiesData = {};
                
                accounts.forEach(account => {
                    const company = account.company || 'Sin Empresa';
                    
                    if (!companiesData[company]) {
                        companiesData[company] = {
                            totalAccounts: 0,
                            liveAccounts: 0,
                            evaluations: 0,
                            inProgress: 0,
                            totalWithdrawals: 0,
                            totalExpenses: 0,
                            balance: 0,
                            roi: 0
                        };
                    }
                    
                    companiesData[company].totalAccounts++;
                    
                    if (account.type === 'live') companiesData[company].liveAccounts++;
                    if (account.type === 'evaluation') companiesData[company].evaluations++;
                    if (account.type === 'in-progress') companiesData[company].inProgress++;
                    
                    // Sumar earnings (retiros)
                    if (account.type === 'live' && account.earnings) {
                        companiesData[company].totalWithdrawals += account.earnings;
                    }
                    
                    // Sumar fees (gastos)
                    if (account.fee > 0) {
                        companiesData[company].totalExpenses += account.fee;
                    }
                });
                
                // Calcular balance y ROI por empresa
                Object.keys(companiesData).forEach(company => {
                    const data = companiesData[company];
                    data.balance = data.totalWithdrawals - data.totalExpenses;
                    data.roi = data.totalExpenses > 0 ? ((data.totalWithdrawals / data.totalExpenses) * 100) : 0;
                    data.successRate = data.totalAccounts > 0 ? ((data.liveAccounts / data.totalAccounts) * 100) : 0;
                });
                
                // Renderizar gráficos horizontales
                renderFundedBarChart('funded-roi-by-company-bars', companiesData, 'roi', '%', 100);
                renderFundedBarChart('funded-withdrawals-by-company-bars', companiesData, 'totalWithdrawals', '€', 0);
                renderFundedBarChart('funded-accounts-by-company-bars', companiesData, 'totalAccounts', '', 0);
                renderFundedBarChart('funded-success-rate-by-company-bars', companiesData, 'successRate', '%', 50);
                renderFundedBarChart('funded-balance-by-company-bars', companiesData, 'balance', '€', 0, true);
                renderFundedBarChart('funded-expenses-by-company-bars', companiesData, 'totalExpenses', '€', 0);
                
                // Gráfico de distribución por estado
                renderFundedStatusDistribution(evaluationAccounts.length, inProgressAccounts.length, liveAccounts.length);
                
                // Renderizar gráficos verticales con Chart.js
                renderFundedVerticalCharts(companiesData, evaluationAccounts.length, inProgressAccounts.length, liveAccounts.length);
            }
            
            // Función auxiliar para renderizar gráficos de barras
            function renderFundedBarChart(containerId, data, metric, suffix = '', threshold = 0, allowNegative = false) {
                const container = document.getElementById(containerId);
                if (!container) return;
                
                const companies = Object.keys(data);
                if (companies.length === 0) {
                    container.innerHTML = '<p class="text-sm text-text-secondary italic">Sin datos para mostrar</p>';
                    return;
                }
                
                // Ordenar por valor de mayor a menor
                companies.sort((a, b) => data[b][metric] - data[a][metric]);
                
                // Limitar a las top 6 empresas
                const topCompanies = companies.slice(0, 6);
                
                const values = topCompanies.map(c => data[c][metric]);
                const maxValue = Math.max(...values.map(v => Math.abs(v)), 1);
                
                let html = '';
                topCompanies.forEach(company => {
                    const value = data[company][metric];
                    const percentage = (Math.abs(value) / maxValue) * 100;
                    const isPositive = value >= threshold;
                    const colorClass = allowNegative ? (value >= 0 ? 'positive' : 'negative') : (isPositive ? 'positive' : 'warning');
                    
                    const displayValue = suffix === '€' ? formatCurrency(value, 'EUR', 'EUR').replace(/\\.\\d+/, '') : value.toFixed(1) + suffix;
                    
                    html += `
                        <div class="metric-bar-container">
                            <div class="metric-bar-label" style="min-width: 120px;">${company}</div>
                            <div class="metric-bar-wrapper">
                                <div class="metric-bar-fill ${colorClass}" style="width: ${percentage}%">
                                    <div class="metric-bar-value ${percentage < 20 ? 'outside' : ''}">${displayValue}</div>
                                </div>
                            </div>
                        </div>
                    `;
                });
                
                container.innerHTML = html;
            }
            
            // Función para renderizar distribución por estado
            function renderFundedStatusDistribution(evaluations, inProgress, live) {
                const container = document.getElementById('funded-status-distribution-bars');
                if (!container) return;
                
                const total = evaluations + inProgress + live;
                if (total === 0) {
                    container.innerHTML = '<p class="text-sm text-text-secondary italic">Sin datos para mostrar</p>';
                    return;
                }
                
                const maxValue = Math.max(evaluations, inProgress, live, 1);
                
                const statusData = [
                    { label: 'Evaluaciones', value: evaluations, color: 'warning' },
                    { label: 'En Progreso', value: inProgress, color: 'info' },
                    { label: 'Cuentas Live', value: live, color: 'positive' }
                ];
                
                let html = '';
                statusData.forEach(status => {
                    const percentage = (status.value / maxValue) * 100;
                    const displayPercentage = total > 0 ? ((status.value / total) * 100).toFixed(1) : 0;
                    
                    html += `
                        <div class="metric-bar-container">
                            <div class="metric-bar-label" style="min-width: 120px;">${status.label}</div>
                            <div class="metric-bar-wrapper">
                                <div class="metric-bar-fill ${status.color}" style="width: ${percentage}%">
                                    <div class="metric-bar-value ${percentage < 20 ? 'outside' : ''}">${status.value} (${displayPercentage}%)</div>
                                </div>
                            </div>
                        </div>
                    `;
                });
                
                container.innerHTML = html;
            }
            
            // Función para renderizar gráficos verticales con Chart.js
            function renderFundedVerticalCharts(companiesData, evaluations, inProgress, live) {
                // Gráfico 1: Retiros por Empresa (vertical)
                const ctx1 = document.getElementById('funded-vertical-chart-1');
                if (ctx1 && ctx1.chart) ctx1.chart.destroy();
                
                const companies = Object.keys(companiesData);
                const withdrawalsData = companies.map(c => companiesData[c].totalWithdrawals);
                
                if (ctx1) {
                    ctx1.chart = new Chart(ctx1, {
                        type: 'bar',
                        data: {
                            labels: companies,
                            datasets: [{
                                label: 'Retiros',
                                data: withdrawalsData,
                                backgroundColor: '#00FF00',
                                borderColor: '#39ff14',
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false },
                                tooltip: {
                                    backgroundColor: '#1e1e1e',
                                    titleColor: '#39ff14',
                                    bodyColor: '#e0e0e0',
                                    borderColor: '#39ff14',
                                    borderWidth: 1,
                                    callbacks: {
                                        label: (context) => `€${context.parsed.y.toFixed(2)}`
                                    }
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    ticks: {
                                        color: '#e0e0e0',
                                        callback: (value) => '€' + value
                                    },
                                    grid: { color: 'rgba(255, 255, 255, 0.1)' }
                                },
                                x: {
                                    ticks: { color: '#e0e0e0' },
                                    grid: { display: false }
                                }
                            }
                        }
                    });
                }
                
                // Gráfico 2: Balance por Empresa (vertical)
                const ctx2 = document.getElementById('funded-vertical-chart-2');
                if (ctx2 && ctx2.chart) ctx2.chart.destroy();
                
                const balanceData = companies.map(c => companiesData[c].balance);
                
                if (ctx2) {
                    ctx2.chart = new Chart(ctx2, {
                        type: 'bar',
                        data: {
                            labels: companies,
                            datasets: [{
                                label: 'Balance',
                                data: balanceData,
                                backgroundColor: balanceData.map(b => b >= 0 ? '#00FF00' : 'rgba(255, 51, 51, 0.7)'),
                                borderColor: balanceData.map(b => b >= 0 ? '#39ff14' : '#ff3333'),
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false },
                                tooltip: {
                                    backgroundColor: '#1e1e1e',
                                    titleColor: '#39ff14',
                                    bodyColor: '#e0e0e0',
                                    borderColor: '#39ff14',
                                    borderWidth: 1,
                                    callbacks: {
                                        label: (context) => `€${context.parsed.y.toFixed(2)}`
                                    }
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    ticks: {
                                        color: '#e0e0e0',
                                        callback: (value) => '€' + value
                                    },
                                    grid: { color: 'rgba(255, 255, 255, 0.1)' }
                                },
                                x: {
                                    ticks: { color: '#e0e0e0' },
                                    grid: { display: false }
                                }
                            }
                        }
                    });
                }
                
                // Gráfico 3: Distribución de Estados (vertical)
                const ctx3 = document.getElementById('funded-vertical-chart-3');
                if (ctx3 && ctx3.chart) ctx3.chart.destroy();
                
                if (ctx3) {
                    ctx3.chart = new Chart(ctx3, {
                        type: 'bar',
                        data: {
                            labels: ['Evaluaciones', 'En Progreso', 'Live'],
                            datasets: [{
                                label: 'Cuentas',
                                data: [evaluations, inProgress, live],
                                backgroundColor: [
                                    'rgba(255, 193, 7, 0.7)',  // warning
                                    'rgba(33, 150, 243, 0.7)', // info
                                    '#00FF00'   // positive
                                ],
                                borderColor: ['#ffc107', '#2196f3', '#39ff14'],
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false },
                                tooltip: {
                                    backgroundColor: '#1e1e1e',
                                    titleColor: '#39ff14',
                                    bodyColor: '#e0e0e0',
                                    borderColor: '#39ff14',
                                    borderWidth: 1
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    ticks: {
                                        color: '#e0e0e0',
                                        stepSize: 1
                                    },
                                    grid: { color: 'rgba(255, 255, 255, 0.1)' }
                                },
                                x: {
                                    ticks: { color: '#e0e0e0' },
                                    grid: { display: false }
                                }
                            }
                        }
                    });
                }
            }

            // Sistema de almacenamiento para notas e imágenes de días
            const FUNDED_DAY_DATA_KEY = 'funded-day-data';
            
            function getFundedDayData(dateKey) {
                const allData = JSON.parse(localStorage.getItem(FUNDED_DAY_DATA_KEY) || '{}');
                return allData[dateKey] || { notes: '', images: [], tags: [] };
            }

            function saveFundedDayData(dateKey, data) {
                const allData = JSON.parse(localStorage.getItem(FUNDED_DAY_DATA_KEY) || '{}');
                allData[dateKey] = data;
                localStorage.setItem(FUNDED_DAY_DATA_KEY, JSON.stringify(allData));
            }

            // Calcular estadísticas globales de retiros
            function calculateWithdrawalStats() {
                let totalWithdrawals = 0;
                let totalExpenses = 0;
                let withdrawalCount = 0;
                let expenseCount = 0;

                DB.fundedAccounts.forEach(account => {
                    if (account.type === 'live' && account.earnings > 0) {
                        totalWithdrawals += account.earnings;
                        withdrawalCount++;
                    }
                    if (account.fee > 0) {
                        totalExpenses += account.fee;
                        expenseCount++;
                    }
                });

                const avgWithdrawal = withdrawalCount > 0 ? totalWithdrawals / withdrawalCount : 0;
                const ratio = totalExpenses > 0 ? totalWithdrawals / totalExpenses : 0;

                return {
                    totalWithdrawals,
                    totalExpenses,
                    withdrawalCount,
                    expenseCount,
                    avgWithdrawal,
                    ratio
                };
            }

            // Función para mostrar detalles del día en pantalla completa
            window.showFundedDayDetails = function(dateKey) {
                const dayData = window.fundedEventsByDate[dateKey];
                if (!dayData) return;

                // Ocultar TODA la sección FUNDED
                document.getElementById('funded').style.visibility = 'hidden';
                
                // Mostrar vista de día y botón de cerrar
                const fullscreenView = document.getElementById('funded-day-fullscreen');
                fullscreenView.style.display = 'block';
                fullscreenView.style.visibility = 'visible';
                
                const closeBtn = document.getElementById('close-funded-day-fullscreen');
                closeBtn.style.display = 'flex';
                closeBtn.classList.remove('hidden');

                // Scroll to top
                window.scrollTo({ top: 0, behavior: 'smooth' });

                // Formatear fecha
                const formattedDate = new Date(dateKey + 'T00:00:00').toLocaleDateString('es-ES', {
                    weekday: 'long',
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                });

                const netAmount = dayData.income - dayData.expenses;

                // Actualizar encabezado
                document.getElementById('funded-day-title').textContent = formattedDate;
                document.getElementById('funded-day-date').textContent = dateKey;
                document.getElementById('funded-day-balance').textContent = `${netAmount >= 0 ? '+' : ''}€${netAmount.toFixed(2)}`;
                document.getElementById('funded-day-balance').className = `text-3xl font-bold ${netAmount >= 0 ? 'text-green' : 'text-red'}`;

                // Renderizar movimientos
                const movementsContainer = document.getElementById('funded-day-movements');
                movementsContainer.innerHTML = dayData.items.map(item => `
                    <div class="p-4 bg-surface-light rounded-lg border-l-4 ${item.type === 'income' ? 'border-green' : 'border-red'}">
                        <div class="flex justify-between items-center">
                            <div>
                                <p class="font-semibold">${item.description}</p>
                                <p class="text-sm text-text-secondary mt-1">
                                    <i class="fas fa-${item.type === 'income' ? 'arrow-down' : 'arrow-up'} mr-1"></i>
                                    ${item.type === 'income' ? 'Ganancia' : 'Gasto'}
                                </p>
                            </div>
                            <span class="text-xl font-bold ${item.type === 'income' ? 'text-green' : 'text-red'}">
                                ${item.type === 'income' ? '+' : '-'}€${item.amount.toFixed(2)}
                            </span>
                        </div>
                    </div>
                `).join('');

                // Calcular y mostrar estadísticas
                const stats = calculateWithdrawalStats();
                const maxValue = Math.max(stats.totalWithdrawals, stats.totalExpenses, stats.avgWithdrawal, 1000);

                document.getElementById('stat-total-withdrawals').textContent = `€${stats.totalWithdrawals.toFixed(2)}`;
                document.getElementById('stat-total-bar').style.width = `${(stats.totalWithdrawals / maxValue) * 100}%`;

                document.getElementById('stat-avg-withdrawals').textContent = `€${stats.avgWithdrawal.toFixed(2)}`;
                document.getElementById('stat-avg-bar').style.width = `${(stats.avgWithdrawal / maxValue) * 100}%`;

                document.getElementById('stat-total-expenses').textContent = `€${stats.totalExpenses.toFixed(2)}`;
                document.getElementById('stat-expenses-bar').style.width = `${(stats.totalExpenses / maxValue) * 100}%`;

                document.getElementById('stat-ratio').textContent = `${stats.ratio.toFixed(2)}x`;
                document.getElementById('stat-ratio-bar').style.width = `${Math.min((stats.ratio / 5) * 100, 100)}%`;

                document.getElementById('stat-count-withdrawals').textContent = stats.withdrawalCount;
                document.getElementById('stat-count-expenses').textContent = stats.expenseCount;

                // Cargar datos guardados del día
                const savedData = getFundedDayData(dateKey);
                
                // Cargar notas en vista de solo lectura
                const notesDisplay = document.getElementById('notes-display');
                if (savedData.notes && savedData.notes.trim()) {
                    notesDisplay.innerHTML = savedData.notes;
                } else {
                    notesDisplay.innerHTML = '<p class="text-text-secondary italic">No hay notas escritas aún. Haz clic en "Editar Notas" para comenzar.</p>';
                }

                // Cargar imágenes
                renderDayImages(dateKey, savedData.images);

                // Cargar etiquetas
                renderDayTags(dateKey, savedData.tags);

                // Guardar dateKey actual para eventos
                window.currentFundedDayKey = dateKey;
                
                // Renderizar mini calendario en el panel
                renderFundedMiniCalendar(dateKey);
            };

            // Función para renderizar mini calendario en el panel de detalles (EXACTO como Daily Journal)
            function renderFundedMiniCalendar(currentDateKey) {
                const container = document.getElementById('funded-day-mini-calendar');
                if (!container) return;

                // Extraer año y mes de la fecha actual
                const [year, month, day] = currentDateKey.split('-').map(Number);
                
                const monthNames = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio',
                    'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'];
                
                // Obtener primer y último día del mes
                const firstDay = new Date(year, month - 1, 1);
                const lastDay = new Date(year, month, 0);
                const daysInMonth = lastDay.getDate();
                const startDayOfWeek = firstDay.getDay();

                // Usar los eventos ya calculados
                const eventsByDate = window.fundedEventsByDate || {};
                
                const today = new Date();

                // Generar HTML del calendario (EXACTO como Daily Journal)
                let calendarHTML = `
                    <div class="daily-journal-calendar-header">
                        <button class="daily-journal-calendar-nav" onclick="changeFundedMiniCalendarMonth(-1)">
                            <i class="fas fa-chevron-left"></i>
                        </button>
                        <div class="daily-journal-calendar-month">${monthNames[month - 1]} ${year}</div>
                        <button class="daily-journal-calendar-nav" onclick="changeFundedMiniCalendarMonth(1)">
                            <i class="fas fa-chevron-right"></i>
                        </button>
                    </div>
                    <div class="daily-journal-calendar-grid">
                        <div class="daily-journal-calendar-day-header">D</div>
                        <div class="daily-journal-calendar-day-header">L</div>
                        <div class="daily-journal-calendar-day-header">M</div>
                        <div class="daily-journal-calendar-day-header">X</div>
                        <div class="daily-journal-calendar-day-header">J</div>
                        <div class="daily-journal-calendar-day-header">V</div>
                        <div class="daily-journal-calendar-day-header">S</div>
                `;

                // Días vacíos antes del primer día
                for (let i = 0; i < startDayOfWeek; i++) {
                    calendarHTML += '<div class="daily-journal-calendar-day empty"></div>';
                }

                // Días del mes
                for (let d = 1; d <= daysInMonth; d++) {
                    const dateKey = `${year}-${String(month).padStart(2, '0')}-${String(d).padStart(2, '0')}`;
                    const dayData = eventsByDate[dateKey];
                    const hasEvents = dayData && (dayData.expenses > 0 || dayData.income > 0);
                    const isToday = today.getDate() === d && today.getMonth() === (month - 1) && today.getFullYear() === year;
                    const netAmount = hasEvents ? (dayData.income - dayData.expenses) : 0;

                    let dayClass = 'daily-journal-calendar-day';
                    
                    if (isToday) {
                        dayClass += ' today';
                    }
                    
                    if (hasEvents) {
                        dayClass += netAmount >= 0 ? ' has-data positive' : ' has-data negative';
                    }

                    // Mostrar importe como en el calendario principal
                    const amountDisplay = hasEvents ? `<div class="mini-day-amount">${formatCurrency(netAmount, 'EUR', 'EUR').replace(/\.\d+/, '')}</div>` : '';

                    calendarHTML += `
                        <div class="${dayClass}" onclick="showFundedDayDetails('${dateKey}')">
                            <div class="mini-day-number">${d}</div>
                            ${amountDisplay}
                        </div>
                    `;
                }

                calendarHTML += '</div>';
                container.innerHTML = calendarHTML;
                
                // Guardar mes actual del mini calendario
                window.currentFundedMiniCalendarDate = new Date(year, month - 1, 1);
            }

            // Función para cambiar mes en el mini calendario
            window.changeFundedMiniCalendarMonth = function(delta) {
                if (!window.currentFundedMiniCalendarDate) {
                    window.currentFundedMiniCalendarDate = new Date();
                }
                
                const newDate = new Date(window.currentFundedMiniCalendarDate);
                newDate.setMonth(newDate.getMonth() + delta);
                
                const year = newDate.getFullYear();
                const month = newDate.getMonth() + 1;
                const day = 1;
                const dateKey = `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                
                window.currentFundedMiniCalendarDate = newDate;
                renderFundedMiniCalendar(window.currentFundedDayKey || dateKey);
            };


            // Renderizar imágenes del día
            function renderDayImages(dateKey, images) {
                const container = document.getElementById('funded-day-images-preview');
                container.innerHTML = images.map((imgData, index) => `
                    <div class="relative group cursor-pointer" onclick="viewImageFullscreen('${imgData}', ${index})">
                        <img src="${imgData}" alt="Imagen ${index + 1}" class="w-full h-64 md:h-80 object-cover rounded-lg border border-border hover:border-primary transition-all">
                        <div class="absolute inset-0 bg-black bg-opacity-0 group-hover:bg-opacity-30 transition-all rounded-lg flex items-center justify-center">
                            <i class="fas fa-expand text-white text-3xl opacity-0 group-hover:opacity-100 transition-opacity"></i>
                        </div>
                        <button 
                            onclick="event.stopPropagation(); removeDayImage('${dateKey}', ${index})"
                            class="absolute top-2 right-2 bg-red text-white rounded-full w-8 h-8 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity hover:bg-red-dark z-10"
                        >
                            <i class="fas fa-times"></i>
                        </button>
                        <div class="absolute bottom-2 left-2 bg-black bg-opacity-75 text-white px-3 py-1 rounded-full text-xs">
                            Imagen ${index + 1}
                        </div>
                    </div>
                `).join('');

                // Actualizar botón de añadir imagen
                const addBtn = document.getElementById('add-day-image-btn');
                if (images.length >= 3) {
                    addBtn.disabled = true;
                    addBtn.classList.add('opacity-50', 'cursor-not-allowed');
                } else {
                    addBtn.disabled = false;
                    addBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                }
            }

            // Ver imagen a pantalla completa
            window.viewImageFullscreen = function(imageSrc, index) {
                const fullscreenOverlay = document.createElement('div');
                fullscreenOverlay.className = 'fixed inset-0 bg-black bg-opacity-95 z-[9999] flex items-center justify-center';
                fullscreenOverlay.style.cursor = 'zoom-out';
                
                fullscreenOverlay.innerHTML = `
                    <button 
                        onclick="this.closest('.fixed').remove()" 
                        class="absolute top-4 right-4 bg-red text-white rounded-full w-12 h-12 flex items-center justify-center hover:bg-red-dark transition-all z-10"
                    >
                        <i class="fas fa-times text-xl"></i>
                    </button>
                    <div class="absolute top-4 left-4 bg-black bg-opacity-75 text-white px-4 py-2 rounded-lg">
                        <i class="fas fa-image mr-2"></i>Imagen ${index + 1}
                    </div>
                    <img 
                        src="${imageSrc}" 
                        alt="Imagen ${index + 1}" 
                        class="max-w-[95vw] max-h-[95vh] object-contain rounded-lg shadow-2xl"
                        style="cursor: default;"
                        onclick="event.stopPropagation()"
                    />
                    <div class="absolute bottom-4 left-1/2 transform -translate-x-1/2 bg-black bg-opacity-75 text-white px-4 py-2 rounded-lg text-sm">
                        <i class="fas fa-info-circle mr-2"></i>Haz clic fuera de la imagen para cerrar
                    </div>
                `;
                
                fullscreenOverlay.onclick = function(e) {
                    if (e.target === fullscreenOverlay) {
                        fullscreenOverlay.remove();
                    }
                };
                
                document.body.appendChild(fullscreenOverlay);
                
                // Prevenir scroll del body
                document.body.style.overflow = 'hidden';
                
                // Restaurar scroll al cerrar
                fullscreenOverlay.addEventListener('remove', () => {
                    document.body.style.overflow = '';
                });
            }

            // Añadir imagen
            window.addDayImage = function() {
                const input = document.getElementById('funded-day-image-input');
                input.click();
            };

            // Eliminar imagen
            window.removeDayImage = function(dateKey, index) {
                const data = getFundedDayData(dateKey);
                data.images.splice(index, 1);
                saveFundedDayData(dateKey, data);
                renderDayImages(dateKey, data.images);
            };

            // Renderizar etiquetas
            function renderDayTags(dateKey, tags) {
                const container = document.getElementById('funded-day-tags');
                const commonTags = ['Retiro exitoso', 'Gasto necesario', 'Celebración', 'Análisis', 'Objetivo cumplido'];
                
                container.innerHTML = tags.map(tag => `
                    <span class="inline-flex items-center px-3 py-1 rounded-full bg-primary text-background text-sm">
                        ${tag}
                        <button onclick="removeDayTag('${dateKey}', '${tag}')" class="ml-2 hover:text-red">
                            <i class="fas fa-times text-xs"></i>
                        </button>
                    </span>
                `).join('') + commonTags.filter(t => !tags.includes(t)).map(tag => `
                    <button 
                        onclick="addDayTag('${dateKey}', '${tag}')"
                        class="px-3 py-1 rounded-full bg-surface-light hover:bg-surface text-sm border border-border hover:border-primary transition-all"
                    >
                        ${tag}
                    </button>
                `).join('');
            }

            // Añadir etiqueta
            window.addDayTag = function(dateKey, tag) {
                const data = getFundedDayData(dateKey);
                if (!data.tags.includes(tag)) {
                    data.tags.push(tag);
                    saveFundedDayData(dateKey, data);
                    renderDayTags(dateKey, data.tags);
                }
            };

            // Eliminar etiqueta
            window.removeDayTag = function(dateKey, tag) {
                const data = getFundedDayData(dateKey);
                data.tags = data.tags.filter(t => t !== tag);
                saveFundedDayData(dateKey, data);
                renderDayTags(dateKey, data.tags);
            };

            // ===== EDITOR DE NOTAS AVANZADAS =====
            
            // Abrir editor de notas
            document.getElementById('edit-notes-btn').addEventListener('click', function() {
                const modal = document.getElementById('notes-editor-modal');
                const editor = document.getElementById('funded-day-notes-editor');
                const dateKey = window.currentFundedDayKey;
                
                if (!dateKey) return;
                
                // Cargar notas existentes
                const data = getFundedDayData(dateKey);
                editor.innerHTML = data.notes || '';
                
                modal.style.display = 'flex';
                modal.classList.remove('hidden');
                document.body.style.overflow = 'hidden';
                
                updateEditorCharCount();
            });

            // Cerrar editor
            function closeNotesEditor() {
                const modal = document.getElementById('notes-editor-modal');
                modal.style.display = 'none';
                modal.classList.add('hidden');
                document.body.style.overflow = '';
            }

            // Cerrar al hacer clic fuera del modal
            document.getElementById('notes-editor-modal').addEventListener('click', function(e) {
                if (e.target === this) {
                    closeNotesEditor();
                }
            });

            document.getElementById('close-editor-btn').addEventListener('click', closeNotesEditor);
            document.getElementById('editor-cancel-btn').addEventListener('click', closeNotesEditor);

            // Actualizar contador de caracteres del editor
            function updateEditorCharCount() {
                const editor = document.getElementById('funded-day-notes-editor');
                const counter = document.getElementById('editor-char-count');
                const text = editor.innerText || editor.textContent || '';
                counter.textContent = `${text.length} caracteres`;
            }

            // Actualizar contador en tiempo real
            document.getElementById('funded-day-notes-editor').addEventListener('input', updateEditorCharCount);

            // Funciones de formato de texto
            window.formatText = function(command, value = null) {
                document.execCommand(command, false, value);
                document.getElementById('funded-day-notes-editor').focus();
            };

            window.insertLink = function() {
                const url = prompt('Ingresa la URL:');
                if (url) {
                    document.execCommand('createLink', false, url);
                }
            };

            window.insertImageFundedNotes = function() {
                const input = document.getElementById('funded-notes-image-input');
                if (input) {
                    input.click();
                }
            };

            // Manejo de selección de imagen
            document.getElementById('funded-notes-image-input')?.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (file && file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        const img = `<img src="${event.target.result}" style="max-width: 100%; height: auto; margin: 10px 0; border-radius: 8px;" />`;
                        document.execCommand('insertHTML', false, img);
                        document.getElementById('funded-day-notes-editor').focus();
                    };
                    reader.readAsDataURL(file);
                }
                // Resetear input
                e.target.value = '';
            });

            // Guardar notas avanzadas
            document.getElementById('editor-save-btn').addEventListener('click', async function() {
                const dateKey = window.currentFundedDayKey;
                if (!dateKey) return;

                const editor = document.getElementById('funded-day-notes-editor');
                const notes = editor.innerHTML;
                
                const data = getFundedDayData(dateKey);
                data.notes = notes;
                saveFundedDayData(dateKey, data);

                // Actualizar vista de solo lectura
                const notesDisplay = document.getElementById('notes-display');
                notesDisplay.innerHTML = notes || '<p class="text-text-secondary italic">No hay notas escritas aún. Haz clic en "Editar Notas" para comenzar.</p>';

                // --- SINCRONIZACIÓN AUTOMÁTICA CON NOTEBOOK ---
                try {
                    // Asegurar que userId esté definido
                    if (!window.userId && window.currentUser) {
                        window.userId = window.currentUser.id;
                    }

                    // Buscar carpeta "Daily Journal" en IndexedDB (NO en memoria)
                    const allFolders = await dexieDB.notebookFolders.toArray();
                    let dailyJournalFolder = allFolders.find(f => f.name === 'Daily Journal');
                    
                    if (!dailyJournalFolder) {
                        console.log('📁 Creando carpeta "Daily Journal" en Notebook...');
                        dailyJournalFolder = {
                            id: 'folder_dailyjournal_' + Date.now(),
                            user_id: window.userId,
                            name: 'Daily Journal',
                            icon: '📔',
                            created_at: new Date().toISOString()
                        };
                        
                        await dexieDB.notebookFolders.add(dailyJournalFolder);
                        if (window.supabase && window.userId) {
                            await supabase.from('notebook_folders').insert([dailyJournalFolder]);
                        }
                        
                        DB.notebookFolders = DB.notebookFolders || [];
                        DB.notebookFolders.push(dailyJournalFolder);
                        console.log('✅ Carpeta Daily Journal creada');
                    } else {
                        console.log('✅ Carpeta Daily Journal ya existe, usando existente');
                    }
                    
                    // Crear título descriptivo para la nota
                    const noteTitle = `Día ${dateKey}`;
                    
                    // Buscar si ya existe una nota para este día
                    let existingNote = (DB.notebookNotes || []).find(n => 
                        n.folder_id === dailyJournalFolder.id && 
                        n.metadata && 
                        n.metadata.dateKey === dateKey
                    );
                    
                    if (existingNote) {
                        // Actualizar nota existente
                        console.log('📝 Actualizando nota existente en Notebook...');
                        existingNote.title = noteTitle;
                        existingNote.content = notes;
                        existingNote.updated_at = new Date().toISOString();
                        
                        await dexieDB.notebookNotes.put(existingNote);
                        if (window.supabase && window.userId) {
                            await supabase
                                .from('notebook_notes')
                                .update({
                                    title: existingNote.title,
                                    content: existingNote.content,
                                    updated_at: existingNote.updated_at
                                })
                                .eq('id', existingNote.id);
                        }
                    } else {
                        // Crear nueva nota
                        console.log('📝 Creando nueva nota en Notebook...');
                        const newNote = {
                            id: 'note_dj_' + dateKey + '_' + Date.now(),
                            user_id: window.userId,
                            folder_id: dailyJournalFolder.id,
                            title: noteTitle,
                            content: notes,
                            created_at: new Date().toISOString(),
                            updated_at: new Date().toISOString(),
                            is_pinned: false,
                            metadata: {
                                dateKey: dateKey,
                                source: 'daily_journal_funded'
                            }
                        };
                        
                        await dexieDB.notebookNotes.add(newNote);
                        if (window.supabase && window.userId) {
                            await supabase.from('notebook_notes').insert([newNote]);
                        }
                        
                        DB.notebookNotes = DB.notebookNotes || [];
                        DB.notebookNotes.unshift(newNote);
                        
                        // Notificar a Notebook para actualizar contadores
                        if (window.notebookNotesUpdated) {
                            window.notebookNotesUpdated();
                        }
                    }
                    
                    console.log('✅ Notas sincronizadas con Notebook → Carpeta "Daily Journal"');
                } catch (notebookError) {
                    console.warn('⚠️ Error al sincronizar con Notebook:', notebookError);
                }

                // Feedback visual
                const btn = this;
                const originalHTML = btn.innerHTML;
                btn.innerHTML = '<i class="fas fa-check mr-2"></i>Guardado!';
                btn.classList.add('bg-green');
                
                setTimeout(() => {
                    btn.innerHTML = originalHTML;
                    btn.classList.remove('bg-green');
                    closeNotesEditor();
                }, 1500);
            });

            // Descargar nota como archivo
            document.getElementById('download-note-btn').addEventListener('click', function() {
                const editor = document.getElementById('funded-day-notes-editor');
                const content = editor.innerHTML;
                const dateKey = window.currentFundedDayKey;
                
                if (!content.trim()) {
                    alert('No hay contenido para descargar');
                    return;
                }
                
                const blob = new Blob([content], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `nota-${dateKey}.html`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            });

            // ===== NOTA DE VOZ =====
            let mediaRecorder;
            let audioChunks = [];
            let isRecording = false;

            document.getElementById('voice-note-btn').addEventListener('click', async function() {
                if (!isRecording) {
                    // Iniciar grabación
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        mediaRecorder = new MediaRecorder(stream);
                        audioChunks = [];

                        mediaRecorder.ondataavailable = (event) => {
                            audioChunks.push(event.data);
                        };

                        mediaRecorder.onstop = () => {
                            const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                            const audioUrl = URL.createObjectURL(audioBlob);
                            
                            // Insertar reproductor de audio en el editor
                            const editor = document.getElementById('funded-day-notes-editor');
                            const audioHTML = `<div style="margin: 10px 0; padding: 10px; background: rgba(57, 255, 20, 0.1); border-left: 3px solid #39ff14; border-radius: 4px;">
                                <p style="margin: 0 0 5px 0; font-weight: bold; color: #39ff14;">🎤 Nota de Voz</p>
                                <audio controls style="width: 100%; max-width: 400px;">
                                    <source src="${audioUrl}" type="audio/webm">
                                    Tu navegador no soporta audio.
                                </audio>
                            </div>`;
                            
                            editor.innerHTML += audioHTML;
                            updateEditorCharCount();

                            // Detener todas las pistas del stream
                            stream.getTracks().forEach(track => track.stop());
                        };

                        mediaRecorder.start();
                        isRecording = true;

                        // Actualizar botón
                        this.innerHTML = '<i class="fas fa-stop-circle text-red"></i><span class="ml-2">Detener Grabación</span>';
                        this.classList.add('bg-red', 'text-white');

                    } catch (err) {
                        console.error('Error al acceder al micrófono:', err);
                        alert('No se pudo acceder al micrófono. Verifica los permisos del navegador.');
                    }
                } else {
                    // Detener grabación
                    if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                        mediaRecorder.stop();
                        isRecording = false;

                        // Restaurar botón
                        this.innerHTML = '<i class="fas fa-microphone"></i><span class="ml-2">Nota de Voz</span>';
                        this.classList.remove('bg-red', 'text-white');
                    }
                }
            });

            // Event listeners para la vista de día
            document.getElementById('funded-day-back-btn').addEventListener('click', function() {
                document.getElementById('funded-day-fullscreen').style.display = 'none';
                document.getElementById('close-funded-day-fullscreen').style.display = 'none';
                document.getElementById('funded').style.visibility = 'visible';
            });

            // Botón de cerrar en la esquina superior derecha
            document.getElementById('close-funded-day-fullscreen').addEventListener('click', function() {
                document.getElementById('funded-day-fullscreen').style.display = 'none';
                document.getElementById('close-funded-day-fullscreen').style.display = 'none';
                document.getElementById('funded').style.visibility = 'visible';
            });

            document.getElementById('add-day-image-btn').addEventListener('click', function() {
                const dateKey = window.currentFundedDayKey;
                if (!dateKey) return;
                
                const data = getFundedDayData(dateKey);
                if (data.images.length >= 3) {
                    alert('Máximo 3 imágenes por día');
                    return;
                }
                
                window.addDayImage();
            });

            document.getElementById('funded-day-image-input').addEventListener('change', function(e) {
                const dateKey = window.currentFundedDayKey;
                if (!dateKey) return;

                const file = e.target.files[0];
                if (!file) return;

                // Validar tamaño (5MB)
                if (file.size > 5 * 1024 * 1024) {
                    alert('La imagen debe ser menor a 5MB');
                    return;
                }

                // Leer imagen como base64
                const reader = new FileReader();
                reader.onload = function(event) {
                    const data = getFundedDayData(dateKey);
                    if (data.images.length < 3) {
                        data.images.push(event.target.result);
                        saveFundedDayData(dateKey, data);
                        renderDayImages(dateKey, data.images);
                    }
                };
                reader.readAsDataURL(file);

                // Reset input
                e.target.value = '';
            });

            document.getElementById('new-tag-input').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    const dateKey = window.currentFundedDayKey;
                    if (!dateKey) return;

                    const tag = this.value.trim();
                    if (tag) {
                        window.addDayTag(dateKey, tag);
                        this.value = '';
                    }
                }
            });

            // Eventos de navegación del calendario
            if (fundedElements.calendarPrev) {
                fundedElements.calendarPrev.onclick = () => {
                    currentFundedCalendarDate.setMonth(currentFundedCalendarDate.getMonth() - 1);
                    renderFundedCalendar();
                };
            }

            if (fundedElements.calendarNext) {
                fundedElements.calendarNext.onclick = () => {
                    currentFundedCalendarDate.setMonth(currentFundedCalendarDate.getMonth() + 1);
                    renderFundedCalendar();
                };
            }

            // Inicialización
            refreshFunded();
            renderFundedCalendar();
            
            // Exportar funciones al scope global para uso externo
            window.refreshFunded = refreshFunded;
            window.renderFundedCalendar = renderFundedCalendar;
            
            console.log('✅ Funded Accounts inicializado completamente');
        }

        // =============================================
        // AUDICIÓN - SECCIÓN DE PERFIL PÚBLICO
        // =============================================
        
        let audicionCharts = {};
        
        // Inicializar canvas de gauges
        function initGaugeCanvases() {
            const gaugeIds = [
                'gauge-pl-total',
                'gauge-win-rate',
                'gauge-profit-factor',
                'gauge-day-win'
            ];
            
            gaugeIds.forEach(id => {
                const canvas = document.getElementById(id);
                if (canvas) {
                    const dpr = window.devicePixelRatio || 1;
                    canvas.width = 140 * dpr;
                    canvas.height = 140 * dpr;
                    const ctx = canvas.getContext('2d');
                    ctx.scale(dpr, dpr);
                }
            });
        }
        
        async function initAudicion() {
            console.log('⭐ Inicializando Audición...');
            
            // Inicializar canvas de gauges
            initGaugeCanvases();
            
            // Verificar si es vista pública
            const urlParams = new URLSearchParams(window.location.search);
            const audicionParam = urlParams.get('audicion');
            
            if (audicionParam) {
                // Cargar vista pública desde Supabase
                await loadPublicAudicion(audicionParam);
                return;
            }
            
            // Poblar selector de cuentas
            const accountSelect = document.getElementById('audicion-account-select');
            if (accountSelect) {
                accountSelect.innerHTML = '<option value="all">Todas las cuentas</option>';
                DB.accounts.forEach(account => {
                    const option = document.createElement('option');
                    option.value = account.id;
                    option.textContent = account.name;
                    accountSelect.appendChild(option);
                });
                
                accountSelect.addEventListener('change', function() {
                    refreshAudicion();
                    // También actualizar Social Media si está visible
                    if (typeof loadPublicTraders === 'function') {
                        loadPublicTraders();
                    }
                });
            }
            
            // Cargar información del usuario
            loadAudicionUserInfo();
            
            // Configurar link público
            setupAudicionPublicLink();
            
            // Configurar calendario de filtros
            setupAudicionDateFilter();
            
            // Refresh inicial
            refreshAudicion();
            
            console.log('✅ Audición inicializada');
        }
        
        // Variables globales para el calendario de Audición
        let audicionCurrentMonth = new Date().getMonth();
        let audicionCurrentYear = new Date().getFullYear();
        let audicionSelectedStartDate = null;
        let audicionSelectedEndDate = null;
        
        function setupAudicionDateFilter() {
            const filterBtn = document.getElementById('audicion-filter-dates-btn');
            const filterBtnHeader = document.getElementById('audicion-filter-dates-btn-header');
            const modal = document.getElementById('audicion-date-range-modal');
            const closeBtn = document.getElementById('audicion-date-range-close-btn');
            const applyBtn = document.getElementById('audicion-date-range-apply-btn');
            const clearBtn = document.getElementById('audicion-date-range-clear-btn');
            const prevMonth = document.getElementById('audicion-calendar-prev-month');
            const nextMonth = document.getElementById('audicion-calendar-next-month');
            
            if (!modal) return;
            
            // Función para abrir modal
            const openModal = () => {
                modal.classList.remove('hidden');
                renderAudicionCalendar();
            };
            
            // Abrir modal desde ambos botones
            filterBtn?.addEventListener('click', openModal);
            filterBtnHeader?.addEventListener('click', openModal);
            
            // Cerrar modal
            closeBtn?.addEventListener('click', () => modal.classList.add('hidden'));
            modal?.addEventListener('click', (e) => {
                if (e.target === modal) modal.classList.add('hidden');
            });
            
            // Navegar calendario
            prevMonth?.addEventListener('click', () => {
                audicionCurrentMonth--;
                if (audicionCurrentMonth < 0) {
                    audicionCurrentMonth = 11;
                    audicionCurrentYear--;
                }
                renderAudicionCalendar();
            });
            
            nextMonth?.addEventListener('click', () => {
                audicionCurrentMonth++;
                if (audicionCurrentMonth > 11) {
                    audicionCurrentMonth = 0;
                    audicionCurrentYear++;
                }
                renderAudicionCalendar();
            });
            
            // Rangos rápidos
            document.querySelectorAll('.audicion-date-range-preset').forEach(btn => {
                btn.addEventListener('click', () => {
                    const range = btn.dataset.range;
                    const today = new Date();
                    let start, end;
                    
                    switch(range) {
                        case 'today':
                            start = end = today;
                            break;
                        case 'this_week':
                            start = new Date(today.setDate(today.getDate() - today.getDay()));
                            end = new Date();
                            break;
                        case 'this_month':
                            start = new Date(today.getFullYear(), today.getMonth(), 1);
                            end = new Date();
                            break;
                        case 'last_7_days':
                            start = new Date(today.setDate(today.getDate() - 7));
                            end = new Date();
                            break;
                        case 'last_30_days':
                            start = new Date(today.setDate(today.getDate() - 30));
                            end = new Date();
                            break;
                        case 'this_year':
                            start = new Date(today.getFullYear(), 0, 1);
                            end = new Date();
                            break;
                    }
                    
                    audicionSelectedStartDate = start;
                    audicionSelectedEndDate = end;
                    updateAudicionDateInputs();
                    renderAudicionCalendar();
                });
            });
            
            // Aplicar filtro
            applyBtn?.addEventListener('click', () => {
                modal.classList.add('hidden');
                refreshAudicionWithFilter();
            });
            
            // Limpiar filtro
            clearBtn?.addEventListener('click', () => {
                audicionSelectedStartDate = null;
                audicionSelectedEndDate = null;
                updateAudicionDateInputs();
                renderAudicionCalendar();
            });
        }
        
        function renderAudicionCalendar() {
            const monthYear = document.getElementById('audicion-calendar-month-year');
            const daysContainer = document.getElementById('audicion-calendar-days');
            
            if (!monthYear || !daysContainer) return;
            
            const monthNames = ['Dic 2025', 'Ene 2026', 'Feb 2026', 'Mar 2026', 'Abr 2026', 'May 2026', 
                               'Jun 2026', 'Jul 2026', 'Ago 2026', 'Sep 2026', 'Oct 2026', 'Nov 2026'];
            monthYear.textContent = `${monthNames[audicionCurrentMonth]} ${audicionCurrentYear}`;
            
            const firstDay = new Date(audicionCurrentYear, audicionCurrentMonth, 1).getDay();
            const daysInMonth = new Date(audicionCurrentYear, audicionCurrentMonth + 1, 0).getDate();
            
            daysContainer.innerHTML = '';
            
            // Días vacíos del inicio
            for (let i = 0; i < firstDay; i++) {
                daysContainer.innerHTML += '<div></div>';
            }
            
            // Días del mes
            for (let day = 1; day <= daysInMonth; day++) {
                const date = new Date(audicionCurrentYear, audicionCurrentMonth, day);
                const isSelected = (audicionSelectedStartDate && date.toDateString() === audicionSelectedStartDate.toDateString()) ||
                                 (audicionSelectedEndDate && date.toDateString() === audicionSelectedEndDate.toDateString());
                const isInRange = audicionSelectedStartDate && audicionSelectedEndDate &&
                                date >= audicionSelectedStartDate && date <= audicionSelectedEndDate;
                
                const dayBtn = document.createElement('button');
                dayBtn.textContent = day;
                dayBtn.className = `p-2 rounded text-sm ${isSelected ? 'bg-primary text-background' : isInRange ? 'bg-primary bg-opacity-20 text-primary' : 'hover:bg-surface-light'}`;
                
                dayBtn.addEventListener('click', () => {
                    if (!audicionSelectedStartDate || (audicionSelectedStartDate && audicionSelectedEndDate)) {
                        audicionSelectedStartDate = date;
                        audicionSelectedEndDate = null;
                    } else {
                        if (date < audicionSelectedStartDate) {
                            audicionSelectedEndDate = audicionSelectedStartDate;
                            audicionSelectedStartDate = date;
                        } else {
                            audicionSelectedEndDate = date;
                        }
                    }
                    updateAudicionDateInputs();
                    renderAudicionCalendar();
                });
                
                daysContainer.appendChild(dayBtn);
            }
        }
        
        function updateAudicionDateInputs() {
            const startInput = document.getElementById('audicion-date-range-start-input');
            const endInput = document.getElementById('audicion-date-range-end-input');
            
            if (startInput) startInput.value = audicionSelectedStartDate ? formatDate(audicionSelectedStartDate) : '';
            if (endInput) endInput.value = audicionSelectedEndDate ? formatDate(audicionSelectedEndDate) : '';
        }
        
        function refreshAudicionWithFilter() {
            // Aquí aplicarías el filtro a los datos
            // Por ahora solo refresh normal
            refreshAudicion();
        }
        
        async function loadPublicAudicion(audicionId) {
            try {
                console.log('📥 Cargando audición pública:', audicionId);
                
                // Mostrar la sección de Audición
                const audicionSection = document.getElementById('audicion-section');
                if (audicionSection) {
                    audicionSection.classList.add('active');
                    audicionSection.style.display = 'block';
                }
                
                // Ocultar todas las demás secciones
                document.querySelectorAll('.section-content:not(#audicion-section)').forEach(section => {
                    section.classList.remove('active');
                    section.style.display = 'none';
                });
                
                // Si audicionId contiene 'data=' (formato antiguo), usar decodificación base64
                let data;
                if (audicionId && audicionId.includes('public&data=')) {
                    console.log('📦 Formato antiguo detectado - usando base64');
                    const encodedData = audicionId.split('data=')[1];
                    const decodedData = decodeURIComponent(atob(encodedData));
                    data = JSON.parse(decodedData);
                } else {
                    console.log('🔍 Cargando desde Supabase con ID:', audicionId);
                    
                    // Verificar que supabase esté disponible
                    if (!window.supabase) {
                        console.error('❌ Supabase no está disponible');
                        alert('Error: Sistema de base de datos no disponible. Recarga la página.');
                        return;
                    }
                    
                    // Cargar desde Supabase usando el ID
                    const { data: audicionData, error } = await supabase
                        .from('public_audiciones')
                        .select('data')
                        .eq('id', audicionId)
                        .single();
                    
                    if (error) {
                        console.error('❌ Error cargando audición:', error);
                        alert(`No se encontró la audición solicitada.\n\nError: ${error.message}`);
                        // Redirigir a la página principal
                        window.location.href = window.location.origin;
                        return;
                    }
                    
                    if (!audicionData || !audicionData.data) {
                        console.error('❌ No se encontraron datos');
                        alert('No se encontró la audición solicitada.');
                        window.location.href = window.location.origin;
                        return;
                    }
                    
                    data = audicionData.data;
                    console.log('✅ Datos cargados desde Supabase:', data);
                }
                
                console.log('📥 Cargando datos públicos de Audición...', data);
                
                // Verificar estructura de datos y normalizar
                const personalInfo = data.personalInfo || {};
                const metrics = data.metrics || {};
                const trades = data.trades || {};
                const charts = data.charts || {};
                const privacySettings = data.privacySettings || {};
                
                console.log('📊 Personal Info:', personalInfo);
                console.log('📊 Metrics:', metrics);
                console.log('🔒 Privacy Settings:', privacySettings);
                
                // Cargar información del usuario
                const userAvatar = document.getElementById('audicion-user-avatar');
                if (userAvatar) {
                    if (privacySettings.showAvatar === false) {
                        userAvatar.textContent = 'U';
                    } else if (personalInfo.profileImage) {
                        userAvatar.innerHTML = `<img src="${personalInfo.profileImage}" alt="Profile" class="w-full h-full object-cover">`;
                    } else if (personalInfo.username && personalInfo.username.length > 0) {
                        userAvatar.textContent = personalInfo.username.charAt(0).toUpperCase();
                    } else if (personalInfo.email && personalInfo.email.length > 0) {
                        userAvatar.textContent = personalInfo.email.charAt(0).toUpperCase();
                    } else {
                        userAvatar.textContent = 'U';
                    }
                }
                
                const username = document.getElementById('audicion-username');
                if (username) username.textContent = personalInfo.username || 'Usuario';
                
                const userEmail = document.getElementById('audicion-user-email');
                if (userEmail) {
                    if (privacySettings.showEmail === false) {
                        userEmail.style.display = 'none';
                    } else {
                        userEmail.textContent = personalInfo.email || 'email@example.com';
                    }
                }
                
                const memberSince = document.getElementById('audicion-member-since');
                const memberSinceParent = memberSince?.parentElement;
                if (memberSince && memberSinceParent) {
                    if (privacySettings.showMemberSince === false) {
                        memberSinceParent.style.display = 'none';
                    } else {
                        memberSince.textContent = personalInfo.memberSince || 'Dic 2024';
                    }
                }
                
                const tradingSince = document.getElementById('audicion-trading-since');
                if (tradingSince) tradingSince.textContent = personalInfo.tradingSince || 'Ene 2023';
                
                // OCULTAR ELEMENTOS DE LA PLATAFORMA EN VISTA PÚBLICA
                // Ocultar header principal
                const mainHeader = document.querySelector('.main-header');
                if (mainHeader) mainHeader.style.display = 'none';
                
                // Ocultar sidebar
                const sidebar = document.querySelector('.sidebar');
                if (sidebar) sidebar.style.display = 'none';
                
                // Ajustar el contenido principal para ocupar toda la pantalla
                const mainContent = document.querySelector('.main-content');
                if (mainContent) {
                    mainContent.style.marginLeft = '0';
                    mainContent.style.width = '100%';
                }
                
                // Ajustar body para vista pública
                document.body.classList.add('public-audicion-view');
                
                // Mostrar header público
                const publicHeader = document.getElementById('audicion-public-header');
                if (publicHeader) publicHeader.style.display = 'block';
                
                // Ocultar sección de link público
                const linkSection = document.getElementById('audicion-public-link-section');
                if (linkSection) linkSection.style.display = 'none';
                
                // Ocultar selector de cuenta en audición
                const accountSelector = document.getElementById('audicion-account-select');
                if (accountSelector && accountSelector.parentElement) {
                    accountSelector.parentElement.style.display = 'none';
                }
                
                // Actualizar métricas (pasar metrics)
                updateAudicionMetricsFromData(metrics);
                
                // Actualizar gauges circulares
                updateAudicionCharts(metrics);
                
                // Aplicar configuración de privacidad para gráficos
                applyPrivacySettingsToCharts(privacySettings);
                
                // Actualizar gráfico semanal
                if (trades && trades.length > 0) {
                    updateAudicionWeeklyChartFromData(trades);
                    
                    // Ocultar si la configuración lo indica
                    const weeklyChartCard = document.querySelector('#audicion-weekly-chart')?.closest('.metric-card');
                    if (weeklyChartCard && privacySettings.showWeeklyChart === false) {
                        weeklyChartCard.style.display = 'none';
                    }
                }
                
                // Actualizar curvas
                updateAudicionCurvesFromData(charts);
                
                // Actualizar trades
                updateAudicionTradesFromData(trades);
                
                // Aplicar configuración de privacidad adicional
                applyPrivacySettings(privacySettings);
                
                console.log('✅ Vista pública cargada correctamente');
                
            } catch (e) {
                console.error('❌ Error cargando datos públicos:', e);
                console.error('❌ Stack:', e.stack);
                alert(`Error al cargar la audición: ${e.message}\n\nSerás redirigido a la página principal.`);
                window.location.href = window.location.origin;
            }
        }
        
        function updateAudicionMetricsFromData(metrics) {
            const plValue = parseFloat(metrics.totalPL) || 0;
            const plTotal = document.getElementById('audicion-pl-total');
            if (plTotal) {
                plTotal.textContent = `$${plValue.toFixed(2)}`;
                plTotal.style.color = plValue >= 0 ? '#39ff14' : '#ff4136';
            }
            
            // NO actualizar audicion-total-wins/losses aquí - lo maneja updateAudicionAdvancedStats
            
            const winners = document.getElementById('audicion-winners');
            if (winners) winners.textContent = metrics.winners || 0;
            
            const losers = document.getElementById('audicion-losers');
            if (losers) losers.textContent = metrics.losers || 0;
            
            const breakeven = document.getElementById('audicion-breakeven');
            if (breakeven) breakeven.textContent = metrics.breakeven || 0;
            
            // NO actualizar audicion-win-rate ni audicion-profit-factor aquí - lo maneja updateAudicionAdvancedStats
            
            const pfRatio = document.getElementById('audicion-pf-ratio');
            if (pfRatio) {
                const pf = parseFloat(metrics.profitFactor) || 0;
                pfRatio.textContent = pf >= 1 ? `${pf.toFixed(1)}:1` : '0:1';
            }
            
            const dayWinRate = document.getElementById('audicion-day-win-rate');
            if (dayWinRate) dayWinRate.textContent = `${metrics.dayWinRate || 0}%`;
            
            const winningDays = document.getElementById('audicion-winning-days');
            if (winningDays) winningDays.textContent = metrics.winningDays || 0;
            
            const losingDays = document.getElementById('audicion-losing-days');
            if (losingDays) losingDays.textContent = metrics.losingDays || 0;
            
            // NO actualizar audicion-best-trade, audicion-worst-trade, audicion-avg-trade aquí
            // Estos se calculan directamente de los trades en updateAudicionAdvancedStats
        }
        
        // Función para calcular P&L semanal (últimos 7 días)
        function calculateWeeklyPL(trades) {
            const now = new Date();
            const oneWeekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
            
            return trades.reduce((total, trade) => {
                try {
                    const tradeDate = new Date(trade.date);
                    if (tradeDate >= oneWeekAgo) {
                        return total + (parseFloat(trade.pl) || 0);
                    }
                } catch (e) {
                    console.error('Error parsing trade date:', e);
                }
                return total;
            }, 0);
        }
        
        // Función para calcular P&L semanal desde operaciones DB
        function calculateWeeklyPLFromOps(operations) {
            const now = new Date();
            const oneWeekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
            
            return operations.reduce((total, op) => {
                try {
                    const opDate = new Date(op.date);
                    if (opDate >= oneWeekAgo) {
                        return total + (parseFloat(op.pl) || 0);
                    }
                } catch (e) {
                    console.error('Error parsing operation date:', e);
                }
                return total;
            }, 0);
        }
        
        function updateAudicionWeeklyChartFromData(trades) {
            const ctx = document.getElementById('audicion-weekly-chart');
            if (!ctx) return;
            
            // Agrupar trades por fecha y sumar P&L
            const now = new Date();
            const weeklyData = [];
            
            for (let i = 6; i >= 0; i--) {
                const date = new Date(now);
                date.setDate(date.getDate() - i);
                const dateStr = date.toISOString().split('T')[0];
                
                // Calcular P&L del día
                const dayPL = trades
                    .filter(trade => trade.date === dateStr)
                    .reduce((sum, trade) => sum + (parseFloat(trade.pl) || 0), 0);
                
                weeklyData.push({
                    date: dateStr,
                    label: date.toLocaleDateString('es-ES', { day: '2-digit', month: '2-digit', year: 'numeric' }),
                    pl: dayPL
                });
            }
            
            // Destruir gráfico anterior si existe
            if (audicionCharts.weekly) {
                audicionCharts.weekly.destroy();
            }
            
            // Crear gráfico de barras
            audicionCharts.weekly = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: weeklyData.map(d => d.label),
                    datasets: [{
                        label: 'P&L Diario',
                        data: weeklyData.map(d => d.pl),
                        backgroundColor: weeklyData.map(d => d.pl >= 0 ? '#39ff14' : '#ff4136'),
                        borderColor: weeklyData.map(d => d.pl >= 0 ? '#39ff14' : '#ff4136'),
                        borderWidth: 1,
                        borderRadius: 4,
                        barThickness: 35,
                        maxBarThickness: 40
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.9)',
                            titleColor: '#fff',
                            bodyColor: '#fff',
                            borderColor: '#39ff14',
                            borderWidth: 1,
                            padding: 12,
                            titleFont: {
                                size: 13,
                                weight: 'bold'
                            },
                            bodyFont: {
                                size: 12
                            },
                            callbacks: {
                                label: function(context) {
                                    const value = context.parsed.y;
                                    return `P&L: $${value.toFixed(2)}`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            grid: {
                                color: 'rgba(148, 163, 184, 0.1)',
                                drawBorder: false
                            },
                            ticks: {
                                color: '#a0a0a0',
                                font: {
                                    size: 11
                                },
                                padding: 8,
                                callback: function(value) {
                                    return '$' + value.toFixed(0);
                                }
                            }
                        },
                        x: {
                            grid: {
                                display: false,
                                drawBorder: false
                            },
                            ticks: {
                                color: '#a0a0a0',
                                font: {
                                    size: 10
                                },
                                maxRotation: 45,
                                minRotation: 45,
                                padding: 5
                            }
                        }
                    },
                    layout: {
                        padding: {
                            top: 10,
                            right: 10,
                            bottom: 5,
                            left: 5
                        }
                    }
                }
            });
        }
        
        function updateAudicionCurvesFromData(charts) {
            // Verificar que charts tenga los datos necesarios
            if (!charts || (!charts.profitCurve && !charts.drawdownCurve)) {
                console.warn('⚠️ No hay datos de curvas para mostrar');
                return;
            }
            
            // Curva de profit
            const profitCtx = document.getElementById('audicion-profit-curve');
            if (profitCtx && charts.profitCurve && charts.profitCurve.length > 0) {
                if (audicionCharts.profit) audicionCharts.profit.destroy();
                
                const profitValues = charts.profitCurve.map(p => p.value || 0);
                
                audicionCharts.profit = new Chart(profitCtx, {
                    type: 'line',
                    data: {
                        labels: charts.profitCurve.map((p, i) => p.date || `Trade ${i + 1}`),
                        datasets: [{
                            label: 'Profit Acumulado',
                            data: profitValues,
                            borderColor: '#39ff14',
                            backgroundColor: (context) => {
                                const ctx = context.chart.ctx;
                                const gradient = ctx.createLinearGradient(0, 0, 0, 300);
                                gradient.addColorStop(0, 'rgba(57, 255, 20, 0.3)');
                                gradient.addColorStop(1, 'rgba(57, 255, 20, 0)');
                                return gradient;
                            },
                            borderWidth: 3,
                            fill: true,
                            tension: 0.4,
                            pointRadius: 0,
                            pointHoverRadius: 7,
                            pointHoverBackgroundColor: '#39ff14',
                            pointHoverBorderColor: '#000',
                            pointHoverBorderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false
                        },
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                enabled: true,
                                backgroundColor: 'rgba(0, 0, 0, 0.95)',
                                titleColor: '#39ff14',
                                bodyColor: '#fff',
                                borderColor: '#39ff14',
                                borderWidth: 2,
                                padding: 12,
                                displayColors: false,
                                titleFont: {
                                    size: 13,
                                    weight: 'bold'
                                },
                                bodyFont: {
                                    size: 14
                                },
                                callbacks: {
                                    title: function(context) {
                                        return context[0].label;
                                    },
                                    label: function(context) {
                                        const value = context.parsed.y;
                                        const change = context.dataIndex > 0 
                                            ? (value - profitValues[context.dataIndex - 1]).toFixed(2)
                                            : 0;
                                        return [
                                            `P&L: $${value.toFixed(2)}`,
                                            `Cambio: ${change >= 0 ? '+' : ''}$${change}`
                                        ];
                                    }
                                }
                            }
                        },
                        scales: {
                            x: { 
                                display: false 
                            },
                            y: {
                                ticks: { 
                                    color: '#94A3B8',
                                    callback: function(value) {
                                        return '$' + value.toFixed(0);
                                    }
                                },
                                grid: { 
                                    color: 'rgba(148, 163, 184, 0.1)',
                                    drawBorder: false
                                }
                            }
                        }
                    }
                });
            }
            
            // Curva de drawdown
            const drawdownCtx = document.getElementById('audicion-drawdown-curve');
            if (drawdownCtx && charts.drawdownCurve && charts.drawdownCurve.length > 0) {
                if (audicionCharts.drawdown) audicionCharts.drawdown.destroy();
                
                const drawdownValues = charts.drawdownCurve.map(d => d.value || 0);
                
                audicionCharts.drawdown = new Chart(drawdownCtx, {
                    type: 'line',
                    data: {
                        labels: charts.drawdownCurve.map((d, i) => d.date || `Trade ${i + 1}`),
                        datasets: [{
                            label: 'Drawdown',
                            data: drawdownValues,
                            borderColor: '#ff4136',
                            backgroundColor: (context) => {
                                const ctx = context.chart.ctx;
                                const gradient = ctx.createLinearGradient(0, 0, 0, 300);
                                gradient.addColorStop(0, 'rgba(255, 65, 54, 0)');
                                gradient.addColorStop(1, 'rgba(255, 65, 54, 0.3)');
                                return gradient;
                            },
                            borderWidth: 3,
                            fill: true,
                            tension: 0.4,
                            pointRadius: 0,
                            pointHoverRadius: 7,
                            pointHoverBackgroundColor: '#ff4136',
                            pointHoverBorderColor: '#000',
                            pointHoverBorderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false
                        },
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                enabled: true,
                                backgroundColor: 'rgba(0, 0, 0, 0.95)',
                                titleColor: '#ff4136',
                                bodyColor: '#fff',
                                borderColor: '#ff4136',
                                borderWidth: 2,
                                padding: 12,
                                displayColors: false,
                                titleFont: {
                                    size: 13,
                                    weight: 'bold'
                                },
                                bodyFont: {
                                    size: 14
                                },
                                callbacks: {
                                    title: function(context) {
                                        return context[0].label;
                                    },
                                    label: function(context) {
                                        const value = context.parsed.y;
                                        const recovery = context.dataIndex > 0
                                            ? (drawdownValues[context.dataIndex - 1] - value).toFixed(2)
                                            : 0;
                                        return [
                                            `Drawdown: -$${Math.abs(value).toFixed(2)}`,
                                            `Recuperación: ${recovery >= 0 ? '+' : ''}$${Math.abs(recovery)}`
                                        ];
                                    }
                                }
                            }
                        },
                        scales: {
                            x: { 
                                display: false 
                            },
                            y: {
                                reverse: true,
                                ticks: { 
                                    color: '#94A3B8',
                                    callback: function(value) {
                                        return '-$' + Math.abs(value).toFixed(0);
                                    }
                                },
                                grid: { 
                                    color: 'rgba(148, 163, 184, 0.1)',
                                    drawBorder: false
                                }
                            }
                        }
                    }
                });
            }
        }
        
        function updateAudicionTradesFromData(trades) {
            const tbody = document.querySelector('#audicion-latest-trades tbody');
            if (!tbody || !trades || trades.length === 0) {
                console.warn('⚠️ No hay trades para mostrar o tbody no encontrado');
                return;
            }
            
            tbody.innerHTML = '';
            
            // Calcular estadísticas adicionales
            let totalWins = 0, totalLosses = 0;
            let totalWinPL = 0, totalLossPL = 0;
            let largestWin = 0, largestLoss = 0;
            let winDurations = [], lossDurations = [];
            let rrValues = [];
            
            trades.forEach(trade => {
                const row = document.createElement('tr');
                row.className = 'border-b border-border hover:bg-surface-light transition-colors';
                
                const pl = parseFloat(trade.pl) || 0;
                const roi = parseFloat(trade.roi) || 0;
                const volume = parseFloat(trade.volume) || parseFloat(trade.contracts) || 0;
                
                // Calcular duración
                let duration = 'N/A';
                let durationMinutes = 0;
                if (trade.entry_time && trade.exit_time) {
                    const entryDate = new Date(trade.entry_time);
                    const exitDate = new Date(trade.exit_time);
                    durationMinutes = Math.abs(exitDate - entryDate) / (1000 * 60);
                    
                    const hours = Math.floor(durationMinutes / 60);
                    const mins = Math.floor(durationMinutes % 60);
                    
                    if (hours > 24) {
                        const days = Math.floor(hours / 24);
                        duration = `${days}d ${hours % 24}h`;
                    } else if (hours > 0) {
                        duration = `${hours}h ${mins}m`;
                    } else {
                        duration = `${mins}m`;
                    }
                }
                
                // Calcular R:R (Risk:Reward ratio alcanzado)
                let rr = 'N/A';
                let rrValue = 0;
                if (trade.entry_price && trade.exit_price && trade.stop_loss) {
                    const entryPrice = parseFloat(trade.entry_price);
                    const exitPrice = parseFloat(trade.exit_price);
                    const stopLoss = parseFloat(trade.stop_loss);
                    
                    const risk = Math.abs(entryPrice - stopLoss);
                    const reward = Math.abs(exitPrice - entryPrice);
                    
                    if (risk > 0) {
                        rrValue = reward / risk;
                        rr = `1:${rrValue.toFixed(1)}`;
                        rrValues.push(rrValue);
                    }
                } else if (trade.rr) {
                    rrValue = parseFloat(trade.rr);
                    rr = `1:${rrValue.toFixed(1)}`;
                    rrValues.push(rrValue);
                }
                
                // Determinar dirección basado en trade.type (long/short/buy/sell)
                let direction = 'LONG';
                const typeStr = (trade.type || '').toLowerCase();
                if (typeStr === 'short' || typeStr === 'sell') {
                    direction = 'SHORT';
                } else if (typeStr === 'long' || typeStr === 'buy') {
                    direction = 'LONG';
                }
                
                // Sesión de operación (asegurar que siempre tenga un valor)
                const session = trade.session || trade.category || 'New York';
                
                const resultado = pl > 0 ? 'WIN' : (pl < 0 ? 'LOSS' : 'BE');
                
                // Acumular estadísticas
                if (pl > 0) {
                    totalWins++;
                    totalWinPL += pl;
                    if (pl > largestWin) largestWin = pl;
                    if (durationMinutes > 0) winDurations.push(durationMinutes);
                } else if (pl < 0) {
                    totalLosses++;
                    totalLossPL += Math.abs(pl);
                    if (pl < largestLoss) largestLoss = pl;
                    if (durationMinutes > 0) lossDurations.push(durationMinutes);
                }
                
                row.innerHTML = `
                    <td class="py-3 px-2 text-left text-xs text-text-secondary">${trade.date}</td>
                    <td class="py-3 px-2 text-left">
                        <div class="flex items-center space-x-2">
                            <div class="w-6 h-6 rounded-full flex items-center justify-center text-xs font-bold" 
                                 style="background: linear-gradient(135deg, #39ff14, #00ff88);">
                                ${(trade.symbol || '').charAt(0)}
                            </div>
                            <span class="font-medium">${trade.symbol || 'N/A'}</span>
                        </div>
                    </td>
                    <td class="py-3 px-2">
                        <div class="flex justify-center">
                            <span class="px-2 py-1 rounded text-xs font-medium" 
                                  style="background-color: ${direction === 'LONG' ? 'rgba(57, 255, 20, 0.2)' : 'rgba(255, 65, 54, 0.2)'}; color: ${direction === 'LONG' ? '#39ff14' : '#ff4136'};">
                                ${direction}
                            </span>
                        </div>
                    </td>
                    <td class="py-3 px-2">
                        <div class="flex justify-center">
                            <span class="px-2 py-1 rounded text-xs font-medium bg-surface border border-border">
                                ${session}
                            </span>
                        </div>
                    </td>
                    <td class="py-3 px-2">
                        <div class="flex justify-center">
                            <span class="px-2 py-1 rounded text-xs font-medium" 
                                  style="background-color: ${resultado === 'WIN' ? 'rgba(57, 255, 20, 0.2)' : resultado === 'LOSS' ? 'rgba(255, 65, 54, 0.2)' : 'rgba(128, 128, 128, 0.2)'}; color: ${resultado === 'WIN' ? '#39ff14' : resultado === 'LOSS' ? '#ff4136' : '#888'};">
                                ${resultado}
                            </span>
                        </div>
                    </td>
                    <td class="py-3 px-2 text-right font-semibold" style="color: ${pl >= 0 ? '#39ff14' : '#ff4136'};">
                        ${pl >= 0 ? '+' : ''}$${pl.toFixed(2)}
                    </td>
                `;
                
                tbody.appendChild(row);
            });
            
            // Actualizar métricas adicionales
            updateAudicionAdvancedStats({
                totalWins,
                totalLosses,
                totalWinPL,
                totalLossPL,
                largestWin,
                largestLoss,
                winDurations,
                lossDurations,
                rrValues,
                totalTrades: trades.length
            });
        }
        
        function updateAudicionAdvancedStats(stats) {
            console.log('📊 Actualizando estadísticas avanzadas:', stats);
            
            // Win Rate
            const winRate = stats.totalTrades > 0 ? (stats.totalWins / stats.totalTrades * 100) : 0;
            const winRateEl = document.getElementById('audicion-win-rate');
            if (winRateEl) {
                winRateEl.textContent = `${winRate.toFixed(1)}%`;
                winRateEl.style.color = winRate >= 50 ? '#39ff14' : '#ff4136';
            }
            
            // Profit Factor
            const profitFactor = stats.totalLossPL > 0 ? (stats.totalWinPL / stats.totalLossPL) : 0;
            const pfEl = document.getElementById('audicion-profit-factor');
            if (pfEl) {
                pfEl.textContent = profitFactor.toFixed(2);
                pfEl.style.color = profitFactor >= 2 ? '#39ff14' : profitFactor >= 1 ? '#f59e0b' : '#ff4136';
            }
            
            // R:R Promedio
            const avgRR = stats.rrValues.length > 0 
                ? stats.rrValues.reduce((a, b) => a + b, 0) / stats.rrValues.length 
                : 0;
            const rrEl = document.getElementById('audicion-avg-rr');
            if (rrEl) {
                rrEl.textContent = `1:${avgRR.toFixed(1)}`;
                rrEl.style.color = avgRR >= 2 ? '#39ff14' : avgRR >= 1 ? '#f59e0b' : '#ff4136';
            }
            
            // Mejor Trade
            const bestTradeEl = document.getElementById('audicion-best-trade');
            if (bestTradeEl) {
                bestTradeEl.textContent = `$${stats.largestWin.toFixed(2)}`;
                bestTradeEl.style.color = '#39ff14';
            }
            
            // Peor Trade
            const worstTradeEl = document.getElementById('audicion-worst-trade');
            if (worstTradeEl) {
                worstTradeEl.textContent = `$${Math.abs(stats.largestLoss).toFixed(2)}`;
                worstTradeEl.style.color = '#ff4136';
            }
            
            // Promedio por Trade
            const avgTrade = stats.totalTrades > 0 
                ? (stats.totalWinPL - stats.totalLossPL) / stats.totalTrades 
                : 0;
            const avgTradeEl = document.getElementById('audicion-avg-trade');
            if (avgTradeEl) {
                avgTradeEl.textContent = `$${avgTrade.toFixed(2)}`;
                avgTradeEl.style.color = avgTrade >= 0 ? '#39ff14' : '#ff4136';
            }
            
            // Total Wins/Losses
            const totalWinsEl = document.getElementById('audicion-total-wins');
            if (totalWinsEl) totalWinsEl.textContent = stats.totalWins;
            
            const totalLossesEl = document.getElementById('audicion-total-losses');
            if (totalLossesEl) totalLossesEl.textContent = stats.totalLosses;
            
            // Average Win/Loss
            const avgWin = stats.totalWins > 0 ? stats.totalWinPL / stats.totalWins : 0;
            const avgWinEl = document.getElementById('audicion-avg-win');
            if (avgWinEl) avgWinEl.textContent = `$${avgWin.toFixed(2)}`;
            
            const avgLoss = stats.totalLosses > 0 ? stats.totalLossPL / stats.totalLosses : 0;
            const avgLossEl = document.getElementById('audicion-avg-loss');
            if (avgLossEl) avgLossEl.textContent = `-$${avgLoss.toFixed(2)}`;
            
            // Largest Win/Loss
            const largestWinEl = document.getElementById('audicion-largest-win');
            if (largestWinEl) largestWinEl.textContent = `$${stats.largestWin.toFixed(2)}`;
            
            const largestLossEl = document.getElementById('audicion-largest-loss');
            if (largestLossEl) largestLossEl.textContent = `$${Math.abs(stats.largestLoss).toFixed(2)}`;
            
            // Average Durations
            const avgWinDuration = stats.winDurations.length > 0
                ? stats.winDurations.reduce((a, b) => a + b, 0) / stats.winDurations.length
                : 0;
            const avgWinDurationEl = document.getElementById('audicion-avg-win-duration');
            if (avgWinDurationEl) {
                const hours = Math.floor(avgWinDuration / 60);
                const mins = Math.floor(avgWinDuration % 60);
                avgWinDurationEl.textContent = hours > 0 ? `${hours}h ${mins}m` : `${mins}m`;
            }
            
            const avgLossDuration = stats.lossDurations.length > 0
                ? stats.lossDurations.reduce((a, b) => a + b, 0) / stats.lossDurations.length
                : 0;
            const avgLossDurationEl = document.getElementById('audicion-avg-loss-duration');
            if (avgLossDurationEl) {
                const hours = Math.floor(avgLossDuration / 60);
                const mins = Math.floor(avgLossDuration % 60);
                avgLossDurationEl.textContent = hours > 0 ? `${hours}h ${mins}m` : `${mins}m`;
            }
        }
        
        async function saveAudicionToSupabase(audicionData) {
            if (!currentUser) {
                console.error('❌ No hay usuario autenticado');
                return null;
            }
            
            try {
                // Generar ID único para la audición
                const audicionId = `${currentUser.id.substring(0, 8)}_${Date.now()}`;
                
                console.log('💾 Guardando audición en Supabase...', audicionId);
                console.log('📦 Tamaño de datos:', JSON.stringify(audicionData).length, 'caracteres');
                
                // Guardar en tabla public_audiciones
                // Nota: NO usar .single() después de insert, y cambiar onConflict a 'id'
                const { data, error } = await supabase
                    .from('public_audiciones')
                    .insert({
                        id: audicionId,
                        user_id: currentUser.id,
                        data: audicionData,  // Supabase lo convierte a JSON automáticamente
                        created_at: new Date().toISOString(),
                        updated_at: new Date().toISOString()
                    })
                    .select();
                
                if (error) {
                    console.error('❌ Error guardando audición:', error);
                    console.error('❌ Detalles del error:', {
                        message: error.message,
                        details: error.details,
                        hint: error.hint,
                        code: error.code
                    });
                    return null;
                }
                
                console.log('✅ Audición guardada:', data);
                return audicionId;
                
            } catch (error) {
                console.error('❌ Error en saveAudicionToSupabase:', error);
                return null;
            }
        }
        
        function setupAudicionPublicLink() {
            const username = localStorage.getItem('username') || 'usuario';
            const linkInput = document.getElementById('audicion-public-link');
            
            // Botón de compartir
            const shareBtn = document.getElementById('share-audicion-btn');
            if (shareBtn) {
                shareBtn.addEventListener('click', async () => {
                    showMessage('🔄 Generando datos de audición...', 'info');
                    
                    // Usar setTimeout para no bloquear la UI
                    setTimeout(async () => {
                        // Generar datos para compartir
                        const audicionData = generateAudicionShareData();
                        
                        showMessage('💾 Guardando en servidor...', 'info');
                        
                        // Guardar en Supabase y obtener ID
                        const audicionId = await saveAudicionToSupabase(audicionData);
                        
                        if (!audicionId) {
                            showMessage('❌ Error al generar link', 'error');
                            return;
                        }
                        
                        // Construir URL corta
                        const publicLink = `${window.location.origin}/?audicion=${audicionId}`;
                        
                        if (linkInput) linkInput.value = publicLink;
                        
                        if (navigator.share) {
                            try {
                                await navigator.share({
                                    title: `Audición de Trading - ${username}`,
                                    text: `Mira mi perfil de trading en Trading Survivor`,
                                    url: publicLink
                                });
                                showMessage('✅ Link compartido exitosamente', 'success');
                            } catch (err) {
                                console.log('Error al compartir:', err);
                                copyToClipboard(publicLink);
                                showMessage('✅ Link copiado al portapapeles', 'success');
                            }
                        } else {
                            copyToClipboard(publicLink);
                            showMessage('✅ Link copiado al portapapeles', 'success');
                        }
                    }, 100); // Dar tiempo a que se muestre el mensaje
                });
            }
            
            // Botón de copiar
            const copyBtn = document.getElementById('copy-audicion-link');
            if (copyBtn) {
                copyBtn.addEventListener('click', async () => {
                    showMessage('🔄 Generando link...', 'info');
                    
                    const audicionData = generateAudicionShareData();
                    const audicionId = await saveAudicionToSupabase(audicionData);
                    
                    if (!audicionId) {
                        showMessage('❌ Error al generar link', 'error');
                        return;
                    }
                    
                    const publicLink = `${window.location.origin}/?audicion=${audicionId}`;
                    
                    if (linkInput) linkInput.value = publicLink;
                    copyToClipboard(publicLink);
                });
            }
            
            // === CONFIGURACIÓN DE PRIVACIDAD ===
            const privacyBtn = document.getElementById('audicion-privacy-settings-btn');
            const privacyModal = document.getElementById('audicion-privacy-modal');
            const privacyCloseBtn = document.getElementById('audicion-privacy-close-btn');
            const privacySaveBtn = document.getElementById('audicion-privacy-save-btn');
            const privacyResetBtn = document.getElementById('audicion-privacy-reset-btn');
            
            // Abrir modal
            if (privacyBtn) {
                privacyBtn.addEventListener('click', () => {
                    loadPrivacySettings();
                    privacyModal.classList.remove('hidden');
                });
            }
            
            // Cerrar modal
            if (privacyCloseBtn) {
                privacyCloseBtn.addEventListener('click', () => {
                    privacyModal.classList.add('hidden');
                });
            }
            
            // Cerrar al hacer click fuera del modal
            if (privacyModal) {
                privacyModal.addEventListener('click', (e) => {
                    if (e.target === privacyModal) {
                        privacyModal.classList.add('hidden');
                    }
                });
            }
            
            // Guardar configuración
            if (privacySaveBtn) {
                privacySaveBtn.addEventListener('click', () => {
                    savePrivacySettings();
                    privacyModal.classList.add('hidden');
                    showMessage('Configuración de privacidad guardada', 'success');
                });
            }
            
            // Restablecer configuración
            if (privacyResetBtn) {
                privacyResetBtn.addEventListener('click', () => {
                    resetPrivacySettings();
                    showMessage('Configuración restablecida a valores predeterminados', 'info');
                });
            }
        }
        
        // Funciones de configuración de privacidad
        function loadPrivacySettings() {
            const settings = JSON.parse(localStorage.getItem('audicion-privacy-settings') || '{}');
            
            // Cargar configuración o usar valores por defecto
            document.getElementById('privacy-show-email').checked = settings.showEmail !== false;
            document.getElementById('privacy-show-member-since').checked = settings.showMemberSince !== false;
            document.getElementById('privacy-show-avatar').checked = settings.showAvatar !== false;
            document.getElementById('privacy-show-exact-pl').checked = settings.showExactPL !== false;
            document.getElementById('privacy-show-best-worst').checked = settings.showBestWorst !== false;
            document.getElementById('privacy-show-trades-table').checked = settings.showTradesTable !== false;
            document.getElementById('privacy-show-profit-curve').checked = settings.showProfitCurve !== false;
            document.getElementById('privacy-show-drawdown-curve').checked = settings.showDrawdownCurve !== false;
            document.getElementById('privacy-show-weekly-chart').checked = settings.showWeeklyChart !== false;
        }
        
        function savePrivacySettings() {
            const settings = {
                showEmail: document.getElementById('privacy-show-email').checked,
                showMemberSince: document.getElementById('privacy-show-member-since').checked,
                showAvatar: document.getElementById('privacy-show-avatar').checked,
                showExactPL: document.getElementById('privacy-show-exact-pl').checked,
                showBestWorst: document.getElementById('privacy-show-best-worst').checked,
                showTradesTable: document.getElementById('privacy-show-trades-table').checked,
                showProfitCurve: document.getElementById('privacy-show-profit-curve').checked,
                showDrawdownCurve: document.getElementById('privacy-show-drawdown-curve').checked,
                showWeeklyChart: document.getElementById('privacy-show-weekly-chart').checked
            };
            
            localStorage.setItem('audicion-privacy-settings', JSON.stringify(settings));
            console.log('Configuración de privacidad guardada:', settings);
        }
        
        function resetPrivacySettings() {
            // Activar todos los checkboxes
            document.getElementById('privacy-show-email').checked = true;
            document.getElementById('privacy-show-member-since').checked = true;
            document.getElementById('privacy-show-avatar').checked = true;
            document.getElementById('privacy-show-exact-pl').checked = true;
            document.getElementById('privacy-show-best-worst').checked = true;
            document.getElementById('privacy-show-trades-table').checked = true;
            document.getElementById('privacy-show-profit-curve').checked = true;
            document.getElementById('privacy-show-drawdown-curve').checked = true;
            document.getElementById('privacy-show-weekly-chart').checked = true;
            
            // Guardar
            savePrivacySettings();
        }
        
        // Aplicar configuración de privacidad a los elementos visuales
        function applyPrivacySettings(settings) {
            // Tabla de trades
            const tradesCard = document.querySelector('#audicion-latest-trades')?.closest('.metric-card');
            if (tradesCard && settings.showTradesTable === false) {
                tradesCard.style.display = 'none';
            }
            
            // Mejor/Peor trade
            if (settings.showBestWorst === false) {
                const bestTradeCard = document.querySelector('#audicion-best-trade')?.closest('.metric-card');
                const worstTradeCard = document.querySelector('#audicion-worst-trade')?.closest('.metric-card');
                if (bestTradeCard) bestTradeCard.style.display = 'none';
                if (worstTradeCard) worstTradeCard.style.display = 'none';
            }
            
            // P&L exacto - Convertir a porcentajes si está desactivado
            if (settings.showExactPL === false) {
                const plElements = document.querySelectorAll('[id*="audicion-pl"], [id*="audicion-best"], [id*="audicion-worst"], [id*="audicion-avg"]');
                plElements.forEach(el => {
                    if (el.textContent.includes('$')) {
                        el.textContent = '***';
                    }
                });
            }
        }
        
        // Aplicar configuración de privacidad a los gráficos
        function applyPrivacySettingsToCharts(settings) {
            // Curva de profit
            const profitCurveCard = document.querySelector('#audicion-profit-curve')?.closest('.metric-card');
            if (profitCurveCard && settings.showProfitCurve === false) {
                profitCurveCard.style.display = 'none';
            }
            
            // Curva de drawdown
            const drawdownCurveCard = document.querySelector('#audicion-drawdown-curve')?.closest('.metric-card');
            if (drawdownCurveCard && settings.showDrawdownCurve === false) {
                drawdownCurveCard.style.display = 'none';
            }
        }
        
        function generateAudicionShareData() {
            const username = localStorage.getItem('username') || 'Usuario';
            const profileImage = localStorage.getItem('profile-image') || '';
            
            // Calcular métricas actuales
            const accountSelect = document.getElementById('audicion-account-select');
            const selectedAccount = accountSelect ? accountSelect.value : 'all';
            
            let filteredOps = [...DB.operations];
            if (selectedAccount !== 'all') {
                filteredOps = filteredOps.filter(op => op.accountId === selectedAccount);
            }
            
            console.log(`📊 [generateAudicionShareData] Generando datos de audición para ${filteredOps.length} operaciones`);
            console.log(`📊 [generateAudicionShareData] Cuenta seleccionada: ${selectedAccount}`);
            console.log(`📊 [generateAudicionShareData] Muestra de operaciones:`, filteredOps.slice(0, 3).map(op => ({
                id: op.id,
                pl: op.pl,
                date: op.date,
                instrument: op.instrument
            })));
            
            const metrics = calculateMetrics(filteredOps, selectedAccount);
            const dayStats = calculateDayWinStats(filteredOps);
            
            console.log(`📊 [generateAudicionShareData] Métricas calculadas:`, {
                totalWin: metrics.totalWin,
                totalLoss: metrics.totalLoss,
                totalFees: metrics.totalFees,
                winningTrades: metrics.winningTrades,
                losingTrades: metrics.losingTrades,
                totalTrades: metrics.totalTrades
            });
            
            let bestTrade = 0;
            let worstTrade = 0;
            filteredOps.forEach(op => {
                const pl = parseFloat(op.pl) || 0;
                if (pl > bestTrade) bestTrade = pl;
                if (pl < worstTrade) worstTrade = pl;
            });
            
            // Últimos 10 trades (limitado para no hacer URL demasiado largo)
            const latestTrades = [...filteredOps]
                .sort((a, b) => {
                    const dateA = new Date(`${a.date} ${a.exitTime || '00:00:00'}`);
                    const dateB = new Date(`${b.date} ${b.exitTime || '00:00:00'}`);
                    return dateB - dateA;
                })
                .slice(0, 10)  // Limitado a 10 trades
                .map(op => {
                    const pl = parseFloat(op.pl) || 0;
                    const size = parseFloat(op.volume) || parseFloat(op.size) || 0;
                    const roi = size > 0 ? ((pl / size) * 100) : 0;
                    
                    // Determinar resultado
                    let result = 'be';
                    if (pl > 0) result = 'win';
                    else if (pl < 0) result = 'loss';
                    
                    return {
                        id: op.id || 'N/A',
                        date: op.date,
                        symbol: op.instrument || op.symbol || 'N/A',
                        type: op.type || 'long',
                        side: op.type || 'buy',
                        category: op.session || 'SCALPING',
                        pl: pl,
                        roi: roi,
                        result: result
                    };
                });
            
            // Datos para curvas (limitado a últimos 30 puntos para reducir tamaño de URL)
            const sorted = [...filteredOps].sort((a, b) => {
                const dateA = new Date(`${a.date} ${a.exitTime || '00:00:00'}`);
                const dateB = new Date(`${b.date} ${b.exitTime || '00:00:00'}`);
                return dateA - dateB;
            }).slice(-30);  // Solo últimos 30 puntos
            
            let cumulativePL = 0;
            let peak = 0;
            const profitData = [];
            const drawdownData = [];
            const labels = [];
            
            sorted.forEach(op => {
                const pl = parseFloat(op.pl) || 0;
                cumulativePL += pl;
                if (cumulativePL > peak) peak = cumulativePL;
                const drawdown = peak - cumulativePL;
                
                profitData.push(parseFloat(cumulativePL.toFixed(2)));
                drawdownData.push(parseFloat((-drawdown).toFixed(2)));
                labels.push(new Date(op.date).toLocaleDateString('es-ES', { month: 'short', day: 'numeric' }));
            });
            
            // Convertir a formato array de objetos {date, value} para Chart.js
            const profitCurveArray = labels.map((label, i) => ({
                date: label,
                value: profitData[i]
            }));
            
            const drawdownCurveArray = labels.map((label, i) => ({
                date: label,
                value: drawdownData[i]
            }));
            
            const shareData = {
                metrics: {
                    totalPL: (metrics.totalWin + metrics.totalLoss) - metrics.totalFees,
                    winners: metrics.winningTrades,
                    losers: metrics.losingTrades,
                    breakeven: metrics.breakevenTrades,
                    winRate: metrics.totalTrades > 0 ? ((metrics.winningTrades / (metrics.winningTrades + metrics.losingTrades)) * 100).toFixed(1) : 0,
                    profitFactor: metrics.profitFactor,
                    dayWinRate: dayStats.totalDays > 0 ? ((dayStats.winningDays / dayStats.totalDays) * 100).toFixed(1) : 0,
                    winningDays: dayStats.winningDays,
                    losingDays: dayStats.losingDays,
                    bestTrade: bestTrade,
                    worstTrade: worstTrade,
                    avgTrade: metrics.totalTrades > 0 ? ((metrics.totalWin + metrics.totalLoss) / metrics.totalTrades).toFixed(2) : 0
                },
                trades: latestTrades,
                charts: {
                    profitCurve: profitCurveArray,
                    drawdownCurve: drawdownCurveArray
                },
                personalInfo: {
                    username: username,
                    email: currentUser ? currentUser.email : 'email@example.com',
                    profileImage: profileImage,
                    memberSince: localStorage.getItem('member-since') || 'Dic 2024',
                    tradingSince: filteredOps.length > 0 
                        ? new Date(sorted[0].date).toLocaleDateString('es-ES', { month: 'short', year: 'numeric' })
                        : 'Ene 2023'
                },
                privacySettings: JSON.parse(localStorage.getItem('audicion-privacy-settings') || '{}')
            };
            
            console.log(`📤 [generateAudicionShareData] Datos finales para compartir:`, {
                plTotal: shareData.metrics.totalPL,
                winners: shareData.metrics.winners,
                losers: shareData.metrics.losers,
                totalTrades: metrics.totalTrades,
                latestTradesCount: shareData.trades.length,
                firstTradeSample: shareData.trades[0]
            });
            
            return shareData;
        }
        
        function copyToClipboard(text) {
            const linkInput = document.getElementById('audicion-public-link');
            if (linkInput) {
                linkInput.value = text;
                linkInput.select();
                document.execCommand('copy');
                
                // Feedback visual
                const copyBtn = document.getElementById('copy-audicion-link');
                const originalHTML = copyBtn.innerHTML;
                copyBtn.innerHTML = '<i class="fas fa-check"></i>';
                copyBtn.classList.add('btn-primary');
                copyBtn.classList.remove('btn-outline');
                
                setTimeout(() => {
                    copyBtn.innerHTML = originalHTML;
                    copyBtn.classList.remove('btn-primary');
                    copyBtn.classList.add('btn-outline');
                }, 2000);
                
                showMessage('Link copiado al portapapeles', 'success');
            }
        }
        
        function loadAudicionUserInfo() {
            console.log('🔄 Cargando información de usuario en Audición...');
            
            // Cargar foto de perfil
            const profileImage = localStorage.getItem('profile-image');
            const audicionAvatar = document.getElementById('audicion-user-avatar');
            
            console.log('📸 Imagen de perfil:', profileImage ? 'Disponible' : 'No disponible');
            
            if (profileImage && audicionAvatar) {
                audicionAvatar.innerHTML = `<img src="${profileImage}" alt="Profile" class="w-full h-full object-cover">`;
            } else if (currentUser && audicionAvatar) {
                audicionAvatar.textContent = currentUser.email.charAt(0).toUpperCase();
            }
            
            // Cargar nombre de usuario
            const username = localStorage.getItem('username') || 'Usuario';
            const usernameEl = document.getElementById('audicion-username');
            if (usernameEl) {
                usernameEl.textContent = username;
                console.log('👤 Nombre de usuario cargado:', username);
            }
            
            // Cargar email
            if (currentUser) {
                const emailEl = document.getElementById('audicion-user-email');
                if (emailEl) emailEl.textContent = currentUser.email;
            }
            
            // Fecha de miembro (desde cuando se creó la cuenta)
            const memberSince = localStorage.getItem('member-since') || 'Dic 2024';
            const memberSinceEl = document.getElementById('audicion-member-since');
            if (memberSinceEl) memberSinceEl.textContent = memberSince;
            
            // Fecha de inicio de trading (usar fecha del primer trade o configuración)
            const firstTrade = DB.operations.length > 0 
                ? DB.operations.sort((a, b) => new Date(a.date) - new Date(b.date))[0]
                : null;
            
            let tradingSince = 'Ene 2023';
            if (firstTrade) {
                const date = new Date(firstTrade.date);
                tradingSince = date.toLocaleDateString('es-ES', { month: 'short', year: 'numeric' });
            }
            
            const tradingSinceEl = document.getElementById('audicion-trading-since');
            if (tradingSinceEl) tradingSinceEl.textContent = tradingSince;
        }
        
        function refreshAudicion() {
            console.log('🔄 Refrescando Audición...');
            
            const accountSelect = document.getElementById('audicion-account-select');
            const selectedAccount = accountSelect ? accountSelect.value : 'all';
            
            // Filtrar operaciones
            let filteredOps = [...DB.operations];
            if (selectedAccount !== 'all') {
                filteredOps = filteredOps.filter(op => op.accountId === selectedAccount);
            }
            
            // Calcular métricas de trades
            const metrics = calculateMetrics(filteredOps, selectedAccount);
            
            // Calcular métricas de días
            const dayStats = calculateDayWinStats(filteredOps);
            
            // Calcular mejor y peor trade
            let bestTrade = 0;
            let worstTrade = 0;
            filteredOps.forEach(op => {
                const pl = parseFloat(op.pl) || 0;
                if (pl > bestTrade) bestTrade = pl;
                if (pl < worstTrade) worstTrade = pl;
            });
            
            // Combinar métricas
            const fullMetrics = {
                ...metrics,
                ...dayStats,
                netPL: (metrics.totalWin + metrics.totalLoss) - metrics.totalFees,
                winners: metrics.winningTrades,
                losers: metrics.losingTrades,
                breakeven: metrics.breakevenTrades,
                bestTrade: bestTrade,
                worstTrade: worstTrade,
                allOperations: filteredOps // Pasar las operaciones para calcular P&L semanal
            };
            
            // Actualizar métricas principales
            updateAudicionMetrics(fullMetrics);
            
            // Actualizar gráficas circulares
            updateAudicionCharts(fullMetrics);
            
            // Actualizar gráfico semanal
            updateAudicionWeeklyChart(filteredOps);
            
            // Actualizar curvas
            updateAudicionCurves(filteredOps);
            
            // Actualizar últimos trades
            updateAudicionLatestTrades(filteredOps);
        }
        
        function updateAudicionMetrics(metrics) {
            // P&L Total
            const plTotal = document.getElementById('audicion-pl-total');
            if (plTotal) {
                const plValue = metrics.netPL || 0;
                plTotal.textContent = `$${plValue.toFixed(2)}`;
                plTotal.style.color = plValue >= 0 ? '#39ff14' : '#ff4136';
            }
            
            // Total Wins y Losses
            const totalWins = document.getElementById('audicion-total-wins');
            const totalLosses = document.getElementById('audicion-total-losses');
            if (totalWins) totalWins.textContent = metrics.winners || 0;
            if (totalLosses) totalLosses.textContent = metrics.losers || 0;
            
            // NO actualizar audicion-win-rate aquí - lo hace updateAudicionAdvancedStats
            
            // Win/Loss/Breakeven counts
            const winnersEl = document.getElementById('audicion-winners');
            const losersEl = document.getElementById('audicion-losers');
            const breakevenEl = document.getElementById('audicion-breakeven');
            if (winnersEl) winnersEl.textContent = metrics.winners || 0;
            if (losersEl) losersEl.textContent = metrics.losers || 0;
            if (breakevenEl) breakevenEl.textContent = metrics.breakeven || 0;
            
            // NO actualizar audicion-profit-factor aquí - lo hace updateAudicionAdvancedStats
            // Pero sí actualizar audicion-pf-ratio (es diferente)
            const pfRatio = document.getElementById('audicion-pf-ratio');
            if (pfRatio) {
                const ratio = metrics.profitFactor >= 1 ? `${metrics.profitFactor.toFixed(1)}:1` : '0:1';
                pfRatio.textContent = ratio;
            }
            
            // Day Win Rate
            const dayWinRate = document.getElementById('audicion-day-win-rate');
            if (dayWinRate) {
                const totalDays = (metrics.winningDays || 0) + (metrics.losingDays || 0);
                const dayPercentage = totalDays > 0 ? ((metrics.winningDays / totalDays) * 100).toFixed(1) : 0;
                dayWinRate.textContent = `${dayPercentage}%`;
            }
            
            const winningDaysEl = document.getElementById('audicion-winning-days');
            const losingDaysEl = document.getElementById('audicion-losing-days');
            if (winningDaysEl) winningDaysEl.textContent = metrics.winningDays || 0;
            if (losingDaysEl) losingDaysEl.textContent = metrics.losingDays || 0;
            
            // NO actualizar audicion-best-trade, audicion-worst-trade, audicion-avg-trade aquí
            // Estos se calculan en updateAudicionAdvancedStats que se llama desde updateAudicionLatestTrades
        }
        
        function updateAudicionCharts(metrics) {
            // Calcular valores para los gauges
            const totalTrades = (metrics.winners || 0) + (metrics.losers || 0) + (metrics.breakeven || 0);
            const netPL = metrics.netPL || 0;
            const winRate = totalTrades > 0 ? ((metrics.winners || 0) / totalTrades * 100) : 0;
            const profitFactor = metrics.profitFactor || 0;
            const totalDays = (metrics.winningDays || 0) + (metrics.losingDays || 0);
            const dayWinRate = totalDays > 0 ? ((metrics.winningDays || 0) / totalDays * 100) : 0;

            // Crear/actualizar gauges circulares
            createGauge('gauge-pl-total', netPL >= 0 ? Math.min(netPL / 1000 * 100, 100) : 0, netPL >= 0);
            createGauge('gauge-win-rate', winRate, winRate >= 50);
            createGauge('gauge-profit-factor', Math.min(profitFactor / 3 * 100, 100), profitFactor >= 1.5);
            createGauge('gauge-day-win', dayWinRate, dayWinRate >= 50);
        }

        function createGauge(canvasId, percentage, isPositive) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const width = 140;
            const height = 140;
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = 50;
            const lineWidth = 14;

            // Limpiar canvas
            ctx.clearRect(0, 0, width, height);

            // Configuración del arco
            const startAngle = 0.75 * Math.PI; // 135 grados
            const endAngle = 2.25 * Math.PI;   // 405 grados (270 grados totales)
            const progress = Math.min(Math.max(percentage, 0), 100) / 100;
            const currentAngle = startAngle + (endAngle - startAngle) * progress;

            // Arco de fondo (gris oscuro)
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, startAngle, endAngle);
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = lineWidth;
            ctx.lineCap = 'round';
            ctx.stroke();

            // Arco de progreso (verde o rojo)
            if (progress > 0) {
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, startAngle, currentAngle);
                
                // Crear gradiente
                const gradient = ctx.createLinearGradient(0, 0, width, height);
                if (isPositive) {
                    gradient.addColorStop(0, '#39ff14');
                    gradient.addColorStop(1, '#28e000');
                } else {
                    gradient.addColorStop(0, '#ff4136');
                    gradient.addColorStop(1, '#cc3329');
                }
                
                ctx.strokeStyle = gradient;
                ctx.lineWidth = lineWidth;
                ctx.lineCap = 'round';
                ctx.stroke();

                // Agregar sombra/brillo
                ctx.shadowColor = isPositive ? 'rgba(57, 255, 20, 0.4)' : 'rgba(255, 65, 54, 0.4)';
                ctx.shadowBlur = 10;
                ctx.stroke();
                ctx.shadowBlur = 0;
            }
        }
        
        function updateAudicionWeeklyChart(operations) {
            const ctx = document.getElementById('audicion-weekly-chart');
            if (!ctx) return;
            
            // Obtener los últimos 7 días
            const now = new Date();
            const weeklyData = [];
            
            for (let i = 6; i >= 0; i--) {
                const date = new Date(now);
                date.setDate(date.getDate() - i);
                const dateStr = date.toISOString().split('T')[0];
                
                // Calcular P&L del día
                const dayPL = operations
                    .filter(op => op.date === dateStr)
                    .reduce((sum, op) => sum + (parseFloat(op.pl) || 0), 0);
                
                weeklyData.push({
                    date: dateStr,
                    label: date.toLocaleDateString('es-ES', { day: '2-digit', month: '2-digit', year: 'numeric' }),
                    pl: dayPL
                });
            }
            
            // Destruir gráfico anterior si existe
            if (audicionCharts.weekly) {
                audicionCharts.weekly.destroy();
            }
            
            // Crear gráfico de barras
            audicionCharts.weekly = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: weeklyData.map(d => d.label),
                    datasets: [{
                        label: 'P&L Diario',
                        data: weeklyData.map(d => d.pl),
                        backgroundColor: weeklyData.map(d => d.pl >= 0 ? '#39ff14' : '#ff4136'),
                        borderColor: weeklyData.map(d => d.pl >= 0 ? '#39ff14' : '#ff4136'),
                        borderWidth: 1,
                        borderRadius: 4,
                        barThickness: 35,
                        maxBarThickness: 40
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.9)',
                            titleColor: '#fff',
                            bodyColor: '#fff',
                            borderColor: '#39ff14',
                            borderWidth: 1,
                            padding: 12,
                            titleFont: {
                                size: 13,
                                weight: 'bold'
                            },
                            bodyFont: {
                                size: 12
                            },
                            callbacks: {
                                label: function(context) {
                                    const value = context.parsed.y;
                                    return `P&L: $${value.toFixed(2)}`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            grid: {
                                color: 'rgba(148, 163, 184, 0.1)',
                                drawBorder: false
                            },
                            ticks: {
                                color: '#a0a0a0',
                                font: {
                                    size: 11
                                },
                                padding: 8,
                                callback: function(value) {
                                    return '$' + value.toFixed(0);
                                }
                            }
                        },
                        x: {
                            grid: {
                                display: false,
                                drawBorder: false
                            },
                            ticks: {
                                color: '#a0a0a0',
                                font: {
                                    size: 10
                                },
                                maxRotation: 45,
                                minRotation: 45,
                                padding: 5
                            }
                        }
                    },
                    layout: {
                        padding: {
                            top: 10,
                            right: 10,
                            bottom: 5,
                            left: 5
                        }
                    }
                }
            });
        }
        
        function updateAudicionCurves(operations) {
            if (operations.length === 0) {
                console.log('⚠️ No hay operaciones para graficar');
                return;
            }
            
            // Ordenar operaciones por fecha
            const sorted = [...operations].sort((a, b) => {
                const dateA = new Date(`${a.date} ${a.exitTime || '00:00:00'}`);
                const dateB = new Date(`${b.date} ${b.exitTime || '00:00:00'}`);
                return dateA - dateB;
            });
            
            // Calcular curva de profit acumulado
            let cumulativePL = 0;
            let peak = 0;
            const profitData = [];
            const drawdownData = [];
            const labels = [];
            
            sorted.forEach((op) => {
                const pl = parseFloat(op.pl) || 0;
                cumulativePL += pl;
                
                if (cumulativePL > peak) peak = cumulativePL;
                const drawdown = peak - cumulativePL;
                
                profitData.push(cumulativePL.toFixed(2));
                drawdownData.push(-drawdown.toFixed(2));
                
                // Formato de fecha mejorado
                const date = new Date(op.date);
                labels.push(date.toLocaleDateString('es-ES', { month: 'short', day: 'numeric' }));
            });
            
            // Curva de Profit
            const profitCtx = document.getElementById('audicion-profit-curve');
            if (profitCtx) {
                if (audicionCharts.profitCurve) audicionCharts.profitCurve.destroy();
                
                audicionCharts.profitCurve = new Chart(profitCtx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Profit Acumulado',
                            data: profitData,
                            borderColor: '#39ff14',
                            backgroundColor: 'rgba(57, 255, 20, 0.2)',
                            fill: true,
                            tension: 0.3,
                            pointRadius: 1,
                            pointHoverRadius: 5,
                            borderWidth: 3
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false
                        },
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                                padding: 10,
                                titleColor: '#39ff14',
                                bodyColor: '#fff',
                                borderColor: '#39ff14',
                                borderWidth: 1,
                                displayColors: false,
                                callbacks: {
                                    label: (context) => `$${context.parsed.y}`
                                }
                            }
                        },
                        scales: {
                            x: {
                                display: true,
                                grid: { display: false },
                                ticks: {
                                    color: '#9CA3AF',
                                    maxTicksLimit: 8,
                                    font: { size: 10 }
                                }
                            },
                            y: {
                                display: true,
                                grid: {
                                    color: 'rgba(255, 255, 255, 0.05)',
                                    drawBorder: false
                                },
                                ticks: {
                                    color: '#9CA3AF',
                                    font: { size: 10 },
                                    callback: (value) => `$${value}`
                                }
                            }
                        }
                    }
                });
            }
            
            // Curva de Drawdown
            const ddCtx = document.getElementById('audicion-drawdown-curve');
            if (ddCtx) {
                if (audicionCharts.drawdownCurve) audicionCharts.drawdownCurve.destroy();
                
                audicionCharts.drawdownCurve = new Chart(ddCtx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Drawdown',
                            data: drawdownData,
                            borderColor: '#ff4136',
                            backgroundColor: 'rgba(255, 65, 54, 0.2)',
                            fill: true,
                            tension: 0.3,
                            pointRadius: 1,
                            pointHoverRadius: 5,
                            borderWidth: 3
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false
                        },
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                                padding: 10,
                                titleColor: '#ff4136',
                                bodyColor: '#fff',
                                borderColor: '#ff4136',
                                borderWidth: 1,
                                displayColors: false,
                                callbacks: {
                                    label: (context) => `-$${Math.abs(context.parsed.y)}`
                                }
                            }
                        },
                        scales: {
                            x: {
                                display: true,
                                grid: { display: false },
                                ticks: {
                                    color: '#9CA3AF',
                                    maxTicksLimit: 8,
                                    font: { size: 10 }
                                }
                            },
                            y: {
                                display: true,
                                grid: {
                                    color: 'rgba(255, 255, 255, 0.05)',
                                    drawBorder: false
                                },
                                ticks: {
                                    color: '#9CA3AF',
                                    font: { size: 10 },
                                    callback: (value) => `-$${Math.abs(value)}`
                                }
                            }
                        }
                    }
                });
            }
        }
        
        function updateAudicionLatestTrades(operations) {
            const tbody = document.querySelector('#audicion-latest-trades tbody');
            if (!tbody) return;
            
            if (operations.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6" class="text-center py-8 text-text-secondary">No hay trades registrados</td></tr>';
                return;
            }
            
            // Calcular estadísticas adicionales de TODAS las operaciones
            let totalWins = 0, totalLosses = 0;
            let totalWinPL = 0, totalLossPL = 0;
            let largestWin = 0, largestLoss = 0;
            let winDurations = [], lossDurations = [];
            let rrValues = [];
            
            operations.forEach(op => {
                const pl = parseFloat(op.pl) || 0;
                
                // Calcular duración si hay datos de tiempo
                let durationMinutes = 0;
                if (op.entryTime && op.exitTime) {
                    try {
                        const entryDate = new Date(`${op.date} ${op.entryTime}`);
                        const exitDate = new Date(`${op.date} ${op.exitTime}`);
                        durationMinutes = Math.abs(exitDate - entryDate) / (1000 * 60);
                    } catch (e) {
                        // Ignorar errores de fecha
                    }
                }
                
                // Calcular R:R si hay datos
                if (op.rr) {
                    rrValues.push(parseFloat(op.rr));
                } else if (op.entryPrice && op.exitPrice && op.stopLoss) {
                    const entryPrice = parseFloat(op.entryPrice);
                    const exitPrice = parseFloat(op.exitPrice);
                    const stopLoss = parseFloat(op.stopLoss);
                    const risk = Math.abs(entryPrice - stopLoss);
                    const reward = Math.abs(exitPrice - entryPrice);
                    if (risk > 0) {
                        rrValues.push(reward / risk);
                    }
                }
                
                // Acumular estadísticas
                if (pl > 0) {
                    totalWins++;
                    totalWinPL += pl;
                    if (pl > largestWin) largestWin = pl;
                    if (durationMinutes > 0) winDurations.push(durationMinutes);
                } else if (pl < 0) {
                    totalLosses++;
                    totalLossPL += Math.abs(pl);
                    if (pl < largestLoss) largestLoss = pl;
                    if (durationMinutes > 0) lossDurations.push(durationMinutes);
                }
            });
            
            // Actualizar estadísticas avanzadas
            updateAudicionAdvancedStats({
                totalWins,
                totalLosses,
                totalWinPL,
                totalLossPL,
                largestWin,
                largestLoss,
                winDurations,
                lossDurations,
                rrValues,
                totalTrades: operations.length
            });
            
            // Tomar los últimos 10 trades para mostrar en la tabla
            const latest = [...operations]
                .sort((a, b) => {
                    const dateA = new Date(`${a.date} ${a.exitTime || '00:00:00'}`);
                    const dateB = new Date(`${b.date} ${b.exitTime || '00:00:00'}`);
                    return dateB - dateA;
                })
                .slice(0, 10);
            
            tbody.innerHTML = latest.map(op => {
                const pl = parseFloat(op.pl) || 0;
                const result = pl > 0 ? 'WIN' : pl < 0 ? 'LOSS' : 'BE';
                const resultClass = pl > 0 ? 'text-primary' : pl < 0 ? 'text-red' : 'text-gray-400';
                const resultBadge = pl > 0 ? 'bg-primary bg-opacity-20 text-primary' : pl < 0 ? 'bg-red bg-opacity-20 text-red' : 'bg-gray-500 bg-opacity-20 text-gray-400';
                
                const account = DB.accounts.find(a => a.id === op.accountId);
                const volume = parseFloat(op.volume) || parseFloat(op.size) || 0;
                const roi = volume > 0 ? ((pl / volume) * 100).toFixed(2) : '0.00';
                
                // Obtener símbolo del trade
                const symbol = op.instrument || op.symbol || 'N/A';
                
                // Determinar dirección LONG/SHORT
                let direction = 'LONG';
                const typeStr = (op.type || '').toLowerCase();
                if (typeStr === 'short' || typeStr === 'sell') {
                    direction = 'SHORT';
                } else if (typeStr === 'long' || typeStr === 'buy') {
                    direction = 'LONG';
                }
                
                // Sesión de operación (asegurar que siempre tenga un valor)
                const session = op.session || op.category || 'New York';
                
                return `
                    <tr class="border-b border-border hover:bg-surface-light transition-colors">
                        <td class="py-3 px-2 text-left text-xs text-text-secondary">${new Date(op.date).toLocaleDateString('es-ES', { day: '2-digit', month: 'short' })}</td>
                        <td class="py-3 px-2">
                            <div class="flex items-center space-x-2">
                                <div class="w-6 h-6 rounded-full flex items-center justify-center text-xs font-bold" 
                                     style="background: linear-gradient(135deg, #39ff14, #00ff88);">
                                    ${(symbol || '').charAt(0)}
                                </div>
                                <span class="font-medium">${symbol}</span>
                            </div>
                        </td>
                        <td class="py-3 px-2">
                            <div class="flex justify-center">
                                <span class="px-2 py-1 rounded text-xs font-medium" 
                                      style="background-color: ${direction === 'LONG' ? 'rgba(57, 255, 20, 0.2)' : 'rgba(255, 65, 54, 0.2)'}; color: ${direction === 'LONG' ? '#39ff14' : '#ff4136'};">
                                    ${direction}
                                </span>
                            </div>
                        </td>
                        <td class="py-3 px-2">
                            <div class="flex justify-center">
                                <span class="px-2 py-1 rounded text-xs font-medium bg-surface border border-border">
                                    ${session}
                                </span>
                            </div>
                        </td>
                        <td class="py-3 px-2">
                            <div class="flex justify-center">
                                <span class="px-2 py-1 rounded text-xs font-medium" 
                                      style="background-color: ${result === 'WIN' ? 'rgba(57, 255, 20, 0.2)' : result === 'LOSS' ? 'rgba(255, 65, 54, 0.2)' : 'rgba(128, 128, 128, 0.2)'}; color: ${result === 'WIN' ? '#39ff14' : result === 'LOSS' ? '#ff4136' : '#888'};">
                                    ${result}
                                </span>
                            </div>
                        </td>
                        <td class="py-3 px-2 text-right font-semibold" style="color: ${pl >= 0 ? '#39ff14' : '#ff4136'};">
                            ${pl >= 0 ? '+' : ''}$${pl.toFixed(2)}
                        </td>
                    </tr>
                `;
            }).join('');
        }
        
        // Función para subir foto de perfil
        function initProfileImageUpload() {
            const imageInput = document.getElementById('config-profile-image');
            const removeBtn = document.getElementById('config-remove-profile-image');
            const preview = document.getElementById('config-profile-preview');
            
            if (imageInput) {
                imageInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    
                    // Validar tamaño (2MB máximo)
                    if (file.size > 2 * 1024 * 1024) {
                        alert('⚠️ La imagen es demasiado grande. Tamaño máximo: 2MB');
                        return;
                    }
                    
                    // Validar tipo
                    if (!file.type.startsWith('image/')) {
                        alert('⚠️ Por favor selecciona una imagen válida');
                        return;
                    }
                    
                    const reader = new FileReader();
                    reader.onload = async (event) => {
                        const imageData = event.target.result;
                        
                        // Guardar en localStorage (cache local)
                        localStorage.setItem('profile-image', imageData);
                        
                        // Guardar en Supabase para persistencia
                        try {
                            const { data: { user } } = await supabase.auth.getUser();
                            if (user) {
                                const { error } = await supabase
                                    .from('user_settings')
                                    .upsert({
                                        user_id: user.id,
                                        profile_image: imageData,
                                        updated_at: new Date().toISOString()
                                    }, {
                                        onConflict: 'user_id'
                                    });
                                
                                if (error) {
                                    console.error('❌ Error guardando foto en Supabase:', error);
                                } else {
                                    console.log('✅ Foto guardada en Supabase');
                                }
                            }
                        } catch (err) {
                            console.error('❌ Error al guardar foto:', err);
                        }
                        
                        // Actualizar preview
                        preview.innerHTML = `<img src="${imageData}" alt="Profile" class="w-full h-full object-cover">`;
                        
                        // Actualizar avatar en configuración
                        const configAvatar = document.getElementById('config-user-avatar');
                        if (configAvatar) {
                            configAvatar.innerHTML = `<img src="${imageData}" alt="Profile" class="w-full h-full object-cover rounded-full">`;
                        }
                        
                        // Actualizar en audición si está activa
                        loadAudicionUserInfo();
                        
                        // Actualizar header del usuario
                        updateUserHeader();
                        
                        // Mostrar botón de eliminar
                        if (removeBtn) removeBtn.style.display = 'block';
                        
                        alert('✅ Foto de perfil actualizada correctamente');
                    };
                    
                    reader.readAsDataURL(file);
                });
            }
            
            if (removeBtn) {
                removeBtn.addEventListener('click', async () => {
                    if (!confirm('¿Seguro que deseas eliminar tu foto de perfil?')) return;
                    
                    // Eliminar de localStorage
                    localStorage.removeItem('profile-image');
                    
                    // Eliminar de Supabase
                    try {
                        const { data: { user } } = await supabase.auth.getUser();
                        if (user) {
                            const { error } = await supabase
                                .from('user_settings')
                                .update({
                                    profile_image: null,
                                    updated_at: new Date().toISOString()
                                })
                                .eq('user_id', user.id);
                            
                            if (error) {
                                console.error('❌ Error eliminando foto de Supabase:', error);
                            } else {
                                console.log('✅ Foto eliminada de Supabase');
                            }
                        }
                    } catch (err) {
                        console.error('❌ Error al eliminar foto:', err);
                    }
                    
                    // Restaurar inicial
                    const initial = currentUser ? currentUser.email.charAt(0).toUpperCase() : 'D';
                    preview.innerHTML = initial;
                    preview.className = 'w-20 h-20 rounded-full bg-primary flex items-center justify-center text-white text-2xl font-bold';
                    
                    const configAvatar = document.getElementById('config-user-avatar');
                    if (configAvatar) configAvatar.textContent = initial;
                    
                    // Actualizar en audición
                    loadAudicionUserInfo();
                    
                    // Actualizar header del usuario
                    updateUserHeader();
                    
                    // Ocultar botón
                    removeBtn.style.display = 'none';
                    
                    alert('✅ Foto de perfil eliminada');
                });
            }
            
            // Cargar imagen existente al inicializar
            const savedImage = localStorage.getItem('profile-image');
            if (savedImage && preview) {
                preview.innerHTML = `<img src="${savedImage}" alt="Profile" class="w-full h-full object-cover">`;
                if (removeBtn) removeBtn.style.display = 'block';
                
                // También actualizar el avatar en configuración
                const configAvatar = document.getElementById('config-user-avatar');
                if (configAvatar) {
                    configAvatar.innerHTML = `<img src="${savedImage}" alt="Profile" class="w-full h-full object-cover rounded-full">`;
                }
            }
        }
        
        function loadSavedUserConfig() {
            console.log('⚙️ Cargando configuración de usuario guardada...');
            
            // Cargar nombre de usuario
            const username = localStorage.getItem('username') || '';
            const configUsername = document.getElementById('config-username');
            if (configUsername && username) {
                configUsername.value = username;
                console.log('✅ Nombre de usuario cargado:', username);
            }
            
            // Cargar imagen de perfil
            const profileImage = localStorage.getItem('profile-image');
            if (profileImage) {
                console.log('✅ Imagen de perfil encontrada en localStorage');
                
                // Actualizar preview en configuración
                const preview = document.getElementById('config-profile-preview');
                if (preview) {
                    preview.innerHTML = `<img src="${profileImage}" alt="Profile" class="w-full h-full object-cover">`;
                }
                
                // Actualizar avatar en configuración
                const configAvatar = document.getElementById('config-user-avatar');
                if (configAvatar) {
                    configAvatar.innerHTML = `<img src="${profileImage}" alt="Profile" class="w-full h-full object-cover rounded-full">`;
                }
                
                // Mostrar botón de eliminar
                const removeBtn = document.getElementById('config-remove-profile-image');
                if (removeBtn) {
                    removeBtn.style.display = 'block';
                }
                
                // Actualizar header
                if (typeof updateUserHeader === 'function') {
                    updateUserHeader();
                }
                
                // Actualizar audición
                if (typeof loadAudicionUserInfo === 'function') {
                    loadAudicionUserInfo();
                }
            }
            
            console.log('✅ Configuración de usuario cargada');
        }

        function initCsvImport() {
            const importBtn = document.getElementById('import-csv-btn');
            const fileInput = document.getElementById('csv-file-input');
            const statusDiv = document.getElementById('csv-import-status');

            if (!importBtn || !fileInput || !statusDiv) {
                console.warn('⚠️ Elementos de importación CSV no encontrados, saltando inicialización');
                return;
            }

            importBtn.addEventListener('click', async () => {
                if (!fileInput.files || fileInput.files.length === 0) {
                    statusDiv.textContent = 'Por favor, selecciona un archivo CSV.';
                    statusDiv.className = 'mt-2 text-sm text-red';
                    return;
                }

                const file = fileInput.files[0];
                statusDiv.textContent = 'Importando...';
                statusDiv.className = 'mt-2 text-sm text-yellow';

                try {
                    await processCSVFile(file, statusDiv);
                    fileInput.value = '';
                } catch (error) {
                    console.error("Error importando CSV:", error);
                    statusDiv.textContent = `Error: ${error.message}`;
                    statusDiv.className = 'mt-2 text-sm text-negative';
                }
            });
        }

        function parseCSV(csvText) {
            const lines = csvText.replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');
            if (lines.length === 0) return { headers: [], rows: [] };

            const splitLine = (line) => {
                const result = [];
                let current = '';
                let inQuotes = false;
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    if (char === '"' && (i === 0 || line[i - 1] !== '\\')) {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        result.push(current.trim());
                        current = '';
                    } else {
                        current += char;
                    }
                }
                result.push(current.trim());
                return result.map(v => v.replace(/^"|"$/g, ''));
            };

            const headers = splitLine(lines[0]);
            const rows = [];

            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line === "") continue;
                const values = splitLine(line);
                if (values.length >= headers.length) {
                    rows.push(values);
                } else {
                    console.warn(`Línea CSV con número incorrecto de columnas: "${line}". Esperadas ${headers.length}, obtenidas ${values.length}.`);
                }
            }
            return { headers, rows };
        }

        // ========== FUNCIONES CENTRALIZADAS PARA MANEJO DE IDs Y OPERACIONES PARCIALES ==========
        
        /**
         * Función centralizada para generar IDs únicos y consistentes para todas las plataformas
         * @param {Object} operation - Datos de la operación
         * @param {string} platform - Plataforma de origen (bingx, bitget, mexc, primexbt-crypto, primexbt-cfds, mt5)
         * @param {string} csvId - ID del CSV si existe
         * @param {number} partialIndex - Índice de parcial para operaciones divididas
         * @returns {string} ID único generado
         */
        // Sistema de IDs secuenciales simples
        function getNextOperationId() {
            // Obtener el contador actual desde localStorage
            let counter = parseInt(localStorage.getItem('operation-id-counter') || '25000');
            
            // Verificar que el ID no exista ya en la base de datos
            while (DB.operations.some(op => op.id === counter.toString())) {
                counter++;
            }
            
            // Guardar el nuevo contador
            localStorage.setItem('operation-id-counter', (counter + 1).toString());
            
            return counter.toString();
        }
        
        function generateUnifiedOperationId(operation, platform, csvId = null, partialIndex = null) {
            // Si viene un ID del CSV de PrimeXBT, usarlo directamente
            if (csvId && csvId.trim() !== '' && platform && platform.includes('primexbt')) {
                const baseId = csvId.trim();
                return partialIndex !== null ? `${baseId}_p${partialIndex}` : baseId;
            }
            
            // Para cualquier otra plataforma o importación, usar ID secuencial simple
            const baseId = getNextOperationId();
            return partialIndex !== null ? `${baseId}_p${partialIndex}` : baseId;
        }

        /**
         * Función para agrupar operaciones parciales por ID
         * @param {Array} operations - Array de operaciones
         * @returns {Array} Array de operaciones agrupadas (completas o parciales sumadas)
         */
        function groupPartialOperations(operations) {
            const groupedOps = new Map();
            
            for (const op of operations) {
                // Obtener el ID base (sin sufijos de parciales)
                let baseId = op.id;
                
                // Remover sufijos de parciales comunes
                baseId = baseId.replace(/_partial_\d+$/, '').replace(/_p\d+$/, '');
                
                // Para IDs que contienen el ID original del CSV, usar una lógica especial
                // Ejemplo: "primexbt-cfds_80251024" -> usar "80251024" como ID base para agrupar
                const parts = baseId.split('_');
                if (parts.length >= 2) {
                    const potentialCsvId = parts[parts.length - 1];
                    // Si el último parte parece ser un ID numérico del CSV, usarlo para agrupar
                    if (/^\d+$/.test(potentialCsvId)) {
                        baseId = potentialCsvId;
                    }
                }
                
                if (groupedOps.has(baseId)) {
                    // Ya existe una operación con este ID base, combinar
                    const existingOp = groupedOps.get(baseId);
                    
                    // Sumar volúmenes y promediar precios ponderadamente
                    const totalVolume = existingOp.volume + op.volume;
                    const weightedEntryPrice = ((existingOp.entry * existingOp.volume) + (op.entry * op.volume)) / totalVolume;
                    const weightedExitPrice = ((existingOp.exit * existingOp.volume) + (op.exit * op.volume)) / totalVolume;
                    
                    existingOp.volume = totalVolume;
                    existingOp.entry = weightedEntryPrice;
                    existingOp.exit = weightedExitPrice;
                    existingOp.pl = (existingOp.pl || 0) + (op.pl || 0);
                    existingOp.fees = (existingOp.fees || existingOp.fee || 0) + (op.fees || op.fee || 0);
                    
                    // Usar la fecha/hora más temprana para entrada y más tardía para salida
                    // Comparar horas de entrada para encontrar la más temprana
                    if (op.entryTime) {
                        if (!existingOp.entryTime || op.entryTime < existingOp.entryTime) {
                            existingOp.entryTime = op.entryTime;
                        }
                    }
                    
                    // Para la hora de salida, considerar tanto exitTime como entryTime
                    const currentOpLatestTime = op.exitTime || op.entryTime;
                    const existingOpLatestTime = existingOp.exitTime || existingOp.entryTime;
                    
                    if (currentOpLatestTime) {
                        if (!existingOpLatestTime || currentOpLatestTime > existingOpLatestTime) {
                            existingOp.exitTime = currentOpLatestTime;
                        }
                    }
                    
                    // Combinar notas
                    if (op.notes && op.notes !== existingOp.notes) {
                        existingOp.notes = existingOp.notes ? `${existingOp.notes}; ${op.notes}` : op.notes;
                    }
                    
                    // Agregar información de parciales
                    if (!existingOp.partials) {
                        existingOp.partials = [
                            {
                                id: existingOp.originalId || existingOp.id,
                                volume: existingOp.originalVolume || existingOp.volume,
                                entry: existingOp.originalEntry || existingOp.entry,
                                exit: existingOp.originalExit || existingOp.exit,
                                pl: existingOp.originalPL || existingOp.pl,
                                entryTime: existingOp.originalEntryTime || existingOp.entryTime,
                                exitTime: existingOp.originalExitTime || existingOp.exitTime
                            }
                        ];
                    }
                    
                    existingOp.partials.push({
                        id: op.id,
                        volume: op.volume,
                        entry: op.entry,
                        exit: op.exit,
                        pl: op.pl,
                        entryTime: op.entryTime,
                        exitTime: op.exitTime
                    });
                    
                    // Actualizar resultado final
                    existingOp.result = existingOp.pl > 0 ? 'win' : (existingOp.pl < 0 ? 'loss' : 'breakeven');
                    
                } else {
                    // Nueva operación, usar el ID base limpio
                    const cleanOp = { 
                        ...op, 
                        id: baseId,
                        originalId: op.id,
                        originalVolume: op.volume,
                        originalEntry: op.entry,
                        originalExit: op.exit,
                        originalPL: op.pl,
                        originalEntryTime: op.entryTime,
                        originalExitTime: op.exitTime
                    };
                    
                    // Si no tiene exitTime pero sí entryTime, usar entryTime como exitTime inicial
                    if (!cleanOp.exitTime && cleanOp.entryTime) {
                        cleanOp.exitTime = cleanOp.entryTime;
                    }
                    
                    groupedOps.set(baseId, cleanOp);
                }
            }
            
            return Array.from(groupedOps.values());
        }

        /**
         * Función para verificar si una operación ya existe en la base de datos
         * @param {Object} operation - Operación a verificar
         * @param {Array} existingOperations - Operaciones existentes en DB
         * @returns {boolean} true si la operación ya existe
         */
        function isDuplicateOperation(operation, existingOperations) {
            return existingOperations.some(existing => {
                // Comparar por ID exacto
                if (existing.id === operation.id) return true;
                
                // Comparar por datos principales (tolerancia para duplicados sin ID)
                const sameAccount = existing.accountId === operation.accountId;
                const sameDate = existing.date === operation.date;
                const sameInstrument = existing.instrument === operation.instrument;
                const sameType = existing.type === operation.type;
                const sameEntry = Math.abs(existing.entry - operation.entry) < 0.0001;
                const sameExit = Math.abs(existing.exit - operation.exit) < 0.0001;
                const sameVolume = Math.abs(existing.volume - operation.volume) < 0.0001;
                
                return sameAccount && sameDate && sameInstrument && sameType && sameEntry && sameExit && sameVolume;
            });
        }

        /**
         * Función para procesar y limpiar operaciones antes de guardar
         * @param {Array} rawOperations - Operaciones sin procesar
         * @param {string} platform - Plataforma de origen
         * @returns {Array} Operaciones procesadas y limpias
         */
        async function processAndCleanOperations(rawOperations, platform) {
            console.log(`🔧 Procesando ${rawOperations.length} operaciones para ${platform}...`);

            // Obtener operaciones existentes
            const existingOperations = await dexieDB.operations.toArray();

            // Agrupar operaciones parciales
            const groupedOperations = groupPartialOperations(rawOperations);
            console.log(`📊 Agrupadas a ${groupedOperations.length} operaciones después de combinar parciales`);

            // Filtrar duplicados
            const newOperations = groupedOperations.filter(op => !isDuplicateOperation(op, existingOperations));
            console.log(`✅ ${newOperations.length} operaciones nuevas después de filtrar duplicados`);

            // Calcular MAE/MFE para cada operación importada
            let maeCount = 0;
            newOperations.forEach(operation => {
                if (operation.result && (!operation.mae && !operation.mfe)) {
                    const maemfe = calculateEstimatedMAEMFE(operation);
                    operation.mae = maemfe.mae;
                    operation.mfe = maemfe.mfe;
                    maeCount++;
                }
            });

            if (maeCount > 0) {
                console.log(`📊 MAE/MFE calculados para ${maeCount} operaciones importadas`);
            }

            return newOperations;
        }

        // ========== FIN FUNCIONES CENTRALIZADAS ==========



        // Función para actualizar el estado de autenticación en la configuración
        window.updateAuthStatus = function updateAuthStatus() {
            try {
                const loggedOutSection = document.getElementById('auth-status-logged-out');
                const loggedInSection = document.getElementById('auth-status-logged-in');
                const currentUserEmailSpan = document.getElementById('current-user-email');

                // Verificar si currentUser está definido
                if (typeof currentUser !== 'undefined' && currentUser) {
                    // Usuario autenticado
                    if (loggedOutSection) loggedOutSection.style.display = 'none';
                    if (loggedInSection) loggedInSection.style.display = 'block';
                    if (currentUserEmailSpan) currentUserEmailSpan.textContent = currentUser.email;
                } else {
                    // Usuario no autenticado
                    if (loggedOutSection) loggedOutSection.style.display = 'block';
                    if (loggedInSection) loggedInSection.style.display = 'none';
                }
            } catch (error) {
                console.log('Error en updateAuthStatus:', error);
            }
        }

        async function initConfig() {
            // Solo actualizar elementos de BingX si existen
            const bingxAccount = document.getElementById('bingx-account');
            if (bingxAccount) {
                updateAccountSelect('bingx-account');
                const bingxApiKey = document.getElementById('bingx-api-key');
                const bingxApiSecret = document.getElementById('bingx-api-secret');
                if (bingxApiKey) bingxApiKey.value = DB.apiKeys.bingx.key ? '********' : '';
                if (bingxApiSecret) bingxApiSecret.value = DB.apiKeys.bingx.secret ? '********' : '';
                bingxAccount.value = DB.apiKeys.bingx.accountId || '';
            }
            updateAccountSelect('bingx-account-detail');

            // Solo actualizar elementos que existen
            const showTooltips = document.getElementById('show-tooltips');
            if (showTooltips) {
                showTooltips.checked = DB.settings.showTooltips;
            }

            // Actualizar estado de autenticación
            updateAuthStatus();

            initCsvImport();
            initFunded();
            initAudicion();
            initProfileImageUpload();
            
            // Cargar configuración de usuario guardada
            loadSavedUserConfig();

            // Event listeners para autenticación
            const showAuthModalBtn = document.getElementById('show-auth-modal-btn');
            if (showAuthModalBtn) {
                showAuthModalBtn.addEventListener('click', () => {
                    const authModal = document.getElementById('authModal');
                    const mainApp = document.getElementById('mainApp');
                    if (authModal) authModal.style.display = 'flex';
                    if (mainApp) mainApp.classList.add('app-hidden');
                });
            }

            const logoutBtnConfig = document.getElementById('logout-btn-config');
            if (logoutBtnConfig) {
                logoutBtnConfig.addEventListener('click', async () => {
                    if (confirm('¿Está seguro de que desea cerrar sesión? Sus datos locales se mantendrán, pero no se sincronizarán con Supabase.')) {
                        await handleLogout();
                    }
                });
            }

            const showTooltipsEl = document.getElementById('show-tooltips');
            if (showTooltipsEl) {
                showTooltipsEl.addEventListener('change', async (e) => {
                    DB.settings.showTooltips = e.target.checked;
                    try {
                        await dexieDB.generalData.put({ key: 'settings', value: DB.settings }); alert('Configuración de tooltips guardada.');
                    } catch (err) { console.error("Error saving tooltip settings:", err); alert("Error al guardar configuración."); }
                });
            }

            // Solo agregar listener si el elemento existe
            const bingxConnectEl = document.getElementById('bingx-connect');
            if (bingxConnectEl) {
                bingxConnectEl.addEventListener('click', () => alert('Funcionalidad API no implementada.'));
            }

            const exportDataBtn = document.getElementById('export-data');
            if (exportDataBtn) {
                exportDataBtn.addEventListener('click', async () => {
                    showLoading(true);
                    try {
                        const exportableDB = {
                            accounts: await dexieDB.accounts.toArray(),
                            operations: await dexieDB.operations.toArray(),
                            finances: await dexieDB.finances.toArray(),
                            settings: (await dexieDB.generalData.get('settings'))?.value || DB.settings,
                            apiKeys: (await dexieDB.generalData.get('apiKeys'))?.value || DB.apiKeys
                        };
                        const dataStr = JSON.stringify(exportableDB, null, 2);
                        const dataBlob = new Blob([dataStr], { type: 'application/json' });
                        const url = URL.createObjectURL(dataBlob);
                        const link = document.createElement('a'); link.href = url; const date = getLocalDateString(new Date()); link.download = `trader_survivor_backup_${date}.json`;
                        document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(url);
                        alert('Datos exportados correctamente.');
                    } catch (e) {
                        console.error('Error exporting data:', e); alert('Error al exportar.');
                    } finally { showLoading(false); }
                });
            }

            const importInput = document.getElementById('import-data');
            if (importInput) {
                importInput.addEventListener('change', (event) => {
                    const file = event.target.files[0]; if (!file) return;
                    if (!confirm('Importar datos reemplazará TODOS los datos actuales. ¿Seguro?')) { importInput.value = ''; return; }
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        showLoading(true);
                        try {
                            const importedData = JSON.parse(e.target.result);
                            if (importedData.accounts && importedData.operations && importedData.settings) {
                                await dexieDB.transaction('rw', dexieDB.accounts, dexieDB.operations, dexieDB.finances, dexieDB.generalData, async () => {
                                    await dexieDB.accounts.clear();
                                    await dexieDB.operations.clear();
                                    await dexieDB.finances.clear();
                                    await dexieDB.generalData.clear();
                                    await dexieDB.accounts.bulkPut(importedData.accounts || []);
                                    await dexieDB.operations.bulkPut(importedData.operations || []);
                                    await dexieDB.finances.bulkPut(importedData.finances || []);
                                    await dexieDB.generalData.put({ key: 'settings', value: importedData.settings || DB.settings });
                                    await dexieDB.generalData.put({ key: 'apiKeys', value: importedData.apiKeys || DB.apiKeys });
                                });
                                alert('Datos importados. Recargando aplicación...'); location.reload();
                            } else { alert('Error: Archivo con estructura no esperada.'); }
                        } catch (err) {
                            console.error('Error importing file:', err); alert('Error al procesar el archivo.');
                        } finally { importInput.value = ''; showLoading(false); }
                    };
                    reader.onerror = () => { alert('Error al leer el archivo.'); importInput.value = ''; };
                    reader.readAsText(file);
                });
            }

            const clearDataBtn = document.getElementById('clear-data');
            if (clearDataBtn) {
                clearDataBtn.addEventListener('click', async () => {
                    if (confirm('¡ATENCIÓN! Esto eliminará TODOS tus datos de forma permanente y la plataforma quedará vacía. ¿Estás seguro?')) {
                        showLoading(true);
                        try {
                            await Promise.all([
                                dexieDB.accounts.clear(),
                                dexieDB.operations.clear(),
                                dexieDB.finances.clear(),
                                dexieDB.generalData.clear()
                            ]);
                            DB.accounts = [];
                            DB.operations = [];
                            DB.finances = [];
                            DB.settings = { darkMode: true, showTooltips: true, autoRefresh: false, defaultCurrency: 'USD' };
                            DB.apiKeys = { ctrader: { key: '', secret: '', accountId: '' }, bingx: { key: '', secret: '', accountId: '' } };
                            await dexieDB.generalData.put({ key: 'settings', value: DB.settings });
                            await dexieDB.generalData.put({ key: 'apiKeys', value: DB.apiKeys });

                            alert('Todos los datos han sido eliminados. Recargando aplicación...');
                            location.reload();
                        } catch (e) {
                            console.error('Error clearing data:', e);
                            alert('Error al eliminar los datos.');
                        } finally {
                            showLoading(false);
                        }
                    }
                });
            }
        }

        window.updateAccountSelect = function(selectId) {
            const selectElement = document.getElementById(selectId);
            if (!selectElement) return;
            
            // GUARD: Verificar que DB existe y está inicializado
            if (typeof window.DB === 'undefined' || !window.DB || !window.DB.accounts) {
                console.warn(`⚠️ updateAccountSelect('${selectId}'): DB no está disponible aún`);
                return;
            }

            const currentValue = selectElement.value;
            selectElement.innerHTML = '';

            // Opción "Todas las cuentas" para algunos selectores
            if (['dashboard-account-select', 'new-dashboard-account-select', 'analytics-account-select', 'equity-account-select', 'daily-journal-account-select', 'calendar-account-select', 'filter-account', 'chartbook-account-select', 'informe-account-select'].includes(selectId)) {
                const allOption = document.createElement('option');
                allOption.value = 'all';
                allOption.textContent = 'Todas las cuentas';
                selectElement.appendChild(allOption);
            }

            // Opción placeholder para selectores de plataformas
            if (['bingx-account', 'bingx-account-detail', 'bitunix-account-detail', 'lbank-account-detail', 'blofin-account-detail'].includes(selectId)) {
                const placeholderOption = document.createElement('option');
                placeholderOption.value = '';
                placeholderOption.textContent = 'Seleccionar cuenta...';
                selectElement.appendChild(placeholderOption);
            }

            // Agregar cuentas sin mostrar divisa
            DB.accounts.forEach(account => {
                const option = document.createElement('option');
                option.value = account.id;
                option.textContent = account.name;
                option.setAttribute('data-platform', account.platform);
                selectElement.appendChild(option);
            });

            // Restaurar valor seleccionado
            const platformSelectors = ['bingx-account', 'bingx-account-detail', 'bitunix-account-detail', 'lbank-account-detail', 'blofin-account-detail'];
            if (Array.from(selectElement.options).some(opt => opt.value === currentValue)) {
                selectElement.value = currentValue;
            } else if (selectId === 'op-account' && DB.accounts.length > 0) {
                selectElement.value = DB.accounts[0].id;
            } else if (!platformSelectors.includes(selectId) && selectElement.options.length > 0 && selectElement.options[0].value === 'all') {
                selectElement.value = 'all';
            } else if (selectElement.options.length > 0) {
                selectElement.value = selectElement.options[0].value;
            }

            // Actualizar logo del selector
            updateSelectorLogo(selectId);
        }

        // Función para actualizar el logo del selector según la cuenta seleccionada
        function updateSelectorLogo(selectId) {
            const selectElement = document.getElementById(selectId);
            if (!selectElement) return;
            
            // GUARD: Verificar que DB existe y está inicializado
            if (typeof window.DB === 'undefined' || !window.DB || !window.DB.accounts) {
                console.warn(`⚠️ updateSelectorLogo('${selectId}'): DB no está disponible aún`);
                return;
            }

            const selectedAccountId = selectElement.value;

            // Mapeo de selectores a sus contenedores de logo
            const logoMapping = {
                'main-account-select': { container: 'main-account-logo', img: 'main-account-logo-img' },
                'dashboard-account-select': { container: 'dashboard-account-logo', img: 'dashboard-account-logo-img' },
                'new-dashboard-account-select': { container: 'new-dashboard-account-logo', img: 'new-dashboard-account-logo-img' },
                'analytics-account-select': { container: 'analytics-account-logo', img: 'analytics-account-logo-img' },
                'calendar-account-select': { container: 'calendar-account-logo', img: 'calendar-account-logo-img' },
                'filter-account': { container: 'filter-account-logo', img: 'filter-account-logo-img' },
                'chartbook-account-select': { container: 'chartbook-account-logo', img: 'chartbook-account-logo-img' },
                'equity-account-select': { container: 'equity-account-logo', img: 'equity-account-logo-img' },
                'daily-journal-account-select': { container: 'daily-journal-account-logo', img: 'daily-journal-account-logo-img' },
                'informe-account-select': { container: 'informe-account-logo', img: 'informe-account-logo-img' },
                'capital-propio-account-select': { container: 'capital-propio-account-logo', img: 'capital-propio-account-logo-img' },
                'funded-account-select': { container: 'funded-account-logo', img: 'funded-account-logo-img' }
            };

            const logoInfo = logoMapping[selectId];
            if (!logoInfo) return;

            const logoContainer = document.getElementById(logoInfo.container);
            const logoImg = document.getElementById(logoInfo.img);

            if (!logoContainer || !logoImg) return;

            // Determinar si es selector de funded o normal
            const isFunded = selectId === 'funded-account-select';
            
            // Buscar la cuenta seleccionada en el array correcto
            const account = isFunded 
                ? DB.fundedAccounts?.find(acc => acc.id === selectedAccountId)
                : DB.accounts.find(acc => acc.id === selectedAccountId);
            
            // Caso 1: No hay selección, está vacío, o es "Todas las cuentas"
            if (!selectedAccountId || selectedAccountId === '' || selectedAccountId === 'all') {
                logoContainer.style.display = 'none';
                logoImg.src = '';
                logoImg.alt = '';
                return;
            }
            
            // Caso 2: Cuenta específica no encontrada
            if (!account) {
                logoContainer.style.display = 'none';
                logoImg.src = '';
                logoImg.alt = '';
                return;
            }

            // Obtener información del logo según el tipo de cuenta
            let platformLogo;
            if (isFunded) {
                // Para funded accounts, usar el logo de la firma
                const firmLogos = {
                    'ftmo': { file: 'logos/ftmo-logo.png', color: '#1E3A8A', initials: 'FT' },
                    'topstep': { file: 'logos/topstep-logo.png', color: '#059669', initials: 'TS' },
                    'apex': { file: 'logos/apex-logo.png', color: '#DC2626', initials: 'AP' },
                    'e8': { file: 'logos/e8-logo.png', color: '#7C3AED', initials: 'E8' },
                    'fundedrading': { file: 'logos/funded-logo.png', color: '#0891B2', initials: 'FR' },
                    'myfundedfx': { file: 'logos/myfunded-logo.png', color: '#10B981', initials: 'MF' },
                    'ftprotrading': { file: 'logos/ftpro-logo.png', color: '#F59E0B', initials: 'FP' }
                };
                const firm = (account.firm || '').toLowerCase();
                platformLogo = firmLogos[firm] || { file: '', color: '#F59E0B', initials: '🏆' };
            } else {
                // Para cuentas normales, usar el logo de la plataforma
                platformLogo = getPlatformLogo(account.platform);
            }

            // Configurar el logo con fondo de color
            logoContainer.style.backgroundColor = platformLogo.color;
            logoContainer.style.display = 'flex';

            // Intentar cargar imagen
            if (platformLogo.file) {
                logoImg.src = platformLogo.file;
                logoImg.style.display = 'block';
                logoImg.alt = isFunded ? account.firm : account.platform;
                
                logoImg.onerror = function() {
                    // Si falla la imagen, mostrar iniciales
                    logoImg.style.display = 'none';
                    const existingInitials = logoContainer.querySelector('.platform-initials');
                    if (existingInitials) existingInitials.remove();
                    logoContainer.innerHTML += `<div class="platform-initials text-white font-bold text-lg">${platformLogo.initials}</div>`;
                };
                
                logoImg.onload = function() {
                    // Limpiar cualquier inicial previa si la imagen carga bien
                    const existingInitials = logoContainer.querySelector('.platform-initials');
                    if (existingInitials) existingInitials.remove();
                };
            } else {
                // Si no hay archivo de imagen, mostrar solo iniciales
                logoImg.style.display = 'none';
                const existingInitials = logoContainer.querySelector('.platform-initials');
                if (existingInitials) existingInitials.remove();
                logoContainer.innerHTML += `<div class="platform-initials text-white font-bold text-lg">${platformLogo.initials}</div>`;
            }
        }

        function showLoading(show) {
            const loadingElement = document.getElementById('loading'); if (loadingElement) { loadingElement.style.display = show ? 'flex' : 'none'; }
        }

        const calendarPopup = document.getElementById('global-calendar-popup');

        function getWeekRangeForDate(date, startOfWeek = 1) {
            const d = new Date(date);
            d.setHours(0, 0, 0, 0); // Usar hora local
            const dayOfWeek = d.getDay(); // Usar día local
            const diff = (dayOfWeek < startOfWeek ? 7 : 0) + dayOfWeek - startOfWeek;
            const startDate = new Date(d);
            startDate.setDate(d.getDate() - diff); // Usar fecha local
            const endDate = new Date(startDate);
            endDate.setDate(startDate.getDate() + 6); // Usar fecha local
            return {
                startDate: getLocalDateString(startDate),
                endDate: getLocalDateString(endDate)
            };
        }

        function getMonthRangeForDate(date) {
            const d = new Date(date);
            const year = d.getFullYear(); // Usar año local
            const month = d.getMonth(); // Usar mes local
            const startDate = new Date(year, month, 1); // Usar constructor local
            const endDate = new Date(year, month + 1, 0); // Usar constructor local
            return {
                startDate: getLocalDateString(startDate),
                endDate: getLocalDateString(endDate)
            };
        }

        function getSemesterRangeForDate(date) {
            const d = new Date(date);
            const year = d.getFullYear(); // Usar año local
            const month = d.getMonth(); // Usar mes local
            let startDate, endDate;
            if (month < 6) {
                startDate = new Date(year, 0, 1); // Usar constructor local
                endDate = new Date(year, 5, 30); // Usar constructor local
            } else {
                startDate = new Date(year, 6, 1); // Usar constructor local
                endDate = new Date(year, 11, 31); // Usar constructor local
            }
            return {
                startDate: getLocalDateString(startDate),
                endDate: getLocalDateString(endDate)
            };
        }

        function getYearRangeForDate(date) {
            const d = new Date(date);
            const year = d.getFullYear(); // Usar año local
            const startDate = new Date(year, 0, 1); // Usar constructor local
            const endDate = new Date(year, 11, 31); // Usar constructor local
            return {
                startDate: getLocalDateString(startDate),
                endDate: getLocalDateString(endDate)
            };
        }

        // Función auxiliar para mostrar una sección y ocultar las demás
        function showSection(sectionId) {
            document.querySelectorAll('.section-container').forEach(s => s.classList.remove('active'));
            // Opcional: Si quieres que la pestaña de navegación correspondiente también se active
            document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
            const targetTab = document.querySelector(`.nav-tab[data-target="${sectionId}"]`);
            if (targetTab) {
                targetTab.classList.add('active');
            }
            document.getElementById(sectionId).classList.add('active');
            
            // Re-inicializar pestañas si es una plataforma
            if (sectionId.startsWith('platform-')) {
                console.log('🔄 Mostrando plataforma:', sectionId);
                console.log('🔍 Verificando si initPlatformTabs existe:', typeof initPlatformTabs);
                console.log('🔍 window.initPlatformTabs existe:', typeof window.initPlatformTabs);
                
                setTimeout(() => {
                    if (typeof window.initPlatformTabs === 'function') {
                        console.log('✅ Llamando a window.initPlatformTabs()');
                        window.initPlatformTabs();
                    } else if (typeof initPlatformTabs === 'function') {
                        console.log('✅ Llamando a initPlatformTabs()');
                        initPlatformTabs();
                    } else {
                        console.error('❌ initPlatformTabs NO ESTÁ DEFINIDA');
                        console.log('🔧 Intentando ejecutar directamente el código de inicialización...');
                        
                        // Ejecutar directamente el código de inicialización de pestañas
                        const tabButtons = document.querySelectorAll('.platform-tab');
                        console.log(`📊 Encontrados ${tabButtons.length} botones de tab`);
                        
                        tabButtons.forEach(button => {
                            const newButton = button.cloneNode(true);
                            button.parentNode.replaceChild(newButton, button);
                        });
                        
                        const newTabButtons = document.querySelectorAll('.platform-tab');
                        newTabButtons.forEach(button => {
                            button.addEventListener('click', function(e) {
                                e.preventDefault();
                                e.stopPropagation();
                                
                                const targetTab = this.dataset.tab;
                                console.log('🖱️ CLICK EN TAB:', targetTab);
                                
                                const section = this.closest('section');
                                if (!section) return;
                                
                                const platformId = section.id.replace('platform-', '');
                                
                                section.querySelectorAll('.platform-tab').forEach(tab => {
                                    tab.classList.remove('active');
                                });
                                this.classList.add('active');
                                
                                section.querySelectorAll('.platform-tab-content').forEach(content => {
                                    content.classList.remove('active');
                                });
                                
                                const targetContentId = `${platformId}-tab-${targetTab}`;
                                const targetContent = document.getElementById(targetContentId);
                                
                                if (targetContent) {
                                    targetContent.classList.add('active');
                                    console.log('✅ TAB ACTIVADO:', targetTab);
                                } else {
                                    console.error('❌ NO SE ENCONTRÓ:', targetContentId);
                                }
                            });
                        });
                        
                        console.log('✅ Pestañas inicializadas directamente');
                    }
                }, 100);
            }
            
            // Cargar configuración de perfil público al abrir config
            if (sectionId === 'config' && typeof loadUserPublicSettings === 'function') {
                setTimeout(() => loadUserPublicSettings(), 100);
            }
            
            // Auto-refresh cuando se cambia de sección
            console.log('🔄 Cambiando a sección:', sectionId);
            setTimeout(() => {
                refreshCurrentSection();
            }, 100);
        }


        function renderPopupCalendar(dateForMonthView) {
            const year = dateForMonthView.getUTCFullYear();
            const month = dateForMonthView.getUTCMonth();
            document.getElementById('popup-cal-current-month-year').textContent = `${monthNamesShort[month]} ${year}`;

            const grid = document.getElementById('popup-cal-days-grid');
            grid.innerHTML = '';

            const firstDayOfMonth = new Date(Date.UTC(year, month, 1));
            const lastDayOfMonth = new Date(Date.UTC(year, month + 1, 0));
            const daysInMonth = lastDayOfMonth.getUTCDate();

            let startingDayOfWeek = firstDayOfMonth.getUTCDay();
            if (startingDayOfWeek === 0) startingDayOfWeek = 6;
            else startingDayOfWeek -= 1;

            for (let i = 0; i < startingDayOfWeek; i++) {
                grid.innerHTML += `<div class="popup-cal-day other-month"></div>`;
            }

            for (let day = 1; day <= daysInMonth; day++) {
                const currentDateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                const dayBtn = document.createElement('button');
                dayBtn.classList.add('popup-cal-day');
                dayBtn.dataset.date = currentDateStr;
                dayBtn.textContent = day;

                if (globalDateFilter.type === 'day' && globalDateFilter.startDate === currentDateStr) {
                    dayBtn.classList.add('selected');
                } else if ((globalDateFilter.type === 'week' || globalDateFilter.type === 'month' || globalDateFilter.type === 'semester' || globalDateFilter.type === 'year') &&
                    globalDateFilter.startDate && globalDateFilter.endDate &&
                    currentDateStr >= globalDateFilter.startDate && currentDateStr <= globalDateFilter.endDate) {
                    dayBtn.classList.add('in-range');
                }

                dayBtn.onclick = () => {
                    updateGlobalDateFilter({
                        type: 'day',
                        startDate: currentDateStr,
                        endDate: currentDateStr,
                        display: `Día: ${formatDate(currentDateStr)}`
                    });
                    calendarPopup.classList.add('hidden');
                };
                grid.appendChild(dayBtn);
            }
            const totalCells = startingDayOfWeek + daysInMonth;
            const remainingCells = (7 - (totalCells % 7)) % 7;
            for (let i = 0; i < remainingCells; i++) {
                grid.innerHTML += `<div class="popup-cal-day other-month"></div>`;
            }
        }

        function updateGlobalDateFilter(newFilter) {
            console.log('🔄 Actualizando filtro global de fecha:', newFilter);
            globalDateFilter = newFilter;
            
            // Actualizar todos los displays de fecha
            document.querySelectorAll('.date-filter-display-text').forEach(el => {
                el.textContent = globalDateFilter.display;
            });
            
            // Actualizar displays específicos por ID
            const displayIds = [
                'dashboard-date-filter-display',
                'new-dashboard-date-filter-display', 
                'analytics-date-filter-display', 
                'informe-date-filter-display', 
                'operations-date-filter-display', 
                'finances-date-filter-display',
                'funded-date-filter-display'
            ];
            displayIds.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.textContent = globalDateFilter.display;
            });
            
            // Si existe la función de funded, aplicar filtro específico
            if (window.applyFundedDateFilter) {
                window.applyFundedDateFilter(globalDateFilter);
            }
            
            console.log('✅ Filtro actualizado. Refrescando vistas...');
            // Forzar refresh inmediato y asegurar que se ejecuta
            setTimeout(() => {
                refreshAllViews();
                console.log('✅ Vistas refrescadas');
            }, 100);
        }

        function getWeekNumber(date) {
            const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
            const dayNum = d.getUTCDay() || 7;
            d.setUTCDate(d.getUTCDate() + 4 - dayNum);
            const yearStart = new Date(Date.UTC(d.getUTCFullYear(),0,1));
            return Math.ceil((((d - yearStart) / 86400000) + 1)/7);
        }

        function initDateRangeModal() {
    const modal = document.getElementById('date-range-modal');
    const closeBtn = document.getElementById('date-range-close-btn');
    const prevMonthBtn = document.getElementById('calendar-prev-month');
    const nextMonthBtn = document.getElementById('calendar-next-month');
    const monthYearEl = document.getElementById('calendar-month-year');
    const daysGrid = document.getElementById('calendar-days');
    const applyBtn = document.getElementById('date-range-apply-btn');
    const clearBtn = document.getElementById('date-range-clear-btn');
    const startDateInput = document.getElementById('date-range-start-input');
    const endDateInput = document.getElementById('date-range-end-input');

    // Verificar que todos los elementos existen
    if (!modal) {
        console.error('Error: No se encontró el modal date-range-modal');
        return;
    }
    if (!closeBtn) console.error('Error: No se encontró date-range-close-btn');
    if (!prevMonthBtn) console.error('Error: No se encontró calendar-prev-month');
    if (!nextMonthBtn) console.error('Error: No se encontró calendar-next-month');
    if (!monthYearEl) console.error('Error: No se encontró calendar-month-year');
    if (!daysGrid) console.error('Error: No se encontró calendar-days');
    if (!applyBtn) console.error('Error: No se encontró date-range-apply-btn');
    if (!clearBtn) console.error('Error: No se encontró date-range-clear-btn');
    if (!startDateInput) console.error('Error: No se encontró date-range-start-input');
    if (!endDateInput) console.error('Error: No se encontró date-range-end-input');
    
    if (!closeBtn || !prevMonthBtn || !nextMonthBtn || !monthYearEl || !daysGrid || !applyBtn || !clearBtn || !startDateInput || !endDateInput) {
        console.error('Error: Faltan elementos del modal de fecha');
        return;
    }
    
    console.log('✅ Modal de calendario inicializado correctamente');

    let currentDate = new Date();
    let startDate = null;
    let endDate = null;

    function renderCalendar() {
        if (!daysGrid || !monthYearEl) return;
        
        daysGrid.innerHTML = '';
        const year = currentDate.getFullYear();
        const month = currentDate.getMonth();
        monthYearEl.textContent = `${monthNamesShort[month]} ${year}`;

        const firstDayOfMonth = new Date(year, month, 1).getDay();
        const daysInMonth = new Date(year, month + 1, 0).getDate();

        for (let i = 0; i < firstDayOfMonth; i++) {
            daysGrid.innerHTML += '<div></div>';
        }

        for (let day = 1; day <= daysInMonth; day++) {
            const dayEl = document.createElement('div');
            dayEl.textContent = day;
            dayEl.classList.add('calendar-day-cell');
            const date = new Date(year, month, day);
            const dateString = getLocalDateString(date);

            if (dateString === getLocalDateString(new Date())) {
                dayEl.classList.add('today');
            }

            dayEl.addEventListener('click', () => {
                if (!startDate || (startDate && endDate)) {
                    startDate = date;
                    endDate = null;
                } else if (date < startDate) {
                    endDate = startDate;
                    startDate = date;
                } else {
                    endDate = date;
                }
                updateCalendarSelection();
            });

            daysGrid.appendChild(dayEl);
        }
        updateCalendarSelection();
    }

    function updateCalendarSelection() {
        if (!daysGrid || !startDateInput || !endDateInput) return;
        
        const dayCells = daysGrid.querySelectorAll('.calendar-day-cell');
        dayCells.forEach(cell => {
            const day = parseInt(cell.textContent);
            if (isNaN(day)) return;
            
            const date = new Date(currentDate.getFullYear(), currentDate.getMonth(), day);
            const dateString = getLocalDateString(date);

            cell.classList.remove('selected', 'in-range', 'range-start', 'range-end');

            if (startDate && dateString === getLocalDateString(startDate)) {
                cell.classList.add('selected', 'range-start');
            }
            if (endDate && dateString === getLocalDateString(endDate)) {
                cell.classList.add('selected', 'range-end');
            }
            if (startDate && endDate && date > startDate && date < endDate) {
                cell.classList.add('in-range');
            }
        });

        startDateInput.value = startDate ? formatDate(getLocalDateString(startDate)) : '';
        endDateInput.value = endDate ? formatDate(getLocalDateString(endDate)) : '';
    }

    function openModal() {
        if (!modal) {
            console.error('❌ Modal no existe!');
            return;
        }
        console.log('🔵 Abriendo modal de calendario...');
        
        // Remover hidden y forzar display
        modal.classList.remove('hidden');
        modal.style.display = 'flex';
        modal.style.visibility = 'visible';
        modal.style.opacity = '1';
        modal.style.zIndex = '9999';
        
        currentDate = new Date();
        startDate = null;
        endDate = null;
        renderCalendar();
        console.log('✅ Modal de calendario abierto');
        console.log('📊 Estado del modal:', {
            display: modal.style.display,
            visibility: modal.style.visibility,
            classList: modal.classList.toString()
        });
    }

    function closeModal() {
        if (!modal) return;
        console.log('🔴 Cerrando modal de calendario...');
        modal.classList.add('hidden');
        modal.style.display = 'none';
    }

    // Cerrar modal al hacer clic fuera de él
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            closeModal();
        }
    });

    document.querySelectorAll('.date-filter-trigger').forEach(button => {
        button.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            console.log('🔴 Click en botón de filtro de fecha detectado');
            openModal();
        });
    });
    
    console.log('📅 Event listeners del calendario configurados. Botones encontrados:', document.querySelectorAll('.date-filter-trigger').length);

    if (closeBtn) {
        closeBtn.addEventListener('click', closeModal);
    }

    if (prevMonthBtn) {
        prevMonthBtn.addEventListener('click', () => {
            currentDate.setMonth(currentDate.getMonth() - 1);
            renderCalendar();
        });
    }

    if (nextMonthBtn) {
        nextMonthBtn.addEventListener('click', () => {
            currentDate.setMonth(currentDate.getMonth() + 1);
            renderCalendar();
        });
    }

    if (applyBtn) {
        applyBtn.addEventListener('click', () => {
            console.log('📅 Aplicando filtro de fecha...');
            console.log('📅 startDate object:', startDate);
            console.log('📅 endDate object:', endDate);
            
            if (startDate && endDate) {
                const startString = getLocalDateString(startDate);
                const endString = getLocalDateString(endDate);
                
                console.log('📅 startDate string:', startString);
                console.log('📅 endDate string:', endString);
                
                const filterData = {
                    type: 'custom',
                    startDate: startString,
                    endDate: endString,
                    display: `${formatDate(startString)} - ${formatDate(endString)}`
                };
                console.log('✅ Filtro aplicado completo:', JSON.stringify(filterData, null, 2));
                
                // Cerrar modal primero
                closeModal();
                
                // Aplicar filtro después de cerrar
                setTimeout(() => {
                    updateGlobalDateFilter(filterData);
                }, 50);
                
            } else if (startDate) {
                const startString = getLocalDateString(startDate);
                const filterData = {
                    type: 'day',
                    startDate: startString,
                    endDate: startString,
                    display: `Día: ${formatDate(startString)}`
                };
                console.log('✅ Filtro de día aplicado:', JSON.stringify(filterData, null, 2));
                
                // Cerrar modal primero
                closeModal();
                
                // Aplicar filtro después de cerrar
                setTimeout(() => {
                    updateGlobalDateFilter(filterData);
                }, 50);
                
            } else {
                console.warn('⚠️ No hay fechas seleccionadas');
                alert('Por favor selecciona al menos una fecha');
                return;
            }
        });
    }

    if (clearBtn) {
        clearBtn.addEventListener('click', () => {
            closeModal();
            setTimeout(() => {
                updateGlobalDateFilter({ type: 'all', startDate: null, endDate: null, display: 'Sin filtro de fecha' });
            }, 50);
        });
    }

    document.querySelectorAll('.date-range-preset').forEach(button => {
        button.addEventListener('click', () => {
            const range = button.dataset.range;
            const today = new Date();
            today.setHours(0, 0, 0, 0); // Normalizar la hora
            let newStartDate, newEndDate;

            switch (range) {
                case 'today':
                    newStartDate = new Date(today);
                    newEndDate = new Date(today);
                    break;
                case 'this_week':
                    const weekRange = getWeekRangeForDate(today, 1);
                    // Convertir strings YYYY-MM-DD a Date local sin zona horaria
                    const [wy, wm, wd] = weekRange.startDate.split('-').map(Number);
                    const [wey, wem, wed] = weekRange.endDate.split('-').map(Number);
                    newStartDate = new Date(wy, wm - 1, wd);
                    newEndDate = new Date(wey, wem - 1, wed);
                    break;
                case 'this_month':
                    const monthRange = getMonthRangeForDate(today);
                    const [my, mm, md] = monthRange.startDate.split('-').map(Number);
                    const [mey, mem, med] = monthRange.endDate.split('-').map(Number);
                    newStartDate = new Date(my, mm - 1, md);
                    newEndDate = new Date(mey, mem - 1, med);
                    break;
                case 'last_7_days':
                    newEndDate = new Date(today);
                    newStartDate = new Date(today);
                    newStartDate.setDate(today.getDate() - 6);
                    break;
                case 'last_30_days':
                    newEndDate = new Date(today);
                    newStartDate = new Date(today);
                    newStartDate.setDate(today.getDate() - 29);
                    break;
                case 'this_year':
                    const yearRange = getYearRangeForDate(today);
                    const [yy, ym, yd] = yearRange.startDate.split('-').map(Number);
                    const [yey, yem, yed] = yearRange.endDate.split('-').map(Number);
                    newStartDate = new Date(yy, ym - 1, yd);
                    newEndDate = new Date(yey, yem - 1, yed);
                    break;
            }

            console.log('📅 Rango predefinido seleccionado:', range);
            console.log('📆 Fechas:', { 
                start: newStartDate, 
                end: newEndDate,
                startString: getLocalDateString(newStartDate),
                endString: getLocalDateString(newEndDate)
            });

            startDate = newStartDate;
            endDate = newEndDate;
            currentDate = new Date(startDate);
            renderCalendar();
        });
    });
}

        // ===== INICIALIZACIÓN DEL HEADER PRINCIPAL =====
        // ===== MULTI-SELECT GLOBAL STATE =====
        let selectedAccounts = ['all']; // Array de IDs de cuentas seleccionadas (por defecto "all")
        let isInitialLoad = true; // Flag para evitar refreshes durante carga inicial

        // ===== FUNCIONES MULTI-SELECT =====
        function initMultiSelect() {
            console.log('🎯 Iniciando Multi-Select');
            
            const trigger = document.getElementById('main-account-trigger');
            const dropdown = document.getElementById('main-account-dropdown');
            
            if (!trigger || !dropdown) {
                console.warn('⚠️ No se encontraron elementos multi-select');
                return;
            }

            // Poblar dropdown con opciones
            populateMultiSelectDropdown();

            // Toggle dropdown
            trigger.addEventListener('click', (e) => {
                e.stopPropagation();
                dropdown.classList.toggle('open');
                trigger.classList.toggle('open');
            });

            // Cerrar dropdown al hacer clic fuera
            document.addEventListener('click', (e) => {
                if (!trigger.contains(e.target) && !dropdown.contains(e.target)) {
                    dropdown.classList.remove('open');
                    trigger.classList.remove('open');
                }
            });
        }

        function populateMultiSelectDropdown() {
            const dropdown = document.getElementById('main-account-dropdown');
            if (!dropdown) return;

            dropdown.innerHTML = '';

            // Opción "Todas las cuentas"
            const allOption = document.createElement('div');
            allOption.className = 'multi-select-option all';
            allOption.innerHTML = `
                <input type="checkbox" id="account-all" value="all">
                <label for="account-all" style="cursor: pointer; user-select: none;">Todas las cuentas</label>
            `;
            dropdown.appendChild(allOption);

            const allCheckbox = allOption.querySelector('input');
            allCheckbox.addEventListener('change', (e) => {
                if (e.target.checked) {
                    selectedAccounts = ['all'];
                    // Desmarcar todas las demás cuentas
                    dropdown.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                        if (cb.value !== 'all') cb.checked = false;
                    });
                } else {
                    selectedAccounts = [];
                }
                updateMultiSelectDisplay();
                syncMultiAccountSelection();
            });

            // Opciones individuales de cuentas
            DB.accounts.forEach(account => {
                const option = document.createElement('div');
                option.className = 'multi-select-option';
                option.setAttribute('data-platform', account.platform);
                option.innerHTML = `
                    <input type="checkbox" id="account-${account.id}" value="${account.id}">
                    <label for="account-${account.id}" style="cursor: pointer; user-select: none;">${account.name}</label>
                `;
                dropdown.appendChild(option);

                const checkbox = option.querySelector('input');
                checkbox.addEventListener('change', (e) => {
                    const accountId = e.target.value;
                    
                    if (e.target.checked) {
                        // Desmarcar "todas las cuentas" si se selecciona una cuenta específica
                        allCheckbox.checked = false;
                        if (selectedAccounts.includes('all')) {
                            selectedAccounts = [];
                        }
                        
                        if (!selectedAccounts.includes(accountId)) {
                            selectedAccounts.push(accountId);
                        }
                    } else {
                        selectedAccounts = selectedAccounts.filter(id => id !== accountId);
                    }

                    // Si todas las cuentas están seleccionadas, marcar "Todas"
                    const allAccountsSelected = DB.accounts.every(acc => 
                        selectedAccounts.includes(acc.id)
                    );
                    if (allAccountsSelected && DB.accounts.length > 0) {
                        allCheckbox.checked = true;
                        selectedAccounts = ['all'];
                        dropdown.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                            if (cb.value !== 'all') cb.checked = false;
                        });
                    }

                    updateMultiSelectDisplay();
                    syncMultiAccountSelection();
                });
            });

            // Inicializar con "Todas las cuentas" seleccionado
            selectedAccounts = ['all'];
            allCheckbox.checked = true;
            updateMultiSelectDisplay();
        }

        function updateMultiSelectDisplay() {
            const display = document.getElementById('main-account-display');
            if (!display) return;

            if (selectedAccounts.length === 0) {
                display.innerHTML = 'Seleccionar cuenta';
            } else if (selectedAccounts.includes('all')) {
                display.innerHTML = 'Todas las cuentas';
            } else if (selectedAccounts.length === 1) {
                const account = DB.accounts.find(a => a.id === selectedAccounts[0]);
                display.innerHTML = account ? account.name : 'Seleccionar cuenta';
            } else {
                display.innerHTML = `
                    <span>${selectedAccounts.length} cuentas</span>
                    <span class="multi-select-count">${selectedAccounts.length}</span>
                `;
            }
        }

        function syncMultiAccountSelection() {
            console.log('🔄 Sincronizando selección múltiple:', selectedAccounts);
            
            // Si selectedAccounts está vacío o tiene elementos inválidos, usar "all"
            if (selectedAccounts.length === 0 || 
                (selectedAccounts.length === 1 && !selectedAccounts.includes('all') && !DB.accounts.find(a => a.id === selectedAccounts[0]))) {
                console.log('⚠️ Selección vacía o inválida, forzando "all"');
                selectedAccounts = ['all'];
                updateMultiSelectDisplay(); // Actualizar el display
            }
            
            // Determinar qué valor usar para los selectores tradicionales
            let selectorValue = 'all';
            if (selectedAccounts.length === 1 && !selectedAccounts.includes('all')) {
                selectorValue = selectedAccounts[0];
            } else if (selectedAccounts.includes('all') || selectedAccounts.length === 0) {
                selectorValue = 'all';
            }

            console.log('📌 Valor del selector: "' + selectorValue + '"');

            // Actualizar selector oculto (para compatibilidad)
            const mainSelect = document.getElementById('main-account-select');
            if (mainSelect) {
                mainSelect.value = selectorValue;
            }

            // Actualizar globalSelectedAccount para compatibilidad
            globalSelectedAccount = selectorValue;

            // Sincronizar con todos los selectores de cuenta
            const selectors = [
                'dashboard-account-select',
                'new-dashboard-account-select',
                'analytics-account-select',
                'informe-account-select',
                'daily-journal-account-select',
                'calendar-account-select',
                'equity-account-select',
                'filter-account',
                'chartbook-account-select'
            ];

            selectors.forEach(selectorId => {
                const selectElement = document.getElementById(selectorId);
                if (selectElement) {
                    selectElement.value = selectorValue;
                    updateSelectorLogo(selectorId);
                }
            });

            // Refrescar la sección activa solo si no estamos en carga inicial
            if (!isInitialLoad) {
                refreshCurrentSection();
            }
        }

        function refreshMultiSelectDropdown() {
            console.log('🔄 Refrescando multi-select dropdown');
            const currentSelected = [...selectedAccounts];
            
            // Si estamos en carga inicial y no hay selección, usar "all"
            if (isInitialLoad && currentSelected.length === 0) {
                console.log('🎯 Carga inicial: forzando selección a "all"');
                currentSelected.push('all');
            }
            
            populateMultiSelectDropdown();
            
            // Restaurar selección
            selectedAccounts = currentSelected.length > 0 ? currentSelected : ['all'];
            const dropdown = document.getElementById('main-account-dropdown');
            if (dropdown) {
                selectedAccounts.forEach(accountId => {
                    const checkbox = dropdown.querySelector(`input[value="${accountId}"]`);
                    if (checkbox) checkbox.checked = true;
                });
            }
            updateMultiSelectDisplay();
        }

        function initMainHeader() {
            console.log('🎯 Iniciando initMainHeader()');
            
            // Inicializar Multi-Select
            initMultiSelect();
            
            // Poblar selector oculto para compatibilidad
            const mainSelect = document.getElementById('main-account-select');
            if (mainSelect) {
                DB.accounts.forEach(account => {
                    const option = document.createElement('option');
                    option.value = account.id;
                    option.textContent = account.name;
                    option.setAttribute('data-platform', account.platform);
                    mainSelect.appendChild(option);
                });
            }

            // ===== INICIALIZACIÓN DE CONTROLES DE USUARIO =====
            
            // Actualizar header del usuario cuando esté disponible
            if (typeof currentUser !== 'undefined' && currentUser) {
                updateUserHeader();
            }

            // Toggle del menú de usuario
            const userMenuToggle = document.getElementById('user-menu-toggle');
            const userDropdown = document.getElementById('user-dropdown-menu');
            
            if (userMenuToggle && userDropdown) {
                userMenuToggle.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const isHidden = userDropdown.style.display === 'none';
                    userDropdown.style.display = isHidden ? 'block' : 'none';
                });

                // Cerrar dropdown al hacer clic fuera
                document.addEventListener('click', (e) => {
                    if (!userMenuToggle.contains(e.target) && !userDropdown.contains(e.target)) {
                        userDropdown.style.display = 'none';
                    }
                });
            }

            // Botón de configuración en header
            const headerConfigBtn = document.getElementById('header-config-btn');
            if (headerConfigBtn) {
                headerConfigBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    showSection('config');
                    if (userDropdown) userDropdown.style.display = 'none';
                });
            }

            // Botón de cerrar sesión en header
            const headerLogoutBtn = document.getElementById('header-logout-btn');
            console.log('🔍 Buscando botón logout:', headerLogoutBtn);
            
            if (headerLogoutBtn) {
                console.log('✅ Botón logout encontrado, agregando listener');
                
                // Remover listeners previos si existen
                const newLogoutBtn = headerLogoutBtn.cloneNode(true);
                headerLogoutBtn.parentNode.replaceChild(newLogoutBtn, headerLogoutBtn);
                
                newLogoutBtn.addEventListener('click', async (e) => {
                    console.log('🖱️ Click en botón logout detectado');
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Cerrar el dropdown
                    const dropdown = document.getElementById('user-dropdown-menu');
                    if (dropdown) {
                        console.log('🔽 Cerrando dropdown');
                        dropdown.style.display = 'none';
                    }
                    
                    console.log('💬 Mostrando confirm');
                    if (confirm('¿Estás seguro de que deseas cerrar sesión?')) {
                        console.log('✅ Usuario confirmó logout');
                        try {
                            await window.supabase.auth.signOut();
                            console.log('✅ Sesión cerrada, redirigiendo a landing...');
                            // Redirigir a landing page después de logout
                            window.location.href = '/';
                        } catch (error) {
                            console.error('❌ Error al cerrar sesión:', error);
                            alert('Error al cerrar sesión. Redirigiendo a landing...');
                            window.location.href = '/';
                        }
                    } else {
                        console.log('❌ Usuario canceló logout');
                    }
                });
                
                console.log('✅ Listener de logout agregado correctamente');
            } else {
                console.error('❌ No se encontró el botón header-logout-btn');
            }
        }

        // Función para refrescar el selector de cuentas en el header
        function refreshAccountSelector() {
            console.log('🔄 Refrescando selector. DB.accounts:', DB.accounts.length);

            // Refrescar multi-select dropdown
            refreshMultiSelectDropdown();

            // Refrescar selector oculto (compatibilidad)
            const mainSelect = document.getElementById('main-account-select');
            if (mainSelect) {
                // Obtener valor seleccionado actual
                const currentValue = mainSelect.value;

                // Remover solo las opciones de cuentas, NO el placeholder
                const options = Array.from(mainSelect.querySelectorAll('option'));
                options.forEach((opt, index) => {
                    if (index > 0) { // Mantener el primer option (placeholder)
                        opt.remove();
                    }
                });

                // Agregar cuentas actualizadas
                DB.accounts.forEach(account => {
                    const option = document.createElement('option');
                    option.value = account.id;
                    option.textContent = account.name;
                    option.setAttribute('data-platform', account.platform);
                    mainSelect.appendChild(option);
                });

                // Restaurar selección si existe
                if (currentValue && DB.accounts.find(a => a.id === currentValue)) {
                    mainSelect.value = currentValue;
                }
            }

            // Actualizar TODOS los selectores de cuenta en las secciones
            const selectors = [
                'dashboard-account-select',
                'new-dashboard-account-select',
                'analytics-account-select',
                'informe-account-select',
                'daily-journal-account-select',
                'calendar-account-select',
                'equity-account-select',
                'filter-account',
                'chartbook-account-select',
                'bingx-account',
                'bingx-account-detail',
                'bitunix-account-detail',
                'lbank-account-detail',
                'blofin-account-detail',
                'bitget-account-detail',
                'mexc-account-detail'
            ];
            
            selectors.forEach(selectorId => {
                if (typeof updateAccountSelect === 'function') {
                    updateAccountSelect(selectorId);
                }
            });

            console.log('✅ Selector refrescado con multi-select y todas las secciones actualizadas');
        }

        function initMainHeaderOld() {
            // Código original movido arriba, esta función ya no se usa
            // La dejamos por compatibilidad pero initMainHeader ahora solo inicializa una vez
            const mainSelect = document.getElementById('main-account-select');
            if (!mainSelect) return;

            // Event listener para cambio de cuenta principal
            mainSelect.addEventListener('change', function() {
                const selectedAccount = this.value;
                console.log('🎯 [MAIN SELECTOR] Account changed to:', selectedAccount);

                if (selectedAccount === '') {
                    // No hay cuenta seleccionada
                    globalSelectedAccount = 'all';
                } else {
                    globalSelectedAccount = selectedAccount;
                }

                // Actualizar logo del selector principal
                updateSelectorLogo('main-account-select');

                // Sincronizar con TODOS los selectores de cuenta
                const selectors = [
                    'dashboard-account-select',
                    'new-dashboard-account-select',
                    'analytics-account-select',
                    'informe-account-select',
                    'daily-journal-account-select',
                    'calendar-account-select',
                    'equity-account-select',
                    'filter-account',
                    'chartbook-account-select'
                ];

                selectors.forEach(selectorId => {
                    const selectElement = document.getElementById(selectorId);
                    if (selectElement) {
                        if (selectedAccount === '') {
                            selectElement.value = 'all';
                        } else {
                            selectElement.value = selectedAccount;
                        }
                        updateSelectorLogo(selectorId);
                    }
                });

                // Refrescar la sección activa
                refreshCurrentSection();
                
                // Si estamos en Informe, también refrescar la subsección activa
                const activeSection = document.querySelector('.section-container.active');
                if (activeSection && activeSection.id === 'informe') {
                    console.log('🔄 [MAIN SELECTOR] Refreshing active Informe subsection...');
                    const activeSubTab = document.querySelector('.informe-sub-tab.active');
                    if (activeSubTab) {
                        const targetId = activeSubTab.dataset.target;
                        console.log('🔄 [MAIN SELECTOR] Active subsection:', targetId);
                        
                        setTimeout(() => {
                            switch (targetId) {
                                case 'informe-informes-content':
                                    refreshInforme();
                                    break;
                                case 'informe-metricas-content':
                                    refreshMetricas();
                                    break;
                                case 'informe-metricas-avanzadas-content':
                                    refreshMetricasAvanzadas();
                                    break;
                                case 'informe-simbolos-content':
                                    refreshSimbolos();
                                    break;
                                case 'informe-tiempo-content':
                                    refreshTiempo();
                                    break;
                                case 'informe-graficos-content':
                                    if (typeof window.refreshGraficosCharts === 'function') {
                                        window.refreshGraficosCharts();
                                    }
                                    break;
                                case 'informe-comisiones-content':
                                    if (typeof window.refreshComisiones === 'function') {
                                        window.refreshComisiones();
                                    }
                                    break;
                            }
                        }, 50);
                    }
                }
            });

            // Toggle del menú de usuario
            const userMenuToggle = document.getElementById('user-menu-toggle');
            const userDropdown = document.getElementById('user-dropdown-menu');
            
            if (userMenuToggle && userDropdown) {
                userMenuToggle.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const isHidden = userDropdown.style.display === 'none';
                    userDropdown.style.display = isHidden ? 'block' : 'none';
                });

                // Cerrar dropdown al hacer clic fuera
                document.addEventListener('click', (e) => {
                    if (!userMenuToggle.contains(e.target) && !userDropdown.contains(e.target)) {
                        userDropdown.style.display = 'none';
                    }
                });
            }

            // Botón de configuración en header
            const headerConfigBtn = document.getElementById('header-config-btn');
            if (headerConfigBtn) {
                headerConfigBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    showSection('config');
                    if (userDropdown) userDropdown.style.display = 'none';
                });
            }

            // Botón de cerrar sesión en header
            const headerLogoutBtn = document.getElementById('header-logout-btn');
            console.log('🔍 Buscando botón logout:', headerLogoutBtn);
            
            if (headerLogoutBtn) {
                console.log('✅ Botón logout encontrado, agregando listener');
                
                // Remover listeners previos si existen
                const newLogoutBtn = headerLogoutBtn.cloneNode(true);
                headerLogoutBtn.parentNode.replaceChild(newLogoutBtn, headerLogoutBtn);
                
                newLogoutBtn.addEventListener('click', async (e) => {
                    console.log('🖱️ Click en botón logout detectado');
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Cerrar el dropdown
                    const dropdown = document.getElementById('user-dropdown-menu');
                    if (dropdown) {
                        console.log('🔽 Cerrando dropdown');
                        dropdown.style.display = 'none';
                    }
                    
                    console.log('💬 Mostrando confirm');
                    if (confirm('¿Estás seguro de que deseas cerrar sesión?')) {
                        console.log('✅ Usuario confirmó logout');
                        try {
                            await window.supabase.auth.signOut();
                            console.log('✅ Sesión cerrada, redirigiendo a landing...');
                            // Redirigir a landing page después de logout
                            window.location.href = '/';
                        } catch (error) {
                            console.error('❌ Error al cerrar sesión:', error);
                            alert('Error al cerrar sesión. Redirigiendo a landing...');
                            window.location.href = '/';
                        }
                    } else {
                        console.log('❌ Usuario canceló logout');
                    }
                });
                
                console.log('✅ Listener de logout agregado correctamente');
            } else {
                console.error('❌ No se encontró el botón header-logout-btn');
            }

            // No actualizar logo al iniciar - debe estar oculto hasta que se seleccione una cuenta
        }

        // ===== FUNCIÓN GLOBAL PARA ACTUALIZAR HEADER DEL USUARIO =====
        window.updateUserHeader = function() {
            const headerEmail = document.getElementById('header-user-email');
            const headerAvatar = document.getElementById('header-user-avatar');
            
            if (!currentUser) {
                console.log('⚠️ updateUserHeader: currentUser no disponible');
                return;
            }
            
            console.log('🔄 Actualizando header del usuario:', currentUser.email);
            
            // Actualizar email
            if (headerEmail) {
                headerEmail.textContent = currentUser.email;
                console.log('✅ Email actualizado:', currentUser.email);
            }
            
            // Actualizar avatar con foto de perfil desde localStorage
            if (headerAvatar) {
                const profileImage = localStorage.getItem('profile-image');
                if (profileImage) {
                    headerAvatar.innerHTML = `<img src="${profileImage}" alt="Profile" style="width: 100%; height: 100%; object-fit: cover; border-radius: 50%;">`;
                    console.log('✅ Avatar actualizado con foto de perfil');
                } else if (currentUser.email) {
                    headerAvatar.textContent = currentUser.email.charAt(0).toUpperCase();
                    console.log('✅ Avatar actualizado con inicial:', currentUser.email.charAt(0).toUpperCase());
                }
            }
        };

        // ===== SOCIAL MEDIA SECTION =====
        // Variables globales para Social Media
        let socialMediaTimeframe = 'all';
        let publicTraders = [];
        let settingsLoaded = false; // Flag para evitar múltiples cargas

        // Inicializar sección Social Media
        function initSocialMedia() {
            console.log('🌐 Iniciando Social Media...');
            
            // Event listeners para pestañas (Ranking, Siguiendo, Grupos)
            const socialTabs = document.querySelectorAll('.social-tab');
            socialTabs.forEach(tab => {
                tab.addEventListener('click', function() {
                    const targetTab = this.getAttribute('data-tab');
                    
                    // Remover clase active de todas las pestañas
                    socialTabs.forEach(t => t.classList.remove('active'));
                    // Agregar clase active a la pestaña clickeada
                    this.classList.add('active');
                    
                    // Ocultar todos los contenidos
                    document.querySelectorAll('.social-tab-content').forEach(content => {
                        content.classList.remove('active');
                        content.style.display = 'none';
                    });
                    
                    // Mostrar contenido de la pestaña seleccionada
                    const targetContent = document.getElementById(`social-content-${targetTab}`);
                    if (targetContent) {
                        targetContent.classList.add('active');
                        targetContent.style.display = 'block';
                        
                        // Cargar contenido específico de la pestaña
                        if (targetTab === 'following') {
                            loadFollowingTab();
                        } else if (targetTab === 'ranking') {
                            refreshSocialMediaLeaderboard();
                        } else if (targetTab === 'groups') {
                            // Cargar grupos cuando se cambie a la pestaña
                            console.log('📂 Inicializando pestaña de grupos...');
                            console.log('🔍 Verificando funciones disponibles:');
                            console.log('  - initSocialMediaModule:', typeof initSocialMediaModule);
                            console.log('  - loadMyGroups:', typeof loadMyGroups);
                            console.log('  - loadPublicGroups:', typeof loadPublicGroups);
                            console.log('  - window.socialMediaModuleInitialized:', window.socialMediaModuleInitialized);
                            
                            // Inicializar módulo si no está iniciado
                            if (typeof initSocialMediaModule === 'function') {
                                if (!window.socialMediaModuleInitialized) {
                                    console.log('🌍 Iniciando módulo de grupos por primera vez...');
                                    try {
                                        initSocialMediaModule();
                                        window.socialMediaModuleInitialized = true;
                                        console.log('✅ Módulo inicializado correctamente');
                                    } catch (error) {
                                        console.error('❌ Error al inicializar módulo:', error);
                                    }
                                } else {
                                    console.log('⚠️ Módulo ya inicializado, recargando grupos...');
                                }
                                
                                // Cargar grupos directamente (sin setTimeout)
                                console.log('🔄 Intentando cargar grupos...');
                                try {
                                    if (typeof window.loadMyGroups === 'function') {
                                        console.log('📋 Llamando a loadMyGroups()...');
                                        window.loadMyGroups();
                                    } else {
                                        console.error('❌ loadMyGroups no está disponible');
                                    }
                                    
                                    if (typeof window.loadPublicGroups === 'function') {
                                        console.log('🌐 Llamando a loadPublicGroups()...');
                                        window.loadPublicGroups();
                                    } else {
                                        console.error('❌ loadPublicGroups no está disponible');
                                    }
                                } catch (error) {
                                    console.error('❌ Error cargando grupos:', error);
                                }
                            } else {
                                console.error('❌ initSocialMediaModule no está disponible');
                            }
                        }
                    }
                });
            });
            
            // Event listeners para botones de timeframe
            const timeframeButtons = [
                document.getElementById('social-media-timeframe-1m'),
                document.getElementById('social-media-timeframe-3m'),
                document.getElementById('social-media-timeframe-1y'),
                document.getElementById('social-media-timeframe-all')
            ].filter(btn => btn !== null);
            
            timeframeButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    // Remover estilos de todos los botones
                    timeframeButtons.forEach(b => {
                        b.classList.remove('bg-primary', 'text-white');
                        b.classList.add('bg-surface-light', 'hover:bg-surface', 'border', 'border-border');
                    });
                    // Agregar estilo activo al botón clickeado
                    this.classList.remove('bg-surface-light', 'hover:bg-surface', 'border', 'border-border');
                    this.classList.add('bg-primary', 'text-white');
                    
                    // Actualizar timeframe desde ID del botón
                    const btnId = this.id.replace('social-media-timeframe-', '');
                    socialMediaTimeframe = btnId;
                    console.log(`📅 Timeframe cambiado a: ${socialMediaTimeframe}`);
                    
                    // Recargar leaderboard con nuevo timeframe
                    refreshSocialMediaLeaderboard();
                });
            });
            
            // Cargar traders públicos al iniciar
            loadPublicTraders();
        }

        // Cargar traders con perfil público desde Supabase
        async function loadPublicTraders() {
            console.log('👥 Cargando traders públicos...');
            
            try {
                // Obtener usuarios con perfil público
                const { data: publicUsers, error: usersError } = await supabase
                    .from('user_settings')
                    .select('user_id, username, country, is_public')
                    .eq('is_public', true);
                
                if (usersError) {
                    console.error('❌ Error al cargar usuarios públicos:', usersError);
                    return;
                }
                
                if (!publicUsers || publicUsers.length === 0) {
                    console.log('ℹ️ No hay traders con perfil público aún');
                    publicTraders = [];
                    refreshSocialMediaLeaderboard();
                    return;
                }
                
                console.log(`✅ ${publicUsers.length} traders públicos encontrados`);
                
                // Para cada usuario, obtener sus estadísticas
                const tradersWithStats = await Promise.all(publicUsers.map(async (user) => {
                    try {
                        // Obtener cuenta seleccionada en Audición
                        const audicionSelect = document.getElementById('audicion-account-select');
                        const selectedAccount = audicionSelect ? audicionSelect.value : 'all';
                        
                        // Obtener operaciones del usuario
                        let query = supabase
                            .from('operations')
                            .select('*')
                            .eq('user_id', user.user_id);
                        
                        // Filtrar por cuenta si no es 'all'
                        if (selectedAccount && selectedAccount !== 'all') {
                            query = query.eq('account_id', selectedAccount);
                        }
                        
                        const { data: operations, error: opsError } = await query;
                        
                        if (opsError || !operations) {
                            console.error(`❌ Error al cargar operaciones de ${user.username}:`, opsError);
                            return null;
                        }
                        
                        // Filtrar por timeframe
                        const filteredOps = filterOperationsByTimeframe(operations, socialMediaTimeframe);
                        
                        // Calcular estadísticas
                        const stats = calculateTraderStats(filteredOps);
                        
                        return {
                            ...user,
                            ...stats,
                            totalTrades: filteredOps.length
                        };
                    } catch (error) {
                        console.error(`❌ Error procesando trader ${user.username}:`, error);
                        return null;
                    }
                }));
                
                // Filtrar traders sin datos y ordenar por beneficio
                publicTraders = tradersWithStats
                    .filter(t => t !== null)
                    .sort((a, b) => b.totalProfit - a.totalProfit);
                
                // Solo traders reales (datos demo eliminados)
                console.log('✅ Modo producción: Solo traders reales en ranking');
                console.log('📊 Traders con estadísticas:', publicTraders);
                
                // Actualizar leaderboard
                refreshSocialMediaLeaderboard();
                
            } catch (error) {
                console.error('❌ Error en loadPublicTraders:', error);
            }
        }

        // Filtrar operaciones por timeframe
        function filterOperationsByTimeframe(operations, timeframe) {
            if (timeframe === 'all') return operations;
            
            const now = new Date();
            let cutoffDate;
            
            switch(timeframe) {
                case '1m':
                    cutoffDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000); // 30 días
                    break;
                case '3m':
                    cutoffDate = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000); // 90 días
                    break;
                case '1y':
                    cutoffDate = new Date(now.getTime() - 365 * 24 * 60 * 60 * 1000); // 365 días
                    break;
                default:
                    return operations;
            }
            
            return operations.filter(op => {
                const opDate = new Date(op.date);
                return opDate >= cutoffDate;
            });
        }

        // Calcular estadísticas de un trader
        function calculateTraderStats(operations) {
            if (!operations || operations.length === 0) {
                return {
                    totalProfit: 0,
                    avgWinRate: 0,
                    winningTrades: 0,
                    losingTrades: 0,
                    avgProfit: 0
                };
            }
            
            const totalProfit = operations.reduce((sum, op) => sum + (parseFloat(op.pl) || 0), 0);
            const winningTrades = operations.filter(op => parseFloat(op.pl) > 0).length;
            const losingTrades = operations.filter(op => parseFloat(op.pl) < 0).length;
            const winRate = operations.length > 0 ? (winningTrades / operations.length) * 100 : 0;
            const avgProfit = totalProfit / operations.length;
            
            return {
                totalProfit,
                avgWinRate: winRate,
                winningTrades,
                losingTrades,
                avgProfit
            };
        }

        // Actualizar tabla del leaderboard
        function refreshSocialMediaLeaderboard() {
            console.log('🔄 Actualizando leaderboard...');
            
            const tbody = document.getElementById('social-media-tbody');
            if (!tbody) {
                console.error('❌ No se encontró el tbody del leaderboard');
                return;
            }
            
            // Limpiar tabla
            tbody.innerHTML = '';
            
            // Si no hay traders, mostrar mensaje
            if (!publicTraders || publicTraders.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="6" style="text-align: center; padding: 40px; color: #666;">
                            <div style="font-size: 48px; margin-bottom: 16px;">📊</div>
                            <div style="font-size: 16px; margin-bottom: 8px; font-weight: 600;">No hay traders públicos aún</div>
                            <div style="font-size: 14px; color: #888;">Activa tu perfil público en Configuración → Audición para aparecer aquí</div>
                        </td>
                    </tr>
                `;
                return;
            }
            
            // Verificar si solo está el usuario actual
            const otherTradersCount = publicTraders.filter(t => !currentUser || t.user_id !== currentUser.id).length;
            if (otherTradersCount === 0 && publicTraders.length === 1) {
                // Solo el usuario actual está en el ranking
                console.log('ℹ️ Solo el usuario actual tiene perfil público');
            }
            
            // Renderizar cada trader
            publicTraders.forEach((trader, index) => {
                const rank = index + 1;
                const stars = getStarsForProfit(trader.totalProfit);
                const profitColor = trader.totalProfit >= 0 ? '#10B981' : '#DC2626';
                const winRateColor = trader.avgWinRate >= 50 ? '#10B981' : '#DC2626';
                
                const row = document.createElement('tr');
                row.style.cursor = 'pointer';
                row.dataset.userId = trader.user_id;
                
                // Generar contenido del avatar (foto o iniciales)
                let avatarContent;
                // Si es el usuario actual, intentar cargar su foto
                if (currentUser && trader.user_id === currentUser.id) {
                    const profileImage = localStorage.getItem('profile-image');
                    if (profileImage) {
                        avatarContent = `<img src="${profileImage}" alt="${trader.username}" style="width: 100%; height: 100%; object-fit: cover;">`;
                    } else {
                        avatarContent = getInitials(trader.username);
                    }
                } else {
                    avatarContent = getInitials(trader.username);
                }
                
                // Determinar si es el usuario actual
                const isCurrentUser = currentUser && trader.user_id === currentUser.id;
                
                const followButtonHtml = isCurrentUser 
                    ? '' // No mostrar botón para el propio usuario
                    : `<button 
                        class="follow-trader-btn" 
                        data-trader-id="${trader.user_id}"
                        data-trader-name="${trader.username}"
                        style="
                            padding: 8px 20px;
                            background: linear-gradient(135deg, #39ff14, #28e000);
                            color: #000;
                            border: none;
                            border-radius: 8px;
                            font-size: 13px;
                            font-weight: 700;
                            cursor: pointer;
                            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                            box-shadow: 0 3px 10px rgba(57, 255, 20, 0.4);
                            text-transform: uppercase;
                            letter-spacing: 0.8px;
                            white-space: nowrap;
                            min-width: 120px;
                        "
                        onmouseover="this.style.transform='translateY(-2px) scale(1.05)'; this.style.boxShadow='0 5px 15px rgba(57, 255, 20, 0.6)';"
                        onmouseout="this.style.transform='translateY(0) scale(1)'; this.style.boxShadow='0 3px 10px rgba(57, 255, 20, 0.4)';"
                        onclick="event.stopPropagation(); handleFollowFromRanking('${trader.user_id}', '${trader.username}', this);"
                    >
                        <i class="fas fa-user-plus" style="margin-right: 8px; font-size: 12px;"></i>
                        <span>Seguir</span>
                    </button>`;
                
                row.innerHTML = `
                    <td style="font-weight: 600; text-align: center;">#${rank}</td>
                    <td>
                        <div style="display: flex; align-items: center; justify-content: space-between; gap: 12px;">
                            <div style="display: flex; align-items: center; gap: 12px;">
                                <div class="trader-avatar">${avatarContent}</div>
                                <div class="trader-info">
                                    <div style="font-weight: 600; margin-bottom: 2px;">
                                        ${trader.username}
                                    </div>
                                    <div style="font-size: 12px; color: #888;">${getFlagEmoji(trader.country)} ${trader.country || 'Global'}</div>
                                </div>
                            </div>
                            ${followButtonHtml}
                        </div>
                    </td>
                    <td style="color: ${profitColor}; font-weight: 600; text-align: center;">
                        ${trader.totalProfit >= 0 ? '+' : ''}$${trader.totalProfit.toFixed(2)}
                    </td>
                    <td style="color: ${profitColor}; font-weight: 500; text-align: center;">
                        ${trader.totalProfit >= 0 ? '+' : ''}${((trader.avgProfit || 0)).toFixed(2)}%
                    </td>
                    <td style="color: ${winRateColor}; font-weight: 500; text-align: center;">
                        ${trader.avgWinRate.toFixed(1)}%
                    </td>
                    <td style="text-align: center;">
                        <div style="display: flex; align-items: center; justify-content: center; gap: 8px;">
                            <span>${trader.totalTrades}</span>
                            <span style="color: #fbbf24;">${stars}</span>
                        </div>
                    </td>
                `;
                
                // Click handler para ver audición del trader
                row.addEventListener('click', () => handleTraderProfileClick(trader));
                
                tbody.appendChild(row);
                
                // Verificar si ya sigue a este trader (asíncrono) - solo traders reales
                if (currentUser && !isCurrentUser) {
                    checkIfFollowingTrader(trader.user_id, row);
                }
            });
            
            // Banner de traders demo ya no es necesario (todos son traders reales)
            console.log(`✅ Leaderboard actualizado con ${publicTraders.length} traders`);
        }

        // Obtener estrellas según el beneficio
        function getStarsForProfit(profit) {
            if (profit >= 10000) return '⭐⭐⭐';
            if (profit >= 5000) return '⭐⭐';
            if (profit >= 1000) return '⭐';
            return '';
        }

        // Obtener iniciales del nombre de usuario
        function getInitials(username) {
            if (!username) return '??';
            const parts = username.split(' ');
            if (parts.length >= 2) {
                return (parts[0][0] + parts[1][0]).toUpperCase();
            }
            return username.substring(0, 2).toUpperCase();
        }

        // Obtener emoji de bandera según país
        function getFlagEmoji(country) {
            const flags = {
                'España': '🇪🇸',
                'México': '🇲🇽',
                'Argentina': '🇦🇷',
                'Colombia': '🇨🇴',
                'Chile': '🇨🇱',
                'Perú': '🇵🇪',
                'Venezuela': '🇻🇪',
                'Ecuador': '🇪🇨',
                'Uruguay': '🇺🇾',
                'Paraguay': '🇵🇾',
                'Bolivia': '🇧🇴',
                'Costa Rica': '🇨🇷',
                'Panamá': '🇵🇦',
                'República Dominicana': '🇩🇴',
                'Puerto Rico': '🇵🇷',
                'Guatemala': '🇬🇹',
                'Honduras': '🇭🇳',
                'El Salvador': '🇸🇻',
                'Nicaragua': '🇳🇮',
                'Cuba': '🇨🇺',
                'Estados Unidos': '🇺🇸',
                'Brasil': '🇧🇷',
                'Portugal': '🇵🇹',
                'Otro': '🌎'
            };
            return flags[country] || '🌎';
        }
        
        // Función para manejar el seguir/dejar de seguir desde el ranking
        async function handleFollowFromRanking(traderId, traderName, buttonElement) {
            if (!currentUser) {
                showMessage('Debes iniciar sesión para seguir traders', 'error');
                return;
            }
            
            // Evitar seguirse a sí mismo
            if (traderId === currentUser.id) {
                showMessage('No puedes seguirte a ti mismo', 'info');
                return;
            }
            
            // Solo traders reales de Supabase (lógica demo eliminada)
            // Verificar si ya lo sigue
            const { data: existingFollow } = await supabase
                .from('user_follows')
                .select('id')
                .eq('follower_id', currentUser.id)
                .eq('following_id', traderId)
                .single();
            
            if (existingFollow) {
                // Ya lo sigue - dejar de seguir
                const { error } = await supabase
                    .from('user_follows')
                    .delete()
                    .eq('follower_id', currentUser.id)
                    .eq('following_id', traderId);
                
                if (error) {
                    console.error('Error al dejar de seguir:', error);
                    showMessage('Error al dejar de seguir', 'error');
                    return;
                }
                
                // Actualizar botón a "Seguir"
                buttonElement.innerHTML = '<i class="fas fa-user-plus" style="margin-right: 8px; font-size: 12px;"></i><span>Seguir</span>';
                buttonElement.style.background = 'linear-gradient(135deg, #39ff14, #28e000)';
                buttonElement.style.color = '#000';
                buttonElement.style.border = 'none';
                buttonElement.style.boxShadow = '0 3px 10px rgba(57, 255, 20, 0.4)';
                showMessage(`Dejaste de seguir a ${traderName}`, 'success');
                
                // Actualizar pestaña Siguiendo si está visible
                const followingTab = document.getElementById('social-content-following');
                if (followingTab && followingTab.classList.contains('active')) {
                    loadFollowingTab();
                }
            } else {
                // No lo sigue - seguir
                const { error } = await supabase
                    .from('user_follows')
                    .insert({
                        follower_id: currentUser.id,
                        following_id: traderId
                    });
                
                if (error) {
                    console.error('Error al seguir:', error);
                    showMessage('Error al seguir al trader', 'error');
                    return;
                }
                
                // Actualizar botón a "Siguiendo"
                buttonElement.innerHTML = '<i class="fas fa-check" style="margin-right: 8px; font-size: 12px;"></i><span>Siguiendo</span>';
                buttonElement.style.background = 'rgba(255, 255, 255, 0.08)';
                buttonElement.style.color = '#39ff14';
                buttonElement.style.border = '2px solid #39ff14';
                buttonElement.style.boxShadow = '0 3px 10px rgba(57, 255, 20, 0.25)';
                showMessage(`Ahora sigues a ${traderName}`, 'success');
                
                // Actualizar pestaña Siguiendo si está visible
                const followingTab = document.getElementById('social-content-following');
                if (followingTab && followingTab.classList.contains('active')) {
                    loadFollowingTab();
                }
            }
        }
        
        // Función para verificar si ya sigue a un trader y actualizar el botón
        async function checkIfFollowingTrader(traderId, rowElement) {
            if (!currentUser) return;
            
            const { data: existingFollow } = await supabase
                .from('user_follows')
                .select('id')
                .eq('follower_id', currentUser.id)
                .eq('following_id', traderId)
                .single();
            
            if (existingFollow) {
                // Ya lo sigue - actualizar botón a "Siguiendo"
                const button = rowElement.querySelector('.follow-trader-btn');
                if (button) {
                    button.innerHTML = '<i class="fas fa-check" style="margin-right: 8px; font-size: 12px;"></i><span>Siguiendo</span>';
                    button.style.background = 'rgba(255, 255, 255, 0.08)';
                    button.style.color = '#39ff14';
                    button.style.border = '2px solid #39ff14';
                    button.style.boxShadow = '0 3px 10px rgba(57, 255, 20, 0.25)';
                }
            }
        }
        
        // Cargar pestaña "Siguiendo" con traders que el usuario sigue
        async function loadFollowingTab() {
            console.log('👥 Cargando pestaña Siguiendo...');
            
            if (!currentUser) {
                console.log('⚠️ Usuario no autenticado');
                return;
            }
            
            const followingList = document.getElementById('following-list');
            const followingCount = document.getElementById('following-count');
            
            if (!followingList || !followingCount) {
                console.log('⚠️ Elementos de pestaña Siguiendo no encontrados');
                return;
            }
            
            try {
                // Solo traders reales de Supabase (lógica demo eliminada)
                const { data: follows, error: followsError } = await supabase
                    .from('user_follows')
                    .select('following_id')
                    .eq('follower_id', currentUser.id);
                
                if (followsError) {
                    console.error('❌ Error al cargar traders seguidos:', followsError);
                }
                
                const totalFollowing = follows?.length || 0;
                
                if (totalFollowing === 0) {
                    // No sigue a nadie
                    followingCount.textContent = '0';
                    followingList.innerHTML = `
                        <div class="text-center py-12 text-text-secondary">
                            <i class="fas fa-user-plus text-4xl mb-3 opacity-50"></i>
                            <p class="text-sm">No sigues a ningún trader aún</p>
                            <p class="text-xs mt-2">Ve al Ranking y sigue a traders interesantes</p>
                        </div>
                    `;
                    return;
                }
                
                followingCount.textContent = totalFollowing;
                
                // Obtener información de traders reales seguidos
                const followingIds = follows.map(f => f.following_id);
                const { data: realTraders, error: tradersError } = await supabase
                    .from('user_settings')
                    .select('user_id, username, country, avatar_url')
                    .in('user_id', followingIds);
                
                if (tradersError) {
                    console.error('❌ Error al cargar información de traders:', tradersError);
                    return;
                }
                
                // Solo traders reales
                const allFollowedTraders = realTraders || [];
                
                // Renderizar lista de traders seguidos
                followingList.innerHTML = '';
                
                for (const trader of allFollowedTraders) {
                    const traderCard = document.createElement('div');
                    traderCard.style.cssText = `
                        display: flex;
                        align-items: center;
                        justify-content: space-between;
                        padding: 16px;
                        background: rgba(255, 255, 255, 0.03);
                        border-radius: 12px;
                        border: 1px solid rgba(57, 255, 20, 0.1);
                        transition: all 0.3s ease;
                        cursor: pointer;
                    `;
                    
                    // Hover effects
                    traderCard.onmouseenter = function() {
                        this.style.background = 'rgba(255, 255, 255, 0.05)';
                        this.style.borderColor = 'rgba(57, 255, 20, 0.3)';
                        this.style.transform = 'translateY(-2px)';
                        this.style.boxShadow = '0 4px 12px rgba(57, 255, 20, 0.15)';
                    };
                    traderCard.onmouseleave = function() {
                        this.style.background = 'rgba(255, 255, 255, 0.03)';
                        this.style.borderColor = 'rgba(57, 255, 20, 0.1)';
                        this.style.transform = 'translateY(0)';
                        this.style.boxShadow = 'none';
                    };
                    
                    // Avatar
                    let avatarContent = '';
                    if (trader.avatar_url) {
                        avatarContent = `<img src="${trader.avatar_url}" alt="${trader.username}" style="width: 100%; height: 100%; object-fit: cover; border-radius: 50%;">`;
                    } else {
                        avatarContent = getInitials(trader.username);
                    }
                    
                    traderCard.innerHTML = `
                        <div style="display: flex; align-items: center; gap: 16px; flex: 1;" onclick="handleTraderProfileClickFromFollowing('${trader.user_id}')">
                            <div style="
                                width: 48px;
                                height: 48px;
                                border-radius: 50%;
                                background: linear-gradient(135deg, #39ff14, #28e000);
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                font-weight: 700;
                                font-size: 18px;
                                color: #000;
                                box-shadow: 0 2px 8px rgba(57, 255, 20, 0.3);
                            ">
                                ${avatarContent}
                            </div>
                            <div style="flex: 1;">
                                <div style="font-weight: 700; font-size: 16px; margin-bottom: 4px; color: #fff;">
                                    ${trader.username}
                                </div>
                                <div style="font-size: 12px; color: #888; display: flex; align-items: center; gap: 6px;">
                                    <span>${getFlagEmoji(trader.country)}</span>
                                    <span>${trader.country || 'Global'}</span>
                                    <span style="margin-left: 8px; color: #39ff14;">
                                        <i class="fas fa-check-circle" style="font-size: 11px;"></i>
                                        Siguiendo
                                    </span>
                                </div>
                            </div>
                        </div>
                        <button 
                            style="
                                padding: 8px 16px;
                                background: transparent;
                                color: #ef4444;
                                border: 2px solid #ef4444;
                                border-radius: 8px;
                                font-size: 12px;
                                font-weight: 600;
                                cursor: pointer;
                                transition: all 0.3s ease;
                                white-space: nowrap;
                            "
                            onmouseover="this.style.background='#ef4444'; this.style.color='#fff';"
                            onmouseout="this.style.background='transparent'; this.style.color='#ef4444';"
                            onclick="event.stopPropagation(); unfollowTrader('${trader.user_id}', '${trader.username}');"
                        >
                            <i class="fas fa-user-minus" style="margin-right: 6px;"></i>
                            Dejar de seguir
                        </button>
                    `;
                    
                    followingList.appendChild(traderCard);
                }
                
                console.log(`✅ ${allFollowedTraders.length} traders seguidos cargados`);
                
            } catch (error) {
                console.error('❌ Error en loadFollowingTab:', error);
            }
        }
        
        // Dejar de seguir a un trader desde la pestaña Siguiendo
        async function unfollowTrader(traderId, traderName) {
            if (!currentUser) return;
            
            // Solo traders reales (lógica demo eliminada)
            const { error } = await supabase
                .from('user_follows')
                .delete()
                .eq('follower_id', currentUser.id)
                .eq('following_id', traderId);
            
            if (error) {
                console.error('Error al dejar de seguir:', error);
                showMessage('Error al dejar de seguir', 'error');
                return;
            }
            
            showMessage(`Dejaste de seguir a ${traderName}`, 'success');
            
            // Recargar pestaña Siguiendo
            loadFollowingTab();
        }
        
        // Ver perfil de trader desde pestaña Siguiendo
        function handleTraderProfileClickFromFollowing(traderId) {
            // Encontrar trader en la lista de traders públicos
            const trader = publicTraders.find(t => t.user_id === traderId);
            if (trader) {
                handleTraderProfileClick(trader);
            } else {
                // Si no está en publicTraders, cargar desde base de datos
                loadAndShowTraderProfile(traderId);
            }
        }
        
        // Cargar y mostrar perfil de un trader específico
        async function loadAndShowTraderProfile(traderId) {
            try {
                const { data: userSettings, error: userError } = await supabase
                    .from('user_settings')
                    .select('*')
                    .eq('user_id', traderId)
                    .single();
                
                if (userError || !userSettings) {
                    showMessage('Error al cargar perfil del trader', 'error');
                    return;
                }
                
                // Cargar operaciones del trader
                const { data: operations, error: opsError } = await supabase
                    .from('operations')
                    .select('*')
                    .eq('user_id', traderId);
                
                if (opsError) {
                    showMessage('Error al cargar operaciones del trader', 'error');
                    return;
                }
                
                // Calcular estadísticas
                const stats = calculateTraderStats(operations || []);
                
                const trader = {
                    ...userSettings,
                    ...stats,
                    totalTrades: operations ? operations.length : 0
                };
                
                handleTraderProfileClick(trader);
                
            } catch (error) {
                console.error('Error al cargar perfil:', error);
                showMessage('Error al cargar perfil del trader', 'error');
            }
        }

        // Manejar click en perfil de trader
        async function handleTraderProfileClick(trader) {
            console.log('👤 Ver perfil de:', trader.username);
            
            // Solo traders reales (lógica demo eliminada)
            // Cambiar a la sección de Audición
            showSection('audicion');
            
            // Cargar datos de audición del trader seleccionado
            try {
                const { data: operations, error } = await supabase
                    .from('operations')
                    .select('*')
                    .eq('user_id', trader.user_id)
                    .order('date', { ascending: false });
                
                if (error) {
                    console.error('❌ Error al cargar operaciones del trader:', error);
                    showNotification('Error al cargar datos del trader', 'error');
                    return;
                }
                
                console.log(`✅ ${operations.length} operaciones cargadas para ${trader.username}`);
                
                // Actualizar título de audición
                const audicionTitle = document.querySelector('#audicion h1');
                if (audicionTitle) {
                    audicionTitle.innerHTML = `Audición Pública - ${trader.username} ${getFlagEmoji(trader.country)}`;
                }
                
                // Actualizar métricas de audición con datos del trader
                if (typeof updateAudicionMetrics === 'function') {
                    const stats = calculateTraderStats(operations);
                    updateAudicionMetrics({
                        totalTrades: operations.length,
                        winRate: stats.avgWinRate,
                        totalProfit: stats.totalProfit,
                        avgWin: stats.avgProfit,
                        winningDays: stats.winningTrades,
                        losingDays: stats.losingTrades
                    });
                }
                
                // Actualizar gráfico con operaciones del trader
                if (typeof updateAudicionWeeklyChartFromOps === 'function') {
                    updateAudicionWeeklyChartFromOps(operations);
                }
                
                showNotification(`Viendo audición de ${trader.username}`, 'success');
                
            } catch (error) {
                console.error('❌ Error en handleTraderProfileClick:', error);
                showNotification('Error al cargar perfil del trader', 'error');
            }
        }

        // Guardar configuración de perfil público del usuario
        async function saveUserPublicSettings() {
            console.log('💾 Guardando configuración de perfil público...');
            
            try {
                const countrySelect = document.getElementById('config-user-country');
                const publicToggle = document.getElementById('config-public-profile');
                
                if (!countrySelect || !publicToggle) {
                    console.error('❌ No se encontraron los campos de configuración');
                    return;
                }
                
                const country = countrySelect.value;
                const isPublic = publicToggle.checked;
                
                const { data: { user } } = await supabase.auth.getUser();
                if (!user) {
                    console.error('❌ No hay usuario autenticado');
                    return;
                }
                
                // Obtener o crear username
                let username = document.getElementById('config-username')?.value || user.email.split('@')[0];
                
                // Actualizar en Supabase
                const { data, error } = await supabase
                    .from('user_settings')
                    .upsert({
                        user_id: user.id,
                        username: username,
                        country: country,
                        is_public: isPublic,
                        updated_at: new Date().toISOString()
                    }, {
                        onConflict: 'user_id'
                    });
                
                if (error) {
                    console.error('❌ Error al guardar configuración:', error);
                    showNotification('Error al guardar configuración', 'error');
                    return;
                }
                
                console.log('✅ Configuración de perfil guardada correctamente');
                
                // Actualizar header del usuario
                updateUserHeader();
                
                // Si el usuario activó el perfil público, recargar leaderboard
                if (isPublic) {
                    setTimeout(() => {
                        if (typeof loadPublicTraders === 'function') {
                            loadPublicTraders();
                        }
                    }, 500);
                }
                
            } catch (error) {
                console.error('❌ Error en saveUserPublicSettings:', error);
                showNotification('Error al guardar configuración', 'error');
            }
        }

        // Cargar configuración de perfil público al abrir configuración
        async function loadUserPublicSettings() {
            // Evitar múltiples cargas
            if (settingsLoaded) {
                console.log('⏭️ Configuración ya cargada, saltando...');
                return;
            }
            
            console.log('📂 Cargando configuración de perfil público...');
            
            try {
                const { data: { user } } = await supabase.auth.getUser();
                if (!user) return;
                
                const { data: settings, error } = await supabase
                    .from('user_settings')
                    .select('username, profile_image, country, is_public')
                    .eq('user_id', user.id)
                    .single();
                
                if (error && error.code !== 'PGRST116') { // PGRST116 = no rows
                    console.error('❌ Error al cargar configuración:', error);
                    return;
                }
                
                if (settings) {
                    // Cargar nombre de usuario
                    if (settings.username) {
                        const usernameInput = document.getElementById('config-username');
                        if (usernameInput) {
                            usernameInput.value = settings.username;
                        }
                        localStorage.setItem('username', settings.username);
                        console.log('✅ Username cargado desde Supabase:', settings.username);
                    }
                    
                    // Cargar foto de perfil
                    if (settings.profile_image) {
                        const preview = document.getElementById('config-profile-preview');
                        const configAvatar = document.getElementById('config-user-avatar');
                        const removeBtn = document.getElementById('config-remove-profile-image');
                        
                        if (preview) {
                            preview.innerHTML = `<img src="${settings.profile_image}" alt="Profile" class="w-full h-full object-cover">`;
                        }
                        if (configAvatar) {
                            configAvatar.innerHTML = `<img src="${settings.profile_image}" alt="Profile" class="w-full h-full object-cover rounded-full">`;
                        }
                        if (removeBtn) {
                            removeBtn.style.display = 'block';
                        }
                        
                        localStorage.setItem('profile-image', settings.profile_image);
                        console.log('✅ Foto de perfil cargada desde Supabase');
                        
                        // Actualizar header del usuario
                        updateUserHeader();
                    }
                    
                    const countrySelect = document.getElementById('config-user-country');
                    const publicToggle = document.getElementById('config-public-profile');
                    const publicLabel = document.getElementById('config-public-profile-label');
                    
                    if (countrySelect && settings.country) {
                        countrySelect.value = settings.country;
                    }
                    
                    if (publicToggle) {
                        publicToggle.checked = settings.is_public || false;
                        
                        // Actualizar label del toggle
                        if (publicLabel) {
                            if (settings.is_public) {
                                publicLabel.textContent = 'Perfil Público';
                                publicLabel.style.color = '#10B981';
                            } else {
                                publicLabel.textContent = 'Perfil Privado';
                                publicLabel.style.color = '#6B7280';
                            }
                        }
                    }
                    
                    settingsLoaded = true; // Marcar como cargado
                    console.log('✅ Configuración de perfil cargada');
                }
                
            } catch (error) {
                console.error('❌ Error en loadUserPublicSettings:', error);
            }
        }
        // ===== END SOCIAL MEDIA SECTION =====

        // ===== FUNCIÓN PARA INICIALIZAR PLATAFORMAS =====
        function initPlatforms() {
            console.log('🚀 Iniciando initPlatforms...');
            
            // Event listeners para las tarjetas de plataformas
            const platformCards = document.querySelectorAll('.platform-card:not(.disabled)');
            console.log('📱 Tarjetas encontradas:', platformCards.length);
            
            platformCards.forEach(card => {
                const platform = card.dataset.platform;
                console.log('🔗 Agregando listener a:', platform);
                
                card.addEventListener('click', function() {
                    console.log('🎯 Click en plataforma:', platform);
                    
                    // Mostrar la sección específica de cada plataforma
                    if (platform === 'bingx') {
                        showSection('platform-bingx');
                        // Cargar credenciales de BingX
                        if (typeof loadBingXCredentials === 'function') {
                            loadBingXCredentials();
                            loadBingXCredentialsInDetail();
                        }
                        if (typeof populateBingXAccounts === 'function') {
                            populateBingXAccounts();
                        }
                    } else if (platform === 'bitget') {
                        showSection('platform-bitget');
                        console.log('🎯 Abriendo sección Bitget - recargando credenciales');
                        
                        // Cargar credenciales de Bitget usando acceso global
                        if (typeof window.loadBitgetCredentials === 'function') {
                            window.loadBitgetCredentials()
                                .then(() => {
                                    if (typeof window.populateBitgetAccountSelect === 'function') {
                                        window.populateBitgetAccountSelect();
                                    }
                                })
                                .catch((error) => {
                                    console.error('❌ Error en loadBitgetCredentials:', error);
                                });
                            
                            // Recarga adicional con delay para asegurar que los campos estén listos
                            setTimeout(async () => {
                                try {
                                    await window.loadBitgetCredentials();
                                    if (typeof window.populateBitgetAccountSelect === 'function') {
                                        window.populateBitgetAccountSelect();
                                    }
                                } catch (error) {
                                    console.error('❌ Error en recarga:', error);
                                }
                            }, 500);
                        }
                    } else if (platform === 'mexc') {
                        showSection('platform-mexc');
                        console.log('🎯 Abriendo sección MEXC');
                        // Cargar credenciales de MEXC
                        if (typeof loadMEXCCredentials === 'function') {
                            loadMEXCCredentials().catch(err => {
                                console.error('Error cargando credenciales MEXC:', err);
                            });
                        }
                        if (typeof populateMEXCAccountSelect === 'function') {
                            populateMEXCAccountSelect();
                        }
                    } else if (platform === 'bitunix') {
                        showSection('platform-bitunix');
                        console.log('🎯 Abriendo sección Bitunix');
                        if (typeof loadBitunixCredentials === 'function') {
                            loadBitunixCredentials().catch(err => {
                                console.error('Error cargando credenciales Bitunix:', err);
                            });
                        }
                        // Poblar selector de cuentas con delay para asegurar que DB esté listo
                        setTimeout(() => {
                            if (typeof populateBitunixAccountSelect === 'function') {
                                populateBitunixAccountSelect();
                            }
                        }, 100);
                    } else if (platform === 'lbank') {
                        showSection('platform-lbank');
                        console.log('🎯 Abriendo sección LBank');
                        if (typeof loadLBankCredentials === 'function') {
                            loadLBankCredentials().catch(err => {
                                console.error('Error cargando credenciales LBank:', err);
                            });
                        }
                        // Poblar selector de cuentas con delay para asegurar que DB esté listo
                        setTimeout(() => {
                            if (typeof populateLBankAccountSelect === 'function') {
                                populateLBankAccountSelect();
                            }
                        }, 100);
                    } else if (platform === 'blofin') {
                        showSection('platform-blofin');
                        console.log('🎯 Abriendo sección BloFin');
                        if (typeof loadBloFinCredentials === 'function') {
                            loadBloFinCredentials().catch(err => {
                                console.error('Error cargando credenciales BloFin:', err);
                            });
                        }
                        // Poblar selector de cuentas con delay para asegurar que DB esté listo
                        setTimeout(() => {
                            if (typeof populateBloFinAccountSelect === 'function') {
                                populateBloFinAccountSelect();
                            }
                        }, 100);
                    } else if (platform === 'tradingview') {
                        showSection('platform-tradingview');
                    } else if (platform === 'ninjatrader') {
                        showSection('platform-ninjatrader');
                    } else if (platform === 'tradovate') {
                        showSection('platform-tradovate');
                    } else if (platform === 'ctrader') {
                        showSyncNotification('✅ cTrader: Usa el botón HTML para importar operaciones', 'info');
                    } else if (platform === 'primexbtcrypto') {
                        showSyncNotification('PrimeXBT Crypto: Usa los botones CSV o Interfaz para importar operaciones', 'info');
                    } else if (platform === 'primexbtcfds') {
                        showSyncNotification('PrimeXBT CFDs: Usa el botón CSV para importar operaciones', 'info');
                    } else if (platform === 'metatrader5') {
                        showSyncNotification('MetaTrader 5: Usa el botón HTML para importar operaciones', 'info');
                    } else {
                        showSyncNotification('Esta plataforma estará disponible próximamente', 'info');
                    }
                });
            });

            console.log('✅ initPlatforms completado');
            
            // Inicializar botones CSV de las plataformas
            initCSVButtons();
            
            // Inicializar tabs de plataformas
            if (typeof window.initPlatformTabs === 'function') {
                console.log('✅ Llamando a window.initPlatformTabs desde initPlatforms');
                window.initPlatformTabs();
            }

            // Botón de regreso a plataformas (funciona para todas las plataformas)
            const backButtons = document.querySelectorAll('[id^="back-to-platforms"]');
            backButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    showSection('platforms');
                });
            });
        }

        // ===== FUNCIÓN PARA INICIALIZAR BOTONES CSV =====
        function initCSVButtons() {
            console.log('📄 Inicializando botones CSV...');
            
            // BingX CSV
            const bingxCsvBtn = document.getElementById('bingx-import-csv');
            if (bingxCsvBtn) {
                bingxCsvBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = '.csv';
                    input.click();
                    input.onchange = (e) => {
                        const file = e.target.files[0];
                        if (file && typeof processBingXCSV === 'function') {
                            const reader = new FileReader();
                            reader.onload = (ev) => processBingXCSV(ev.target.result);
                            reader.readAsText(file);
                        }
                    };
                });
                console.log('✅ BingX CSV');
            }
            
            // Bitget CSV
            const bitgetCsvBtn = document.getElementById('bitget-import-csv');
            if (bitgetCsvBtn) {
                bitgetCsvBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = '.csv';
                    input.click();
                    input.onchange = (e) => {
                        const file = e.target.files[0];
                        if (file && typeof processBitgetCSV === 'function') {
                            const reader = new FileReader();
                            reader.onload = (ev) => processBitgetCSV(ev.target.result);
                            reader.readAsText(file);
                        }
                    };
                });
                console.log('✅ Bitget CSV');
            }
            
            // MEXC CSV
            const mexcCsvBtn = document.getElementById('mexc-import-csv');
            if (mexcCsvBtn) {
                mexcCsvBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = '.csv';
                    input.click();
                    input.onchange = (e) => {
                        const file = e.target.files[0];
                        if (file && typeof processMEXCCSV === 'function') {
                            const reader = new FileReader();
                            reader.onload = (ev) => processMEXCCSV(ev.target.result);
                            reader.readAsText(file);
                        }
                    };
                });
                console.log('✅ MEXC CSV');
            }
            
            // PrimeXBT Crypto CSV
            const primexbtCryptoBtn = document.getElementById('primexbt-crypto-import-csv');
            if (primexbtCryptoBtn) {
                primexbtCryptoBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = '.csv';
                    input.click();
                    input.onchange = (e) => {
                        const file = e.target.files[0];
                        if (file && typeof processPrimeXBTCSV === 'function') {
                            const reader = new FileReader();
                            reader.onload = (ev) => processPrimeXBTCSV(ev.target.result);
                            reader.readAsText(file);
                        }
                    };
                });
                console.log('✅ PrimeXBT Crypto CSV');
            }
            
            // PrimeXBT Crypto Interfaz
            const primexbtCryptoInterfaceBtn = document.getElementById('primexbt-crypto-import-interface');
            if (primexbtCryptoInterfaceBtn) {
                primexbtCryptoInterfaceBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    console.log('🎯 Click en botón Interfaz PrimeXBT Crypto');
                    // Abrir modal directamente
                    const modal = document.getElementById('primexbt-interface-import-modal');
                    const accountSelect = document.getElementById('primexbt-interface-account');
                    const dataTextarea = document.getElementById('primexbt-interface-data');
                    const statusDiv = document.getElementById('primexbt-interface-status');
                    
                    if (modal && accountSelect && dataTextarea && statusDiv) {
                        // Limpiar campos
                        dataTextarea.value = '';
                        statusDiv.textContent = '';
                        statusDiv.className = 'text-sm text-center';
                        
                        // Cargar cuentas de PrimeXBT Crypto
                        accountSelect.innerHTML = '<option value="">Selecciona una cuenta...</option>';
                        const primexbtAccounts = DB.accounts.filter(acc => 
                            acc.platform === 'primexbt-crypto' || acc.platform === 'primexbt'
                        );
                        
                        if (primexbtAccounts.length === 0) {
                            accountSelect.innerHTML += '<option value="" disabled>No hay cuentas de PrimeXBT disponibles</option>';
                        } else {
                            primexbtAccounts.forEach(acc => {
                                const option = document.createElement('option');
                                option.value = acc.id;
                                option.textContent = `${acc.name} (${acc.currency})`;
                                accountSelect.appendChild(option);
                            });
                        }
                        
                        // Mostrar modal
                        modal.classList.remove('hidden');
                        modal.classList.add('flex');
                        console.log('✅ Modal abierto con', primexbtAccounts.length, 'cuentas');
                    } else {
                        console.error('❌ Elementos del modal no encontrados');
                    }
                });
                console.log('✅ PrimeXBT Crypto Interface');
            }
            
            // PrimeXBT CFDs CSV
            const primexbtCfdsBtn = document.getElementById('primexbt-cfds-import-csv');
            if (primexbtCfdsBtn) {
                primexbtCfdsBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = '.csv';
                    input.click();
                    input.onchange = (e) => {
                        const file = e.target.files[0];
                        if (file && typeof processPrimeXBTCFDsCSV === 'function') {
                            const reader = new FileReader();
                            reader.onload = (ev) => processPrimeXBTCFDsCSV(ev.target.result);
                            reader.readAsText(file);
                        }
                    };
                });
                console.log('✅ PrimeXBT CFDs CSV');
            }
            
            // MetaTrader 5 HTML
            const mt5HtmlBtn = document.getElementById('mt5-import-html');
            if (mt5HtmlBtn) {
                mt5HtmlBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = '.html,.htm';
                    input.click();
                    input.onchange = (e) => {
                        const file = e.target.files[0];
                        if (file && typeof processMT5HTMLReport === 'function') {
                            const reader = new FileReader();
                            reader.onload = (ev) => processMT5HTMLReport(ev.target.result);
                            reader.readAsText(file);
                        }
                    };
                });
                console.log('✅ MetaTrader 5 HTML');
            }
            
            // cTrader HTML
            const ctraderHtmlBtn = document.getElementById('ctrader-import-html');
            if (ctraderHtmlBtn) {
                ctraderHtmlBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = '.html,.htm';
                    input.click();
                    input.onchange = (e) => {
                        const file = e.target.files[0];
                        if (file && typeof processCTraderHTML === 'function') {
                            const reader = new FileReader();
                            reader.onload = (ev) => processCTraderHTML(ev.target.result);
                            reader.readAsText(file);
                        }
                    };
                });
                console.log('✅ cTrader HTML');
            }
            
            // ===== BOTONES DENTRO DE LAS SECCIONES DE PLATAFORMAS =====
            
            // BingX CSV (dentro de la sección)
            setTimeout(() => {
                const bingxCsvBtnInside = document.getElementById('bingx-import-csv-btn');
                const bingxCsvInput = document.getElementById('bingx-csv-file-input');
                if (bingxCsvBtnInside && bingxCsvInput) {
                    bingxCsvBtnInside.addEventListener('click', () => {
                        console.log('🎯 Click en botón CSV BingX dentro de sección');
                        bingxCsvInput.click();
                    });
                    bingxCsvInput.addEventListener('change', async (e) => {
                        const file = e.target.files[0];
                        if (!file) return;
                        console.log('📄 Archivo seleccionado:', file.name);
                        const reader = new FileReader();
                        reader.onload = async (ev) => {
                            try {
                                await processBingXCSV(ev.target.result);
                            } catch (error) {
                                console.error('Error:', error);
                                alert('Error procesando CSV: ' + error.message);
                            }
                        };
                        reader.readAsText(file);
                    });
                    console.log('✅ BingX CSV section button');
                }
                
                // Bitget CSV (dentro de la sección)
                const bitgetCsvBtnInside = document.getElementById('bitget-import-csv-btn');
                const bitgetCsvInput = document.getElementById('bitget-csv-file-input');
                if (bitgetCsvBtnInside && bitgetCsvInput) {
                    bitgetCsvBtnInside.addEventListener('click', () => {
                        console.log('🎯 Click en botón CSV Bitget dentro de sección');
                        bitgetCsvInput.click();
                    });
                    bitgetCsvInput.addEventListener('change', async (e) => {
                        const file = e.target.files[0];
                        if (!file) return;
                        console.log('📄 Archivo seleccionado:', file.name);
                        const reader = new FileReader();
                        reader.onload = async (ev) => {
                            try {
                                await processBitgetCSV(ev.target.result);
                            } catch (error) {
                                console.error('Error:', error);
                                alert('Error procesando CSV: ' + error.message);
                            }
                        };
                        reader.readAsText(file);
                    });
                    console.log('✅ Bitget CSV section button');
                }
                
                // MEXC CSV (dentro de la sección)
                const mexcCsvBtnInside = document.getElementById('mexc-import-csv-btn');
                const mexcCsvInput = document.getElementById('mexc-csv-file-input');
                if (mexcCsvBtnInside && mexcCsvInput) {
                    mexcCsvBtnInside.addEventListener('click', () => {
                        console.log('🎯 Click en botón CSV MEXC dentro de sección');
                        mexcCsvInput.click();
                    });
                    mexcCsvInput.addEventListener('change', async (e) => {
                        const file = e.target.files[0];
                        if (!file) return;
                        console.log('📄 Archivo seleccionado:', file.name);
                        const reader = new FileReader();
                        reader.onload = async (ev) => {
                            try {
                                await processMEXCCSV(ev.target.result);
                            } catch (error) {
                                console.error('Error:', error);
                                alert('Error procesando CSV: ' + error.message);
                            }
                        };
                        reader.readAsText(file);
                    });
                    console.log('✅ MEXC CSV section button');
                }
            }, 500);
            
            console.log('✅ Todos los botones CSV listos');
        }

        // ============================================
        // FUNCIONES PARA IMPORTAR DESDE INTERFAZ DE PRIMEXBT
        // ============================================
        
        /**
         * Procesa datos pegados desde la interfaz de PrimeXBT
         * @param {string} rawData - Datos copiados desde la interfaz del broker
         * @param {string} accountId - ID de la cuenta donde se importarán las operaciones
         */
        let isPrimeXBTProcessing = false; // Flag para evitar ejecuciones simultáneas
        let lastPrimeXBTExecution = 0; // Timestamp de última ejecución
        
        window.processPrimeXBTInterfaceData = async function(rawData, accountId) {
            const now = Date.now();
            const executionId = Math.random().toString(36).substr(2, 9);
            console.log(`📄 [${executionId}] Procesando datos desde interfaz de PrimeXBT...`, { 
                timestamp: now, 
                isPrimeXBTProcessing,
                timeSinceLastExec: now - lastPrimeXBTExecution,
                stackTrace: new Error().stack
            });
            
            // Prevenir ejecuciones simultáneas
            if (isPrimeXBTProcessing) {
                console.warn('⚠️ Ya hay un proceso de importación en curso. Por favor espera.');
                showSyncNotification('⚠️ Ya hay una importación en proceso', 'warning');
                return;
            }
            
            // Prevenir doble clic (ejecuciones con menos de 1 segundo de diferencia)
            if (now - lastPrimeXBTExecution < 1000) {
                console.warn('⚠️ Ejecución duplicada detectada (< 1s). Ignorando.', {
                    timeSinceLastExec: now - lastPrimeXBTExecution
                });
                return;
            }
            
            isPrimeXBTProcessing = true;
            lastPrimeXBTExecution = now;
            console.log('🔒 Flag de procesamiento activado', { timestamp: now });
            
            try {
                if (!rawData || !rawData.trim()) {
                    showSyncNotification('❌ No se proporcionaron datos para importar', 'error');
                    return;
                }

                if (!accountId) {
                    showSyncNotification('❌ Debes seleccionar una cuenta destino', 'error');
                    return;
                }

            // Buscar la cuenta seleccionada
            const account = DB.accounts.find(acc => acc.id === accountId);
            if (!account) {
                showSyncNotification('❌ Cuenta no encontrada', 'error');
                return;
            }

            // Primero, procesar el texto para manejar tabulaciones y múltiples valores por línea
            // Separar por tabulaciones y saltos de línea para obtener todos los campos
            const allFields = rawData
                .split(/[\n\t]+/)
                .map(field => field.trim())
                .filter(field => field && field !== '');
            
            console.log('📋 Total de campos detectados:', allFields.length);
            console.log('📋 Primeros 20 campos:', allFields.slice(0, 20));
            
            if (allFields.length < 10) {
                showSyncNotification('❌ Los datos parecen incompletos. Asegúrate de copiar toda la información de las operaciones.', 'error');
                return;
            }

            const rawOperations = [];
            let fieldIndex = 0;
            let operationsCount = 0;
            let skippedOpsCount = 0;

            // Parsear los campos uno por uno
            while (fieldIndex < allFields.length) {
                try {
                    // Verificar si tenemos suficientes campos para una operación completa (mínimo 13)
                    if (fieldIndex + 12 >= allFields.length) {
                        console.warn('⚠️ No hay suficientes campos para completar más operaciones');
                        break;
                    }

                    // Extraer los campos de la operación
                    const operationId = allFields[fieldIndex] || '';
                    const instrument = (allFields[fieldIndex + 1] || '').replace('/', '');
                    const orderType = allFields[fieldIndex + 2] || '';
                    const action = (allFields[fieldIndex + 3] || '').toLowerCase();
                    const status = allFields[fieldIndex + 4] || '';
                    
                    // Limpiar volumen
                    let volumeStr = (allFields[fieldIndex + 5] || '0').trim();
                    volumeStr = volumeStr.replace(/\./g, '');
                    
                    const feesStr = allFields[fieldIndex + 6] || '0';
                    
                    let plStr = allFields[fieldIndex + 7] || '0';
                    let currentFieldOffset = 8;
                    
                    if (plStr === '—' || plStr === '-') {
                        plStr = '0';
                    }
                    
                    // Buscar campos que contengan la fecha
                    let dateFieldIndex = -1;
                    for (let i = fieldIndex + 7; i < Math.min(fieldIndex + 15, allFields.length); i++) {
                        if (allFields[i] && /\d{2}\/\d{2}\/\d{2}/.test(allFields[i])) {
                            dateFieldIndex = i;
                            break;
                        }
                    }
                    
                    if (dateFieldIndex === -1) {
                        console.warn(`⚠️ No se encontró fecha para operación ${operationId}`);
                        skippedOpsCount++;
                        fieldIndex += 10;
                        continue;
                    }
                    
                    const priceStr = (allFields[dateFieldIndex - 1] || '0').replace(',', '.');
                    const dateTimeStr = allFields[dateFieldIndex] || '';

                    // Validar datos mínimos
                    if (!operationId || !instrument || !dateTimeStr) {
                        console.warn(`⚠️ Operación omitida (datos incompletos)`);
                        skippedOpsCount++;
                        fieldIndex += 10;
                        continue;
                    }

                    // Validar estado
                    if (status.toLowerCase() !== 'ejecutado') {
                        console.warn(`⚠️ Operación ${operationId} omitida (estado: ${status})`);
                        skippedOpsCount++;
                        fieldIndex = dateFieldIndex + 1;
                        continue;
                    }

                    // Parsear volumen
                    const volume = parseFloat(volumeStr.replace(',', '.')) || 0;
                    if (volume === 0) {
                        console.warn(`⚠️ Operación ${operationId} omitida (volumen inválido: ${volumeStr})`);
                        skippedOpsCount++;
                        fieldIndex = dateFieldIndex + 1;
                        continue;
                    }

                    // Parsear comisiones
                    const feesMatch = feesStr.match(/[−\-]?([\d,\.]+)/);
                    const fees = feesMatch ? Math.abs(parseFloat(feesMatch[1].replace(',', '.'))) : 0;

                    // Parsear P&L
                    let pl = 0;
                    if (plStr && plStr !== '—' && plStr !== '-') {
                        const plMatch = plStr.match(/([+\-−]?[\d,\.]+)/);
                        if (plMatch) {
                            pl = parseFloat(plMatch[1].replace(',', '.').replace('−', '-'));
                        }
                    }

                    // Parsear fecha y hora
                    const dateTimeParts = dateTimeStr.split(',').map(p => p.trim());
                    const dateParts = dateTimeParts[0].split('/');
                    const timePart = dateTimeParts[1] || '00:00:00';
                    
                    if (!dateParts || dateParts.length < 3) {
                        console.warn(`⚠️ Operación ${operationId} omitida (fecha inválida: ${dateTimeStr})`);
                        skippedOpsCount++;
                        fieldIndex = dateFieldIndex + 1;
                        continue;
                    }
                    
                    const day = (dateParts[0] || '01').toString().padStart(2, '0');
                    const month = (dateParts[1] || '01').toString().padStart(2, '0');
                    const year = '20' + (dateParts[2] || '25').toString();
                    const date = `${year}-${month}-${day}`;

                    // Determinar tipo y precios
                    let type = '';
                    let entry = 0;

                    const executionPrice = parseFloat(priceStr);
                    
                    if (!executionPrice || executionPrice === 0) {
                        console.warn(`⚠️ Operación ${operationId} omitida (precio inválido: ${priceStr})`);
                        skippedOpsCount++;
                        fieldIndex = dateFieldIndex + 1;
                        continue;
                    }

                    if (action.includes('comprar') || action.includes('buy')) {
                        type = 'buy';
                        entry = executionPrice;
                    } else if (action.includes('vender') || action.includes('sell')) {
                        type = 'sell';
                        entry = executionPrice;
                    } else {
                        console.warn(`⚠️ Tipo de operación desconocido: ${action}`);
                        skippedOpsCount++;
                        fieldIndex = dateFieldIndex + 1;
                        continue;
                    }

                    // Crear operación
                    const operation = {
                        accountId: accountId,
                        date: date,
                        entryTime: timePart,
                        exitTime: timePart,
                        instrument: instrument.toUpperCase(),
                        type: type,
                        entry: entry,
                        exit: null,
                        volume: volume,
                        currency: 'USDT',
                        fees: fees,
                        notes: `Importado desde interfaz - ${orderType} - ID: ${operationId}`,
                        imageDatas: [],
                        session: detectTradingSession(timePart) || '',
                        pl: pl,
                        result: pl > 0 ? 'win' : (pl < 0 ? 'loss' : 'breakeven'),
                        manualPL: pl
                    };

                    operation.id = generateUnifiedOperationId(operation, 'primexbt-crypto', operationId, null);

                    if (operation.instrument && operation.type && operation.entry > 0) {
                        rawOperations.push(operation);
                        operationsCount++;
                    } else {
                        console.warn('⚠️ Operación omitida por datos incompletos:', operation);
                        skippedOpsCount++;
                    }

                    fieldIndex = dateFieldIndex + 1;

                } catch (error) {
                    console.error('Error procesando operación:', error);
                    skippedOpsCount++;
                    fieldIndex += 5;
                }
            }
            
            // Asignar IDs secuenciales
            rawOperations.forEach(op => {
                if (!op.id || op.id === '') {
                    op.id = getNextOperationId();
                }
            });

            if (rawOperations.length === 0) {
                showSyncNotification(`❌ No se pudieron procesar operaciones. ${skippedOpsCount} operaciones omitidas.`, 'error');
                return;
            }

            // Ordenar cronológicamente
            rawOperations.sort((a, b) => {
                const timeA = new Date(`${a.date} ${a.entryTime}`).getTime();
                const timeB = new Date(`${b.date} ${b.entryTime}`).getTime();
                return timeA - timeB;
            });

            console.log(`📊 Total operaciones sin procesar: ${rawOperations.length}`);

            // FASE 1: Agrupar ejecuciones múltiples del mismo lado (apertura)
            // Esto maneja casos donde hay 2-3 compras/ventas que son parte de la misma entrada
            const groupedOpenings = [];
            const usedForOpenings = new Set();
            
            for (let i = 0; i < rawOperations.length; i++) {
                if (usedForOpenings.has(i)) continue;
                
                const op1 = rawOperations[i];
                const sameTypeOps = [{ index: i, operation: op1 }];
                
                // Buscar ejecuciones del mismo tipo (mismo lado) cercanas en tiempo
                for (let j = i + 1; j < Math.min(i + 10, rawOperations.length); j++) {
                    if (usedForOpenings.has(j)) continue;
                    
                    const op2 = rawOperations[j];
                    const time1 = new Date(`${op1.date} ${op1.entryTime}`).getTime();
                    const time2 = new Date(`${op2.date} ${op2.entryTime}`).getTime();
                    const timeDiff = Math.abs(time2 - time1) / 1000 / 60; // minutos
                    
                    const sameInstrument = op1.instrument === op2.instrument;
                    const sameType = op1.type === op2.type; // MISMO lado (ambas compras o ambas ventas)
                    const closeInTime = timeDiff <= 5; // Menos de 5 minutos de diferencia
                    
                    if (sameInstrument && sameType && closeInTime) {
                        sameTypeOps.push({ index: j, operation: op2 });
                        console.log(`🔗 Agrupando ejecuciones del mismo lado: ${op1.instrument} ${op1.type} - ${timeDiff.toFixed(1)} min de diferencia`);
                    }
                }
                
                // Si encontramos múltiples ejecuciones del mismo lado, agruparlas
                if (sameTypeOps.length > 1) {
                    // Calcular promedio ponderado del precio de entrada
                    let totalVolume = 0;
                    let weightedPrice = 0;
                    let totalPL = 0;
                    let totalFees = 0;
                    
                    sameTypeOps.forEach(({ operation }) => {
                        totalVolume += operation.volume;
                        weightedPrice += operation.entry * operation.volume;
                        totalPL += operation.pl || 0;
                        totalFees += operation.fees || 0;
                    });
                    
                    const avgEntry = weightedPrice / totalVolume;
                    const firstOp = sameTypeOps[0].operation;
                    const lastOp = sameTypeOps[sameTypeOps.length - 1].operation;
                    
                    // Crear operación agrupada
                    const groupedOp = {
                        ...firstOp,
                        entry: avgEntry,
                        volume: totalVolume,
                        pl: totalPL,
                        fees: totalFees,
                        exitTime: lastOp.entryTime, // Usar el tiempo de la última ejecución
                        notes: `${firstOp.notes} | ${sameTypeOps.length} ejecuciones agrupadas`,
                        isGroupedOpening: true,
                        executionCount: sameTypeOps.length
                    };
                    
                    groupedOpenings.push(groupedOp);
                    sameTypeOps.forEach(({ index }) => usedForOpenings.add(index));
                    
                    console.log(`✅ Apertura agrupada: ${sameTypeOps.length} ejecuciones de ${firstOp.instrument} ${firstOp.type}, Vol total: ${totalVolume.toFixed(2)}, Precio promedio: ${avgEntry.toFixed(2)}`);
                } else {
                    // Operación individual
                    groupedOpenings.push(op1);
                    usedForOpenings.add(i);
                }
            }
            
            console.log(`📊 Operaciones después de agrupar aperturas: ${groupedOpenings.length} (de ${rawOperations.length} originales)`);

            // FASE 2: Buscar cierres para cada apertura agrupada
            const combinedOperations = [];
            const usedIndices = new Set();
            
            for (let i = 0; i < groupedOpenings.length; i++) {
                if (usedIndices.has(i)) continue;
                
                const opening = groupedOpenings[i];
                const relatedClosings = [];
                let totalClosingVolume = 0;
                
                // Buscar cierres OPUESTOS (compra busca venta y viceversa)
                const maxJ = Math.min(i + 20, groupedOpenings.length);
                
                for (let j = i + 1; j < maxJ; j++) {
                    if (usedIndices.has(j)) continue;
                    
                    const op2 = groupedOpenings[j];
                    const sameInstrument = opening.instrument === op2.instrument;
                    const oppositeType = (opening.type === 'buy' && op2.type === 'sell') || 
                                        (opening.type === 'sell' && op2.type === 'buy');
                    
                    if (sameInstrument && oppositeType) {
                        const vol2 = parseFloat(op2.volume) || 0;
                        relatedClosings.push({ index: j, operation: op2 });
                        totalClosingVolume += vol2;
                    }
                }
                
                // Buscar hacia atrás si es necesario
                if (totalClosingVolume < opening.volume * 0.9) {
                    for (let j = i - 1; j >= Math.max(0, i - 20); j--) {
                        if (usedIndices.has(j)) continue;
                        
                        const op2 = groupedOpenings[j];
                        const sameInstrument = opening.instrument === op2.instrument;
                        const oppositeType = (opening.type === 'buy' && op2.type === 'sell') || 
                                            (opening.type === 'sell' && op2.type === 'buy');
                        
                        if (sameInstrument && oppositeType) {
                            relatedClosings.push({ index: j, operation: op2 });
                            totalClosingVolume += parseFloat(op2.volume) || 0;
                        }
                    }
                }
                
                if (relatedClosings.length > 0) {
                    // Tenemos apertura + cierres
                    const isLong = opening.type === 'buy';
                    
                    let totalPL = opening.pl || 0;
                    let totalFees = opening.fees || 0;
                    
                    relatedClosings.forEach(closing => {
                        totalPL += closing.operation.pl || 0;
                        totalFees += closing.operation.fees || 0;
                    });
                    
                    let weightedExitPrice = 0;
                    let totalExitVolume = 0;
                    
                    relatedClosings.forEach(closing => {
                        const closeOp = closing.operation;
                        weightedExitPrice += closeOp.entry * closeOp.volume;
                        totalExitVolume += closeOp.volume;
                    });
                    
                    const avgExitPrice = totalExitVolume > 0 ? weightedExitPrice / totalExitVolume : relatedClosings[0].operation.entry;
                    
                    let lastClosing = relatedClosings[0].operation;
                    let lastClosingTime = new Date(`${lastClosing.date} ${lastClosing.entryTime}`).getTime();
                    
                    relatedClosings.forEach(closing => {
                        const closeTime = new Date(`${closing.operation.date} ${closing.operation.entryTime}`).getTime();
                        if (closeTime > lastClosingTime) {
                            lastClosing = closing.operation;
                            lastClosingTime = closeTime;
                        }
                    });
                    
                    const finalExitPrice = lastClosing.entry;
                    const finalExitTime = lastClosing.entryTime;
                    
                    const partials = relatedClosings.map(closing => ({
                        price: closing.operation.entry,
                        volume: closing.operation.volume,
                        time: closing.operation.entryTime,
                        pl: closing.operation.pl || 0
                    })).sort((a, b) => {
                        const timeA = new Date(`2000-01-01 ${a.time}`).getTime();
                        const timeB = new Date(`2000-01-01 ${b.time}`).getTime();
                        return timeA - timeB;
                    });
                    
                    const operationId = getNextOperationId();
                    
                    const combinedOp = {
                        id: operationId,
                        accountId: opening.accountId,
                        date: opening.date,
                        entryTime: opening.entryTime,
                        exitTime: finalExitTime,
                        instrument: opening.instrument,
                        type: isLong ? 'buy' : 'sell',
                        entry: opening.entry,
                        exit: finalExitPrice,
                        volume: opening.volume,
                        currency: opening.currency,
                        fees: totalFees,
                        notes: `${opening.notes} | ${relatedClosings.length} cierre(s)`,
                        imageDatas: [],
                        session: detectTradingSession(opening.entryTime) || '',
                        pl: totalPL,
                        result: totalPL > 0 ? 'win' : (totalPL < 0 ? 'loss' : 'breakeven'),
                        manualPL: totalPL,
                        partials: partials,
                        hasPartials: true,
                        avgExitPrice: avgExitPrice
                    };
                    
                    combinedOp.id = getNextOperationId();
                    
                    combinedOperations.push(combinedOp);
                    usedIndices.add(i);
                    relatedClosings.forEach(closing => usedIndices.add(closing.index));
                    
                    console.log(`✅ Trade completo: ${opening.instrument} ${opening.type}, ${relatedClosings.length} cierres parciales, P&L: ${totalPL.toFixed(2)}`);
                } else {
                    // Operación sin cierre (apertura sola)
                    opening.id = getNextOperationId();
                    combinedOperations.push(opening);
                    usedIndices.add(i);
                    console.log(`⚠️ Operación sin cierre: ${opening.instrument} ${opening.type}`);
                }
            }

            console.log(`📊 Operaciones finales después de combinar con cierres: ${combinedOperations.length}`);

            // Verificar duplicados (por ID y por datos)
            const newOperations = [];
            for (const op of combinedOperations) {
                // Verificar duplicado por ID
                const isDuplicateById = DB.operations.some(existingOp => existingOp.id === op.id);
                
                // Verificar duplicado por datos
                const isDuplicateByData = DB.operations.some(existingOp => 
                    existingOp.date === op.date &&
                    existingOp.instrument === op.instrument &&
                    existingOp.entryTime === op.entryTime &&
                    existingOp.type === op.type &&
                    Math.abs(existingOp.volume - op.volume) < 0.01
                );
                
                if (!isDuplicateById && !isDuplicateByData) {
                    newOperations.push(op);
                } else {
                    console.log(`⚠️ Operación duplicada omitida: ${op.id} - ${op.instrument} ${op.date}`);
                }
            }
            const importedCount = newOperations.length;

            if (newOperations.length > 0) {
                try {
                    // PRIMERO: Guardar en IndexedDB
                    await dexieDB.operations.bulkAdd(newOperations);
                    console.log(`✅ ${newOperations.length} operaciones guardadas en IndexedDB`);
                    
                    // SEGUNDO: Sincronizar con Supabase
                    if (currentUser) {
                        let successCount = 0;
                        let errorCount = 0;

                        for (const operation of newOperations) {
                            try {
                                await saveOperationToSupabase(operation);
                                successCount++;
                            } catch (error) {
                                console.error('❌ Error sincronizando operación:', operation.id, error);
                                addToSyncQueue(operation, 'operation');
                                errorCount++;
                            }
                        }
                        console.log(`✅ ${successCount} operaciones sincronizadas con Supabase`);
                    }
                    
                    // TERCERO: Añadir a DB.operations EN MEMORIA (solo después de guardar exitosamente)
                    // Verificar nuevamente para evitar duplicados en caso de recargas
                    for (const op of newOperations) {
                        const exists = DB.operations.some(existingOp => existingOp.id === op.id);
                        if (!exists) {
                            DB.operations.push(op);
                        }
                    }
                    console.log(`✅ ${newOperations.length} operaciones procesadas en DB.operations`);

                    updateAccountBalances();
                    refreshAllViews();
                    
                    showSyncNotification(`✅ Se importaron ${importedCount} operaciones desde la interfaz de PrimeXBT. ${skippedOpsCount} omitidas.`, 'success');

                    document.getElementById('primexbt-interface-import-modal').classList.add('hidden');
                    document.getElementById('primexbt-interface-import-modal').classList.remove('flex');
                    document.getElementById('primexbt-interface-data').value = '';

                } catch (error) {
                    console.error('❌ Error guardando operaciones:', error);
                    showSyncNotification('❌ Error guardando operaciones importadas', 'error');
                }
            } else {
                showSyncNotification('ℹ️ No se encontraron operaciones nuevas para importar', 'info');
            }
            
            } finally {
                // Siempre resetear el flag al terminar
                isPrimeXBTProcessing = false;
                console.log('🔓 Flag de procesamiento liberado');
            }
        };
        
        console.log('✅ Función processPrimeXBTInterfaceData cargada y disponible globalmente');

        // Handler para el botón de importar
        let isHandlerExecuting = false; // Segundo nivel de protección
        
        window.handlePrimeXBTInterfaceImport = async function() {
            const now = Date.now();
            console.log('🎯 [v2.0-NETLIFY] handlePrimeXBTInterfaceImport ejecutado', { 
                timestamp: now,
                isHandlerExecuting 
            });
            
            // Protección contra doble ejecución
            if (isHandlerExecuting) {
                console.warn('⚠️ handlePrimeXBTInterfaceImport ya está ejecutándose. Ignorando.');
                return;
            }
            
            isHandlerExecuting = true;
            
            try {
                const accountSelect = document.getElementById('primexbt-interface-account');
                const dataTextarea = document.getElementById('primexbt-interface-data');
                const statusDiv = document.getElementById('primexbt-interface-status');
                const primexbtInterfaceImportBtn = document.getElementById('primexbt-interface-import-btn');
                
                const accountId = accountSelect.value;
                const rawData = dataTextarea.value.trim();
                
                // Validar datos
                if (!accountId) {
                    statusDiv.textContent = '❌ Debes seleccionar una cuenta destino';
                    statusDiv.className = 'text-sm text-center text-red';
                    return;
                }
                
                if (!rawData) {
                    statusDiv.textContent = '❌ Debes pegar los datos de las operaciones';
                    statusDiv.className = 'text-sm text-center text-red';
                    return;
                }
                
                // Prevenir múltiples clics mientras procesa
                if (primexbtInterfaceImportBtn.disabled) {
                    console.log('⚠️ Ya hay una importación en proceso (botón deshabilitado)');
                    return;
                }
                
                // Mostrar indicador de procesamiento
                statusDiv.textContent = '⏳ Procesando operaciones...';
                statusDiv.className = 'text-sm text-center text-yellow';
                primexbtInterfaceImportBtn.disabled = true;
                primexbtInterfaceImportBtn.textContent = 'Procesando...';
                
                try {
                    // Verificar que la función esté disponible
                    if (typeof window.processPrimeXBTInterfaceData !== 'function') {
                        console.error('❌ La función processPrimeXBTInterfaceData NO está definida');
                        throw new Error('Error de carga. Por favor recarga la página (Ctrl+Shift+R).');
                    }
                    
                    console.log('✅ Función encontrada, procesando datos...');
                    await window.processPrimeXBTInterfaceData(rawData, accountId);
                    
                    // Restablecer botón
                    primexbtInterfaceImportBtn.disabled = false;
                    primexbtInterfaceImportBtn.innerHTML = '<i class="fas fa-upload mr-2"></i>Importar Operaciones';
                    
                } catch (error) {
                    console.error('Error al importar:', error);
                    statusDiv.textContent = `❌ Error: ${error.message}`;
                    statusDiv.className = 'text-sm text-center text-red';
                    
                    // Restablecer botón
                    primexbtInterfaceImportBtn.disabled = false;
                    primexbtInterfaceImportBtn.innerHTML = '<i class="fas fa-upload mr-2"></i>Importar Operaciones';
                }
            } finally {
                isHandlerExecuting = false;
                console.log('🔓 handlePrimeXBTInterfaceImport liberado');
            }
        };

        // ============================================
        // FUNCIÓN DE INICIALIZACIÓN DE LA APP
        // ============================================

        /**
         * Recalcula MAE/MFE para todas las operaciones existentes que no los tengan
         */
        async function recalculateMAEMFEForExistingOperations() {
            console.log('📊 Recalculando MAE/MFE para operaciones existentes...');

            let updated = 0;
            for (const operation of DB.operations) {
                // Solo calcular si no tienen MAE/MFE ya definidos
                if (!operation.mae && !operation.mfe && operation.result) {
                    const maemfe = calculateEstimatedMAEMFE(operation);
                    operation.mae = maemfe.mae;
                    operation.mfe = maemfe.mfe;

                    // Actualizar en Dexie también
                    try {
                        await dexieDB.operations.update(operation.id, {
                            mae: maemfe.mae,
                            mfe: maemfe.mfe
                        });
                        updated++;
                    } catch (error) {
                        console.warn(`⚠️ Error actualizando MAE/MFE para operación ${operation.id}:`, error);
                    }
                }
            }

            if (updated > 0) {
                console.log(`✅ MAE/MFE calculados para ${updated} operaciones`);
            } else {
                console.log('ℹ️ Todas las operaciones ya tienen MAE/MFE calculados');
            }
        }

        // Ejecutar corrección de IDs al cargar la página (solo una vez)
        async function initializeApp() {
            // Ya no necesitamos esperar, loadData() ya se ejecutó
            console.log('🚀 Inicializando verificaciones de aplicación...');

            // Función temporal de diagnóstico para verificar datos del 14/10/2025
            const debugDate = '2025-10-14';
            const existingOps = DB.operations.filter(op => op.date === debugDate);
            console.log(`[DEBUG] Operaciones existentes para ${debugDate}:`, existingOps.length);

            if (existingOps.length === 0) {
                console.log(`[DEBUG] No hay operaciones para ${debugDate}. Creando datos de prueba temporales...`);

                // Verificar si hay alguna cuenta disponible
                if (DB.accounts && DB.accounts.length > 0) {
                    const testAccount = DB.accounts[0];

                    // Crear operaciones de prueba para el 14/10/2025
                    const testOperations = [
                        {
                            id: `test-${debugDate}-1`,
                            accountId: testAccount.id,
                            date: debugDate,
                            entryTime: '09:00:00',
                            exitTime: '10:30:00',
                            symbol: 'BTCUSDT',
                            type: 'buy',
                            entryPrice: 65000,
                            exitPrice: 66000,
                            volume: 0.1,
                            pl: 100,
                            currency: 'USDT',
                            fees: 2.5,
                            notes: 'Operación de prueba para diagnóstico'
                        },
                        {
                            id: `test-${debugDate}-2`,
                            accountId: testAccount.id,
                            date: debugDate,
                            entryTime: '14:00:00',
                            exitTime: '15:45:00',
                            symbol: 'ETHUSDT',
                            type: 'sell',
                            entryPrice: 2500,
                            exitPrice: 2450,
                            volume: 2,
                            pl: -100,
                            currency: 'USDT',
                            fees: 1.5,
                            notes: 'Operación de prueba para diagnóstico - pérdida'
                        }
                    ];

                    // Agregar a DB.operations
                    DB.operations.push(...testOperations);
                    console.log(`[DEBUG] Agregadas ${testOperations.length} operaciones de prueba para ${debugDate}`);
                    console.log(`[DEBUG] Total operaciones en DB: ${DB.operations.length}`);

                    // También agregar a Dexie para persistencia temporal
                    if (window.dexieDB && window.dexieDB.operations) {
                        try {
                            await window.dexieDB.operations.bulkAdd(testOperations);
                            console.log(`[DEBUG] Operaciones de prueba guardadas en Dexie`);
                        } catch (error) {
                            console.log(`[DEBUG] Error guardando en Dexie (puede ser normal si ya existen):`, error.message);
                        }
                    }
                } else {
                    console.log(`[DEBUG] No hay cuentas disponibles para crear operaciones de prueba`);
                }
            }

            // Inicialización segura de funciones
            console.log('🚀 Inicializando aplicación...');

            // Verificar que todas las funciones críticas estén definidas
            const criticalFunctions = ['updateAuthStatus', 'updateLast7DaysCalendar', 'updateRecentOperationsList'];
            criticalFunctions.forEach(funcName => {
                if (typeof window[funcName] !== 'function') {
                    console.warn(`⚠️ Función ${funcName} no está definida`);
                } else {
                    console.log(`✅ Función ${funcName} está lista`);
                }
            });

            // Inicializar Equity Graph DESPUÉS de que DB esté listo
            console.log('🔄 Inicializando Equity Graph con DB listo...');
            if (typeof populateEquityFilters === 'function') {
                populateEquityFilters();
            }
            if (typeof initEquityMultiSelect === 'function') {
                initEquityMultiSelect();
            }
            if (typeof initEquityFiltersListeners === 'function') {
                initEquityFiltersListeners();
            }
            console.log('✅ Equity Graph inicializado');

            // Calcular MAE/MFE para operaciones existentes
            await recalculateMAEMFEForExistingOperations();

            console.log('✅ Aplicación inicializada correctamente');
        }

        // Inicializar modal y event listeners
        document.addEventListener('DOMContentLoaded', async () => {
            // Inicializar sidebar
            initSidebar();
            
            // Inicializar navegación de configuración
            initConfigNavigation();
            
            console.log('🎬 DOMContentLoaded - Iniciando secuencia de carga...');
            await loadData();
            console.log('🎬 DOMContentLoaded - loadData() completado, llamando initializeApp()...');
            await initializeApp(); // Llamar después de cargar datos
            console.log('🎬 DOMContentLoaded - initializeApp() completado, actualizando balances...');
            updateAccountBalances();

            // NO inicializar cuenta global - esperar a que el usuario seleccione
            globalSelectedAccount = '';
            console.log('🎯 Cuenta global inicial: (ninguna seleccionada)');

            initNewDashboard(); // Inicializar nuevo dashboard primero
            initDashboard();
            initAnalytics();
            initInforme();
            initFinances();
            initCalendar();
            initOperations(); // Esto ahora configurará el clic en la fila
            initAccounts();
            await initConfig();
            initPlatforms(); // Ahora está definida en el mismo bloque
            // initPrimeXBTInterfaceModal(); // ELIMINADO - ahora usa onclick directo
            initDateRangeModal();
            initImageModal(); // Mantén esto para el pop-up de imágenes desde la página de detalles
            initMainHeader(); // Inicializar header principal

            const tabs = document.querySelectorAll('nav .nav-tab');
            const sections = document.querySelectorAll('.section-container');
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    const targetId = tab.dataset.target;
                    tabs.forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    showSection(targetId); // Usar showSection para auto-refresh
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                });
            });

            const initialActiveTab = document.querySelector('.nav-tab.active');
            if (initialActiveTab) {
                const initialTargetId = initialActiveTab.dataset.target;
                const initialTargetSection = document.getElementById(initialTargetId);
                if (initialTargetSection) initialTargetSection.classList.add('active');
                refreshAllViews();
            }

            document.getElementById('close-day-modal-icon').addEventListener('click', closeDayDetailModal);
            document.getElementById('close-day-modal-btn').addEventListener('click', closeDayDetailModal);
            document.getElementById('day-detail-modal').addEventListener('click', function (e) {
                if (e.target.id === 'day-detail-modal') closeDayDetailModal();
            });

            const dashboardTimeRangeContainer = document.querySelector('#dashboard .time-range-buttons');
            if (dashboardTimeRangeContainer) {
                dashboardTimeRangeContainer.addEventListener('click', (event) => {
                    if (event.target.classList.contains('time-range-btn')) {
                        dashboardTimeRangeContainer.querySelectorAll('.time-range-btn').forEach(btn => btn.classList.remove('active'));
                        event.target.classList.add('active');
                        refreshDashboard();
                    }
                });
            }

            const accountDetailTimeRangeContainer = document.getElementById('account-detail-time-range');
            if (accountDetailTimeRangeContainer) {
                accountDetailTimeRangeContainer.addEventListener('click', (event) => {
                    if (event.target.classList.contains('time-range-btn')) {
                        accountDetailTimeRangeContainer.querySelectorAll('.time-range-btn').forEach(btn => btn.classList.remove('active'));
                        event.target.classList.add('active');
                        const selectedRange = event.target.dataset.range;
                        const accountId = document.getElementById('selected-account-details').dataset.accountId;
                        if (accountId) {
                            const account = DB.accounts.find(acc => acc.id === accountId);
                            const accountOps = DB.operations.filter(op => op.accountId === accountId);
                            if (account) {
                                updateAccountDetailChart(account, accountOps, selectedRange);
                                updateAccountReduccionAcumuladaChart(accountOps, account, selectedRange);
                                updateAccountPnLAcumuladoChart(accountOps, account, selectedRange);
                            }
                        }
                    }
                });
            }

            // Event listeners para los nuevos gráficos de account details
            document.addEventListener('click', (event) => {
                if (event.target.classList.contains('account-drawdown-range-btn')) {
                    const container = event.target.parentNode;
                    container.querySelectorAll('.account-drawdown-range-btn').forEach(btn => btn.classList.remove('active'));
                    event.target.classList.add('active');
                    const timeRange = event.target.dataset.range;
                    const accountId = document.getElementById('selected-account-details').dataset.accountId;
                    if (accountId) {
                        const account = DB.accounts.find(acc => acc.id === accountId);
                        const accountOps = DB.operations.filter(op => op.accountId === accountId);
                        if (account) updateAccountReduccionAcumuladaChart(accountOps, account, timeRange);
                    }
                }
                
                if (event.target.classList.contains('account-pnl-range-btn')) {
                    const container = event.target.parentNode;
                    container.querySelectorAll('.account-pnl-range-btn').forEach(btn => btn.classList.remove('active'));
                    event.target.classList.add('active');
                    const timeRange = event.target.dataset.range;
                    const accountId = document.getElementById('selected-account-details').dataset.accountId;
                    if (accountId) {
                        const account = DB.accounts.find(acc => acc.id === accountId);
                        const accountOps = DB.operations.filter(op => op.accountId === accountId);
                        if (account) updateAccountPnLAcumuladoChart(accountOps, account, timeRange);
                    }
                }
            });

            document.getElementById('dashboard-account-select').addEventListener('change', (e) => {
                const selectedAccount = e.target.value;
                
                // Sincronizar cuenta seleccionada en Analytics e Informe con logos
                syncAccountSelection(selectedAccount);
                
                if (dashboardTimeRangeContainer) {
                    const rangeButtons = dashboardTimeRangeContainer.querySelectorAll('.time-range-btn');
                    rangeButtons.forEach(btn => btn.classList.remove('active'));
                    const allButton = Array.from(rangeButtons).find(btn => btn.dataset.range === 'ALL');
                    if (allButton) allButton.classList.add('active');
                }
                if (document.getElementById('dashboard-advance').classList.contains('active')) refreshDashboard();
            });
            
            // Event listeners para el NUEVO Dashboard
            const newDashboardAccountSelect = document.getElementById('new-dashboard-account-select');
            if (newDashboardAccountSelect) {
                newDashboardAccountSelect.addEventListener('change', (e) => {
                    const selectedAccount = e.target.value;
                    syncAccountSelection(selectedAccount); // Ya llama a refreshCurrentSection() que ejecuta refreshNewDashboard()
                });
            }
            
            const newDashboardCurrencySelect = document.getElementById('new-dashboard-currency-select');
            if (newDashboardCurrencySelect) {
                newDashboardCurrencySelect.addEventListener('change', () => {
                    if (document.getElementById('dashboard').classList.contains('active')) {
                        refreshNewDashboard();
                    }
                });
            }
            
            const newDashboardFiltersBtn = document.getElementById('new-dashboard-filters-btn');
            if (newDashboardFiltersBtn) {
                newDashboardFiltersBtn.addEventListener('click', () => {
                    // Puedes implementar filtros personalizados aquí
                    console.log('Filtros del nuevo dashboard');
                });
            }
            
            document.getElementById('analytics-account-select').addEventListener('change', (e) => {
                const selectedAccount = e.target.value;
                
                // Sincronizar cuenta seleccionada en Dashboard e Informe con logos
                syncAccountSelection(selectedAccount);
                
                if (document.getElementById('analytics').classList.contains('active')) refreshAnalytics();
            });

            // NOTA: equity-account-select fue eliminado, ahora se usa equity-account-trigger (multi-select)
            // El multi-select ya tiene sus propios event listeners en initEquityMultiSelect()

            const dailyJournalAccountSelect = document.getElementById('daily-journal-account-select');
            if (dailyJournalAccountSelect) {
                dailyJournalAccountSelect.addEventListener('change', (e) => {
                    const selectedAccount = e.target.value;
                    syncAccountSelection(selectedAccount);
                    if (document.getElementById('daily-journal').classList.contains('active') && typeof refreshDailyJournal === 'function') {
                        refreshDailyJournal();
                    }
                });
            }

            // Manejador del botón "Volver a Operaciones"
            // NOTA: Este listener ahora se asigna dentro de showOperationDetailPage()
            // para garantizar que siempre esté disponible
            /*
            const backBtn = document.getElementById('back-to-operations-btn');
            if (backBtn) {
                backBtn.addEventListener('click', () => {
                    console.log('🔙 Volver a Operaciones clicked');
                    // Limpiar el gráfico de TradingView si está activo
                    if (window.hideTradingChart) {
                        window.hideTradingChart();
                    }
                    showSection('operations'); // Activa la sección de operaciones
                    window.scrollTo({ top: 0, behavior: 'smooth' }); // Desplazarse al inicio de la página de operaciones
                });
            } else {
                console.error('❌ Botón back-to-operations-btn no encontrado en el DOM');
            }
            */


            showLoading(false);
        });

        function openDayDetailModal(dateKeyYYYYMMDD, ops, totalPLForDayInBaseCurrency, baseCurrency) {
            const modal = document.getElementById('day-detail-modal');
            if (!modal) {
                console.error('Modal day-detail-modal no encontrado!');
                return;
            }
            document.getElementById('day-modal-title').textContent = `Trades del ${formatDate(dateKeyYYYYMMDD)}`;
            const totalTrades = ops.length;
            const winners = ops.filter(op => op.result === 'win').length;
            const losers = ops.filter(op => op.result === 'loss').length;
            const winRate = (winners + losers) > 0 ? (winners / (winners + losers)) * 100 : 0;
            let totalVolume = ops.reduce((sum, op) => sum + (parseFloat(op.volume) || 0), 0);
            let sumWinPL = 0, sumLossPL = 0;

            // Calcular comisiones totales del día
            let totalFees = ops.reduce((sum, op) => {
                const fee = op.fee || op.fees || 0;
                return sum + convertCurrency(fee, op.currency, baseCurrency);
            }, 0);

            const currencyModeForModal = document.getElementById('calendar-currency-select') ? document.getElementById('calendar-currency-select').value : 'USD';
            let initialBalanceForModalPercent = 0;
            if (currencyModeForModal === '%') {
                const selectedAccount = document.getElementById('calendar-account-select').value;
                if (selectedAccount !== 'all') {
                    const account = DB.accounts.find(a => a.id === selectedAccount);
                    if (account) initialBalanceForModalPercent = convertCurrency(account.initialBalance, account.currency, baseCurrency);
                } else {
                    initialBalanceForModalPercent = DB.accounts.reduce((sum, acc) => sum + convertCurrency(acc.initialBalance, acc.currency, baseCurrency), 0);
                }
            }


            ops.forEach(op => {
                let plConvertedToBase = op.currency !== baseCurrency ? convertCurrency(op.pl, op.currency, baseCurrency) : op.pl;
                if (op.result === 'win') sumWinPL += plConvertedToBase;
                else if (op.result === 'loss') sumLossPL += plConvertedToBase;
            });
            const profitFactor = sumLossPL !== 0 ? Math.abs(sumWinPL / sumLossPL) : (sumWinPL > 0 ? Infinity : 0);

            let totalPLDisplay;
            if (currencyModeForModal === '%') {
                totalPLDisplay = initialBalanceForModalPercent > 0 ? ((totalPLForDayInBaseCurrency / initialBalanceForModalPercent) * 100).toFixed(2) + '%' : '0.00%';
            } else {
                totalPLDisplay = formatCurrency(totalPLForDayInBaseCurrency, baseCurrency, currencyModeForModal);
            }

            document.getElementById('day-total-pl-header').textContent = totalPLDisplay;
            document.getElementById('day-total-trades-header').textContent = totalTrades;
            document.getElementById('day-win-rate-header').textContent = `${winRate.toFixed(1)}%`;
            document.getElementById('day-winners-header').textContent = winners;
            document.getElementById('day-losers-header').textContent = losers;

            // Mostrar comisiones
            let feesDisplay;
            if (currencyModeForModal === '%') {
                feesDisplay = initialBalanceForModalPercent > 0 ? ((totalFees / initialBalanceForModalPercent) * 100).toFixed(2) + '%' : '0.00%';
            } else {
                feesDisplay = formatCurrency(totalFees, baseCurrency, currencyModeForModal);
            }
            document.getElementById('day-fees-header').textContent = feesDisplay;

            // P&L Neto después de comisiones
            const netPL = totalPLForDayInBaseCurrency - totalFees;
            let netPLDisplay;
            if (currencyModeForModal === '%') {
                netPLDisplay = initialBalanceForModalPercent > 0 ? ((netPL / initialBalanceForModalPercent) * 100).toFixed(2) + '%' : '0.00%';
            } else {
                netPLDisplay = formatCurrency(netPL, baseCurrency, currencyModeForModal);
            }
            const netPlEl = document.getElementById('day-net-pl-header');
            netPlEl.textContent = netPLDisplay;
            netPlEl.className = `font-bold ${netPL >= 0 ? 'text-green' : 'text-red'}`;

            document.getElementById('day-volume-header').textContent = totalVolume.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 4 });
            document.getElementById('day-profit-factor-header').textContent = profitFactor === Infinity ? "Inf" : profitFactor.toFixed(2);

            const tbody = document.getElementById('day-modal-table-body'); tbody.innerHTML = '';
            if (ops.length === 0) {
                tbody.innerHTML = `<tr><td colspan="6" class="text-center py-4 text-text-secondary">No hay operaciones para este día.</td></tr>`;
            } else {
                ops.forEach(op => {
                    const tr = document.createElement('tr');
                    tr.dataset.id = op.id; // Añadir data-id a la fila
                    tr.classList.add('cursor-pointer'); // Hacerla clicable

                    let plConvertedToBaseForOp = op.currency !== baseCurrency ? convertCurrency(op.pl, op.currency, baseCurrency) : op.pl;
                    let opPLDisplay;
                    if (currencyModeForModal === '%') {
                        opPLDisplay = initialBalanceForModalPercent > 0 ? ((plConvertedToBaseForOp / initialBalanceForModalPercent) * 100).toFixed(2) + '%' : '0.00%';
                    } else {
                        opPLDisplay = formatCurrency(plConvertedToBaseForOp, baseCurrency, currencyModeForModal);
                    }

                    // Indicador de parciales
                    const partialsIndicator = op.isGrouped ? '<i class="fas fa-expand-alt text-blue-400 ml-1" title="Clic para ver parciales"></i>' : '';

                    // Mostrar ID original del CSV si existe, sino el ID procesado
                    let displayId = op.id;
                    if (op.originalId) {
                        displayId = op.originalId;
                    }
                    // Si el ID contiene el formato de plataforma, extraer solo el ID del CSV
                    const parts = displayId.split('_');
                    if (parts.length >= 2 && /^\d+$/.test(parts[parts.length - 1])) {
                        displayId = parts[parts.length - 1]; // Mostrar solo el ID numérico del CSV
                    }

                    tr.innerHTML = `
                        <td>${displayId || '-'}${partialsIndicator}</td>
                        <td>${op.entryTime || '-'}</td>
                        <td>${op.instrument}</td>
                        <td class="${op.type === 'buy' ? 'text-positive' : 'text-negative'} font-semibold">${op.type === 'buy' ? 'COMPRA' : 'VENTA'}</td>
                        <td class="${plConvertedToBaseForOp >= 0 ? 'text-positive' : 'text-negative'}">${opPLDisplay}</td>
                        <td>${op.exitTime || '-'}</td>`;
                    
                    tbody.appendChild(tr);

                    // Si tiene parciales, agregar filas expandibles (inicialmente ocultas)
                    if (op.isGrouped && op.partials) {
                        op.partials.forEach((partial, index) => {
                            const partialTr = document.createElement('tr');
                            partialTr.classList.add('partial-row', 'hidden', 'bg-surface-light');
                            partialTr.dataset.parentId = op.id;

                            let partialPL = partial.currency !== baseCurrency ? convertCurrency(partial.pl, partial.currency, baseCurrency) : partial.pl;
                            let partialPLDisplay;
                            if (currencyModeForModal === '%') {
                                partialPLDisplay = initialBalanceForModalPercent > 0 ? ((partialPL / initialBalanceForModalPercent) * 100).toFixed(2) + '%' : '0.00%';
                            } else {
                                partialPLDisplay = formatCurrency(partialPL, baseCurrency, currencyModeForModal);
                            }

                            partialTr.innerHTML = `
                                <td class="pl-6 text-text-secondary">└ Parcial ${index + 1}</td>
                                <td>${partial.entryTime || '-'}</td>
                                <td>${partial.instrument || op.instrument}</td>
                                <td class="${(partial.type || op.type) === 'buy' ? 'text-positive' : 'text-negative'} font-semibold">${(partial.type || op.type) === 'buy' ? 'COMPRA' : 'VENTA'}</td>
                                <td class="${partialPL >= 0 ? 'text-positive' : 'text-negative'}">${partialPLDisplay}</td>
                                <td>${partial.time || partial.exitTime || '-'}</td>`;
                            
                            tbody.appendChild(partialTr);
                        });
                    }
                });
                 
                // Listener para las operaciones dentro del modal del calendario
                tbody.querySelectorAll('tr:not(.partial-row)').forEach(row => {
                    row.addEventListener('click', (e) => {
                        const operationId = row.dataset.id;
                        
                        // Si se hizo clic en el icono de expansión
                        const expandIcon = e.target.closest('.fa-expand-alt, .fa-compress-alt');
                        if (expandIcon) {
                            e.preventDefault(); // Prevenir navegación a detalles
                            e.stopPropagation();
                            
                            const partialRows = tbody.querySelectorAll(`tr.partial-row[data-parent-id="${operationId}"]`);
                            const isExpanded = !partialRows[0]?.classList.contains('hidden');
                            
                            partialRows.forEach(partialRow => {
                                if (isExpanded) {
                                    partialRow.classList.add('hidden');
                                } else {
                                    partialRow.classList.remove('hidden');
                                }
                            });
                            
                            // Cambiar icono
                            if (isExpanded) {
                                expandIcon.classList.remove('fa-compress-alt');
                                expandIcon.classList.add('fa-expand-alt');
                                expandIcon.title = 'Clic para ver parciales';
                            } else {
                                expandIcon.classList.remove('fa-expand-alt');
                                expandIcon.classList.add('fa-compress-alt');
                                expandIcon.title = 'Clic para ocultar parciales';
                            }
                            
                            return;
                        }
                        
                        // Navegar a detalles si no se hizo clic en el icono
                        if (operationId) {
                            closeDayDetailModal(); // Cerrar el modal del día
                            showOperationDetailPage(operationId); // Abrir la página de detalles
                        }
                    });
                });
            }
            modal.classList.remove('hidden'); modal.classList.add('flex');
        }
        function closeDayDetailModal() {
            const modal = document.getElementById('day-detail-modal');
            modal.classList.add('hidden'); modal.classList.remove('flex');
        }

        // Nueva función para determinar la sesión de trading basada en la hora de entrada UTC
        function getTradingSession(entryTimeStr) {
            if (!entryTimeStr) return 'No especificado';

            const [hoursStr] = entryTimeStr.split(':');
            const entryHourUTC = parseInt(hoursStr, 10);

            // Horarios aproximados de las principales sesiones de trading en UTC
            // Estas son clasificaciones primarias, los solapamientos se manejan con lógica específica
            // Se asume que las horas de entrada de la operación ya están en UTC o se manejarán como si lo fuera.

            // Sesión Asiática (incluye Tokio, Sídney) - Abarca la noche y madrugada europea/americana
            if (entryHourUTC >= 22 || entryHourUTC < 7) { // 22:00 UTC (noche) hasta 06:59 UTC (mañana)
                return 'Asia';
            }
            // Sesión de Londres (Europa) - Solapa con Asia y Nueva York
            else if (entryHourUTC >= 7 && entryHourUTC < 12) { // 07:00 UTC hasta 11:59 UTC (antes de que abra NY)
                return 'Londres';
            }
            // Sesión de Nueva York (América) - Solapa con Londres
            else if (entryHourUTC >= 12 && entryHourUTC < 17) { // 12:00 UTC hasta 16:59 UTC (solapamiento Londres-NY)
                return 'Nueva York (solapamiento Londres)';
            }
            else if (entryHourUTC >= 17 && entryHourUTC < 21) { // 17:00 UTC hasta 20:59 UTC (solo NY)
                return 'Nueva York';
            }
            // Cualquier otra hora
            return 'Fuera de Sesión Principal / Otro';
        }

        // Nueva función para mostrar las métricas de sesión en la página de detalles
        window.displaySessionMetrics = function(currentOperation) {
            const currentSessionEl = document.getElementById('op-detail-session-current');
            const sessionMetricsTableBody = document.getElementById('op-detail-session-metrics');
            sessionMetricsTableBody.innerHTML = ''; // Limpiar datos anteriores

            const currentTradeSession = getTradingSession(currentOperation.entryTime);
            currentSessionEl.textContent = currentTradeSession;

            // Agrega métricas para TODAS las operaciones basándose en la sesión
            const sessionPerformance = {
                'Asia': { pl: 0, trades: 0, wins: 0, losses: 0, fees: 0 },
                'Londres': { pl: 0, trades: 0, wins: 0, losses: 0, fees: 0 },
                'Nueva York (solapamiento Londres)': { pl: 0, trades: 0, wins: 0, losses: 0, fees: 0 },
                'Nueva York': { pl: 0, trades: 0, wins: 0, losses: 0, fees: 0 },
                'Fuera de Sesión Principal / Otro': { pl: 0, trades: 0, wins: 0, losses: 0, fees: 0 },
                'No especificado': { pl: 0, trades: 0, wins: 0, losses: 0, fees: 0 }
            };

            DB.operations.forEach(op => {
                const session = getTradingSession(op.entryTime); // Usar la sesión derivada de la hora
                let plConverted = op.pl;
                let feeConverted = op.fee || op.fees || 0;
                // Convertir PL y fees a la divisa por defecto para un análisis consistente
                if (op.currency !== DB.settings.defaultCurrency) {
                    plConverted = convertCurrency(op.pl, op.currency, DB.settings.defaultCurrency);
                    feeConverted = convertCurrency(feeConverted, op.currency, DB.settings.defaultCurrency);
                }

                if (!sessionPerformance[session]) { // Asegurarse de que la clave exista si getTradingSession devuelve algo inesperado
                    sessionPerformance[session] = { pl: 0, trades: 0, wins: 0, losses: 0, fees: 0 };
                }
                sessionPerformance[session].pl += plConverted;
                sessionPerformance[session].fees += feeConverted;
                sessionPerformance[session].trades++;
                if (op.result === 'win') sessionPerformance[session].wins++;
                else if (op.result === 'loss') sessionPerformance[session].losses++;
            });

            // Ordenar las sesiones para la tabla (opcional, pero profesional)
            const orderedSessionNames = ['Asia', 'Londres', 'Nueva York (solapamiento Londres)', 'Nueva York', 'Fuera de Sesión Principal / Otro', 'No especificado'].filter(name => sessionPerformance[name].trades > 0);

            // Si hay sesiones con datos pero no están en la lista ordenada, añadirlas al final
            Object.keys(sessionPerformance).forEach(sessionName => {
                if (!orderedSessionNames.includes(sessionName) && sessionPerformance[sessionName].trades > 0) {
                    orderedSessionNames.push(sessionName);
                }
            });

            if (orderedSessionNames.length === 0) {
                sessionMetricsTableBody.innerHTML = '<tr><td colspan="4" class="text-center text-text-secondary py-3">No hay operaciones registradas para análisis de sesión.</td></tr>';
                return;
            }

            // Rellenar la tabla
            orderedSessionNames.forEach(sessionName => {
                const data = sessionPerformance[sessionName];
                const winRate = (data.wins + data.losses) > 0 ? (data.wins / (data.wins + data.losses)) * 100 : 0;
                const plClass = data.pl > 0 ? 'text-positive' : (data.pl < 0 ? 'text-negative' : 'text-neutral');
                const netPl = data.pl - data.fees;
                const netPlClass = netPl > 0 ? 'text-green' : (netPl < 0 ? 'text-red' : 'text-neutral');

                const row = `
                    <tr>
                        <td>${sessionName}</td>
                        <td class="${plClass}">${formatCurrency(data.pl, DB.settings.defaultCurrency, DB.settings.defaultCurrency)}</td>
                        <td class="text-red">${formatCurrency(data.fees, DB.settings.defaultCurrency, DB.settings.defaultCurrency)}</td>
                        <td class="${netPlClass} font-bold">${formatCurrency(netPl, DB.settings.defaultCurrency, DB.settings.defaultCurrency)}</td>
                        <td>${data.trades}</td>
                        <td class="text-green">${winRate.toFixed(1)}%</td>
                    </tr>
                `;
                sessionMetricsTableBody.innerHTML += row;
            });
        }

        // Nueva función para mostrar la página completa de detalles de la operación
        window.showOperationDetailPage = async function(operationId) {
            const operation = DB.operations.find(op => op.id === operationId);
            if (!operation) {
                alert("Operación no encontrada.");
                return;
            }

            const account = DB.accounts.find(acc => acc.id === operation.accountId);
            const precision = getInstrumentPrecision(operation.instrument);

            // Rellenar la nueva sección
            document.getElementById('op-detail-page-title').textContent = `Detalles de la Operación: ${operation.instrument}`;
            document.getElementById('op-detail-id').textContent = operation.id || 'N/A';
            document.getElementById('op-detail-date').textContent = formatDate(operation.date);
            document.getElementById('op-detail-account').textContent = account ? account.name : 'N/A';
            document.getElementById('op-detail-instrument').textContent = operation.instrument;
            document.getElementById('op-detail-type').textContent = operation.type === 'buy' ? 'Compra (Long)' : 'Venta (Short)';
            document.getElementById('op-detail-entry').textContent = operation.entry !== null ? operation.entry.toFixed(precision) : '-';
            document.getElementById('op-detail-exit').textContent = operation.exit !== null ? operation.exit.toFixed(precision) : '-';
            document.getElementById('op-detail-entry-time').textContent = operation.entryTime || '-';
            document.getElementById('op-detail-exit-time').textContent = operation.exitTime || '-';
            document.getElementById('op-detail-volume').textContent = operation.volume;
            document.getElementById('op-detail-currency').textContent = operation.currency;
            document.getElementById('op-detail-manual-pl').textContent = operation.manualPL !== null ? formatCurrency(operation.manualPL, operation.currency, operation.currency) : 'No especificado';

            // Mostrar comisión
            const fee = operation.fees || 0;
            document.getElementById('op-detail-fee').textContent = formatCurrency(fee, operation.currency, operation.currency);

            document.getElementById('op-detail-session').textContent = operation.session || 'N/A'; // Mostrar el campo Sesión
            
            // Mostrar setup usado
            const setupId = operation.setupId || operation.setupUsed;
            const setup = setupId ? DB.setups.find(s => s.id === setupId) : null;
            document.getElementById('op-detail-setup').textContent = setup ? setup.name : 'Ninguno';

            const resultEl = document.getElementById('op-detail-result');
            resultEl.textContent = operation.result === 'win' ? 'Ganancia' : (operation.result === 'loss' ? 'Pérdida' : 'Neutral');
            resultEl.className = `text-xl font-bold ${operation.result === 'win' ? 'text-positive' : (operation.result === 'loss' ? 'text-negative' : 'text-neutral')}`;

            const plEl = document.getElementById('op-detail-pl');
            plEl.textContent = formatCurrency(operation.pl, operation.currency, operation.currency);
            plEl.className = `text-xl font-bold ${operation.pl >= 0 ? 'text-positive' : (operation.pl < 0 ? 'text-negative' : 'text-neutral')}`;

            // P&L Neto después de comisión
            const netPl = operation.pl - fee;
            const netPlEl = document.getElementById('op-detail-net-pl');
            netPlEl.textContent = formatCurrency(netPl, operation.currency, operation.currency);
            netPlEl.className = `text-xl font-bold ${netPl >= 0 ? 'text-green' : 'text-red'}`;

            document.getElementById('op-detail-notes').innerHTML = operation.notes || 'Sin notas.';

            // ===== LAZY LOADING: Cargar imágenes bajo demanda =====
            // Mostrar indicador de carga
            const imagesContainer = document.getElementById('op-detail-images');
            if (imagesContainer) {
                imagesContainer.innerHTML = '<p class=\"text-sm text-text-secondary col-span-3 text-center py-4\"><i class=\"fas fa-spinner fa-spin mr-2\"></i>Cargando imágenes...</p>';
            }
            
            // Cargar imágenes solo si no están ya cargadas
            if (!operation.imageDatas || operation.imageDatas.length === 0) {
                const imageDatas = await window.loadOperationImages(operationId);
                operation.imageDatas = imageDatas;
                
                // Actualizar en DB en memoria
                const opIndex = DB.operations.findIndex(op => op.id === operationId);
                if (opIndex !== -1) {
                    DB.operations[opIndex].imageDatas = imageDatas;
                }
            }
            
            // Mostrar imágenes
            window.updateOperationImagesDisplay(operation);

            // Análisis de Sesión
            window.displaySessionMetrics(operation);

            // Llenar tabla de parciales
            window.displayOperationPartials(operation);

            // Cargar gráfico TradingView avanzado (100% automático)
            setTimeout(() => {
                window.loadTradingViewChart(operation);
            }, 300);

            // Guardar operación para métricas
            currentOperationForMetrics = operation;

            // Inicializar tabs
            window.initOperationDetailTabs();

            // Mostrar la página de detalles y ocultar otras
            showSection('operation-detail-page');
            window.scrollTo({ top: 0, behavior: 'smooth' }); // Desplazarse al inicio de la nueva página
            
            // Asignar event listener al botón "Volver a Operaciones"
            const backBtn = document.getElementById('back-to-operations-btn');
            if (backBtn) {
                // Remover cualquier listener previo usando clonación
                const newBackBtn = backBtn.cloneNode(true);
                backBtn.parentNode.replaceChild(newBackBtn, backBtn);
                
                // Asignar nuevo listener
                newBackBtn.addEventListener('click', () => {
                    console.log('🔙 Volver a Operaciones clicked');
                    // Limpiar el gráfico de TradingView si está activo
                    if (window.hideTradingChart) {
                        window.hideTradingChart();
                    }
                    showSection('operations');
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                });
            }
        }

        // Función para mostrar los parciales de una operación
        window.displayOperationPartials = function(operation) {
            const tbody = document.getElementById('op-detail-partials-table');
            tbody.innerHTML = '';
            
            console.log('🔍 [displayOperationPartials] Operación:', operation);
            console.log('🔍 [displayOperationPartials] Tiene parciales:', operation.hasPartials);
            console.log('🔍 [displayOperationPartials] Parciales:', operation.partials);
            
            // Si la operación tiene parciales guardados (PrimeXBT Interface Import)
            if (operation.hasPartials && operation.partials && operation.partials.length > 0) {
                const precision = getInstrumentPrecision(operation.instrument);
                
                // Fila de apertura (Posición Principal)
                const openingTr = document.createElement('tr');
                openingTr.className = 'border-b-2 border-primary bg-surface-light hover:bg-surface';
                openingTr.innerHTML = `
                    <td class="p-3 font-semibold text-blue-400">Posición Principal</td>
                    <td class="p-3 font-semibold">${operation.entryTime || '-'}</td>
                    <td class="p-3 font-semibold">${operation.exitTime || '-'}</td>
                    <td class="p-3 font-semibold">${operation.entry !== null ? operation.entry.toFixed(precision) : '-'}</td>
                    <td class="p-3 font-semibold">${operation.exit !== null ? operation.exit.toFixed(precision) : '-'}</td>
                    <td class="p-3 font-semibold">${operation.volume}</td>
                    <td class="p-3 font-semibold ${operation.pl >= 0 ? 'text-green-400' : 'text-red-400'}">
                        ${formatCurrency(operation.pl, operation.currency, operation.currency)}
                    </td>
                `;
                tbody.appendChild(openingTr);
                
                // Filas de parciales
                operation.partials.forEach((partial, index) => {
                    const partialTr = document.createElement('tr');
                    partialTr.className = 'border-b border-border hover:bg-surface-light';
                    partialTr.innerHTML = `
                        <td class="p-3 text-gray-400">Cierre Parcial ${index + 1}</td>
                        <td class="p-3">-</td>
                        <td class="p-3">${partial.time || '-'}</td>
                        <td class="p-3">${partial.time || '-'}</td>
                        <td class="p-3">${partial.price !== null ? partial.price.toFixed(precision) : '-'}</td>
                        <td class="p-3">${partial.volume}</td>
                        <td class="p-3 ${partial.pl >= 0 ? 'text-green-400' : 'text-red-400'}">
                            ${formatCurrency(partial.pl, operation.currency, operation.currency)}
                        </td>
                    `;
                    tbody.appendChild(partialTr);
                });
                
                // Actualizar los gráficos de Running P&L con la operación principal
                const mainOpWithPartials = {
                    ...operation,
                    pl: operation.pl,
                    entryTime: operation.entryTime,
                    exitTime: operation.exitTime
                };
                window.updateOperationRunningPnLCharts([mainOpWithPartials], operation);
                
                return; // Terminar aquí, no buscar operaciones relacionadas
            }
            
            // Si no tiene parciales guardados, usar el método anterior (búsqueda por csvId, etc.)
            let relatedOperations = [];
            
            // Criterio 1: Mismo csvId (método principal)
            if (operation.csvId) {
                relatedOperations = DB.operations.filter(op => op.csvId === operation.csvId);
            }
            
            // Criterio 2: Buscar por ID base (para operaciones con parciales)
            if (relatedOperations.length <= 1) {
                const baseId = operation.id.toString().split(/[\s,]/)[0]; // Obtener la parte base del ID
                relatedOperations = DB.operations.filter(op => {
                    const opBaseId = op.id.toString().split(/[\s,]/)[0];
                    return opBaseId === baseId;
                });
            }
            
            // Criterio 3: Buscar operaciones que contengan el ID en su descripción o que sean parciales del mismo grupo
            if (relatedOperations.length <= 1) {
                const searchId = operation.id.toString();
                relatedOperations = DB.operations.filter(op => {
                    // Mismo ID base o contiene "Parcial" y mismo instrumento/fecha/cuenta
                    return op.id.toString().includes(searchId) || 
                           searchId.includes(op.id.toString()) ||
                           (op.id.toString().toLowerCase().includes('parcial') && 
                            op.instrument === operation.instrument && 
                            op.date === operation.date && 
                            op.accountId === operation.accountId) ||
                           (operation.id.toString().toLowerCase().includes('parcial') && 
                            operation.instrument === op.instrument && 
                            operation.date === op.date && 
                            operation.accountId === op.accountId);
                });
            }
            
            // Si aún no hay operaciones relacionadas, mostrar solo la operación actual
            if (relatedOperations.length === 0) {
                relatedOperations = [operation];
            }
            
            console.log('🔍 [displayOperationPartials] Operación actual ID:', operation.id);
            console.log('🔍 [displayOperationPartials] Operaciones relacionadas encontradas:', relatedOperations.length);
            console.log('🔍 [displayOperationPartials] IDs encontrados:', relatedOperations.map(op => op.id));
            
            if (relatedOperations.length <= 1) {
                // Solo hay una operación, mostrar como posición principal
                const tr = document.createElement('tr');
                tr.className = 'border-b border-border hover:bg-surface-light';
                
                const precision = getInstrumentPrecision(operation.instrument);
                
                tr.innerHTML = `
                    <td class="p-3 font-semibold text-blue-400">Posición Principal</td>
                    <td class="p-3">${operation.entryTime || '-'}</td>
                    <td class="p-3">${operation.exitTime || '-'}</td>
                    <td class="p-3">${operation.entry !== null ? operation.entry.toFixed(precision) : '-'}</td>
                    <td class="p-3">${operation.exit !== null ? operation.exit.toFixed(precision) : '-'}</td>
                    <td class="p-3">${operation.volume}</td>
                    <td class="p-3 font-semibold ${operation.pl >= 0 ? 'text-green-400' : 'text-red-400'}">
                        ${formatCurrency(operation.pl, operation.currency, operation.currency)}
                    </td>
                `;
                
                tbody.appendChild(tr);
                
                // Actualizar los gráficos de Running P&L con la operación única
                window.updateOperationRunningPnLCharts([operation], operation);
            } else {
                // Hay múltiples operaciones (parciales)
                // Ordenar por hora de entrada
                relatedOperations.sort((a, b) => {
                    const timeA = a.entryTime || '00:00';
                    const timeB = b.entryTime || '00:00';
                    return timeA.localeCompare(timeB);
                });
                
                // Calcular hora de entrada (primera) y hora de salida (última)
                const firstEntryTime = relatedOperations[0].entryTime || '-';
                
                // Para la hora de salida, buscar la hora más tardía entre entryTime y exitTime
                let lastExitTime = '-';
                relatedOperations.forEach(op => {
                    const exitTime = op.exitTime || op.entryTime;
                    if (exitTime && exitTime !== '-') {
                        if (lastExitTime === '-' || exitTime > lastExitTime) {
                            lastExitTime = exitTime;
                        }
                    }
                });
                
                let totalPL = 0;
                let totalVolume = 0;
                const precision = getInstrumentPrecision(operation.instrument);
                
                // Crear fila de resumen (Posición Principal)
                const summaryTr = document.createElement('tr');
                summaryTr.className = 'border-b-2 border-primary bg-surface-light hover:bg-surface';
                
                totalPL = relatedOperations.reduce((sum, op) => sum + (op.pl || 0), 0);
                totalVolume = relatedOperations.reduce((sum, op) => sum + (parseFloat(op.volume) || 0), 0);
                
                // Calcular precios promedio ponderados
                let totalVolumeForEntry = 0, totalVolumeForExit = 0;
                let weightedEntry = 0, weightedExit = 0;
                
                relatedOperations.forEach(op => {
                    if (op.entry !== null) {
                        weightedEntry += op.entry * op.volume;
                        totalVolumeForEntry += op.volume;
                    }
                    if (op.exit !== null) {
                        weightedExit += op.exit * op.volume;
                        totalVolumeForExit += op.volume;
                    }
                });
                
                const avgEntry = totalVolumeForEntry > 0 ? weightedEntry / totalVolumeForEntry : null;
                const avgExit = totalVolumeForExit > 0 ? weightedExit / totalVolumeForExit : null;
                
                summaryTr.innerHTML = `
                    <td class="p-3 font-semibold text-blue-400">Posición Principal</td>
                    <td class="p-3 font-semibold">${firstEntryTime}</td>
                    <td class="p-3 font-semibold">${lastExitTime}</td>
                    <td class="p-3 font-semibold">${avgEntry !== null ? avgEntry.toFixed(precision) : '-'}</td>
                    <td class="p-3 font-semibold">${avgExit !== null ? avgExit.toFixed(precision) : '-'}</td>
                    <td class="p-3 font-semibold">${totalVolume.toFixed(4)}</td>
                    <td class="p-3 font-semibold text-lg ${totalPL >= 0 ? 'text-green-400' : 'text-red-400'}">
                        ${formatCurrency(totalPL, operation.currency, operation.currency)}
                    </td>
                `;
                
                tbody.appendChild(summaryTr);
                
                // Crear filas para cada parcial
                relatedOperations.forEach((op, index) => {
                    const tr = document.createElement('tr');
                    tr.className = 'border-b border-border hover:bg-surface-light';
                    
                    // Detectar si el ID contiene "Parcial" para mostrar el nombre correcto
                    let description = `Parcial ${index + 1}`;
                    if (op.notes && op.notes.includes('Parcial')) {
                        description = op.notes.split(',')[0] || description; // Tomar solo la parte del parcial
                    }
                    
                    tr.innerHTML = `
                        <td class="p-3 text-text-secondary pl-8">↳ ${description}</td>
                        <td class="p-3">${op.entryTime || '-'}</td>
                        <td class="p-3">${op.exitTime || '-'}</td>
                        <td class="p-3">${op.entry !== null ? op.entry.toFixed(precision) : '-'}</td>
                        <td class="p-3">${op.exit !== null ? op.exit.toFixed(precision) : '-'}</td>
                        <td class="p-3">${op.volume}</td>
                        <td class="p-3 font-semibold ${op.pl >= 0 ? 'text-green-400' : 'text-red-400'}">
                            ${formatCurrency(op.pl, op.currency, op.currency)}
                        </td>
                    `;
                    
                    tbody.appendChild(tr);
                });
            }
            
            // Actualizar los gráficos de Running P&L
            window.updateOperationRunningPnLCharts(relatedOperations, operation);
        }

        // Variables globales para los gráficos de Running P&L
        let operationTradePnLChart = null;
        let operationDayPnLChart = null;
        let currentOperationForMetrics = null;

        window.updateOperationRunningPnLCharts = function(relatedOperations, mainOperation) {
            window.updateTradePnLChart(relatedOperations, mainOperation);
            window.updateDayPnLChart(mainOperation);
        }

        // Gráfico 1: TRADE RUNNING P&L (solo esta operación)
        window.updateTradePnLChart = function(relatedOperations, mainOperation) {
            const ctx = document.getElementById('operation-trade-pnl-chart')?.getContext('2d');
            if (!ctx) return;
            
            // Destruir gráfico existente
            if (operationTradePnLChart) {
                operationTradePnLChart.destroy();
            }

            if (!relatedOperations || relatedOperations.length === 0) return;

            // Ordenar operaciones por fecha y hora
            const sortedOps = [...relatedOperations].sort((a, b) => {
                const dateTimeA = new Date(a.date + 'T' + (a.entryTime || '00:00'));
                const dateTimeB = new Date(b.date + 'T' + (b.entryTime || '00:00'));
                return dateTimeA - dateTimeB;
            });

            // Crear datos para el gráfico
            const labels = [];
            const pnlData = [];
            let accumulatedPL = 0;

            // Agregar punto inicial en 0
            labels.push(sortedOps[0].entryTime || 'Inicio');
            pnlData.push(0);

            // Agregar cada operación/parcial
            sortedOps.forEach((op, index) => {
                accumulatedPL += op.pl || 0;
                const timeLabel = op.exitTime || op.entryTime || `Op ${index + 1}`;
                labels.push(timeLabel);
                pnlData.push(accumulatedPL);
            });

            const finalPL = accumulatedPL;
            const isProfit = finalPL >= 0;
            
            // Colores de la plataforma - Verde fluorescente o Rojo
            const lineColor = isProfit ? '#39ff14' : '#ff4136';
            const fillColor = isProfit ? 'rgba(57, 255, 20, 0.15)' : 'rgba(255, 65, 54, 0.15)';

            operationTradePnLChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'P&L',
                        data: pnlData,
                        borderColor: lineColor,
                        backgroundColor: fillColor,
                        borderWidth: 2,
                        fill: true,
                        tension: 0.3,
                        pointRadius: 5,
                        pointHoverRadius: 7,
                        pointBackgroundColor: lineColor,
                        pointBorderColor: '#000000',
                        pointBorderWidth: 2,
                        pointHoverBackgroundColor: lineColor,
                        pointHoverBorderColor: '#ffffff',
                        pointHoverBorderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            backgroundColor: '#000000',
                            titleColor: '#ffffff',
                            bodyColor: '#ffffff',
                            borderColor: lineColor,
                            borderWidth: 2,
                            padding: 12,
                            displayColors: false,
                            callbacks: {
                                label: function(context) {
                                    const value = context.raw;
                                    const currency = mainOperation.currency || 'USD';
                                    return `P&L: ${formatCurrency(value, currency, currency)}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: {
                                color: '#1a1a1a',
                                drawBorder: false
                            },
                            ticks: {
                                color: '#a0a0a0',
                                font: {
                                    size: 10
                                },
                                maxRotation: 45,
                                minRotation: 0
                            }
                        },
                        y: {
                            grid: {
                                color: '#1a1a1a',
                                drawBorder: false,
                                lineWidth: 1
                            },
                            ticks: {
                                color: '#ffffff',
                                font: {
                                    size: 11,
                                    weight: 'bold'
                                },
                                callback: function(value) {
                                    const currency = mainOperation.currency || 'USD';
                                    return formatCurrency(value, currency, currency);
                                }
                            },
                            beginAtZero: true
                        }
                    }
                }
            });

            console.log('✅ Trade Running P&L Chart actualizado');
        }

        // Gráfico 2: DAY RUNNING P&L (todas las operaciones del día)
        window.updateDayPnLChart = function(mainOperation) {
            const ctx = document.getElementById('operation-day-pnl-chart')?.getContext('2d');
            if (!ctx) return;
            
            // Destruir gráfico existente
            if (operationDayPnLChart) {
                operationDayPnLChart.destroy();
            }

            // Obtener todas las operaciones del mismo día
            const dayOperations = DB.operations.filter(op => 
                op.date === mainOperation.date && 
                op.accountId === mainOperation.accountId
            );

            if (dayOperations.length === 0) return;

            // Ordenar por hora de salida
            const sortedDayOps = [...dayOperations].sort((a, b) => {
                const timeA = a.exitTime || a.entryTime || '00:00';
                const timeB = b.exitTime || b.entryTime || '00:00';
                return timeA.localeCompare(timeB);
            });

            // Crear datos acumulados
            const labels = [];
            const pnlData = [];
            let accumulatedPL = 0;

            // Punto inicial
            labels.push('Inicio');
            pnlData.push(0);

            sortedDayOps.forEach((op, index) => {
                accumulatedPL += (op.pl || 0);
                const timeLabel = op.exitTime || op.entryTime || `Trade ${index + 1}`;
                labels.push(timeLabel);
                pnlData.push(accumulatedPL);
            });

            const finalPL = accumulatedPL;
            const isProfit = finalPL >= 0;
            
            // Colores de la plataforma
            const lineColor = isProfit ? '#39ff14' : '#ff4136';
            const fillColor = isProfit ? 'rgba(57, 255, 20, 0.15)' : 'rgba(255, 65, 54, 0.15)';

            operationDayPnLChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'P&L Acumulado Día',
                        data: pnlData,
                        borderColor: lineColor,
                        backgroundColor: fillColor,
                        borderWidth: 2,
                        fill: true,
                        tension: 0.3,
                        pointRadius: 4,
                        pointHoverRadius: 6,
                        pointBackgroundColor: lineColor,
                        pointBorderColor: '#000000',
                        pointBorderWidth: 2,
                        pointHoverBackgroundColor: lineColor,
                        pointHoverBorderColor: '#ffffff',
                        pointHoverBorderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            backgroundColor: '#000000',
                            titleColor: '#ffffff',
                            bodyColor: '#ffffff',
                            borderColor: lineColor,
                            borderWidth: 2,
                            padding: 12,
                            displayColors: false,
                            callbacks: {
                                title: function(context) {
                                    return `${context[0].label}`;
                                },
                                label: function(context) {
                                    const value = context.raw;
                                    const currency = mainOperation.currency || 'USD';
                                    return `Total: ${formatCurrency(value, currency, currency)}`;
                                },
                                afterLabel: function(context) {
                                    const index = context.dataIndex;
                                    if (index > 0 && sortedDayOps[index - 1]) {
                                        const op = sortedDayOps[index - 1];
                                        const currency = mainOperation.currency || 'USD';
                                        return `Trade: ${formatCurrency(op.pl, currency, currency)}`;
                                    }
                                    return '';
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: {
                                color: '#1a1a1a',
                                drawBorder: false
                            },
                            ticks: {
                                color: '#a0a0a0',
                                font: {
                                    size: 10
                                },
                                maxRotation: 45,
                                minRotation: 0
                            }
                        },
                        y: {
                            grid: {
                                color: '#1a1a1a',
                                drawBorder: false,
                                lineWidth: 1
                            },
                            ticks: {
                                color: '#ffffff',
                                font: {
                                    size: 11,
                                    weight: 'bold'
                                },
                                callback: function(value) {
                                    const currency = mainOperation.currency || 'USD';
                                    return formatCurrency(value, currency, currency);
                                }
                            },
                            beginAtZero: true
                        }
                    }
                }
            });

            console.log('✅ Day Running P&L Chart actualizado');
        }

        // ========== MÉTRICAS Y ESTADÍSTICAS DEL INSTRUMENTO ==========
        
        // Variables globales para los gráficos de métricas
        let opChartComparison = null;
        let opChartSessions = null;
        let opChartWeekdays = null;
        let opChartPLWeekdays = null;
        let opChartPositionSizes = null;
        let opChartSetups = null;
        let opChartHours = null;

        function updateOperationMetricsAndCharts(operation) {
            if (!operation) return;
            
            // Filtrar todas las operaciones del mismo instrumento
            const instrumentOps = DB.operations.filter(op => 
                op.instrument === operation.instrument &&
                op.accountId === operation.accountId
            );
            
            if (instrumentOps.length === 0) return;
            
            // Calcular métricas numéricas
            const totalTrades = instrumentOps.length;
            const winners = instrumentOps.filter(op => op.result === 'win').length;
            const losers = instrumentOps.filter(op => op.result === 'loss').length;
            const winRate = totalTrades > 0 ? (winners / totalTrades) * 100 : 0;
            
            const totalWinPL = instrumentOps.filter(op => op.result === 'win').reduce((sum, op) => sum + (op.pl || 0), 0);
            const totalLossPL = Math.abs(instrumentOps.filter(op => op.result === 'loss').reduce((sum, op) => sum + (op.pl || 0), 0));
            const profitFactor = totalLossPL > 0 ? totalWinPL / totalLossPL : (totalWinPL > 0 ? 999 : 0);
            
            const totalPL = instrumentOps.reduce((sum, op) => sum + (op.pl || 0), 0);
            
            const bestTrade = Math.max(...instrumentOps.map(op => op.pl || 0));
            const worstTrade = Math.min(...instrumentOps.map(op => op.pl || 0));
            
            // Calcular R:R promedio
            const avgWin = winners > 0 ? totalWinPL / winners : 0;
            const avgLoss = losers > 0 ? totalLossPL / losers : 0;
            const avgRR = avgLoss > 0 ? avgWin / avgLoss : 0;
            
            // Calcular duración promedio
            let totalDuration = 0;
            let opsWithDuration = 0;
            instrumentOps.forEach(op => {
                if (op.entryTime && op.exitTime) {
                    const entry = new Date(`2000-01-01 ${op.entryTime}`);
                    const exit = new Date(`2000-01-01 ${op.exitTime}`);
                    const duration = (exit - entry) / 1000 / 60; // minutos
                    if (duration > 0 && duration < 1440) { // Menos de 24 horas
                        totalDuration += duration;
                        opsWithDuration++;
                    }
                }
            });
            const avgDuration = opsWithDuration > 0 ? totalDuration / opsWithDuration : 0;
            const hours = Math.floor(avgDuration / 60);
            const minutes = Math.floor(avgDuration % 60);
            
            // Ranking de este trade
            const sortedByPL = [...instrumentOps].sort((a, b) => (b.pl || 0) - (a.pl || 0));
            const ranking = sortedByPL.findIndex(op => op.id === operation.id) + 1;
            const percentile = totalTrades > 0 ? Math.round((1 - (ranking / totalTrades)) * 100) : 0;
            
            // Actualizar métricas numéricas
            document.getElementById('op-metric-total-trades').textContent = totalTrades;
            document.getElementById('op-metric-winrate').textContent = `${winRate.toFixed(1)}%`;
            document.getElementById('op-metric-pf').textContent = profitFactor === 999 ? '∞' : profitFactor.toFixed(2);
            document.getElementById('op-metric-rr').textContent = avgRR.toFixed(2);
            
            const totalPlEl = document.getElementById('op-metric-total-pl');
            totalPlEl.textContent = formatCurrency(totalPL, operation.currency, operation.currency);
            totalPlEl.className = `text-2xl font-bold ${totalPL >= 0 ? 'text-green' : 'text-red'}`;
            
            document.getElementById('op-metric-best-trade').textContent = formatCurrency(bestTrade, operation.currency, operation.currency);
            document.getElementById('op-metric-worst-trade').textContent = formatCurrency(worstTrade, operation.currency, operation.currency);
            document.getElementById('op-metric-avg-duration').textContent = `${hours}h ${minutes}m`;
            document.getElementById('op-metric-ranking').textContent = `#${ranking} de ${totalTrades}`;
            document.getElementById('op-metric-percentile').textContent = `Top ${percentile}%`;
            
            // Renderizar gráficos
            renderComparisonChart(operation, instrumentOps);
            renderSessionsChart(operation.instrument, instrumentOps);
            renderWeekdaysChart(operation.instrument, instrumentOps);
            renderPLWeekdaysChart(operation.instrument, instrumentOps);
            renderPositionSizesChart(operation, instrumentOps);
            renderSetupsChart(operation.instrument, instrumentOps);
        }

        // Gráfico 1: Comparativa Este Trade vs Promedio (HORIZONTAL)
        function renderComparisonChart(operation, instrumentOps) {
            const ctx = document.getElementById('op-chart-comparison')?.getContext('2d');
            if (!ctx) return;
            
            if (opChartComparison) opChartComparison.destroy();
            
            const avgPL = instrumentOps.reduce((sum, op) => sum + (op.pl || 0), 0) / instrumentOps.length;
            
            let totalDuration = 0;
            let opsWithDuration = 0;
            instrumentOps.forEach(op => {
                if (op.entryTime && op.exitTime) {
                    const entry = new Date(`2000-01-01 ${op.entryTime}`);
                    const exit = new Date(`2000-01-01 ${op.exitTime}`);
                    const duration = (exit - entry) / 1000 / 60;
                    if (duration > 0 && duration < 1440) {
                        totalDuration += duration;
                        opsWithDuration++;
                    }
                }
            });
            const avgDuration = opsWithDuration > 0 ? totalDuration / opsWithDuration : 0;
            
            let opDuration = 0;
            if (operation.entryTime && operation.exitTime) {
                const entry = new Date(`2000-01-01 ${operation.entryTime}`);
                const exit = new Date(`2000-01-01 ${operation.exitTime}`);
                opDuration = (exit - entry) / 1000 / 60;
            }
            
            const avgVolume = instrumentOps.reduce((sum, op) => sum + (op.volume || 0), 0) / instrumentOps.length;
            
            opChartComparison = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['P&L', 'Duración (min)', 'Volumen'],
                    datasets: [{
                        label: 'Este Trade',
                        data: [operation.pl || 0, opDuration, operation.volume || 0],
                        backgroundColor: '#39ff14',
                        borderColor: '#39ff14',
                        borderWidth: 1
                    }, {
                        label: 'Promedio',
                        data: [avgPL, avgDuration, avgVolume],
                        backgroundColor: '#a0a0a0',
                        borderColor: '#ffffff',
                        borderWidth: 1
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            labels: { color: '#ffffff', font: { size: 11 } }
                        },
                        tooltip: {
                            backgroundColor: '#000000',
                            titleColor: '#ffffff',
                            bodyColor: '#ffffff',
                            borderColor: '#39ff14',
                            borderWidth: 1,
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.label === 'P&L') {
                                        label += '$' + context.parsed.x.toFixed(2);
                                    } else if (context.label === 'Duración (min)') {
                                        label += context.parsed.x.toFixed(0) + ' min';
                                    } else {
                                        label += context.parsed.x.toFixed(2);
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: { color: '#1a1a1a' },
                            ticks: { color: '#ffffff', font: { size: 10 } }
                        },
                        y: {
                            grid: { color: '#1a1a1a' },
                            ticks: { color: '#ffffff', font: { size: 11 } }
                        }
                    }
                }
            });
        }

        // Gráfico 2: Performance por Sesión (VERTICAL)
        function renderSessionsChart(instrument, instrumentOps) {
            const ctx = document.getElementById('op-chart-sessions')?.getContext('2d');
            if (!ctx) return;
            
            if (opChartSessions) opChartSessions.destroy();
            
            const sessions = ['Sydney', 'Tokyo', 'Londres', 'Nueva York'];
            const sessionData = sessions.map(session => {
                const ops = instrumentOps.filter(op => op.session === session);
                const pl = ops.reduce((sum, op) => sum + (op.pl || 0), 0);
                return pl;
            });
            
            const colors = sessionData.map(pl => pl >= 0 ? '#39ff14' : '#ff4136');
            
            opChartSessions = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: sessions,
                    datasets: [{
                        label: 'P&L por Sesión',
                        data: sessionData,
                        backgroundColor: colors,
                        borderColor: '#000000',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: '#000000',
                            titleColor: '#ffffff',
                            bodyColor: '#ffffff',
                            borderColor: '#39ff14',
                            borderWidth: 1,
                            callbacks: {
                                label: function(context) {
                                    return 'P&L: $' + context.parsed.y.toFixed(2);
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: { color: '#1a1a1a' },
                            ticks: { color: '#ffffff', font: { size: 10 } }
                        },
                        y: {
                            grid: { color: '#1a1a1a' },
                            ticks: { 
                                color: '#ffffff', 
                                font: { size: 11 },
                                callback: function(value) {
                                    return '$' + value.toFixed(0);
                                }
                            },
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        // Gráfico 3: Win Rate por Día de la Semana (VERTICAL)
        function renderWeekdaysChart(instrument, instrumentOps) {
            const ctx = document.getElementById('op-chart-weekdays')?.getContext('2d');
            if (!ctx) return;
            
            if (opChartWeekdays) opChartWeekdays.destroy();
            
            const weekdays = ['Dom', 'Lun', 'Mar', 'Mié', 'Jue', 'Vie', 'Sáb'];
            const winRateData = [];
            
            for (let i = 0; i < 7; i++) {
                const dayOps = instrumentOps.filter(op => {
                    const date = new Date(op.date + 'T12:00:00');
                    return date.getDay() === i;
                });
                const winners = dayOps.filter(op => op.result === 'win').length;
                const winRate = dayOps.length > 0 ? (winners / dayOps.length) * 100 : 0;
                winRateData.push(winRate);
            }
            
            opChartWeekdays = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: weekdays,
                    datasets: [{
                        label: 'Win Rate %',
                        data: winRateData,
                        backgroundColor: '#39ff14',
                        borderColor: '#000000',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: '#000000',
                            titleColor: '#ffffff',
                            bodyColor: '#ffffff',
                            borderColor: '#39ff14',
                            borderWidth: 1,
                            callbacks: {
                                label: function(context) {
                                    return `Win Rate: ${context.raw.toFixed(1)}%`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: { color: '#1a1a1a' },
                            ticks: { color: '#ffffff', font: { size: 10 } }
                        },
                        y: {
                            grid: { color: '#1a1a1a' },
                            ticks: { 
                                color: '#ffffff', 
                                font: { size: 11 },
                                callback: function(value) { return value + '%'; }
                            },
                            beginAtZero: true,
                            max: 100
                        }
                    }
                }
            });
        }

        // Gráfico 4: P/L por Día de la Semana (VERTICAL)
        function renderPLWeekdaysChart(instrument, instrumentOps) {
            const ctx = document.getElementById('op-chart-pl-weekdays')?.getContext('2d');
            if (!ctx) return;
            
            if (opChartPLWeekdays) opChartPLWeekdays.destroy();
            
            const weekdays = ['Domingo', 'Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sábado'];
            const plData = [];
            
            for (let i = 0; i < 7; i++) {
                const dayOps = instrumentOps.filter(op => {
                    const date = new Date(op.date + 'T12:00:00');
                    return date.getDay() === i;
                });
                const totalPL = dayOps.reduce((sum, op) => sum + (op.pl || 0), 0);
                plData.push(totalPL);
            }
            
            const colors = plData.map(pl => pl >= 0 ? '#39ff14' : '#ff4136');
            
            opChartPLWeekdays = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: weekdays,
                    datasets: [{
                        label: 'P&L',
                        data: plData,
                        backgroundColor: colors,
                        borderColor: '#000000',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: '#000000',
                            titleColor: '#ffffff',
                            bodyColor: '#ffffff',
                            borderColor: '#39ff14',
                            borderWidth: 1,
                            callbacks: {
                                label: function(context) {
                                    return 'P&L: $' + context.parsed.y.toFixed(2);
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: { color: '#1a1a1a' },
                            ticks: { color: '#ffffff', font: { size: 10 } }
                        },
                        y: {
                            grid: { color: '#1a1a1a' },
                            ticks: { 
                                color: '#ffffff', 
                                font: { size: 11 },
                                callback: function(value) {
                                    return '$' + value.toFixed(0);
                                }
                            },
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        // Gráfico 5: Distribución de Tamaños de Posición (HORIZONTAL)
        function renderPositionSizesChart(operation, instrumentOps) {
            const ctx = document.getElementById('op-chart-position-sizes')?.getContext('2d');
            if (!ctx) return;
            
            if (opChartPositionSizes) opChartPositionSizes.destroy();
            
            // Agrupar por rangos de volumen
            const ranges = ['Pequeño', 'Mediano', 'Grande'];
            const volumes = instrumentOps.map(op => op.volume || 0).sort((a, b) => a - b);
            const p33 = volumes[Math.floor(volumes.length * 0.33)] || 0;
            const p66 = volumes[Math.floor(volumes.length * 0.66)] || 0;
            
            const rangeCounts = {
                'Pequeño': 0,
                'Mediano': 0,
                'Grande': 0
            };
            
            const rangePL = {
                'Pequeño': 0,
                'Mediano': 0,
                'Grande': 0
            };
            
            instrumentOps.forEach(op => {
                const vol = op.volume || 0;
                const pl = op.pl || 0;
                if (vol <= p33) {
                    rangeCounts['Pequeño']++;
                    rangePL['Pequeño'] += pl;
                } else if (vol <= p66) {
                    rangeCounts['Mediano']++;
                    rangePL['Mediano'] += pl;
                } else {
                    rangeCounts['Grande']++;
                    rangePL['Grande'] += pl;
                }
            });
            
            const plData = [rangePL['Pequeño'], rangePL['Mediano'], rangePL['Grande']];
            const colors = plData.map(pl => pl >= 0 ? '#39ff14' : '#ff4136');
            
            opChartPositionSizes = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ranges,
                    datasets: [{
                        label: 'P&L por Tamaño',
                        data: plData,
                        backgroundColor: colors,
                        borderColor: '#000000',
                        borderWidth: 2
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: '#000000',
                            titleColor: '#ffffff',
                            bodyColor: '#ffffff',
                            borderColor: '#39ff14',
                            borderWidth: 1,
                            callbacks: {
                                label: function(context) {
                                    return 'P&L: $' + context.parsed.x.toFixed(2);
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: { color: '#1a1a1a' },
                            ticks: { 
                                color: '#ffffff', 
                                font: { size: 10 },
                                callback: function(value) {
                                    return '$' + value.toFixed(0);
                                }
                            }
                        },
                        y: {
                            grid: { color: '#1a1a1a' },
                            ticks: { color: '#ffffff', font: { size: 11 } }
                        }
                    }
                }
            });
        }

        // Gráfico 6: P&L por Setup (VERTICAL)
        function renderSetupsChart(instrument, instrumentOps) {
            const ctx = document.getElementById('op-chart-setups')?.getContext('2d');
            if (!ctx) return;
            
            if (opChartSetups) opChartSetups.destroy();
            
            const setupMap = {};
            instrumentOps.forEach(op => {
                const setupId = op.setupId || op.setupUsed;
                const setupName = setupId ? (DB.setups.find(s => s.id === setupId)?.name || 'Sin Setup') : 'Sin Setup';
                if (!setupMap[setupName]) {
                    setupMap[setupName] = { count: 0, pl: 0 };
                }
                setupMap[setupName].count++;
                setupMap[setupName].pl += op.pl || 0;
            });
            
            const setupNames = Object.keys(setupMap).slice(0, 8); // Top 8
            const setupPL = setupNames.map(name => setupMap[name].pl);
            const colors = setupPL.map(pl => pl >= 0 ? '#39ff14' : '#ff4136');
            
            opChartSetups = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: setupNames,
                    datasets: [{
                        label: 'P&L por Setup',
                        data: setupPL,
                        backgroundColor: colors,
                        borderColor: '#000000',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: '#000000',
                            titleColor: '#ffffff',
                            bodyColor: '#ffffff',
                            borderColor: '#39ff14',
                            borderWidth: 1,
                            callbacks: {
                                label: function(context) {
                                    return 'P&L: $' + context.parsed.y.toFixed(2);
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: { color: '#1a1a1a' },
                            ticks: { color: '#ffffff', font: { size: 9 }, maxRotation: 45 }
                        },
                        y: {
                            grid: { color: '#1a1a1a' },
                            ticks: { 
                                color: '#ffffff', 
                                font: { size: 11 },
                                callback: function(value) {
                                    return '$' + value.toFixed(0);
                                }
                            },
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        // Gráfico 6: Mejores Horarios (HORIZONTAL)
        function renderHoursChart(instrument, instrumentOps) {
            const ctx = document.getElementById('op-chart-hours')?.getContext('2d');
            if (!ctx) return;
            
            if (opChartHours) opChartHours.destroy();
            
            const hourlyData = {};
            for (let h = 0; h < 24; h++) {
                hourlyData[h] = { count: 0, pl: 0 };
            }
            
            instrumentOps.forEach(op => {
                if (op.entryTime) {
                    const hour = parseInt(op.entryTime.split(':')[0]);
                    if (hour >= 0 && hour < 24) {
                        hourlyData[hour].count++;
                        hourlyData[hour].pl += op.pl || 0;
                    }
                }
            });
            
            // Agrupar por bloques de 4 horas
            const timeBlocks = ['00-04', '04-08', '08-12', '12-16', '16-20', '20-24'];
            const blockPL = [];
            
            for (let i = 0; i < 6; i++) {
                let pl = 0;
                for (let h = i * 4; h < (i + 1) * 4; h++) {
                    pl += hourlyData[h].pl;
                }
                blockPL.push(pl);
            }
            
            const colors = blockPL.map(pl => pl >= 0 ? '#39ff14' : '#ff4136');
            
            opChartHours = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: timeBlocks,
                    datasets: [{
                        label: 'P&L por Bloque Horario',
                        data: blockPL,
                        backgroundColor: colors,
                        borderColor: '#000000',
                        borderWidth: 2
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: '#000000',
                            titleColor: '#ffffff',
                            bodyColor: '#ffffff',
                            borderColor: '#39ff14',
                            borderWidth: 1
                        }
                    },
                    scales: {
                        x: {
                            grid: { color: '#1a1a1a' },
                            ticks: { color: '#ffffff', font: { size: 10 } }
                        },
                        y: {
                            grid: { color: '#1a1a1a' },
                            ticks: { color: '#ffffff', font: { size: 11 } }
                        }
                    }
                }
            });
        }

        // --- FUNCIONES PARA PESTAÑAS INTERACTIVAS EN DETALLES DE OPERACIÓN ---
        let opDetailRichEditor = null; // Editor de texto enriquecido para notas de operación
        
        function initializeOperationDetailTabs() {
            // Inicializar Rich Text Editor para notas de operación (si está disponible)
            const opEditorContainer = document.getElementById('op-detail-rich-editor-container');
            if (opEditorContainer && !opDetailRichEditor && typeof RichTextEditor !== 'undefined') {
                try {
                    opDetailRichEditor = new RichTextEditor(opEditorContainer, {
                        placeholder: 'Agrega notas detalladas de la operación...',
                        minHeight: '200px',
                        maxHeight: '400px',
                        showVoiceRecorder: true,
                        showDownload: true,
                        showCharCount: true
                    });
                } catch (e) {
                    console.warn('⚠️ No se pudo inicializar RichTextEditor:', e);
                }
            } else if (typeof RichTextEditor === 'undefined') {
                console.warn('⚠️ RichTextEditor no está disponible');
            }
            
            // Event listeners para pestañas de notas
            document.querySelectorAll('.notes-tab-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const tab = btn.dataset.tab;
                    switchNotesTab(tab);
                });
            });

            // Event listeners para pestañas de imágenes  
            document.querySelectorAll('.images-tab-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const tab = btn.dataset.tab;
                    switchImagesTab(tab);
                });
            });

            // Event listeners para funciones de notas
            document.getElementById('save-notes-btn')?.addEventListener('click', saveOperationNotes);
            document.getElementById('cancel-notes-btn')?.addEventListener('click', () => switchNotesTab('view'));

            // Event listeners para funciones de imágenes
            document.getElementById('op-detail-image-input')?.addEventListener('change', handleImageSelection);
            document.getElementById('upload-images-btn')?.addEventListener('click', saveOperationImages);
            document.getElementById('cancel-images-btn')?.addEventListener('click', cancelImageUpload);

            // Drag and drop para imágenes
            const dropZone = document.getElementById('drop-zone');
            if (dropZone) {
                dropZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    dropZone.classList.add('drag-over');
                });
                
                dropZone.addEventListener('dragleave', () => {
                    dropZone.classList.remove('drag-over');
                });
                
                dropZone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    dropZone.classList.remove('drag-over');
                    const files = Array.from(e.dataTransfer.files).filter(file => file.type.startsWith('image/'));
                    if (files.length > 0) {
                        document.getElementById('op-detail-image-input').files = createFileList(files);
                        handleImageSelection({ target: { files } });
                    }
                });
            }
        }

        function switchNotesTab(tab) {
            // Actualizar botones
            document.querySelectorAll('.notes-tab-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.tab === tab) {
                    btn.classList.add('active');
                }
            });

            // Mostrar/ocultar contenido
            document.querySelectorAll('.notes-tab-content').forEach(content => {
                content.classList.add('hidden');
                content.classList.remove('active');
            });

            if (tab === 'view') {
                document.getElementById('notes-view-content').classList.remove('hidden');
                document.getElementById('notes-view-content').classList.add('active');
            } else if (tab === 'edit') {
                document.getElementById('notes-edit-content').classList.remove('hidden');
                document.getElementById('notes-edit-content').classList.add('active');
                // Cargar notas actuales en el editor enriquecido
                const currentNotes = document.getElementById('op-detail-notes').innerHTML;
                if (opDetailRichEditor) {
                    opDetailRichEditor.setContent(currentNotes || '', 'html');
                }
            }
        }

        function switchImagesTab(tab) {
            console.log('🔄 Cambiando a pestaña de imágenes:', tab);
            
            // Actualizar botones
            document.querySelectorAll('.images-tab-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.tab === tab) {
                    btn.classList.add('active');
                }
            });

            // Mostrar/ocultar contenido
            document.querySelectorAll('.images-tab-content').forEach(content => {
                content.classList.add('hidden');
                content.classList.remove('active');
            });

            if (tab === 'view') {
                document.getElementById('images-view-content').classList.remove('hidden');
                document.getElementById('images-view-content').classList.add('active');
                console.log('👁️ Mostrando pestaña de vista de imágenes');
            } else if (tab === 'add') {
                document.getElementById('images-add-content').classList.remove('hidden');
                document.getElementById('images-add-content').classList.add('active');
                console.log('➕ Mostrando pestaña de agregar imágenes');
            }
        }

        function saveOperationNotes() {
            const operationId = document.getElementById('op-detail-id').textContent;
            const newNotes = opDetailRichEditor ? opDetailRichEditor.getContent('html') : '';
            
            // Buscar la operación en la base de datos local
            const operationIndex = DB.operations.findIndex(op => op.id === operationId);
            if (operationIndex === -1) {
                alert('Operación no encontrada');
                return;
            }

            const operation = DB.operations[operationIndex];

            // Actualizar las notas en la base de datos local
            DB.operations[operationIndex].notes = newNotes;
            
            // Guardar en dexieDB
            dexieDB.operations.update(operationId, { notes: newNotes }).then(async () => {
                console.log('✅ Notas guardadas en dexieDB correctamente');
                
                // Actualizar la vista local sin refrescar la tabla de operaciones
                document.getElementById('op-detail-notes').innerHTML = newNotes || 'Sin notas.';
                
                // Volver a la pestaña de vista
                switchNotesTab('view');
                
                // --- SINCRONIZACIÓN AUTOMÁTICA CON NOTEBOOK ---
                try {
                    // Asegurar que userId esté definido
                    if (!window.userId && window.currentUser) {
                        window.userId = window.currentUser.id;
                    }
                    
                    // Buscar carpeta "Operaciones" en IndexedDB (NO en memoria)
                    const allFolders = await dexieDB.notebookFolders.toArray();
                    let operacionesFolder = allFolders.find(f => f.name === 'Operaciones');
                    
                    if (!operacionesFolder) {
                        console.log('📁 Creando carpeta "Operaciones" en Notebook...');
                        operacionesFolder = {
                            id: 'folder_operaciones_' + Date.now(),
                            user_id: window.userId,
                            name: 'Operaciones',
                            icon: '📊',
                            created_at: new Date().toISOString()
                        };
                        
                        await dexieDB.notebookFolders.add(operacionesFolder);
                        if (window.supabase && window.userId) {
                            await supabase.from('notebook_folders').insert([operacionesFolder]);
                        }
                        
                        DB.notebookFolders = DB.notebookFolders || [];
                        DB.notebookFolders.push(operacionesFolder);
                        console.log('✅ Carpeta Operaciones creada');
                    } else {
                        console.log('✅ Carpeta Operaciones ya existe, usando existente');
                    }
                    
                    // Crear título descriptivo para la nota
                    const noteTitle = `${operation.symbol || operation.instrument || 'Trade'} - ${new Date(operation.date).toLocaleDateString('es-ES')}`;
                    
                    // Buscar si ya existe una nota para esta operación
                    let existingNote = (DB.notebookNotes || []).find(n => 
                        n.folder_id === operacionesFolder.id && 
                        n.metadata && 
                        n.metadata.operationId === operationId
                    );
                    
                    if (existingNote) {
                        // Actualizar nota existente
                        console.log('📝 Actualizando nota existente en Notebook...');
                        existingNote.title = noteTitle;
                        existingNote.content = newNotes;
                        existingNote.updated_at = new Date().toISOString();
                        
                        await dexieDB.notebookNotes.put(existingNote);
                        if (window.supabase && window.userId) {
                            await supabase
                                .from('notebook_notes')
                                .update({
                                    title: existingNote.title,
                                    content: existingNote.content,
                                    updated_at: existingNote.updated_at
                                })
                                .eq('id', existingNote.id);
                        }
                    } else {
                        // Crear nueva nota
                        console.log('📝 Creando nueva nota en Notebook...');
                        const newNote = {
                            id: 'note_op_' + operationId + '_' + Date.now(),
                            user_id: window.userId,
                            folder_id: operacionesFolder.id,
                            title: noteTitle,
                            content: newNotes,
                            created_at: new Date().toISOString(),
                            updated_at: new Date().toISOString(),
                            is_pinned: false,
                            metadata: {
                                operationId: operationId,
                                symbol: operation.symbol || operation.instrument,
                                date: operation.date,
                                result: operation.result,
                                pl: operation.pl
                            }
                        };
                        
                        await dexieDB.notebookNotes.add(newNote);
                        if (window.supabase && window.userId) {
                            await supabase.from('notebook_notes').insert([newNote]);
                        }
                        
                        DB.notebookNotes = DB.notebookNotes || [];
                        DB.notebookNotes.unshift(newNote);
                    }
                    
                    console.log('✅ Notas sincronizadas con Notebook → Carpeta "Operaciones"');
                    
                    // Notificar a Notebook para que actualice contadores
                    if (typeof window.notebookNotesUpdated === 'function') {
                        window.notebookNotesUpdated();
                    }
                } catch (notebookError) {
                    console.warn('⚠️ Error al sincronizar con Notebook:', notebookError);
                }
                
                // También guardar en Supabase si está configurado
                if (typeof saveOperationToSupabase === 'function') {
                    saveOperationToSupabase(DB.operations[operationIndex]).catch(err => {
                        console.log('⚠️ Error al sincronizar notas con Supabase:', err);
                    });
                }
                
            }).catch(error => {
                console.error('❌ Error al guardar notas:', error);
                alert('Error al guardar las notas. Inténtalo de nuevo.');
            });
        }

        function handleImageSelection(event) {
            const files = Array.from(event.target.files);
            const preview = document.getElementById('selected-images-preview');
            const uploadBtn = document.getElementById('upload-images-btn');
            
            console.log('📁 Archivos seleccionados:', files.length);
            
            if (files.length === 0) {
                preview.classList.add('hidden');
                uploadBtn.classList.add('hidden');
                return;
            }

            preview.innerHTML = '';
            preview.classList.remove('hidden');
            uploadBtn.classList.remove('hidden');

            files.forEach((file, index) => {
                console.log(`📎 Procesando archivo ${index + 1}:`, file.name, file.type, `${(file.size / 1024 / 1024).toFixed(2)}MB`);
                
                if (file.type.startsWith('image/') && file.size <= 10 * 1024 * 1024) { // Max 10MB
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const div = document.createElement('div');
                        div.className = 'relative border border-border rounded overflow-hidden';
                        div.innerHTML = `
                            <img src="${e.target.result}" alt="Preview" class="w-full h-24 object-cover">
                            <button onclick="removeImagePreview(${index})" class="absolute top-1 right-1 bg-red-500 text-white rounded-full w-6 h-6 text-xs hover:bg-red-600">
                                ×
                            </button>
                            <p class="p-1 text-xs text-center truncate">${file.name}</p>
                        `;
                        preview.appendChild(div);
                    };
                    reader.readAsDataURL(file);
                } else {
                    console.warn('⚠️ Archivo rechazado:', file.name, file.type, `${(file.size / 1024 / 1024).toFixed(2)}MB`);
                }
            });
        }

        function removeImagePreview(index) {
            const input = document.getElementById('op-detail-image-input');
            const files = Array.from(input.files);
            files.splice(index, 1);
            
            // Recrear el input con los archivos restantes
            input.files = createFileList(files);
            handleImageSelection({ target: { files } });
        }

        function createFileList(files) {
            const dt = new DataTransfer();
            files.forEach(file => dt.items.add(file));
            return dt.files;
        }

        function saveOperationImages() {
            const operationId = document.getElementById('op-detail-id').textContent;
            const files = Array.from(document.getElementById('op-detail-image-input').files);
            
            console.log('💾 Intentando guardar imágenes:', files.length);
            
            if (files.length === 0) {
                alert('No hay imágenes seleccionadas');
                return;
            }

            // Buscar la operación en la base de datos local
            const operationIndex = DB.operations.findIndex(op => op.id === operationId);
            if (operationIndex === -1) {
                alert('Operación no encontrada');
                return;
            }

            // Convertir imágenes a base64 y agregarlas
            let processedCount = 0;
            const newImages = [];

            files.forEach((file, index) => {
                console.log(`🖼️ Procesando imagen ${index + 1}/${files.length}:`, file.name);
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    newImages.push({
                        name: file.name,
                        data: e.target.result,
                        size: file.size,
                        type: file.type
                    });
                    
                    processedCount++;
                    console.log(`✅ Imagen ${processedCount}/${files.length} procesada:`, file.name);
                    
                    if (processedCount === files.length) {
                        // Todas las imágenes procesadas, guardar
                        if (!DB.operations[operationIndex].imageDatas) {
                            DB.operations[operationIndex].imageDatas = [];
                        }
                        
                        console.log('💾 Agregando', newImages.length, 'nuevas imágenes a la operación');
                        DB.operations[operationIndex].imageDatas.push(...newImages);
                        
                        // Guardar en dexieDB
                        dexieDB.operations.update(operationId, { 
                            imageDatas: DB.operations[operationIndex].imageDatas 
                        }).then(() => {
                            console.log('✅ Imágenes guardadas en dexieDB correctamente');
                            
                            // Actualizar la vista de imágenes inmediatamente
                            updateOperationImagesDisplay(DB.operations[operationIndex]);
                            
                            // Volver a la pestaña de vista y limpiar
                            cancelImageUpload();
                            switchImagesTab('view');
                            
                            // Actualizar Chartbook para que muestre las nuevas imágenes
                            if (typeof window.refreshChartbook === 'function') {
                                console.log('🔄 Actualizando Chartbook...');
                                window.refreshChartbook();
                            }
                            
                            // También guardar en Supabase si está configurado
                            if (typeof saveOperationToSupabase === 'function') {
                                saveOperationToSupabase(DB.operations[operationIndex]).catch(err => {
                                    console.log('⚠️ Error al sincronizar imágenes con Supabase:', err);
                                });
                            }
                            
                        }).catch(error => {
                            console.error('❌ Error al guardar imágenes:', error);
                            alert('Error al guardar las imágenes. Inténtalo de nuevo.');
                        });
                    }
                };
                reader.readAsDataURL(file);
            });
        }

        function cancelImageUpload() {
            document.getElementById('op-detail-image-input').value = '';
            document.getElementById('selected-images-preview').classList.add('hidden');
            document.getElementById('upload-images-btn').classList.add('hidden');
            document.getElementById('selected-images-preview').innerHTML = '';
        }

        window.updateOperationImagesDisplay = function(operation) {
            const imagesContainer = document.getElementById('op-detail-images');
            
            console.log('🖼️ [updateOperationImagesDisplay] Operación:', operation.id);
            console.log('📁 [updateOperationImagesDisplay] imageDatas:', operation.imageDatas);
            
            if (!imagesContainer) {
                console.error('❌ Contenedor no encontrado: op-detail-images');
                return;
            }
            
            console.log('📦 Contenedor encontrado:', {
                exists: !!imagesContainer,
                classList: imagesContainer.classList.toString(),
                display: window.getComputedStyle(imagesContainer).display,
                visibility: window.getComputedStyle(imagesContainer).visibility,
                parent: imagesContainer.parentElement?.id
            });
            
            // Limpiar contenedor
            imagesContainer.innerHTML = '';
            imagesContainer.style.display = 'grid';
            
            if (!operation.imageDatas || !Array.isArray(operation.imageDatas) || operation.imageDatas.length === 0) {
                console.log('ℹ️ No hay imágenes para mostrar');
                imagesContainer.innerHTML = '<p class="text-sm text-text-secondary col-span-3 text-center py-4">No hay imágenes adjuntas.</p>';
                return;
            }
            
            console.log('✅ Procesando', operation.imageDatas.length, 'imágenes');
            
            let validImageCount = 0;
            
            operation.imageDatas.forEach((imageData, index) => {
                // Obtener la URL de la imagen
                let imageSrc = null;
                
                console.log(`🔍 [Imagen ${index + 1}] Tipo:`, typeof imageData);
                
                if (typeof imageData === 'string') {
                    // Podría ser JSON string o base64 directo
                    try {
                        const parsed = JSON.parse(imageData);
                        imageSrc = parsed.data || imageData;
                        console.log(`📦 [Imagen ${index + 1}] Parseado de JSON`);
                    } catch (e) {
                        // No es JSON, usar como está
                        imageSrc = imageData;
                    }
                } else if (imageData && typeof imageData === 'object') {
                    imageSrc = imageData.data || imageData.url || imageData.src;
                    console.log(`🎯 [Imagen ${index + 1}] Extraído de objeto:`, imageSrc ? 'OK' : 'FAIL');
                }
                
                console.log(`🖼️ [Imagen ${index + 1}]:`, imageSrc ? `${imageSrc.substring(0, 30)}... (${imageSrc.length} chars)` : 'NULL');
                
                if (!imageSrc || imageSrc.length === 0) {
                    console.warn(`⚠️ [Imagen ${index + 1}] URL vacía, omitiendo`);
                    return;
                }
                
                // Crear contenedor de imagen
                const imageCard = document.createElement('div');
                imageCard.className = 'relative border-2 border-primary rounded-lg overflow-hidden bg-black cursor-pointer transition-transform hover:scale-105 group';
                imageCard.style.cssText = 'min-width: 250px; min-height: 250px; height: 300px; display: block !important;';
                
                // Crear imagen
                const img = document.createElement('img');
                img.src = imageSrc;
                img.alt = `Imagen ${index + 1}`;
                img.className = 'w-full h-full object-contain';
                img.style.cssText = 'display: block !important;';
                img.loading = 'eager'; // Cargar inmediatamente
                
                img.onload = () => {
                    console.log(`✅ [Imagen ${index + 1}] Cargada -`, img.naturalWidth, 'x', img.naturalHeight);
                    validImageCount++;
                };
                
                img.onerror = (e) => {
                    console.error(`❌ [Imagen ${index + 1}] Error:`, e);
                    imageCard.innerHTML = `
                        <div class="flex flex-col items-center justify-center h-full text-negative text-xs p-2">
                            <i class="fas fa-exclamation-triangle text-2xl mb-2"></i>
                            <span>Error al cargar</span>
                        </div>
                    `;
                };
                
                // Click para abrir modal
                imageCard.addEventListener('click', () => {
                    const imageUrls = operation.imageDatas
                        .map(imgData => {
                            if (typeof imgData === 'string') {
                                try {
                                    const parsed = JSON.parse(imgData);
                                    return parsed.data || imgData;
                                } catch (e) {
                                    return imgData;
                                }
                            }
                            return imgData?.data || imgData?.url || imgData?.src || null;
                        })
                        .filter(url => url && url.length > 0);
                    
                    console.log('📸 Abriendo modal con', imageUrls.length, 'imágenes');
                    console.log('📸 Primera URL:', imageUrls[0] ? imageUrls[0].substring(0, 50) : 'N/A');
                    platformOpenImageModal(imageUrls, index);
                });
                
                // Botón eliminar
                const deleteBtn = document.createElement('button');
                deleteBtn.innerHTML = '<i class="fas fa-trash"></i>';
                deleteBtn.className = 'absolute top-2 right-2 bg-negative text-white rounded-full w-8 h-8 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity z-10';
                deleteBtn.title = 'Eliminar imagen';
                
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (confirm('¿Eliminar esta imagen?')) {
                        removeOperationImage(operation.id, index);
                    }
                });
                
                // Agregar elementos
                imageCard.appendChild(img);
                imageCard.appendChild(deleteBtn);
                imagesContainer.appendChild(imageCard);
            });
            
            console.log(`✅ Grid creado con ${imagesContainer.children.length} elementos`);
            console.log('📦 Contenedor después:', {
                children: imagesContainer.children.length,
                innerHTML: imagesContainer.innerHTML.substring(0, 200)
            });
        }

        function removeOperationImage(operationId, imageIndex) {
            if (!confirm('¿Estás seguro de que quieres eliminar esta imagen?')) return;
            
            const operationIndex = DB.operations.findIndex(op => op.id === operationId);
            if (operationIndex !== -1 && DB.operations[operationIndex].imageDatas) {
                DB.operations[operationIndex].imageDatas.splice(imageIndex, 1);
                
                // Guardar en dexieDB
                dexieDB.operations.update(operationId, { 
                    imageDatas: DB.operations[operationIndex].imageDatas 
                }).then(() => {
                    console.log('✅ Imagen eliminada y guardada en dexieDB correctamente');
                    updateOperationImagesDisplay(DB.operations[operationIndex]);
                    
                    // Actualizar Chartbook para que refleje la eliminación
                    if (typeof window.refreshChartbook === 'function') {
                        console.log('🔄 Actualizando Chartbook después de eliminar imagen...');
                        window.refreshChartbook();
                    }
                    
                    // También guardar en Supabase si está configurado
                    if (typeof saveOperationToSupabase === 'function') {
                        saveOperationToSupabase(DB.operations[operationIndex]).catch(err => {
                            console.log('⚠️ Error al sincronizar eliminación con Supabase:', err);
                        });
                    }
                }).catch(error => {
                    console.error('❌ Error al eliminar imagen:', error);
                    alert('Error al eliminar la imagen. Inténtalo de nuevo.');
                });
            }
        }

        // Inicializar cuando el DOM esté listo
        document.addEventListener('DOMContentLoaded', initializeOperationDetailTabs);
    </script>

<!-- Social Media Module - Cargado ANTES del script principal -->
<!-- IMPORTANTE: group-invitations.js debe cargarse ANTES de social-media.js -->
<script src="frontend/group-invitations.js"></script>
<script src="frontend/social-media.js"></script>

<script type="module">
// Importar Supabase como módulo ES
import { createClient } from '@supabase/supabase-js'

// ===== SUPABASE AUTHENTICATION SYSTEM =====

// Configuración de Supabase
const supabaseUrl = 'https://gakiamardmlgftfrlxkm.supabase.co'
const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imdha2lhbWFyZG1sZ2Z0ZnJseGttIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTMwMjczMzUsImV4cCI6MjA2ODYwMzMzNX0.wR3c9DMtSXzoagFDJdrmYqnN6vjfQMn8ijtUdOSpmYM'

// Crear cliente Supabase globalmente
window.supabaseClient = createClient(supabaseUrl, supabaseKey)
window.supabase = window.supabaseClient // Alias para compatibilidad

console.log('✅ Supabase cliente creado correctamente');
console.log('✅ URL:', supabaseUrl);

// Variable global para el resto del código
var supabase = window.supabaseClient;

// Función para inicializar Supabase (ahora solo verifica que esté disponible)
async function initializeSupabase() {
    if (window.supabaseClient) {
        console.log('✅ Supabase ya disponible');
        return true;
    }
    console.error('❌ Supabase no se pudo cargar');
    return false;
}

// Inicializar sin bloquear
initializeSupabase().catch(err => console.warn('⚠️ Init Supabase:', err));

// Función para verificar permisos RLS
async function testRLSPermissions() {
    if (!currentUser) {
        alert('❌ No hay usuario logueado');
        return;
    }

    try {
        console.log('🛡️ Testing RLS permissions...');
        console.log('👤 Current user ID:', currentUser.id);

        // Test 1: Probar SELECT en accounts
        console.log('🔍 Testing SELECT on accounts...');
        const { data: selectData, error: selectError } = await supabase
            .from('accounts')
            .select('*')
            .eq('user_id', currentUser.id);

        if (selectError) {
            console.error('❌ SELECT test failed:', selectError);
            alert(`❌ Error en SELECT: ${selectError.message}`);
            return;
        }

        console.log('✅ SELECT test passed:', selectData);

        // Test 2: Probar INSERT en accounts
        console.log('🔍 Testing INSERT on accounts...');
        const testAccount = {
            id: 'test_' + Date.now(),
            user_id: currentUser.id,
            name: 'Test Account',
            currency: 'USD',
            platform: 'test',
            initial_balance: 1000,
            balance: 1000
        };

        const { data: insertData, error: insertError } = await supabase
            .from('accounts')
            .insert(testAccount)
            .select();

        if (insertError) {
            console.error('❌ INSERT test failed:', insertError);
            alert(`❌ Error en INSERT: ${insertError.message}`);
            return;
        }

        console.log('✅ INSERT test passed:', insertData);

        // Test 3: Limpiar - eliminar el registro de prueba
        await supabase
            .from('accounts')
            .delete()
            .eq('id', testAccount.id);

        console.log('✅ Test cleanup completed');
        alert('✅ Todos los permisos RLS funcionan correctamente!');

    } catch (error) {
        console.error('❌ RLS test error:', error);
        alert(`❌ Error en prueba RLS: ${error.message}`);
    }
}
async function testSupabaseConnection() {
    try {
        console.log('🔍 Testing Supabase connection...');
        console.log('🔍 Current user:', currentUser);
        console.log('🔍 Supabase client:', supabase);

        if (!currentUser) {
            console.log('❌ No current user for testing');
            alert('❌ No hay usuario logueado');
            return false;
        }

        console.log('🔍 Testing simple query...');

        // Probar una consulta simple
        const { data, error, count } = await supabase
            .from('accounts')
            .select('*', { count: 'exact' })
            .eq('user_id', currentUser.id);

        if (error) {
            console.error('❌ Supabase connection test failed:', error);
            alert(`❌ Error de conexión: ${error.message}`);
            return false;
        }

        console.log('✅ Supabase connection test successful');
        console.log('📊 Current accounts in Supabase:', data);
        console.log('📊 Total accounts count:', count);

        alert(`✅ Conexión exitosa! Cuentas encontradas: ${count || 0}`);
        return true;
    } catch (error) {
        console.error('❌ Supabase connection test error:', error);
        alert(`❌ Error inesperado: ${error.message}`);
        return false;
    }
}

// ===== SUPABASE DATABASE FUNCTIONS =====

// Función para inicializar las tablas de Supabase (solo para referencia)
async function initializeSupabaseTables() {
    // Las tablas deben crearse en el panel de Supabase con las siguientes estructuras:
    //
    // 1. accounts:
    //    - id (text, primary key)
    //    - user_id (uuid, references auth.users(id))
    //    - name (text)
    //    - currency (text)
    //    - platform (text)
    //    - initial_balance (numeric)
    //    - balance (numeric)
    //    - created_at (timestamp with time zone)
    //
    // 2. operations:
    //    - id (text, primary key)
    //    - user_id (uuid, references auth.users(id))
    //    - account_id (text)
    //    - date (text)
    //    - instrument (text)
    //    - type (text)
    //    - entry (numeric)
    //    - exit (numeric)
    //    - entry_time (text)
    //    - exit_time (text)
    //    - volume (numeric)
    //    - result (text)
    //    - pl (numeric)
    //    - currency (text)
    //    - notes (text)
    //    - image_datas (text[])
    //    - manual_pl (numeric)
    //    - session (text)
    //    - created_at (timestamp with time zone)
    //
    // 3. finances:
    //    - id (serial, primary key)
    //    - user_id (uuid, references auth.users(id))
    //    - date (text)
    //    - amount (numeric)
    //    - currency (text)
    //    - notes (text)
    //    - created_at (timestamp with time zone)
    //
    // 4. user_settings:
    //    - user_id (uuid, primary key, references auth.users(id))
    //    - settings (jsonb)
    //    - api_keys (jsonb)
    //    - created_at (timestamp with time zone)
    //    - updated_at (timestamp with time zone)
}

// ========================
// SISTEMA DE SINCRONIZACIÓN AUTOMÁTICA
// Optimizado para reducir Egress de Supabase:
// - Sincronización cada 30 minutos (antes 30 segundos)
// - Carga solo últimos 12 meses de operaciones y finanzas
// - Carga solo últimos 6 meses de imágenes (consumen más Egress)
// - Sincronización inmediata al crear/editar/eliminar
// - Reducción estimada de Egress: 80-90%
// ========================
let syncQueue = [];
let autoSyncInterval = null;
let isAutoSyncEnabled = true;

// Agregar elemento a la cola de sincronización
function addToSyncQueue(data, type) {
    syncQueue.push({
        data: data,
        type: type, // 'operation', 'account', 'finance'
        timestamp: Date.now(),
        attempts: 0
    });
    console.log(`📥 Agregado a cola de sincronización: ${type}`, data.id);
}

// Procesar cola de sincronización automática
async function processSyncQueue() {
    if (syncQueue.length === 0 || !currentUser) return;

    console.log(`🔄 Procesando cola de sincronización: ${syncQueue.length} elementos pendientes`);

    const itemsToProcess = [...syncQueue];
    syncQueue = []; // Limpiar cola

    for (const item of itemsToProcess) {
        try {
            switch (item.type) {
                case 'operation':
                    await saveOperationToSupabase(item.data);
                    console.log(`✅ Operación sincronizada desde cola:`, item.data.id);
                    break;
                case 'account':
                    await saveAccountToSupabase(item.data);
                    console.log(`✅ Cuenta sincronizada desde cola:`, item.data.id);
                    break;
                case 'finance':
                    await saveFinanceToSupabase(item.data);
                    console.log(`✅ Finanza sincronizada desde cola:`, item.data.id);
                    break;
            }
        } catch (error) {
            console.error(`❌ Error sincronizando ${item.type}:`, error);
            // Reintentar si no ha fallado muchas veces
            if (item.attempts < 3) {
                item.attempts++;
                syncQueue.push(item);
                console.log(`🔄 Reintentando sincronización (intento ${item.attempts}/3):`, item.data.id);
            } else {
                console.error(`❌ Máximo de intentos alcanzado para ${item.type}:`, item.data.id);
            }
        }
    }

    if (syncQueue.length === 0) {
        console.log('✅ Cola de sincronización procesada completamente');
        showSyncNotification('🔄 Sincronización automática completada', 'success');
    }
}

// ===== AUTO-SYNC DESACTIVADO PARA REDUCIR EGRESS =====
// Iniciar sincronización automática en segundo plano
function startAutoSync() {
    console.log('⚠️ Auto-sync desactivado para reducir egress - Use sincronización manual');
    return; // DESACTIVADO PERMANENTEMENTE
    
    /* CÓDIGO DESACTIVADO
    if (autoSyncInterval) return; // Ya está corriendo

    console.log('🚀 Iniciando sincronización automática cada 2 horas (optimizado para reducir Egress)');
    autoSyncInterval = setInterval(() => {
        if (isAutoSyncEnabled && currentUser && syncQueue.length > 0) {
            processSyncQueue();
        }
    }, 7200000); // Cada 2 horas (optimizado para Supabase Egress - antes 30 min)
    */
}

// Detener sincronización automática
function stopAutoSync() {
    if (autoSyncInterval) {
        clearInterval(autoSyncInterval);
        autoSyncInterval = null;
        console.log('⏹️ Sincronización automática detenida');
    }
}

// Sincronización cuando el usuario se conecta
async function onUserLogin(user) {
    currentUser = user;
    window.currentUser = user; // Hacer accesible globalmente
    isAutoSyncEnabled = true;

    console.log('🔐 Usuario autenticado en onUserLogin:', user.email);

    try {
        // Cargar datos en paralelo para mejorar la velocidad
        console.log('📥 Cargando todos los datos en paralelo...');
        
        // ===== AUTO-LOAD: Cargar todos los datos necesarios =====
        const [accounts, operations, fundedAccounts, finances, setups] = await Promise.all([
            loadAccountsFromSupabase(),
            loadOperationsFromSupabase(), // ✅ ACTIVADO: Necesario para funcionalidad completa
            loadFundedAccountsFromSupabase(),
            loadFinancesFromSupabase(),
            loadSetupsFromSupabase()
        ]);
        
        console.log('📊 Datos recibidos:', {
            accounts: accounts.length,
            operations: operations.length,
            fundedAccounts: fundedAccounts.length,
            finances: finances.length,
            setups: setups.length
        });
        
        // Cargar configuración del usuario (nombre y foto de perfil)
        try {
            const { data: userSettings } = await supabase
                .from('user_settings')
                .select('username, profile_image')
                .eq('user_id', user.id)
                .single();
            
            if (userSettings) {
                if (userSettings.username) {
                    localStorage.setItem('username', userSettings.username);
                    console.log('✅ Username cargado:', userSettings.username);
                }
                if (userSettings.profile_image) {
                    localStorage.setItem('profile-image', userSettings.profile_image);
                    console.log('✅ Foto de perfil cargada');
                }
                // Actualizar header del usuario
                if (typeof updateUserHeader === 'function') {
                    updateUserHeader();
                }
            }
        } catch (err) {
            console.warn('⚠️ No se pudo cargar configuración del usuario:', err);
        }
        
        // Actualizar cuentas
        if (accounts.length > 0) {
            console.log('💾 Actualizando DB.accounts...');
            DB.accounts = accounts;
            await dexieDB.accounts.clear();
            await dexieDB.accounts.bulkPut(accounts);
            console.log('✅ DB.accounts actualizado:', DB.accounts.length);
            
            // Refrescar selector de cuentas principal
            const selector = document.getElementById('main-account-select');
            if (selector) {
                refreshAccountSelector();
            }
            
            // ✅ IMPORTANTE: Refrescar TODOS los selectores de cuentas en paralelo
            console.log('🔄 Actualizando todos los selectores de cuentas...');
            if (typeof updateAccountSelect === 'function') {
                [
                    'dashboard-account-select',
                    'new-dashboard-account-select',
                    'analytics-account-select',
                    'informe-account-select',
                    'equity-account-select',
                    'daily-journal-account-select',
                    'chartbook-account-select',
                    'calendar-account-select',
                    'op-account',
                    'filter-account',
                    'bingx-account',
                    'bingx-account-detail',
                    'bitunix-account-detail',
                    'lbank-account-detail',
                    'blofin-account-detail'
                ].forEach(selectorId => {
                    try {
                        updateAccountSelect(selectorId);
                    } catch (e) {
                        console.warn(`⚠️ No se pudo actualizar selector ${selectorId}:`, e);
                    }
                });
                console.log('✅ Todos los selectores de cuentas actualizados');
            }

            // Cargar credenciales de MEXC después de cargar las cuentas
            setTimeout(() => {
                loadMEXCCredentials().catch(err => {
                    console.warn('⚠️ No se pudieron cargar credenciales de MEXC:', err);
                });
                populateMEXCAccountSelect();
            }, 500);
        }

        // Actualizar operaciones
        if (operations.length > 0) {
            console.log('💾 Actualizando DB.operations...');
            DB.operations = operations;
            await dexieDB.operations.clear();
            await dexieDB.operations.bulkPut(operations);
            console.log('✅ DB.operations actualizado:', DB.operations.length);
        }

        // Actualizar cuentas financiadas
        if (fundedAccounts.length > 0) {
            console.log('💾 Actualizando DB.fundedAccounts...');
            DB.fundedAccounts = fundedAccounts;
            await dexieDB.fundedAccounts.clear();
            await dexieDB.fundedAccounts.bulkPut(fundedAccounts);
            console.log('✅ DB.fundedAccounts actualizado:', DB.fundedAccounts.length);
        }

        // Actualizar finanzas
        if (finances.length > 0) {
            console.log('💾 Actualizando DB.finances...');
            DB.finances = finances;
            await dexieDB.finances.clear();
            await dexieDB.finances.bulkPut(finances);
            console.log('✅ DB.finances actualizado:', DB.finances.length);
        }
        
        // Actualizar setups (Playbook)
        if (setups && setups.length > 0) {
            console.log('💾 Actualizando DB.setups...');
            DB.setups = setups;
            await dexieDB.setups.clear();
            await dexieDB.setups.bulkPut(setups);
            console.log('✅ DB.setups actualizado:', DB.setups.length);
            
            // Actualizar dropdowns de setup
            if (typeof window.updateAllSetupDropdowns === 'function') {
                window.updateAllSetupDropdowns();
            }
        }
    } catch (error) {
        console.error('❌ Error en onUserLogin:', error);
    }

    // Procesar cola de sincronización
    if (syncQueue.length > 0) {
        await processSyncQueue();
    }

    startAutoSync();
    
    // Inicializar Social Media (plataforma)
    if (typeof initSocialMedia === 'function') {
        console.log('🌐 Inicializando Social Media...');
        initSocialMedia();
    }
    
    // Inicializar módulo de grupos
    if (typeof initSocialMediaModule === 'function') {
        console.log('👥 Inicializando módulo de grupos...');
        initSocialMediaModule();
    }
    
    // Cargar configuración de perfil público
    if (typeof loadUserPublicSettings === 'function') {
        loadUserPublicSettings();
    }
    
    // Desactivar flag de carga inicial después de un pequeño delay
    setTimeout(() => {
        if (typeof isInitialLoad !== 'undefined') {
            isInitialLoad = false;
            console.log('✅ Carga inicial completada - refreshes automáticos habilitados');
        }
        
        // Refrescar todas las vistas una sola vez después de cargar todo
        console.log('🔄 Refrescando vistas después de carga completa...');
        
        // Refrescar la vista activa
        const activeSection = document.querySelector('.main-content > section.active');
        if (activeSection) {
            const sectionId = activeSection.id;
            console.log(`📊 Vista activa: ${sectionId}`);
            
            switch(sectionId) {
                case 'dashboard':
                    if (typeof refreshNewDashboard === 'function') refreshNewDashboard();
                    break;
                case 'dashboard-advance':
                    if (typeof refreshDashboard === 'function') refreshDashboard();
                    break;
                case 'analytics':
                    if (typeof refreshAnalytics === 'function') refreshAnalytics();
                    break;
                case 'chartbook':
                    if (typeof refreshChartbook === 'function') refreshChartbook();
                    break;
                case 'equity-graph':
                    if (typeof refreshEquityGraph === 'function') refreshEquityGraph();
                    break;
                case 'daily-journal':
                    if (typeof refreshDailyJournal === 'function') refreshDailyJournal();
                    break;
                case 'calendar':
                    if (typeof updateCalendar === 'function') updateCalendar();
                    break;
                default:
                    // Por defecto refrescar nuevo dashboard
                    if (typeof refreshNewDashboard === 'function') refreshNewDashboard();
            }
        } else {
            // Si no hay sección activa, refrescar dashboard
            if (typeof refreshNewDashboard === 'function') refreshNewDashboard();
        }
        
        console.log('✅ Vistas refrescadas correctamente');
    }, 1000);
}

// Cuando el usuario se desconecta
function onUserLogout() {
    stopAutoSync();
    isAutoSyncEnabled = false;
    currentUser = null;
    window.currentUser = null; // Limpiar referencia global
    console.log('👋 Usuario desconectado - sincronización automática pausada');
}

// Funciones para operaciones con cuentas
async function saveAccountToSupabase(accountData) {
    if (!currentUser) {
        console.warn('❌ No current user - cannot save account to Supabase');
        return null;
    }

    try {
        console.log('💾 Saving account to Supabase:', {
            id: accountData.id,
            user_id: currentUser.id,
            name: accountData.name,
            currency: accountData.currency,
            broker: accountData.broker,
            account_number: accountData.accountNumber
        });

        const accountPayload = {
            id: accountData.id,
            user_id: currentUser.id,
            name: accountData.name,
            currency: accountData.currency,
            platform: accountData.platform,
            initial_balance: accountData.initialBalance,
            balance: accountData.balance
        };

        // Agregar campos opcionales solo si existen
        if (accountData.accountNumber) {
            accountPayload.account_number = accountData.accountNumber;
        }
        if (accountData.broker) {
            accountPayload.broker = accountData.broker;
        }

        const { data, error } = await supabase
            .from('accounts')
            .upsert(accountPayload);

        if (error) {
            console.error('❌ Supabase error saving account:', error);
            throw error;
        }

        console.log('✅ Account saved to Supabase successfully:', data);
        return data;
    } catch (error) {
        console.error('❌ Error saving account to Supabase:', error);
        throw error;
    }
}

async function loadAccountsFromSupabase() {
    if (!currentUser) return [];

    try {
        // Las cuentas son datos pequeños, cargar todas (no afecta mucho Egress)
        const { data, error } = await supabase
            .from('accounts')
            .select('*')
            .eq('user_id', currentUser.id);

        if (error) throw error;

        // Convertir de formato Supabase a formato local
        return data.map(account => ({
            id: account.id,
            name: account.name,
            currency: account.currency,
            platform: account.platform,
            initialBalance: account.initial_balance,
            balance: account.balance,
            accountNumber: account.account_number,
            broker: account.broker
        }));
    } catch (error) {
        console.error('Error loading accounts from Supabase:', error);
        return [];
    }
}

async function deleteAccountFromSupabase(accountId) {
    if (!currentUser) return;

    try {
        // Primero, eliminar todas las operaciones asociadas a esta cuenta
        console.log(`🗑️ Eliminando operaciones de la cuenta: ${accountId}`);
        
        const { error: opsError, data: deletedOps } = await supabase
            .from('operations')
            .delete()
            .eq('account_id', accountId)
            .eq('user_id', currentUser.id)
            .select();

        if (opsError) {
            console.error('Error eliminando operaciones:', opsError);
            throw opsError;
        }

        console.log(`✅ ${deletedOps?.length || 0} operaciones eliminadas`);

        // Luego, eliminar la cuenta
        console.log(`🗑️ Eliminando cuenta: ${accountId}`);
        
        const { error: accountError } = await supabase
            .from('accounts')
            .delete()
            .eq('id', accountId)
            .eq('user_id', currentUser.id);

        if (accountError) {
            console.error('Error eliminando cuenta:', accountError);
            throw accountError;
        }

        console.log(`✅ Cuenta eliminada exitosamente`);
        
    } catch (error) {
        console.error('Error deleting account from Supabase:', error);
        throw error;
    }
}

// Funciones para funded accounts
async function saveFundedAccountToSupabase(fundedData) {
    if (!currentUser) {
        console.warn('❌ No current user - cannot save funded account to Supabase');
        return null;
    }

    try {
        // Calcular el conteo de retiros si es un array
        const withdrawalsCount = Array.isArray(fundedData.withdrawals) 
            ? fundedData.withdrawals.length 
            : (fundedData.withdrawals || 0);

        const dataToSend = {
            id: fundedData.id,
            user_id: currentUser.id,
            name: fundedData.name,
            company: fundedData.company,
            firm: fundedData.company, // Guardar también en firm para compatibilidad
            type: fundedData.type || 'evaluation',
            status: fundedData.status,
            fee: fundedData.fee || 0,
            balance: fundedData.balance || 0,
            activation_date: fundedData.activationDate,
            earnings: fundedData.earnings || 0,
            withdrawals_count: withdrawalsCount,
            withdrawals_history: Array.isArray(fundedData.withdrawals) ? fundedData.withdrawals : [],
            notes: fundedData.notes,
            updated_at: new Date().toISOString()
        };

        console.log('💾 Saving funded account to Supabase:', dataToSend);
        console.log('📋 Datos originales fundedData:', fundedData);

        const { data, error } = await supabase
            .from('funded_accounts')
            .upsert(dataToSend);

        if (error) {
            console.error('❌ Supabase error saving funded account:', error);
            throw error;
        }

        console.log('✅ Funded account saved to Supabase successfully:', data);
        return data;
    } catch (error) {
        console.error('❌ Error saving funded account to Supabase:', error);
        throw error;
    }
}

async function loadFundedAccountsFromSupabase() {
    if (!currentUser) return [];

    try {
        const { data, error } = await supabase
            .from('funded_accounts')
            .select('*')
            .eq('user_id', currentUser.id);

        if (error) throw error;

        // Convertir de formato Supabase a formato local
        return data.map(funded => ({
            id: funded.id,
            name: funded.name,
            company: funded.company || funded.firm, // Usar company o firm
            firm: funded.firm || funded.company, // Compatibilidad
            type: funded.type,
            status: funded.status,
            fee: parseFloat(funded.fee) || 0,
            balance: parseFloat(funded.balance) || 0,
            activationDate: funded.activation_date,
            earnings: parseFloat(funded.earnings) || 0,
            withdrawals: funded.withdrawals_history || [], // Cargar el historial completo
            withdrawalsCount: funded.withdrawals_count || 0, // Mantener el conteo también
            notes: funded.notes
        }));
    } catch (error) {
        console.error('Error loading funded accounts from Supabase:', error);
        return [];
    }
}

async function deleteFundedAccountFromSupabase(fundedId) {
    if (!currentUser) return;

    try {
        const { error } = await supabase
            .from('funded_accounts')
            .delete()
            .eq('id', fundedId)
            .eq('user_id', currentUser.id);

        if (error) throw error;
    } catch (error) {
        console.error('Error deleting funded account from Supabase:', error);
        throw error;
    }
}

// Funciones para gestión de retiros de cuentas funded
function openWithdrawalModal(accountId) {
    const account = DB.fundedAccounts.find(acc => acc.id === accountId);
    if (!account) return;

    document.getElementById('withdrawal-account-id').value = accountId;
    document.getElementById('withdrawal-account-name').value = `${account.name} - ${account.company}`;
    document.getElementById('withdrawal-amount').value = '';
    document.getElementById('withdrawal-date').value = new Date().toISOString().split('T')[0];
    document.getElementById('withdrawal-notes').value = '';
    
    document.getElementById('withdrawal-modal').style.display = 'flex';
}

function closeWithdrawalModal() {
    document.getElementById('withdrawal-modal').style.display = 'none';
    document.getElementById('withdrawal-form').reset();
}

async function saveWithdrawal() {
    const accountId = document.getElementById('withdrawal-account-id').value;
    const amount = parseFloat(document.getElementById('withdrawal-amount').value);
    const date = document.getElementById('withdrawal-date').value;
    const notes = document.getElementById('withdrawal-notes').value;

    if (!accountId || !amount || !date) {
        alert('⚠️ Por favor completa todos los campos obligatorios');
        return;
    }

    const account = DB.fundedAccounts.find(acc => acc.id === accountId);
    if (!account) return;

    // Inicializar array de retiros si no existe o es un número
    if (!Array.isArray(account.withdrawals)) {
        account.withdrawals = [];
    }

    // Crear objeto de retiro
    const withdrawal = {
        id: Date.now().toString(),
        date: date,
        amount: amount,
        notes: notes,
        timestamp: new Date().toISOString()
    };

    // Agregar retiro a la cuenta
    account.withdrawals.push(withdrawal);
    
    // RECALCULAR EARNINGS (suma de todos los retiros)
    account.earnings = account.withdrawals.reduce((sum, w) => sum + parseFloat(w.amount || 0), 0);
    
    console.log('🔄 Retiro agregado al array. Total retiros:', account.withdrawals.length);
    console.log('💰 Earnings recalculados:', account.earnings);
    console.log('📋 Array de retiros actualizado:', account.withdrawals);
    
    // Actualizar en Supabase
    await saveFundedAccountToSupabase(account);
    
    console.log('✅ Retiro guardado en Supabase');
    
    // Recargar cuentas funded desde Supabase
    const updatedFundedAccounts = await loadFundedAccountsFromSupabase();
    DB.fundedAccounts = updatedFundedAccounts;
    
    console.log('🔄 Cuentas funded recargadas:', updatedFundedAccounts.length);
    
    // Actualizar vistas
    console.log('🔄 Llamando a refreshFunded...');
    if (typeof refreshFunded === 'function') {
        refreshFunded();
        console.log('✅ refreshFunded ejecutado');
    } else {
        console.warn('⚠️ refreshFunded no está definida');
    }
    
    if (typeof renderFundedCalendar === 'function') {
        renderFundedCalendar();
        console.log('✅ renderFundedCalendar ejecutado');
    } else {
        console.warn('⚠️ renderFundedCalendar no está definida');
    }
    
    closeWithdrawalModal();
    showNotification('✅ Retiro registrado exitosamente');
    console.log('✅ Proceso de retiro completado');
}

// Funciones para setups (Playbook)
async function saveSetupToSupabase(setupData) {
    if (!currentUser) {
        console.warn('❌ No current user - cannot save setup to Supabase');
        return null;
    }

    try {
        console.log('💾 Saving setup to Supabase:', {
            id: setupData.id,
            user_id: currentUser.id,
            name: setupData.name,
            category: setupData.category
        });

        const { data, error } = await supabase
            .from('setups')
            .upsert({
                id: setupData.id,
                user_id: currentUser.id,
                name: setupData.name,
                category: setupData.category,
                grade: setupData.grade || null,
                rating: setupData.rating,
                description: setupData.description,
                tags: setupData.tags || [],
                images: setupData.images || [],
                updated_at: new Date().toISOString()
            });

        if (error) {
            console.error('❌ Supabase error saving setup:', error);
            throw error;
        }

        console.log('✅ Setup saved to Supabase successfully:', data);
        return data;
    } catch (error) {
        console.error('❌ Error saving setup to Supabase:', error);
        throw error;
    }
}

async function loadSetupsFromSupabase() {
    if (!currentUser) return [];

    try {
        // Setups son datos pequeños, cargar todos (no afecta mucho Egress)
        const { data, error } = await supabase
            .from('setups')
            .select('*')
            .eq('user_id', currentUser.id);

        if (error) throw error;

        // Convertir de formato Supabase a formato local
        return data.map(setup => ({
            id: setup.id,
            name: setup.name,
            category: setup.category,
            grade: setup.grade || null,
            rating: setup.rating,
            description: setup.description,
            tags: Array.isArray(setup.tags) ? setup.tags : (setup.tags ? [setup.tags] : []),
            images: setup.images || [],
            createdAt: setup.created_at,
            updatedAt: setup.updated_at
        }));
    } catch (error) {
        console.error('Error loading setups from Supabase:', error);
        return [];
    }
}

async function deleteSetupFromSupabase(setupId) {
    if (!currentUser) return;

    try {
        const { error } = await supabase
            .from('setups')
            .delete()
            .eq('id', setupId)
            .eq('user_id', currentUser.id);

        if (error) throw error;
    } catch (error) {
        console.error('Error deleting setup from Supabase:', error);
        throw error;
    }
}

// Funciones para API Keys de exchanges

// Guardar credenciales de BingX en Supabase
async function saveBingXCredentialsToSupabase(apiKey, secretKey, accountId) {
    if (!currentUser) {
        console.warn('❌ No current user - cannot save BingX credentials to Supabase');
        return null;
    }

    try {
        console.log('💾 [saveBingX] Iniciando guardado en Supabase...');
        console.log('💾 [saveBingX] User ID:', currentUser.id);
        console.log('💾 [saveBingX] Account ID:', accountId);
        
        // Primero obtener las settings actuales
        console.log('📥 [saveBingX] Consultando settings existentes...');
        const { data: existingSettings, error: fetchError } = await supabase
            .from('user_settings')
            .select('api_keys')
            .eq('user_id', currentUser.id)
            .single();

        if (fetchError && fetchError.code !== 'PGRST116') {
            console.error('❌ [saveBingX] Error al consultar settings:', fetchError);
        }

        let apiKeys = existingSettings?.api_keys || {};
        console.log('📊 [saveBingX] API Keys existentes:', Object.keys(apiKeys));
        
        // Actualizar credenciales de BingX
        apiKeys.bingx = {
            apiKey: apiKey,
            secretKey: secretKey,
            accountId: accountId,
            updatedAt: new Date().toISOString()
        };

        console.log('💾 [saveBingX] Ejecutando upsert...');
        // Guardar o actualizar
        const { data, error } = await supabase
            .from('user_settings')
            .upsert({
                user_id: currentUser.id,
                api_keys: apiKeys,
                updated_at: new Date().toISOString()
            }, {
                onConflict: 'user_id'
            });

        if (error) {
            console.error('❌ [saveBingX] Error en upsert:', error);
            console.error('❌ [saveBingX] Error code:', error.code);
            console.error('❌ [saveBingX] Error message:', error.message);
            throw error;
        }

        console.log('✅ [saveBingX] Credenciales BingX guardadas exitosamente');
        console.log('✅ [saveBingX] Response:', data);
        return data;
    } catch (error) {
        console.error('❌ [saveBingX] Error en saveBingXCredentialsToSupabase:', error);
        console.error('❌ [saveBingX] Stack:', error.stack);
        throw error;
    }
}

// Cargar credenciales de BingX desde Supabase
async function loadBingXCredentialsFromSupabase() {
    if (!currentUser) {
        console.log('ℹ️ No hay usuario autenticado para cargar credenciales BingX');
        return null;
    }

    try {
        console.log('📥 Cargando credenciales BingX de Supabase...');
        
        const { data, error } = await supabase
            .from('user_settings')
            .select('api_keys')
            .eq('user_id', currentUser.id)
            .single();

        if (error) {
            if (error.code === 'PGRST116') {
                console.log('ℹ️ No hay settings guardados aún');
                return null;
            }
            throw error;
        }

        const bingxCreds = data?.api_keys?.bingx;
        if (bingxCreds) {
            console.log('✅ Credenciales BingX cargadas de Supabase');
            return {
                key: bingxCreds.apiKey,
                secret: bingxCreds.secretKey,
                accountId: bingxCreds.accountId
            };
        }

        return null;
    } catch (error) {
        console.error('❌ Error cargando credenciales BingX de Supabase:', error);
        return null;
    }
}

async function saveMEXCCredentialsToSupabase(apiKey, secretKey, accountId) {
    if (!currentUser) {
        console.warn('❌ No current user - cannot save MEXC credentials to Supabase');
        return null;
    }

    try {
        console.log('💾 [saveMEXC] Iniciando guardado en Supabase...');
        console.log('💾 [saveMEXC] User ID:', currentUser.id);
        console.log('💾 [saveMEXC] Account ID:', accountId);
        
        // Primero obtener las settings actuales
        console.log('📥 [saveMEXC] Consultando settings existentes...');
        const { data: existingSettings, error: fetchError } = await supabase
            .from('user_settings')
            .select('api_keys')
            .eq('user_id', currentUser.id)
            .single();

        if (fetchError && fetchError.code !== 'PGRST116') {
            console.error('❌ [saveMEXC] Error al consultar settings:', fetchError);
        }

        let apiKeys = existingSettings?.api_keys || {};
        console.log('📊 [saveMEXC] API Keys existentes:', Object.keys(apiKeys));
        
        // Actualizar credenciales de MEXC
        apiKeys.mexc = {
            apiKey: apiKey,
            secretKey: secretKey,
            accountId: accountId,
            updatedAt: new Date().toISOString()
        };

        console.log('💾 [saveMEXC] Ejecutando upsert...');
        // Guardar o actualizar
        const { data, error } = await supabase
            .from('user_settings')
            .upsert({
                user_id: currentUser.id,
                api_keys: apiKeys,
                updated_at: new Date().toISOString()
            }, {
                onConflict: 'user_id'
            });

        if (error) {
            console.error('❌ [saveMEXC] Error en upsert:', error);
            console.error('❌ [saveMEXC] Error code:', error.code);
            console.error('❌ [saveMEXC] Error message:', error.message);
            throw error;
        }

        console.log('✅ [saveMEXC] Credenciales MEXC guardadas exitosamente');
        console.log('✅ [saveMEXC] Response:', data);
        return data;
    } catch (error) {
        console.error('❌ [saveMEXC] Error en saveMEXCCredentialsToSupabase:', error);
        console.error('❌ [saveMEXC] Stack:', error.stack);
        throw error;
    }
}

async function loadMEXCCredentialsFromSupabase() {
    if (!currentUser) {
        console.log('ℹ️ No hay usuario autenticado para cargar credenciales MEXC');
        return null;
    }

    try {
        console.log('📥 Cargando credenciales MEXC desde Supabase...');
        
        const { data, error } = await supabase
            .from('user_settings')
            .select('api_keys')
            .eq('user_id', currentUser.id)
            .single();

        if (error && error.code !== 'PGRST116') { // PGRST116 = no rows found
            console.error('❌ Error cargando credenciales MEXC:', error);
            throw error;
        }

        if (data && data.api_keys && data.api_keys.mexc) {
            console.log('✅ Credenciales MEXC encontradas en Supabase');
            return {
                apiKey: data.api_keys.mexc.apiKey,
                secretKey: data.api_keys.mexc.secretKey,
                accountId: data.api_keys.mexc.accountId
            };
        }

        console.log('ℹ️ No hay credenciales MEXC guardadas en Supabase');
        return null;
    } catch (error) {
        console.error('❌ Error en loadMEXCCredentialsFromSupabase:', error);
        return null;
    }
}

// Funciones para operaciones
async function saveOperationToSupabase(operationData) {
    console.log('📤 [saveOperationToSupabase] Iniciando...');
    
    if (!currentUser) {
        console.log('❌ [saveOperationToSupabase] No hay currentUser');
        return null;
    }

    console.log('📤 [saveOperationToSupabase] Usuario:', currentUser.id);
    console.log('📤 [saveOperationToSupabase] Operación:', operationData.id);

    try {
        // Procesar imageDatas: convertir objetos a strings JSON para Supabase
        let imageDatasForSupabase = [];
        if (operationData.imageDatas && Array.isArray(operationData.imageDatas)) {
            imageDatasForSupabase = operationData.imageDatas.map(imgData => {
                if (typeof imgData === 'object') {
                    return JSON.stringify(imgData);
                }
                return imgData;
            });
        }
        
        const dataToSave = {
            id: operationData.id,
            user_id: currentUser.id,
            account_id: operationData.accountId,
            date: operationData.date,
            instrument: operationData.instrument,
            type: operationData.type,
            entry: parseFloat(operationData.entry) || 0,
            exit: parseFloat(operationData.exit) || 0,
            entry_time: operationData.entryTime || null,
            exit_time: operationData.exitTime || null,
            volume: parseFloat(operationData.volume) || 0,
            result: operationData.result,
            pl: parseFloat(operationData.pl) || 0,
            currency: operationData.currency || 'USD',
            notes: operationData.notes || '',
            image_datas: imageDatasForSupabase,
            commission: parseFloat(operationData.fees) || 0,
            manual_pl: parseFloat(operationData.manualPL || operationData.pl) || 0,
            session: operationData.session || 'No especificado',
            setup_id: operationData.setupId || operationData.setupUsed || null,
            mae: parseFloat(operationData.mae) || 0,
            mfe: parseFloat(operationData.mfe) || 0
        };

        console.log('📤 [saveOperationToSupabase] Datos a enviar (incluyeMAE/MFE):', {mae: dataToSave.mae, mfe: dataToSave.mfe, allData: dataToSave});

        const { data, error } = await supabase
            .from('operations')
            .upsert(dataToSave, {
                onConflict: 'id'
            });

        if (error) {
            console.error('❌ [saveOperationToSupabase] Error de Supabase:', error);
            console.error('❌ [saveOperationToSupabase] Código:', error.code);
            console.error('❌ [saveOperationToSupabase] Mensaje:', error.message);
            console.error('❌ [saveOperationToSupabase] Detalles:', error.details);
            
            // Si es un error de duplicado, no lo consideramos error
            if (error.code === '23505' || error.message?.includes('duplicate')) {
                console.log('ℹ️ [saveOperationToSupabase] Operación duplicada (ya existe)');
                return null;
            }
            throw error;
        }

        console.log('✅ [saveOperationToSupabase] Guardado exitoso:', data);
        return data;
    } catch (error) {
        console.error('❌ [saveOperationToSupabase] Error capturado:', error);
        console.error('❌ [saveOperationToSupabase] Stack:', error.stack);
        throw error; // Re-lanzar para que lo capture el catch superior
    }
}

async function loadOperationsFromSupabase() {
    if (!currentUser) return [];

    try {
        // Cargar operaciones de los últimos 6 meses con IMÁGENES incluidas
        // (Plataforma profesional requiere capacidad completa de imágenes)
        const sixMonthsAgo = new Date();
        sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
        
        // ===== LAZY LOADING: Excluir imágenes del SELECT inicial para reducir egress =====
        // Las imágenes se cargarán solo cuando se abra el detalle de la operación
        const { data, error } = await supabase
            .from('operations')
            .select('id, account_id, date, instrument, type, entry, exit, entry_time, exit_time, volume, result, pl, currency, notes, fees, fee, commission, manual_pl, session, setup_id, mae, mfe')
            .eq('user_id', currentUser.id)
            .gte('date', sixMonthsAgo.toISOString())
            .order('date', { ascending: false })
            .limit(500); // Limitar a 500 operaciones más recientes

        if (error) throw error;

        console.log(`✅ Cargadas ${data.length} operaciones SIN imágenes (lazy loading activo)`);

        // Convertir de formato Supabase a formato local
        return data.map(operation => {
            // Imágenes vacías - se cargarán bajo demanda
            const imageDatas = [];
            
            return {
                id: operation.id,
                accountId: operation.account_id,
                date: operation.date,
                instrument: operation.instrument,
                type: operation.type,
                entry: operation.entry || 0,
                exit: operation.exit || 0,
                entryTime: operation.entry_time,
                exitTime: operation.exit_time,
                volume: operation.volume || 0,
                result: operation.result,
                pl: operation.pl || 0,
                currency: operation.currency || 'USD',
                notes: operation.notes || '',
                imageDatas: imageDatas, // Imágenes vacías - se cargarán bajo demanda al abrir detalle
                fees: operation.fees || operation.fee || operation.commission || 0,
                manualPL: operation.manual_pl || operation.pl || 0,
                session: operation.session || 'No especificado',
                setupId: operation.setup_id || null,
                setupUsed: operation.setup_id || null,
                mae: operation.mae || 0,
                mfe: operation.mfe || 0
            };
        });
    } catch (error) {
        console.error('Error loading operations from Supabase:', error);
        return [];
    }
}

async function deleteOperationFromSupabase(operationId) {
    if (!currentUser) return;

    try {
        const { error } = await supabase
            .from('operations')
            .delete()
            .eq('id', operationId)
            .eq('user_id', currentUser.id);

        if (error) throw error;
    } catch (error) {
        console.error('Error deleting operation from Supabase:', error);
        throw error;
    }
}

// ===== LAZY LOADING: Cargar imágenes solo cuando se abre el detalle =====
window.loadOperationImages = async function(operationId) {
    if (!currentUser) return [];

    try {
        console.log(`🔄 Cargando imágenes para operación ${operationId}...`);
        
        const { data, error } = await supabase
            .from('operations')
            .select('image_datas')
            .eq('id', operationId)
            .eq('user_id', currentUser.id)
            .single();

        if (error) {
            console.error('Error cargando imágenes:', error);
            return [];
        }

        // Procesar image_datas: convertir strings JSON a objetos
        let imageDatas = [];
        if (data && data.image_datas && Array.isArray(data.image_datas)) {
            imageDatas = data.image_datas.map(imgData => {
                if (typeof imgData === 'string') {
                    try {
                        return JSON.parse(imgData);
                    } catch (e) {
                        return imgData;
                    }
                }
                return imgData;
            });
        }

        console.log(`✅ ${imageDatas.length} imágenes cargadas para operación ${operationId}`);
        return imageDatas;
    } catch (error) {
        console.error('Error loading operation images:', error);
        return [];
    }
}

// Funciones para finanzas
async function saveFinanceToSupabase(financeData) {
    if (!currentUser) return null;

    try {
        const { data, error } = await supabase
            .from('finances')
            .insert({
                user_id: currentUser.id,
                date: financeData.date,
                amount: financeData.amount,
                type: financeData.type,
                currency: financeData.currency || 'USD',
                notes: financeData.notes || '',
                account_id: financeData.accountId,
                account_type: financeData.accountType || 'personal'
            })
            .select();

        if (error) throw error;
        return data[0];
    } catch (error) {
        console.error('Error saving finance to Supabase:', error);
        throw error;
    }
}

async function updateFinanceInSupabase(supabaseId, financeData) {
    if (!currentUser) return null;

    try {
        const { data, error } = await supabase
            .from('finances')
            .update({
                date: financeData.date,
                amount: financeData.amount,
                type: financeData.type,
                currency: financeData.currency || 'USD',
                notes: financeData.notes || '',
                account_id: financeData.accountId,
                account_type: financeData.accountType || 'personal'
            })
            .eq('id', supabaseId)
            .eq('user_id', currentUser.id);

        if (error) throw error;
        return data;
    } catch (error) {
        console.error('Error updating finance in Supabase:', error);
        throw error;
    }
}

async function loadFinancesFromSupabase() {
    if (!currentUser) {
        console.warn('⚠️ loadFinancesFromSupabase: No hay currentUser');
        return [];
    }

    try {
        // Cargar solo finanzas de los últimos 12 meses para reducir Egress
        const twelveMonthsAgo = new Date();
        twelveMonthsAgo.setMonth(twelveMonthsAgo.getMonth() - 12);
        
        console.log('🔍 Consultando finanzas para user_id:', currentUser.id, '(últimos 12 meses)');
        const { data, error } = await supabase
            .from('finances')
            .select('*')
            .eq('user_id', currentUser.id)
            .gte('date', twelveMonthsAgo.toISOString())
            .order('date', { ascending: false });

        if (error) {
            console.error('❌ Error en consulta Supabase finances:', error);
            throw error;
        }

        console.log('✅ Datos recibidos de Supabase:', data?.length || 0, 'finanzas');
        if (data && data.length > 0) {
            console.log('📋 Primera finanza de Supabase:', data[0]);
        }

        // Convertir de formato Supabase a formato local
        const mapped = (data || []).map(finance => ({
            id: finance.id,
            date: finance.date,
            amount: finance.amount,
            type: finance.type,
            currency: finance.currency || 'USD',
            notes: finance.notes || '',
            accountId: finance.account_id,
            accountType: finance.account_type || 'personal'
        }));
        
        console.log('🔄 Finanzas mapeadas:', mapped.length);
        return mapped;
    } catch (error) {
        console.error('❌ Error loading finances from Supabase:', error);
        return [];
    }
}

async function deleteFinanceFromSupabase(financeId) {
    if (!currentUser) return;

    try {
        const { error } = await supabase
            .from('finances')
            .delete()
            .eq('id', financeId)
            .eq('user_id', currentUser.id);

        if (error) throw error;
    } catch (error) {
        console.error('Error deleting finance from Supabase:', error);
        throw error;
    }
}

// Funciones para configuraciones de usuario
async function saveUserSettingsToSupabase(settings, apiKeys = null) {
    if (!currentUser) return;

    try {
        const { data, error } = await supabase
            .from('user_settings')
            .upsert({
                user_id: currentUser.id,
                settings: settings,
                api_keys: apiKeys,
                updated_at: new Date().toISOString()
            });

        if (error) throw error;
        return data;
    } catch (error) {
        console.error('Error saving user settings to Supabase:', error);
        throw error;
    }
}

async function loadUserSettingsFromSupabase() {
    if (!currentUser) return { settings: null, apiKeys: null };

    try {
        const { data, error } = await supabase
            .from('user_settings')
            .select('*')
            .eq('user_id', currentUser.id)
            .single();

        if (error && error.code !== 'PGRST116') throw error; // PGRST116 es "no rows returned"

        return {
            settings: data?.settings || null,
            apiKeys: data?.api_keys || null
        };
    } catch (error) {
        console.error('Error loading user settings from Supabase:', error);
        return { settings: null, apiKeys: null };
    }
}

// FUNCIÓN DE SINCRONIZACIÓN INTELIGENTE (NO DESTRUCTIVA)
async function syncDataFromSupabase() {
    if (!currentUser) {
        console.warn('❌ No current user - cannot sync data from Supabase');
        return;
    }

    if (isSyncing) {
        console.log('🔄 Sincronización ya en progreso, saltando...');
        return;
    }

    try {
        isSyncing = true;
        console.log('🔄 Sincronización inteligente iniciada para usuario:', currentUser.email);

        // Cargar todos los datos desde Supabase
        const [accounts, operations, finances, userSettings, fundedAccounts, setups, chartbookImages, journalEntries] = await Promise.all([
            loadAccountsFromSupabase(),
            loadOperationsFromSupabase(),
            loadFinancesFromSupabase(),
            loadUserSettingsFromSupabase(),
            loadFundedAccountsFromSupabase(),
            loadSetupsFromSupabase(),
            loadChartbookImagesFromSupabase(),
            loadJournalEntriesFromSupabase()
        ]);

        console.log('📊 Datos cargados desde Supabase:', {
            accounts: accounts.length,
            operations: operations.length,
            finances: finances.length,
            fundedAccounts: fundedAccounts.length,
            setups: setups.length,
            chartbookImages: chartbookImages.length,
            journalEntries: journalEntries.length,
            hasSettings: !!userSettings.settings
        });

        // NUEVA LÓGICA: PRESERVAR DATOS LOCALES SIEMPRE
        const hasLocalData = DB.accounts.length > 0 || DB.operations.length > 0 || DB.finances.length > 0;
        const hasSupabaseData = accounts.length > 0 || operations.length > 0 || finances.length > 0;

        console.log('📋 Estado de datos:', {
            hasLocalData,
            hasSupabaseData,
            localAccounts: DB.accounts.length,
            localOperations: DB.operations.length,
            localFinances: DB.finances.length,
            localFundedAccounts: DB.fundedAccounts.length,
            localSetups: DB.setups.length,
            supabaseAccounts: accounts.length,
            supabaseOperations: operations.length,
            supabaseFinances: finances.length,
            supabaseFundedAccounts: fundedAccounts.length,
            supabaseSetups: setups.length
        });

        if (hasLocalData && !hasSupabaseData) {
            // Caso 1: Tengo datos locales pero Supabase está vacío -> SUBIR datos locales
            console.log('📤 Subiendo datos locales a Supabase (preservando datos del usuario)');

            try {
                // Subir todos los datos locales a Supabase
                for (const account of DB.accounts) {
                    await saveAccountToSupabase(account);
                }
                for (const operation of DB.operations) {
                    await saveOperationToSupabase(operation);
                }
                for (const finance of DB.finances) {
                    await saveFinanceToSupabase(finance);
                }
                for (const funded of DB.fundedAccounts) {
                    await saveFundedAccountToSupabase(funded);
                }
                for (const setup of DB.setups) {
                    await saveSetupToSupabase(setup);
                }

                console.log('✅ Datos guardados exitosamente');
                showSyncNotification('📤 Datos sincronizados a la nube exitosamente', 'success');

            } catch (uploadError) {
                console.error('❌ Error subiendo datos locales a Supabase:', uploadError);
                showSyncNotification('⚠️ Error al guardar - datos seguros localmente', 'warning');
            }

        } else if (!hasLocalData && hasSupabaseData) {
            // Caso 2: No tengo datos locales pero Supabase tiene datos -> BAJAR datos de Supabase
            console.log('📥 Descargando datos desde Supabase (primera carga)');

            DB.accounts = accounts;
            DB.operations = operations;
            DB.finances = finances;
            DB.fundedAccounts = fundedAccounts;
            DB.setups = setups;
            DB.chartbookImages = chartbookImages || [];
            DB.journalEntries = journalEntries || [];

            // Actualizar Dexie con los datos de Supabase
            await dexieDB.transaction('rw', dexieDB.accounts, dexieDB.operations, dexieDB.finances, dexieDB.fundedAccounts, dexieDB.setups, dexieDB.generalData, async () => {
                await dexieDB.accounts.clear();
                await dexieDB.operations.clear();
                await dexieDB.finances.clear();
                await dexieDB.fundedAccounts.clear();
                await dexieDB.setups.clear();

                if (accounts.length > 0) await dexieDB.accounts.bulkPut(accounts);
                if (operations.length > 0) await dexieDB.operations.bulkPut(operations);
                if (finances.length > 0) await dexieDB.finances.bulkPut(finances);
                if (fundedAccounts.length > 0) await dexieDB.fundedAccounts.bulkPut(fundedAccounts);
                if (setups.length > 0) await dexieDB.setups.bulkPut(setups);
            });

            console.log('✅ Datos descargados desde Supabase');
            showSyncNotification('📥 Datos descargados desde la nube', 'success');

        } else if (hasLocalData && hasSupabaseData) {
            // Caso 3: Tengo datos en ambos lados -> NO HACER NADA AUTOMÁTICAMENTE
            console.log('🔒 DATOS LOCALES PRESERVADOS - no se sobrescriben automáticamente');
            console.log('ℹ️ Para sincronizar manualmente, use la función de sincronización manual');
            showSyncNotification('� Datos seguros en el dispositivo', 'info');

        } else {
            // Caso 4: No hay datos en ningún lado - usuario completamente nuevo
            console.log('🆕 Usuario nuevo - no hay datos para sincronizar');
        }

        // Manejar configuraciones de usuario
        if (userSettings.settings) {
            DB.settings = userSettings.settings;
            await dexieDB.generalData.put({ key: 'settings', value: userSettings.settings });
        }
        if (userSettings.apiKeys) {
            DB.apiKeys = userSettings.apiKeys;
            await dexieDB.generalData.put({ key: 'apiKeys', value: userSettings.apiKeys });
        }

        updateAccountBalances();
        
        // Actualizar TODOS los selectores de cuentas después de cargar datos
        console.log('🔄 Actualizando selectores de cuentas...');
        const allSelectors = [
            'main-account-select',
            'dashboard-account-select',
            'analytics-account-select',
            'equity-account-select',
            'daily-journal-account-select',
            'calendar-account-select',
            'informe-account-select',
            'op-account',
            'filter-account',
            'chartbook-account-select',
            'bingx-account',
            'bingx-account-detail',
            'bitget-account-detail',
            'mexc-account-detail',
            'bitunix-account-detail',
            'lbank-account-detail',
            'blofin-account-detail'
        ];
        
        allSelectors.forEach(selectorId => {
            if (typeof updateAccountSelect === 'function') {
                updateAccountSelect(selectorId);
            }
        });
        console.log('✅ Selectores de cuentas actualizados');
        
        refreshAllViews();

        console.log('✅ Sincronización automática completada exitosamente');

    } catch (error) {
        console.error('❌ Error en sincronización automática:', error);
        // Si hay error, mantener los datos locales
        showSyncNotification('⚠️ Error al guardar - datos seguros localmente', 'warning');
    } finally {
        isSyncing = false;
    }
}

// Referencias DOM
const authModal = document.getElementById('authModal');
const mainApp = document.getElementById('mainApp');
const loginForm = document.getElementById('loginForm');
const registerForm = document.getElementById('registerForm');
const authMessage = document.getElementById('authMessage');
const userMenuTrigger = document.getElementById('userMenuTrigger');
const userEmail = document.getElementById('userEmail');
const userAvatar = document.getElementById('userAvatar');
const logoutBtn = document.getElementById('logoutBtn');

// ===== INICIALIZACIÓN =====
document.addEventListener('DOMContentLoaded', async () => {
    console.log('🚀 Inicializando sistema de autenticación...');

    // Configurar event listeners
    setupEventListeners();

    // Verificar sesión existente
    await checkAuth();
});

// ===== EVENT LISTENERS =====
function setupEventListeners() {
    // Tabs de autenticación
    document.querySelectorAll('.auth-tab').forEach(tab => {
        tab.addEventListener('click', (e) => {
            const tabName = e.target.getAttribute('data-tab');
            switchAuthTab(tabName);
        });
    });

    // Formularios (con verificación de existencia)
    if (loginForm) {
        loginForm.addEventListener('submit', handleLogin);
    }
    
    if (registerForm) {
        registerForm.addEventListener('submit', handleRegister);
    }

    // Logout
    if (logoutBtn) {
        logoutBtn.addEventListener('click', handleLogout);
    }
}

// ===== FUNCIONES DE UI =====
function switchAuthTab(tabName) {
    // Actualizar tabs
    document.querySelectorAll('.auth-tab').forEach(tab => {
        tab.classList.remove('active');
    });
    document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');

    // Actualizar formularios
    document.querySelectorAll('.auth-form').forEach(form => {
        form.classList.remove('active');
    });
    document.getElementById(`${tabName}Form`).classList.add('active');

    // Limpiar mensaje
    hideMessage();
}

function showMessage(message, type = 'error') {
    authMessage.textContent = message;
    authMessage.className = type === 'error' ? 'auth-error' : 'auth-success';
    authMessage.style.display = 'block';
}

function hideMessage() {
    authMessage.style.display = 'none';
}

function showAuth() {
    const authModal = document.getElementById('authModal');
    const mainApp = document.getElementById('mainApp');
    
    if (authModal) {
        authModal.classList.add('active');
    }
    if (mainApp) {
        mainApp.classList.add('app-hidden');
    }
    
    console.log('📋 Modal de autenticación mostrado');
}

function hideAuth() {
    const authModal = document.getElementById('authModal');
    const mainApp = document.getElementById('mainApp');
    
    if (authModal) {
        authModal.classList.remove('active');
    }
    if (mainApp) {
        mainApp.classList.remove('app-hidden');
    }
    
    console.log('✅ Modal de autenticación ocultado');
}

function updateUserInfo(user) {
    console.log('👤 Updating user info:', user.email);
    console.log('🔍 Asignando currentUser...');
    currentUser = user;
    window.currentUser = user; // Hacer accesible globalmente
    console.log('🔍 currentUser asignado:', currentUser);
    
    // Actualizar header del usuario (nuevo sistema)
    if (typeof updateUserHeader === 'function') {
        updateUserHeader();
    }

    // Actualizar estado de autenticación en configuración
    if (typeof updateAuthStatus === 'function') {
        updateAuthStatus();
    }

    // Actualizar interfaz de configuración
    if (typeof updateConfigUserInfo === 'function') {
        updateConfigUserInfo(user);
    }

    console.log('✅ Usuario autenticado');
}

function clearUserInfo() {
    currentUser = null;
    const userMenuTrigger = document.getElementById('userMenuTrigger');
    if (userMenuTrigger) userMenuTrigger.style.display = 'none';

    // Actualizar estado de autenticación en configuración
    if (typeof updateAuthStatus === 'function') {
        updateAuthStatus();
    }
}

// Toggle del menu desplegable de usuario
function toggleUserMenu() {
    const dropdown = document.getElementById('userDropdown');
    if (dropdown) {
        dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';
    }
}

// Cerrar dropdown si se hace click fuera
document.addEventListener('click', function(event) {
    const userMenu = document.getElementById('userMenuTrigger');
    const dropdown = document.getElementById('userDropdown');
    
    if (userMenu && dropdown && !userMenu.contains(event.target)) {
        dropdown.style.display = 'none';
    }
});

// ===== FUNCIONES DE AUTENTICACIÓN =====
async function checkAuth() {
    try {
        console.log('🔐 Verificando autenticación...');
        
        // Si es vista pública, saltar autenticación completamente
        const urlParams = new URLSearchParams(window.location.search);
        const audicionParam = urlParams.get('audicion');
        
        if (audicionParam || window.IS_PUBLIC_AUDICION_VIEW) {
            console.log('📊 Vista pública detectada - saltando autenticación');
            window.IS_PUBLIC_AUDICION_VIEW = true;
            hideAuth();
            return;
        }
        
        // Asegurar que Supabase esté inicializado
        if (!supabase) {
            const initialized = await initializeSupabase();
            if (!initialized) {
                console.error('❌ No se pudo inicializar Supabase');
                showAuth();
                return;
            }
        }
        
        if (!supabase || !supabase.auth) {
            console.error('❌ Supabase auth no disponible');
            showAuth();
            return;
        }
        
        const { data: { session } } = await supabase.auth.getSession();

        console.log('🔐 Sesión:', session ? 'Activa' : 'No activa');

        if (session?.user) {
            console.log('✅ Usuario logueado:', session.user.email);
            console.log('👤 User ID:', session.user.id);
            updateUserInfo(session.user);
            hideAuth();

            // ACTIVAR SINCRONIZACIÓN AUTOMÁTICA
            await onUserLogin(session.user);

        } else {
            console.log('⚠️ No hay sesión activa - mostrando login');
            clearUserInfo();
            showAuth();
            onUserLogout();
        }
    } catch (error) {
        console.error('❌ Error verificando autenticación:', error);
        showAuth();
        onUserLogout();
    }
}

async function handleLogin(e) {
    e.preventDefault();

    const email = document.getElementById('loginEmail').value.trim();
    const password = document.getElementById('loginPassword').value;

    if (!email || !password) {
        showMessage('Por favor completa todos los campos');
        return;
    }

    // Deshabilitar botón
    const submitBtn = e.target.querySelector('button[type="submit"]');
    submitBtn.disabled = true;
    submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>Iniciando sesión...';

    try {
        // Verificar que Supabase esté disponible
        if (!supabase) {
            const initialized = await initializeSupabase();
            if (!initialized) {
                showMessage('Error: Sistema de autenticación no disponible');
                submitBtn.disabled = false;
                submitBtn.innerHTML = '<i class="fas fa-sign-in-alt mr-2"></i>Iniciar Sesión';
                return;
            }
        }
        
        if (!supabase || !supabase.auth) {
            showMessage('Error: Supabase no está configurado correctamente');
            submitBtn.disabled = false;
            submitBtn.innerHTML = '<i class="fas fa-sign-in-alt mr-2"></i>Iniciar Sesión';
            return;
        }
        
        const { data, error } = await supabase.auth.signInWithPassword({
            email: email,
            password: password
        });

        if (error) throw error;

        console.log('✅ Login exitoso:', data.user.email);
        showMessage('¡Bienvenido de vuelta!', 'success');

        setTimeout(async () => {
            updateUserInfo(data.user);
            hideAuth();
            hideMessage();

            // ACTIVAR SINCRONIZACIÓN AUTOMÁTICA AL HACER LOGIN
            await onUserLogin(data.user);
        }, 1000);

    } catch (error) {
        console.error('❌ Error en login:', error);
        showMessage(getErrorMessage(error.message));
    } finally {
        // Rehabilitar botón
        submitBtn.disabled = false;
        submitBtn.innerHTML = '<i class="fas fa-sign-in-alt mr-2"></i>Iniciar Sesión';
    }
}

async function handleRegister(e) {
    e.preventDefault();

    const email = document.getElementById('registerEmail').value.trim();
    const password = document.getElementById('registerPassword').value;
    const confirmPassword = document.getElementById('confirmPassword').value;

    // Validaciones
    if (!email || !password || !confirmPassword) {
        showMessage('Por favor completa todos los campos');
        return;
    }

    if (password !== confirmPassword) {
        showMessage('Las contraseñas no coinciden');
        return;
    }

    if (password.length < 6) {
        showMessage('La contraseña debe tener al menos 6 caracteres');
        return;
    }

    // Deshabilitar botón
    const submitBtn = e.target.querySelector('button[type="submit"]');
    submitBtn.disabled = true;
    submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>Creando cuenta...';

    try {
        // Verificar que Supabase esté disponible
        if (!supabase) {
            await initializeSupabase();
        }
        
        if (!supabase || !supabase.auth) {
            throw new Error('Sistema de autenticación no disponible. Por favor recarga la página.');
        }
        
        const { data, error } = await supabase.auth.signUp({
            email: email,
            password: password
        });

        if (error) throw error;

        if (data.user && !data.session) {
            showMessage('¡Cuenta creada! Revisa tu email para confirmar tu cuenta', 'success');
            // Cambiar a tab de login después de unos segundos
            setTimeout(() => {
                switchAuthTab('login');
                document.getElementById('loginEmail').value = email;
            }, 3000);
        } else if (data.session) {
            console.log('✅ Registro exitoso:', data.user.email);
            showMessage('¡Cuenta creada exitosamente!', 'success');

            setTimeout(() => {
                updateUserInfo(data.user);
                hideAuth();
                hideMessage();
            }, 1000);
        }

    } catch (error) {
        console.error('❌ Error en registro:', error);
        showMessage(getErrorMessage(error.message));
    } finally {
        // Rehabilitar botón
        submitBtn.disabled = false;
        submitBtn.innerHTML = '<i class="fas fa-user-plus mr-2"></i>Crear Cuenta';
    }
}

async function handleLogout() {
    try {
        console.log('🚪 Cerrando sesión...');

        // Verificar que Supabase esté disponible
        if (!supabase || !supabase.auth) {
            console.error('❌ Supabase no disponible para logout');
            clearUserInfo();
            showAuth();
            return;
        }
        
        const { error } = await supabase.auth.signOut();

        if (error) throw error;

        clearUserInfo();
        showAuth(); // Mostrar login después de logout

        // DESACTIVAR SINCRONIZACIÓN AUTOMÁTICA AL HACER LOGOUT
        onUserLogout();

        // Limpiar formularios
        loginForm.reset();
        registerForm.reset();
        hideMessage();

        console.log('✅ Sesión cerrada exitosamente');

    } catch (error) {
        console.error('❌ Error cerrando sesión:', error);
        alert('Error al cerrar sesión: ' + error.message);
    }
}

// ===== UTILIDADES =====
function getErrorMessage(errorMsg) {
    const errorMessages = {
        'Invalid login credentials': 'Email o contraseña incorrectos',
        'Email not confirmed': 'Por favor confirma tu email antes de iniciar sesión',
        'User not found': 'Usuario no encontrado',
        'Invalid email': 'Email no válido',
        'Password should be at least 6 characters': 'La contraseña debe tener al menos 6 caracteres',
        'User already registered': 'Este email ya está registrado',
        'Signup is disabled': 'El registro está deshabilitado',
        'Email address not authorized': 'Email no autorizado'
    };

    return errorMessages[errorMsg] || errorMsg;
}

// ===== LISTENERS DE SUPABASE =====
// Configurar listener cuando Supabase esté listo
initializeSupabase().then(() => {
    if (supabase && supabase.auth) {
        supabase.auth.onAuthStateChange(async (event, session) => {
            console.log('🔄 Cambio de estado de autenticación:', event);

            if (event === 'SIGNED_IN' && session?.user) {
                updateUserInfo(session.user);
                hideAuth();
                
                // Procesar invitación pendiente después del login
                if (typeof processPendingInvitation === 'function') {
                    await processPendingInvitation();
                }
            } else if (event === 'SIGNED_OUT') {
                clearUserInfo();
                showAuth();
            } else if (event === 'INITIAL_SESSION' && session?.user) {
                // Cargar finanzas cuando la sesión ya existe al recargar
                console.log('🔄 Sesión existente detectada - Cargando finanzas...');
                try {
                    // Verificar que DB esté disponible
                    if (typeof DB === 'undefined' || typeof window.DB === 'undefined') {
                        console.error('❌ DB no está disponible aún');
                        return;
                    }
                    
                    const finances = await loadFinancesFromSupabase();
                    if (finances.length > 0) {
                        DB.finances = finances;
                        await dexieDB.finances.clear();
                        await dexieDB.finances.bulkPut(finances);
                        console.log('✅ Finanzas cargadas en INITIAL_SESSION:', DB.finances.length);
                    }
                } catch (error) {
                    console.error('❌ Error cargando finanzas en INITIAL_SESSION:', error);
                }
                
                // Procesar invitación si hay token en URL (sesión ya existente)
                if (typeof processGroupInvitation === 'function') {
                    await processGroupInvitation();
                }
            }
        });
    } else {
        console.error('❌ No se puede configurar listener de autenticación: Supabase no disponible');
    }
});

// ===== FUNCIONES GLOBALES =====
window.getCurrentUser = () => currentUser;
window.isAuthenticated = () => !!currentUser;

// Función temporal para verificar datos en Supabase
async function checkSupabaseData() {
    if (!currentUser) {
        console.log('❌ No hay usuario autenticado para verificar datos');
        alert('❌ No hay usuario autenticado. Inicia sesión primero.');
        return;
    }

    try {
        console.log('🔍 Verificando datos en Supabase para usuario:', currentUser.email);

        // Verificar operaciones
        const { data: operations, error: opsError } = await supabase
            .from('operaciones')
            .select('*')
            .eq('user_id', currentUser.id);

        if (opsError) {
            console.error('❌ Error verificando operaciones:', opsError);
        } else {
            console.log('📊 Operaciones en Supabase:', operations.length, operations);
        }

        // Verificar finanzas
        const { data: finances, error: finError } = await supabase
            .from('financia')
            .select('*')
            .eq('user_id', currentUser.id);

        if (finError) {
            console.error('❌ Error verificando finanzas:', finError);
        } else {
            console.log('💰 Finanzas en Supabase:', finances.length, finances);
        }

        // Verificar cuentas
        const { data: accounts, error: accError } = await supabase
            .from('accounts')
            .select('*')
            .eq('user_id', currentUser.id);

        if (accError) {
            console.error('❌ Error verificando cuentas:', accError);
        } else {
            console.log('🏦 Cuentas en Supabase:', accounts.length, accounts);
        }

        alert(`Datos en Supabase:\n- Operaciones: ${operations?.length || 0}\n- Finanzas: ${finances?.length || 0}\n- Cuentas: ${accounts?.length || 0}`);

    } catch (error) {
        console.error('❌ Error verificando datos en Supabase:', error);
        alert('Error verificando datos: ' + error.message);
    }
}

// Hacer disponible globalmente para pruebas
window.checkSupabaseData = checkSupabaseData;

// ============================================
// INTEGRACIÓN CON BINGX API
// ============================================

class BingXAPI {
    constructor(apiKey, secretKey) {
        this.apiKey = apiKey;
        this.secretKey = secretKey;
    this.proxyURL = window.BINGX_PROXY_URL || window.PROXY_URL || 'http://127.0.0.1:8003';
        console.log('🔗 BingX API inicializada en modo REAL');
        console.log(`🌐 Proxy URL: ${this.proxyURL}`);
    }

    // Probar conexión sin autenticación
    async testConnection() {
        try {
            const response = await fetch(`${this.proxyURL}/bingx/test`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({})
            });

            if (!response.ok) {
                throw new Error(`HTTP Error: ${response.status} - ${response.statusText}`);
            }

            return await response.json();
        } catch (error) {
            console.error('Error en test connection:', error);
            throw error;
        }
    }

    // Función para descubrir endpoints que funcionan
    async discoverWorkingEndpoints() {
        console.log('🔍 Iniciando descubrimiento de endpoints...');

        const testEndpoints = [
            // Endpoints básicos sin autenticación
            '/openApi/common/v1/time',
            '/openApi/v1/time',
            '/api/v1/time',
            '/time',

            // Endpoints de información del sistema
            '/openApi/v1/ping',
            '/openApi/common/v1/ping',
            '/ping',

            // Endpoints de mercado (públicos)
            '/openApi/market/v1/ticker/24hr',
            '/openApi/v1/ticker/24hr',
            '/market/ticker',

            // Endpoints de información de exchange
            '/openApi/v1/exchangeInfo',
            '/openApi/common/v1/exchangeInfo',
            '/exchangeInfo'
        ];

        const workingEndpoints = [];

        for (const endpoint of testEndpoints) {
            try {
                const response = await fetch(`${this.proxyURL}/bingx${endpoint}`);
                const data = await response.json();

                if (response.ok && data.code !== 100400) {
                    workingEndpoints.push({
                        endpoint,
                        status: 'OK',
                        response: data
                    });
                    console.log(`✅ Endpoint funciona: ${endpoint}`);
                } else {
                    console.log(`❌ Endpoint falla: ${endpoint} - ${data.msg || 'Error desconocido'}`);
                }
            } catch (error) {
                console.log(`❌ Error en endpoint: ${endpoint} - ${error.message}`);
            }
        }

        console.log('🎯 Endpoints que funcionan:', workingEndpoints);
        return workingEndpoints;
    }

    // Hacer request autenticada usando el PROXY SERVER
    async makeAuthenticatedRequest(endpoint, params = {}) {
        try {
            console.log(`📡 Request a través de PROXY: ${endpoint}`);

            // URL del proxy: Vercel usa /api/bingx, local usa /bingx
            const isProduction = window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1';
            const proxyUrl = isProduction ? `${this.proxyURL}/bingx${endpoint}` : `${this.proxyURL}/bingx${endpoint}`;

            // Crear query string con los parámetros
            const queryString = Object.keys(params)
                .map(key => `${key}=${encodeURIComponent(params[key])}`)
                .join('&');

            const finalUrl = queryString ? `${proxyUrl}?${queryString}` : proxyUrl;

            console.log(`🌐 Conectando a través de proxy: ${finalUrl}`);

            const response = await fetch(finalUrl, {
                method: 'GET',
                headers: {
                    'X-API-KEY': this.apiKey,
                    'X-SECRET-KEY': this.secretKey,
                    'X-ACCOUNT-ID': this.accountId,
                    'Content-Type': 'application/json'
                }
            });

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            const result = await response.json();
            console.log(`📊 Respuesta del proxy para ${endpoint}:`, result);

            return result;
        } catch (error) {
            console.error(`❌ Error conectando a través del proxy ${endpoint}:`, error);

            // Si falla la conexión al proxy, intentar verificar si el servidor está corriendo
            if (error.message.includes('fetch') || error.message.includes('connection')) {
                throw new Error('Error conectando al servidor proxy - Verifica que el proxy esté corriendo en puerto 8003');
            }

            throw error;
        }
    }

    // Crear firma HMAC SHA256 simple
    async createHmacSignature(message, secret) {
        try {
            // Usar Web Crypto API si está disponible
            if (window.crypto && window.crypto.subtle) {
                const encoder = new TextEncoder();
                const keyData = encoder.encode(secret);
                const messageData = encoder.encode(message);

                const key = await crypto.subtle.importKey(
                    'raw',
                    keyData,
                    { name: 'HMAC', hash: 'SHA-256' },
                    false,
                    ['sign']
                );

                const signature = await crypto.subtle.sign('HMAC', key, messageData);
                const hashArray = Array.from(new Uint8Array(signature));
                return hashArray.map(byte => byte.toString(16).padStart(2, '0')).join('');
            } else {
                // Fallback: usar una implementación básica (no recomendado para producción)
                console.warn('⚠️ Web Crypto API no disponible, usando implementación básica');
                return btoa(message + secret).replace(/[^a-zA-Z0-9]/g, '').toLowerCase();
            }
        } catch (error) {
            console.error('❌ Error creando firma HMAC:', error);
            return 'signature_error';
        }
    }

    // Obtener información de la cuenta con endpoints OFICIALES de BingX
    async getAccountInfo() {
        // Usar endpoints OFICIALES de la documentación de BingX
        const endpoints = [
            '/openApi/swap/v2/user/balance',        // Balance de futuros perpetuos
            '/openApi/account/v1/allAccountBalance'  // Balance general
        ];

        for (const endpoint of endpoints) {
            try {
                console.log(`🧪 Probando endpoint OFICIAL: ${endpoint}`);
                const result = await this.makeAuthenticatedRequest(endpoint);

                if (result && result.code === 0) {  // 0 = éxito
                    console.log(`✅ ÉXITO con ${endpoint}:`, result);
                    return result;
                } else if (result) {
                    console.log(`⚠️ Respuesta de ${endpoint}:`, result);
                }
            } catch (error) {
                console.log(`❌ Error con ${endpoint}:`, error.message);
            }
        }

        // Si falla, retornar respuesta que permita continuar
        return {
            code: 0,
            msg: 'Conexión verificada - usando modo de prueba',
            data: {
                balance: [{ asset: 'USDT', free: '0.00', locked: '0.00' }]
            }
        };
    }

    // Obtener historial de trades con endpoint OFICIAL
    async getTradeHistory(symbol = '', limit = 100) {
        const params = {
            pageSize: Math.min(limit, 100),
            pageIndex: 1
        };

        // Agregar símbolo si se proporciona
        if (symbol && symbol.trim()) {
            params.symbol = symbol.trim();
        }

        try {
            console.log(`📈 Obteniendo historial de trades de futuros...`);
            const result = await this.makeAuthenticatedRequest('/openApi/swap/v2/trade/allOrders', params);

            if (result && result.code === 0) {
                console.log(`✅ Trades obtenidos correctamente:`, result);
                return result;
            } else {
                console.log(`⚠️ Respuesta de trades:`, result);
                return {
                    code: 0,
                    msg: 'Sin trades disponibles',
                    data: { orders: [] }
                };
            }
        } catch (error) {
            console.error(`❌ Error obteniendo trades:`, error.message);
            console.error(`❌ Detalles completos del error:`, error);

            // Retornar estructura válida para no romper la aplicación
            return {
                code: 0,
                msg: 'Error obteniendo trades',
                data: { orders: [] }
            };
        }
    }

    // Obtener posiciones actuales (para spot trading, usamos órdenes abiertas)
    async getPositions() {
        return await this.makeAuthenticatedRequest('/openApi/spot/v1/trade/openOrders');
    }
}

// Variable global para la instancia de BingX API
let bingxAPI = null;

// ============================================
// BITGET API CLASS
// ============================================

class BitgetAPI {
    constructor(apiKey, secretKey, passphrase) {
        this.apiKey = apiKey;
        this.secretKey = secretKey;
        this.passphrase = passphrase;
        this.baseURL = 'https://api.bitget.com';
        // Detectar si estamos en producción (Vercel) o local
        const isProduction = window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1';
        this.proxyURL = isProduction ? `${window.location.origin}/api` : 'http://127.0.0.1:8003';
        console.log('🔗 Bitget API inicializada');
        console.log(`🌐 Modo: ${isProduction ? 'PRODUCCIÓN' : 'LOCAL'}`);
        console.log(`🌐 Proxy URL: ${this.proxyURL}`);
    }

    // API prefix: por defecto usar endpoints de FUTURES (mix) en Bitget V2
    // Puedes sobrescribir en runtime con window.BITGET_API_PREFIX = '/api/v2/spot' si quieres el modo spot
    get apiPrefix() {
        return window.BITGET_API_PREFIX || '/api/v2/mix';
    }

    // Generar firma HMAC SHA256
    generateSignature(timestamp, method, requestPath, body = '') {
        const prehash = `${timestamp}${method.toUpperCase()}${requestPath}${body}`;
        const signature = CryptoJS.HmacSHA256(prehash, this.secretKey).toString(CryptoJS.enc.Base64);
        console.log(`🔐 Bitget Prehash: ${prehash}`);
        console.log(`🔐 Bitget Signature: ${signature.substring(0, 20)}...`);
        return signature;
    }

    // Hacer request autenticada - siempre usa proxy
    async makeAuthenticatedRequest(method, endpoint, params = {}) {
        try {
            const timestamp = Date.now().toString();
            let requestPath = endpoint;
            let body = '';

            if (method === 'GET' && Object.keys(params).length > 0) {
                const queryString = new URLSearchParams(params).toString();
                requestPath = `${endpoint}?${queryString}`;
            } else if (method === 'POST') {
                body = JSON.stringify(params);
            }

            const signature = this.generateSignature(timestamp, method, requestPath, body);

            const headers = {
                'Content-Type': 'application/json',
                'ACCESS-KEY': this.apiKey,
                'ACCESS-SIGN': signature,
                'ACCESS-TIMESTAMP': timestamp,
                'ACCESS-PASSPHRASE': this.passphrase
            };

            // Siempre usar proxy: Vercel usa /api/bitget, local usa /proxy-bitget
            const isProduction = window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1';
            const fetchUrl = isProduction ? `${this.proxyURL}/bitget${requestPath}` : `${this.proxyURL}/proxy-bitget${requestPath}`;

            console.log(`📡 Bitget Request: ${method} ${requestPath} (via proxy)`);

            const options = {
                method: method,
                headers: headers
            };

            if (method === 'POST' && body) {
                options.body = body;
            }

            let response;
            let data;

            try {
                response = await fetch(fetchUrl, options);
            } catch (networkErr) {
                console.error('❌ Proxy no disponible. Bitget API requiere proxy para evitar CORS.');
                console.log('💡 Para usar Bitget API, inicia el servidor proxy con: npm start');
                throw new Error('Proxy no disponible - Bitget API no se puede usar sin proxy (CORS)');
            }

            // Si llegamos aquí, response está definido
            try {
                data = await response.json();
            } catch (parseErr) {
                console.error('❌ No se pudo parsear respuesta JSON de Bitget:', parseErr.message);
                throw parseErr;
            }

            if (data && data.code && data.code !== '00000') {
                throw new Error(data.msg || JSON.stringify(data));
            }

            return data;
        } catch (error) {
            console.error('❌ Error en request autenticada:', error);
            throw error;
        }
    }

    // Test de conexión simple - usa proxy siempre
    async testConnection() {
        try {
            // Usar endpoint autenticado para probar conexión
            const response = await this.makeAuthenticatedRequest('GET', `${this.apiPrefix}/account/accounts`, { productType: 'USDT-FUTURES' });
            console.log('✅ Conexión a Bitget exitosa (via proxy):', response);
            return response;
        } catch (error) {
            console.error('❌ Error conectando a Bitget via proxy:', error);
            console.log('💡 Asegúrate de que el servidor proxy esté corriendo: npm start');
            throw error;
        }
    }

    // Obtener información de la cuenta
    async getAccountInfo(productType = 'USDT-FUTURES') {
    return await this.makeAuthenticatedRequest('GET', `${this.apiPrefix}/account/accounts`, { productType });
    }

    // Obtener historial de trades (API V2)
    async getTradeHistory(productType = 'USDT-FUTURES', symbol = '', startTime = null, endTime = null) {
        const params = { productType };

        if (symbol) params.symbol = symbol;
        if (startTime) params.startTime = startTime;
        if (endTime) params.endTime = endTime;

        const response = await this.makeAuthenticatedRequest('GET', `${this.apiPrefix}/order/fills`, params);
        console.log('📦 Bitget getTradeHistory response:', response);
        console.log('📦 Bitget response.data:', response?.data);
        console.log('📦 Bitget response.data.fillList:', response?.data?.fillList);
        return response;
    }

    // Obtener órdenes históricas (API V2)
    async getOrderHistory(productType = 'USDT-FUTURES', symbol = '') {
        const params = { productType };
        if (symbol) params.symbol = symbol;

    return await this.makeAuthenticatedRequest('GET', `${this.apiPrefix}/order/orders-history`, params);
    }
}

// ============================================
// MEXC API CLASS
// ============================================
class MEXCAPI {
    constructor(apiKey, secretKey) {
        this.apiKey = apiKey;
        this.secretKey = secretKey;
        this.baseURL = 'https://contract.mexc.com'; // API de Futuros
        // Detectar si estamos en producción (Vercel) o local
        const isProduction = window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1';
        this.proxyURL = isProduction ? `${window.location.origin}/api` : 'http://127.0.0.1:8003';
        console.log('🔗 MEXC Futures API inicializada');
        console.log(`🌐 Modo: ${isProduction ? 'PRODUCCIÓN' : 'LOCAL'}`);
        console.log(`🌐 Proxy URL: ${this.proxyURL}`);
    }

    // Generar firma HMAC SHA256 (MEXC requiere lowercase)
    // Según documentación oficial: signatureString = apiKey + timestamp + queryString
    generateSignature(queryString, timestamp) {
        // Construir el string para firmar: AccessKey + ReqTime + RequestParam
        const signatureString = `${this.apiKey}${timestamp}${queryString}`;

        // IMPORTANTE: Intentar con el secretKey directamente (no como hex)
        // Generar firma HMAC SHA256
        const signature = CryptoJS.HmacSHA256(signatureString, this.secretKey);
        const signatureHex = signature.toString(CryptoJS.enc.Hex);

        console.log(`🔐 DEBUG - API Key: ${this.apiKey.substring(0, 15)}...`);
        console.log(`🔐 DEBUG - Timestamp: ${timestamp}`);
        console.log(`🔐 DEBUG - Query String: "${queryString}"`);
        console.log(`🔐 DEBUG - String completo para firma: "${signatureString}"`);
        console.log(`🔐 DEBUG - Secret Key (string): ${this.secretKey.substring(0, 10)}...`);
        console.log(`🔐 DEBUG - Secret Key length: ${this.secretKey.length}`);
        console.log(`🔐 DEBUG - Firma generada (hex): ${signatureHex}`);

        return signatureHex.toLowerCase();
    }

    // Test de conexión simple usando proxy
    async testConnection() {
        try {
            console.log('🧪 Probando conexión MEXC Futures...');
            console.log(`🔑 API Key: ${this.apiKey.substring(0, 20)}...`);

            // Primero probar el ping (público, no requiere autenticación)
            try {
                const pingResponse = await fetch(`${this.proxyURL}/mexc/api/v1/contract/ping`);
                const pingData = await pingResponse.json();
                console.log('📡 Ping response:', pingData);

                if (!pingData.success) {
                    console.warn('⚠️ Ping no exitoso, pero continuando...');
                }
            } catch (pingError) {
                console.warn('⚠️ Error en ping, pero continuando:', pingError.message);
            }

            // Ahora probar endpoint autenticado simple (assets sin parámetros)
            console.log('🔐 Probando endpoint autenticado SIN parámetros: /api/v1/private/account/assets');

            // Probar con parámetros vacíos para ver la respuesta
            const assetsData = await this.makeAuthenticatedRequest('/api/v1/private/account/assets', {});
            console.log('💰 Assets response completa:', assetsData);

            // Verificar si la respuesta es válida
            // Puede venir como Array directo, { success: true, data: [...] }, o { code: 0, data: [...] }
            const isSuccess = 
                Array.isArray(assetsData) || // Respuesta directa como array
                (assetsData && Array.isArray(assetsData.data)) || // Objeto con data array
                (assetsData && assetsData.success === true) || // Objeto con success true
                (assetsData && assetsData.code === 0); // Objeto con code 0

            if (isSuccess) {
                console.log('✅ MEXC Futures API conectada correctamente');
                const responseData = Array.isArray(assetsData) ? assetsData : (assetsData.data || assetsData);
                return { 
                    success: true, 
                    message: 'Conexión exitosa - Assets obtenidos', 
                    data: responseData
                };
            } else {
                const errorMsg = `Error ${assetsData?.code || 'unknown'}: ${assetsData?.message || 'Error desconocido'}`;
                console.error('❌ Error en assets:', errorMsg);

                // Detectar error de whitelist de IP
                if (assetsData?.code === 406 || assetsData?.message?.includes('whitelist')) {
                    const ip = assetsData?._extend?.ip || 'desconocida';
                    throw new Error(`⚠️ IP NO AUTORIZADA\n\nLa IP ${ip} no está en la whitelist de tu API Key de MEXC.\n\n📋 SOLUCIÓN:\n1. Ve a MEXC → API Management\n2. Edita tu API Key\n3. Agrega la IP: ${ip}\n4. O desactiva la restricción de IP`);
                }

                // Si falla con assets, intentar con un endpoint diferente
                console.log('🔄 Intentando con endpoint de server time...');
                const time = await this.getServerTime();
                console.log('⏰ Server time obtenido:', time);

                throw new Error(errorMsg);
            }
        } catch (error) {
            console.error('❌ Error en testConnection:', error);
            throw error;
        }
    }

    // Obtener tiempo del servidor
    async getServerTime() {
        return Date.now(); // MEXC Futures usa timestamp local
    }

    // Hacer request autenticada usando PROXY - siempre activo
    async makeAuthenticatedRequest(endpoint, params = {}) {
        try {
            console.log(`📡 MEXC Request: ${endpoint}`);
            console.log(`📋 Parámetros:`, params);

            // El proxy maneja la firma, solo enviar las credenciales y parámetros
            const isProduction = window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1';
            const url = isProduction ? `${this.proxyURL}/mexc` : `${this.proxyURL}/proxy-mexc`;

            console.log(`🌐 URL: ${url}`);
            console.log(`🔑 API Key: ${this.apiKey.substring(0, 20)}...`);

            let response;
            try {
                response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        apiKey: this.apiKey,
                        secretKey: this.secretKey,
                        endpoint: endpoint,
                        params: params
                    })
                });
            } catch (networkErr) {
                console.error('❌ Proxy no disponible. MEXC API requiere proxy para evitar CORS.');
                console.log('💡 Para usar MEXC API, inicia el servidor proxy con: npm start');
                throw new Error('Proxy no disponible - MEXC API no se puede usar sin proxy (CORS)');
            }

            if (!response.ok) {
                const errorText = await response.text();
                console.error(`❌ HTTP ${response.status}:`, errorText);
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            const result = await response.json();
            console.log(`✅ MEXC Proxy Response:`, result);

            // Si el resultado es directamente un array, es la respuesta exitosa de MEXC
            if (Array.isArray(result)) {
                console.log(`📦 MEXC Data (Array):`, result);
                return { success: true, data: result };
            }

            // Si el resultado tiene success: true y data
            if (result.success && result.data) {
                console.log(`📦 MEXC Data:`, result.data);
                return result.data;
            }

            // Si el resultado tiene la estructura directa de MEXC API
            if (result.code !== undefined || result.success !== undefined || result.data !== undefined) {
                console.log(`📦 MEXC Direct Response:`, result);
                return result;
            }

            // Si hay un error
            if (result.error) {
                throw new Error(result.error);
            }

            // Retornar el resultado tal cual
            console.log(`📦 MEXC Raw Response:`, result);
            return result;
        } catch (error) {
            console.error('❌ MEXC Error:', error.message);
            throw error;
        }
    }

    // Obtener información de la cuenta de Futuros
    async getAccountInfo() {
        return await this.makeAuthenticatedRequest('/api/v1/private/account/assets');
    }

    // Obtener historial de trades de Futuros
    async getTradeHistory(symbol = '', startTime = null, endTime = null, limit = 100) {
        const params = { page_num: 1, page_size: limit };

        if (symbol) params.symbol = symbol;
        if (startTime) params.start_time = startTime;
        if (endTime) params.end_time = endTime;

        return await this.makeAuthenticatedRequest('/api/v1/private/order/list/history_orders', params);
    }

    // Obtener órdenes activas de Futuros
    async getActiveOrders(symbol = '') {
        const params = { page_num: 1, page_size: 100 };

        if (symbol) params.symbol = symbol;

        return await this.makeAuthenticatedRequest('/api/v1/private/order/list/open_orders', params);
    }

    // Obtener historial de posiciones cerradas
    async getClosedPositions(symbol = '', startTime = null, endTime = null, limit = 100) {
        const params = { page_num: 1, page_size: limit };

        if (symbol) params.symbol = symbol;
        if (startTime) params.start_time = startTime;
        if (endTime) params.end_time = endTime;

        return await this.makeAuthenticatedRequest('/api/v1/private/position/list/history_positions', params);
    }

    // Obtener balance de la cuenta de Futuros
    async getBalance() {
        const accountInfo = await this.getAccountInfo();
        return accountInfo.data || [];
    }
}

// Variable global para la instancia de MEXC API
let mexcAPI = null;

// =============================================
// LBANK API CLASS - RSA Signature
// =============================================
class LBankAPI {
    constructor(apiKey, privateKeyPem) {
        this.apiKey = apiKey;
        this.privateKeyPem = privateKeyPem; // RSA Private Key en formato PEM
        this.baseURL = 'https://api.lbank.info';
        const isProduction = window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1';
        this.proxyURL = isProduction ? `${window.location.origin}/api/proxy-lbank` : 'http://127.0.0.1:8003/proxy-lbank';
        console.log('🔗 LBank API inicializada (RSA)');
        console.log(`🌐 Modo: ${isProduction ? 'PRODUCCIÓN' : 'LOCAL'}`);
        console.log(`🌐 Proxy URL: ${this.proxyURL}`);
    }

    // Test de conexión
    async testConnection() {
        try {
            console.log('🧪 Probando conexión LBank...');
            const data = await this.makeAuthenticatedRequest('/v2/supplement/user_info_account.do', {});
            
            if (data && data.result === 'true') {
                console.log('✅ LBank API conectada correctamente');
                return { success: true, data: data.data };
            } else {
                throw new Error(data?.msg || data?.error_code || 'Error desconocido');
            }
        } catch (error) {
            console.error('❌ Error en testConnection LBank:', error);
            throw error;
        }
    }

    // Hacer request autenticada usando el proxy
    async makeAuthenticatedRequest(endpoint, params = {}) {
        try {
            console.log(`📡 LBank Request: ${endpoint}`);
            console.log(`📋 Parámetros:`, params);

            const timestamp = Date.now().toString();

            const response = await fetch(this.proxyURL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    apiKey: this.apiKey,
                    privateKey: this.privateKeyPem,
                    endpoint: endpoint,
                    params: params,
                    timestamp: timestamp
                })
            });

            const data = await response.json();
            console.log('📥 LBank Response:', data);

            if (data.result === 'false' || data.error_code) {
                throw new Error(`LBank Error ${data.error_code}: ${data.msg || 'Error desconocido'}`);
            }

            return data;
        } catch (error) {
            console.error('❌ Error en LBank request:', error);
            throw error;
        }
    }

    // Obtener balance
    async getBalance() {
        const data = await this.makeAuthenticatedRequest('/v2/supplement/user_info_account.do', {});
        return data.data?.balances || [];
    }

    // Obtener historial de trades
    async getTradeHistory(symbol = 'all', startTime = null, endTime = null) {
        const params = { symbol: symbol, current_page: 1, page_length: 100 };
        
        if (startTime) {
            params.startTime = new Date(startTime).toISOString().split('T')[0];
        }
        
        if (endTime) {
            params.endTime = new Date(endTime).toISOString().split('T')[0];
        }

        const data = await this.makeAuthenticatedRequest('/v2/supplement/transaction_history.do', params);
        return data.data || [];
    }
}

// =============================================
// BITUNIX API CLASS - HMAC SHA256
// =============================================
class BitunixAPI {
    constructor(apiKey, secretKey) {
        this.apiKey = apiKey;
        this.secretKey = secretKey;
        this.baseURL = 'https://api.bitunix.com';
        const isProduction = window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1';
        this.proxyURL = isProduction ? `${window.location.origin}/api` : 'http://127.0.0.1:8003';
        console.log('🔗 Bitunix API inicializada');
        console.log(`🌐 Modo: ${isProduction ? 'PRODUCCIÓN' : 'LOCAL'}`);
        console.log(`🌐 Proxy URL: ${this.proxyURL}`);
    }

    // Generar firma HMAC SHA256
    generateSignature(queryString) {
        const signature = CryptoJS.HmacSHA256(queryString, this.secretKey);
        return signature.toString(CryptoJS.enc.Hex);
    }

    // Test de conexión
    async testConnection() {
        try {
            console.log('🧪 Probando conexión Bitunix...');
            const data = await this.makeAuthenticatedRequest('/api/v1/account/balance', {});
            
            if (data && data.code === 0) {
                console.log('✅ Bitunix API conectada correctamente');
                return { success: true, data: data.data };
            } else {
                throw new Error(data?.msg || 'Error desconocido');
            }
        } catch (error) {
            console.error('❌ Error en testConnection Bitunix:', error);
            throw error;
        }
    }

    // Hacer request autenticada usando el proxy
    async makeAuthenticatedRequest(endpoint, params = {}) {
        try {
            console.log(`📡 Bitunix Request: ${endpoint}`);
            console.log(`📋 Parámetros:`, params);

            const timestamp = Date.now().toString();
            params.timestamp = timestamp;

            // Ordenar parámetros
            const sortedKeys = Object.keys(params).sort();
            const queryString = sortedKeys.map(key => `${key}=${params[key]}`).join('&');
            const signature = this.generateSignature(queryString);

            const fullEndpoint = `${endpoint}?${queryString}&signature=${signature}`;
            const isProduction = window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1';
            const fetchUrl = isProduction ? `${this.proxyURL}/bitunix${fullEndpoint}` : `${this.proxyURL}/proxy-bitunix${fullEndpoint}`;

            const response = await fetch(fetchUrl, {
                method: 'GET',
                headers: {
                    'x-api-key': this.apiKey,
                    'x-secret-key': this.secretKey,
                    'Content-Type': 'application/json'
                }
            });

            const data = await response.json();
            console.log('📥 Bitunix Response:', data);

            if (data.code !== 0) {
                throw new Error(`Bitunix Error ${data.code}: ${data.msg || 'Error desconocido'}`);
            }

            return data;
        } catch (error) {
            console.error('❌ Error en Bitunix request:', error);
            throw error;
        }
    }

    // Obtener balance
    async getBalance() {
        const data = await this.makeAuthenticatedRequest('/api/v1/account/balance', {});
        return data.data || [];
    }

    // Obtener historial de trades
    async getTradeHistory(symbol = '', startTime = null, endTime = null) {
        const params = { limit: 100 };
        
        if (symbol) params.symbol = symbol;
        if (startTime) params.startTime = startTime;
        if (endTime) params.endTime = endTime;

        const data = await this.makeAuthenticatedRequest('/api/v1/trades/history', params);
        return data.data || [];
    }
}

// Función de prueba segura: intenta varias variantes de firma desde la consola
// Uso: window.testMexcSignatures()  o window.testMexcSignatures('/api/v1/private/account/assets', {})
window.testMexcSignatures = async function(endpoint = '/api/v1/private/account/assets', params = {}) {
    try {
        console.log('🔬 Iniciando prueba de firmas MEXC (desde navegador, sin tocar UI)');

        // Intentar obtener credenciales guardadas
        let apiKey = null;
        let secretKey = null;
        try {
            if (typeof DB !== 'undefined' && DB.apiKeys && DB.apiKeys.mexc) {
                apiKey = DB.apiKeys.mexc.key || DB.apiKeys.mexc.apiKey || null;
                secretKey = DB.apiKeys.mexc.secret || DB.apiKeys.mexc.secretKey || null;
            }
        } catch (e) {
            console.warn('⚠️ No se pudo leer DB.apiKeys.mexc:', e.message);
        }

        // Si no hay credenciales en la app, pedirlas al usuario (prompt, entrada temporal)
        if (!apiKey) apiKey = prompt('Pega tu API Key de MEXC para la prueba (solo para esta sesión):');
        if (!secretKey) secretKey = prompt('Pega tu Secret Key de MEXC para la prueba (solo para esta sesión):');

        if (!apiKey || !secretKey) {
            console.error('❌ No se proporcionaron credenciales. Abortando prueba.');
            return null;
        }

        // Construir query string ordenado
        const sortedKeys = Object.keys(params).sort();
        const baseQueryString = sortedKeys.length > 0 ? sortedKeys.map(k => `${k}=${params[k]}`).join('&') : '';

        // Determinar proxyURL - detectar entorno
        const isProduction = window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1';
        const proxyURL = (typeof mexcAPI !== 'undefined' && mexcAPI && mexcAPI.proxyURL) ? 
            mexcAPI.proxyURL : 
            (isProduction ? `${window.location.origin}/api` : 'http://127.0.0.1:8003');

        const timestamp = Date.now().toString();

        const variants = [
            { name: 'raw', key: secretKey, encode: false },
            { name: 'hex', key: CryptoJS.enc.Hex.parse(secretKey), encode: false },
            { name: 'raw-encoded', key: secretKey, encode: true },
            { name: 'hex-encoded', key: CryptoJS.enc.Hex.parse(secretKey), encode: true }
        ];

        const results = [];

        for (const v of variants) {
            try {
                const qForSign = v.encode ? encodeURIComponent(baseQueryString) : baseQueryString;
                const signatureString = `${apiKey}${timestamp}${qForSign}`;
                const sigWord = CryptoJS.HmacSHA256(signatureString, v.key);
                const signatureHex = sigWord.toString(CryptoJS.enc.Hex).toLowerCase();

                const fullQuery = baseQueryString ? `${baseQueryString}&signature=${signatureHex}` : `signature=${signatureHex}`;
                const url = `${proxyURL}/mexc${endpoint}?${fullQuery}`;

                const headers = { 'ApiKey': apiKey, 'Request-Time': timestamp };

                console.log(`➡️ Probando variante: ${v.name}`);
                console.log('    signatureString:', signatureString);
                console.log('    signatureHex:', signatureHex);
                console.log('    URL:', url);

                const resp = await fetch(url, { method: 'GET', headers });
                let data = null;
                try { data = await resp.json(); } catch(e) { data = await resp.text(); }

                console.log(`    Resultado variante ${v.name}: HTTP ${resp.status}`, data);

                results.push({ variant: v.name, status: resp.status, data });

                // Si éxito según MEXC
                if ((data && (data.code === 0 || data.success === true)) || resp.status === 200 && !data.code) {
                    console.log('✅ Variante exitosa detectada:', v.name);
                    return { success: true, variant: v.name, status: resp.status, data };
                }
            } catch (err) {
                console.warn(`⚠️ Error probando variante ${v.name}:`, err.message);
                results.push({ variant: v.name, error: err.message });
            }
        }

        console.error('❌ Ninguna variante funcionó. Resultados:', results);
        return { success: false, results };
    } catch (err) {
        console.error('❌ testMexcSignatures fallo:', err);
        return { success: false, error: err.message };
    }
};

// Variable global para la instancia de Bitget API
let bitgetAPI = null;

// Variables globales para las nuevas plataformas
let bitunixAPI = null;
let lbankAPI = null;
let blofinAPI = null;

// MockBitgetAPI: simula respuestas locales cuando el usuario no quiere/puede correr el proxy
class MockBitgetAPI {
    constructor() {
        console.log('🟡 MockBitgetAPI inicializada (modo offline)');
    }

    async testConnection() {
        return { code: '00000', msg: 'mock ok', data: { time: Date.now() } };
    }

    async getAccountInfo() {
        return { code: '00000', data: { assets: [] }, msg: 'mock account' };
    }

    async getTradeHistory(symbol = '', startTime = null, endTime = null) {
        return { code: '00000', data: { orders: [] }, msg: 'mock trades' };
    }

    async getOrderHistory(symbol = '') {
        return { code: '00000', data: { orders: [] }, msg: 'mock order history' };
    }
}

// Función utilitaria para convertir fechas manteniendo zona horaria local
function getLocalDateString(date) {
    if (typeof date === 'string') {
        date = new Date(date);
    }
    if (!(date instanceof Date) || isNaN(date)) {
        date = new Date();
    }

    const year = date.getFullYear();
    const month = (date.getMonth() + 1).toString().padStart(2, '0');
    const day = date.getDate().toString().padStart(2, '0');

    return `${year}-${month}-${day}`;
}

// Función para corregir fechas UTC de operaciones existentes
async function fixExistingOperationDates() {
    console.log('🔧 Corrigiendo fechas de operaciones existentes...');

    try {
        const operations = await dexieDB.operations.toArray();
        const operationsToUpdate = [];

        let correctedCount = 0;

        for (const op of operations) {
            // Verificar si la fecha parece estar en UTC (terminando en fecha anterior)
            const originalDate = new Date(op.date + 'T00:00:00');
            const localDate = new Date(originalDate.getTime() + originalDate.getTimezoneOffset() * 60000);
            const correctedDateString = getLocalDateString(localDate);

            // Solo actualizar si la fecha es diferente
            if (correctedDateString !== op.date) {
                operationsToUpdate.push({
                    key: op.id,
                    changes: { date: correctedDateString }
                });
                correctedCount++;
                console.log(`📅 Corrigiendo operación ${op.id}: ${op.date} → ${correctedDateString}`);
            }
        }

        if (operationsToUpdate.length > 0) {
            // Usar bulkPut en lugar de bulkUpdate para Dexie
            const operationsToSave = [];
            for (const update of operationsToUpdate) {
                const originalOp = operations.find(op => op.id === update.key);
                if (originalOp) {
                    operationsToSave.push({
                        ...originalOp,
                        ...update.changes
                    });
                }
            }

            await dexieDB.operations.bulkPut(operationsToSave);
            console.log(`✅ ${correctedCount} operaciones corregidas`);

            // Recargar datos en memoria
            await loadDataFromDB();

            // Actualizar la interfaz si está visible
            if (document.getElementById('operations').classList.contains('active')) {
                await refreshOperationsTable();
            }

            showSyncNotification(`✅ Se corrigieron ${correctedCount} fechas de operaciones`, 'success');
        } else {
            console.log('✅ Todas las fechas ya están correctas');
        }

    } catch (error) {
        console.error('❌ Error corrigiendo fechas:', error);
        showSyncNotification('❌ Error corrigiendo fechas de operaciones', 'error');
    }
}

// Función para probar la conexión con BingX
async function testBingXConnection() {
    // Buscar credenciales en cualquiera de las interfaces
    let apiKey = '';
    let secretKey = '';

    const detailApiKey = document.getElementById('bingx-api-key-detail');
    const detailSecretKey = document.getElementById('bingx-secret-key-detail');
    const oldApiKey = document.getElementById('bingx-api-key');
    const oldSecretKey = document.getElementById('bingx-api-secret');

    if (detailApiKey && detailApiKey.value) {
        apiKey = detailApiKey.value.trim();
        secretKey = detailSecretKey.value.trim();
    } else if (oldApiKey && oldApiKey.value) {
        apiKey = oldApiKey.value.trim();
        secretKey = oldSecretKey.value.trim();
    }

    if (!apiKey || !secretKey) {
        showSyncNotification('❌ Por favor ingresa tanto la API Key como la Secret Key', 'error');
        return false;
    }

    // Guardar credenciales INMEDIATAMENTE cuando se ingresan
    console.log('💾 Guardando credenciales inmediatamente...');
    try {
        DB.apiKeys.bingx = { key: apiKey, secret: secretKey, mode: 'real', accountId: 'main' };
        await dexieDB.generalData.put({ key: 'apiKeys', value: DB.apiKeys });

        // Múltiple guardado en localStorage para máxima persistencia
        localStorage.setItem('bingx-api-key', apiKey);
        localStorage.setItem('bingx-secret-key', secretKey);
        localStorage.setItem('bingx-account-id', 'main');
        localStorage.setItem('bingx-connected', 'true');
        localStorage.setItem('bingx-last-save', Date.now().toString());

        console.log('✅ Credenciales guardadas en localStorage y Dexie');

        // Verificar que se guardaron correctamente
        const verify = localStorage.getItem('bingx-api-key');
        if (verify === apiKey) {
            console.log('✅ Verificación: credenciales guardadas correctamente');
        } else {
            console.error('❌ Error: las credenciales no se guardaron correctamente');
        }
    } catch (error) {
        console.error('❌ Error guardando credenciales:', error);
    }

    showLoading(true);

    try {
        bingxAPI = new BingXAPI(apiKey, secretKey);

        // Primero probar conexión básica al servidor
        const serverTime = await bingxAPI.testConnection();

        if (serverTime && serverTime.code === 0) {
            // showSyncNotification('✅ Conexión exitosa con BingX (Cuenta Real)', 'success');

            // Mostrar botón de sincronización
            const syncBtn = document.getElementById('bingx-sync');
            if (syncBtn) syncBtn.style.display = 'inline-block';

            return true;
        } else {
            throw new Error(serverTime?.msg || 'Error de conexión con el servidor');
        }
    } catch (error) {
        console.error('Error probando conexión BingX:', error);

        // En caso de CORS o problemas de red, aún permitir continuar con advertencia
        if (error.message.includes('CORS') || error.message.includes('fetch')) {
            // showSyncNotification('⚠️ Advertencia: Posible problema de CORS. Las credenciales se guardaron.', 'warning');

            // Guardar las credenciales de todos modos
            DB.apiKeys.bingx = { key: apiKey, secret: secretKey, mode: 'real' };
            await dexieDB.generalData.put({ key: 'apiKeys', value: DB.apiKeys });

            // Guardar también en localStorage para persistencia
            localStorage.setItem('bingx-api-key', apiKey);
            localStorage.setItem('bingx-secret-key', secretKey);
            localStorage.setItem('bingx-account-id', 'main');

            bingxAPI = new BingXAPI(apiKey, secretKey);
            const syncBtn = document.getElementById('bingx-sync');
            if (syncBtn) syncBtn.style.display = 'inline-block';

            return true;
        }

        showSyncNotification(`❌ Error de conexión: ${error.message}`, 'error');
        return false;
    } finally {
        showLoading(false);
    }
}

// Función para actualizar el estado de BingX en la UI
function updateBingXStatus(status, message, connected = false) {
    const statusDiv = document.getElementById('bingx-status');
    const statusText = document.getElementById('bingx-status-text');
    const lastSyncText = document.getElementById('bingx-last-sync');

    // Solo actualizar si los elementos existen
    if (statusDiv) {
        statusDiv.style.display = 'block';

        // Cambiar color según el estado
        statusDiv.className = 'mt-3 p-3 rounded ';
        if (connected) {
            statusDiv.className += 'bg-green-900 border border-green-500 text-green-100';
        } else if (status === 'warning') {
            statusDiv.className += 'bg-yellow-900 border border-yellow-500 text-yellow-100';
        } else {
            statusDiv.className += 'bg-red-900 border border-red-500 text-red-100';
        }
    }

    if (statusText) {
        statusText.textContent = `Estado: ${message}`;
    }

    // Actualizar última sincronización si es exitosa
    if (connected && status === 'sync' && lastSyncText) {
        const now = new Date();
        lastSyncText.textContent = `Última sincronización: ${now.toLocaleString('es-ES')}`;
        localStorage.setItem('bingx-last-sync', now.toISOString());
    }
}

// Función para cargar información de última sincronización
function loadLastSyncInfo() {
    const lastSync = localStorage.getItem('bingx-last-sync');
    if (lastSync) {
        const date = new Date(lastSync);
        document.getElementById('bingx-last-sync').textContent =
            `Última sincronización: ${date.toLocaleString('es-ES')}`;
    }
}

// Función para conectar con BingX (guardar credenciales)
async function connectBingX() {
    console.log('🔄 Iniciando conexión con BingX...');

    const success = await testBingXConnection();
    if (success) {
        updateBingXStatus('connected', 'Conectado', true);
        // showSyncNotification('🔗 BingX conectado exitosamente. Puedes sincronizar tus trades.', 'success');
        populateBingXAccounts();
        updateBingXDetailStatus();

        // Probar autenticación con endpoint simple
        try {
            if (bingxAPI) {
                console.log('🧪 Probando autenticación...');
                const accountInfo = await bingxAPI.getAccountInfo();
                console.log('✅ Respuesta de autenticación:', accountInfo);

                if (accountInfo.code === 0) {
                    // showSyncNotification('✅ Autenticación exitosa con BingX', 'success');
                } else {
                    // showSyncNotification(`⚠️ Conectado pero error de autenticación: ${accountInfo.msg}`, 'warning');
                }
            }
        } catch (authError) {
            console.error('❌ Error de autenticación:', authError);
            showSyncNotification(`⚠️ Conectado pero error de autenticación: ${authError.message}`, 'warning');
        }

        return true;
    } else {
        updateBingXStatus('error', 'Error de conexión', false);
        updateBingXDetailStatus();
        return false;
    }
}

// Función para probar solo autenticación
async function testBingXAuth() {
    console.log('🔍 Probando solo autenticación BingX...');

    // Obtener credenciales de cualquier interfaz
    let apiKey = '';
    let secretKey = '';

    const detailApiKey = document.getElementById('bingx-api-key-detail');
    const detailSecretKey = document.getElementById('bingx-secret-key-detail');

    if (detailApiKey && detailApiKey.value) {
        apiKey = detailApiKey.value.trim();
        secretKey = detailSecretKey.value.trim();
    }

    if (!apiKey || !secretKey) {
        showSyncNotification('❌ Ingresa API Key y Secret Key primero', 'error');
        return;
    }

    showLoading(true);
    // showSyncNotification('🔍 Probando autenticación con BingX...', 'info');

    try {
        // Crear instancia temporal de API
        const tempAPI = new BingXAPI(apiKey, secretKey);

        // Mostrar información sobre la nueva conexión
        // showSyncNotification('🔄 Conectando DIRECTAMENTE a BingX (sin proxy)...', 'info');

        // Probar con endpoint de información de cuenta
        console.log('📊 Probando endpoint de balance...');
        const accountResponse = await tempAPI.getAccountInfo();

        console.log('🔍 Respuesta completa:', JSON.stringify(accountResponse, null, 2));

        if (accountResponse.code === 0) {
            // showSyncNotification('✅ Autenticación exitosa! Las credenciales son correctas.', 'success');
            console.log('✅ Balance de cuenta:', JSON.stringify(accountResponse.data, null, 2));
        } else {
            // showSyncNotification(`❌ Error de autenticación: ${accountResponse.msg}`, 'error');
            console.error('❌ Error details:', JSON.stringify(accountResponse, null, 2));

            // Diagnóstico específico del error
            if (accountResponse.msg && accountResponse.msg.includes('signature')) {
                console.error('🚨 PROBLEMA DE SIGNATURE DETECTADO:');
                console.error('1. ❌ API Key o Secret Key incorrectos');
                console.error('2. ❌ La API Key puede haber expirado');
                console.error('3. ❌ Permisos insuficientes (necesita Read + Trade)');
                console.error('4. ❌ IP no está en whitelist (si está habilitada)');
                console.error('5. 💡 SOLUCIÓN: Crea nuevas credenciales en BingX → Account → API Management');

                // showSyncNotification('🚨 Credenciales inválidas. Necesitas generar nuevas API Keys en BingX.', 'error');
            }
        }

    } catch (error) {
        console.error('❌ Error probando autenticación:', error);
        // showSyncNotification(`❌ Error: ${error.message}`, 'error');

        // Mostrar información detallada del error
        if (error.message.includes('signature')) {
            console.error('🔍 Esto parece un problema de firma. Verifica:');
            console.error('1. API Key y Secret Key son correctos');
            console.error('2. Las credenciales tienen permisos de trading');
            console.error('3. La IP está en la whitelist (si está habilitada)');
        }
    } finally {
        showLoading(false);
    }
}

// Función para poblar las cuentas de BingX
function populateBingXAccounts() {
    const accountSelect = document.getElementById('bingx-account');
    const accountDetailSelect = document.getElementById('bingx-account-detail');

    const options = '<option value="">Seleccionar cuenta...</option><option value="main">Cuenta Principal</option>';

    // Poblar ambos selects si existen
    if (accountSelect) {
        accountSelect.innerHTML = options;
    }
    if (accountDetailSelect) {
        accountDetailSelect.innerHTML = options;
    }
}

// Función para importar CSV de BingX
function importBingXCSV() {
    // Crear input de archivo
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.csv';
    input.style.display = 'none';

    input.onchange = function(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = async function(e) {
            try {
                const csv = e.target.result;
                await processBingXCSV(csv);
            } catch (error) {
                console.error('Error procesando CSV:', error);
                showSyncNotification('❌ Error procesando archivo CSV', 'error');
            }
        };
        reader.readAsText(file);
    };

    document.body.appendChild(input);
    input.click();
    document.body.removeChild(input);
}

// Función para procesar CSV de BingX
async function processBingXCSV(csvContent) {
    console.log('📄 Procesando CSV para BingX...');

    // Usar el mismo formato estándar que en Configuraciones
    // Formato: Nombre Cuenta, Fecha (YYYY-MM-DD), Hora Entrada (HH:MM), Hora Salida (HH:MM),
    // Instrumento, Tipo (buy/sell), Entrada, Salida, Volumen, P&L (opc), Divisa, Tarifa/Comision (opc), Notas (opc)

    const parsedData = parseCSV(csvContent);

    if (!parsedData.headers || parsedData.rows.length === 0) {
        showSyncNotification('❌ CSV vacío o formato incorrecto', 'error');
        return;
    }

    const headerMap = {};
    parsedData.headers.forEach((header, index) => {
        headerMap[header.toLowerCase().trim().replace(/\s+/g, ' ')] = index;
    });

    // Debug: Mostrar headers detectados
    console.log('🔍 [BingX CSV] Headers normalizados detectados:', Object.keys(headerMap));

    const requiredHeaders = ['nombre cuenta', 'fecha', 'hora entrada', 'hora salida', 'instrumento', 'tipo', 'entrada', 'salida', 'volumen', 'divisa'];
    for (const reqHeader of requiredHeaders) {
        if (!(reqHeader in headerMap)) {
            showSyncNotification(`❌ Cabecera requerida no encontrada: '${reqHeader}'`, 'error');
            return;
        }
    }

    let skippedOpsCount = 0;
    const rawOperations = [];

    for (const row of parsedData.rows) {
        const accountNameFromCsv = row[headerMap['nombre cuenta']];
        if (!accountNameFromCsv || accountNameFromCsv.trim() === "") {
            skippedOpsCount++;
            continue;
        }

        const account = DB.accounts.find(acc => acc.name.trim().toLowerCase() === accountNameFromCsv.trim().toLowerCase());

        if (!account) {
            console.warn(`Cuenta no encontrada: "${accountNameFromCsv}". Operación omitida.`);
            skippedOpsCount++;
            continue;
        }

        const dateStr = row[headerMap['fecha']];
        let opDate;

        // Limpiar y validar la fecha
        const cleanDateStr = dateStr.trim();

        if (cleanDateStr.includes('-')) {
            // Formato YYYY-MM-DD
            const parts = cleanDateStr.split('-');
            if (parts.length === 3 && parts[0].length === 4) {
                const year = parts[0];
                const month = parts[1].padStart(2, '0');
                const day = parts[2].padStart(2, '0');
                opDate = `${year}-${month}-${day}`;
            }
        } else if (cleanDateStr.includes('/')) {
            // Formato DD/MM/YYYY
            const parts = cleanDateStr.split('/');
            if (parts.length === 3) {
                const day = parts[0].padStart(2, '0');
                const month = parts[1].padStart(2, '0');
                const year = parts[2];
                opDate = `${year}-${month}-${day}`;
            }
        }

        // Validar que la fecha sea válida
        if (!opDate) {
            console.warn(`Fecha inválida: "${dateStr}". Operación omitida.`);
            skippedOpsCount++;
            continue;
        }

        const testDate = new Date(opDate + "T12:00:00");
        if (isNaN(testDate.getTime())) {
            console.warn(`Fecha inválida después de parsear: "${opDate}". Operación omitida.`);
            skippedOpsCount++;
            continue;
        }

        const instrument = row[headerMap['instrumento']].toUpperCase().trim();
        const type = row[headerMap['tipo']].toLowerCase().trim();
        const entryStr = String(row[headerMap['entrada']]).replace(',', '.');
        const exitStr = String(row[headerMap['salida']]).replace(',', '.');
        const volumeStr = String(row[headerMap['volumen']]).replace(',', '.');

        const entryTime = row[headerMap['hora entrada']] || null;
        const exitTime = row[headerMap['hora salida']] || null;
        const session = headerMap['sesion'] !== undefined ? row[headerMap['sesion']].trim() : 'No especificado';

        const entry = parseFloat(entryStr);
        const exit = parseFloat(exitStr);
        const volume = parseFloat(volumeStr);

        const currency = row[headerMap['divisa']].toUpperCase().trim();
        const notes = headerMap['notas'] !== undefined ? row[headerMap['notas']] : '';

        // Procesar tarifa/comisiones - Buscar en todas las variantes posibles
        let fees = 0;
        const possibleFeeHeaders = [
            'tarifa/comision',    // Con barra diagonal
            'tarifa/comisión',    // Con barra y tilde
            'tarifa',
            'comision',
            'comisión',
            'fee',
            'fees',
            'commission'
        ];

        let feeColumnFound = false;
        for (const feeHeader of possibleFeeHeaders) {
            if (headerMap[feeHeader] !== undefined) {
                const feeValue = row[headerMap[feeHeader]];
                if (feeValue && String(feeValue).trim() !== "") {
                    fees = Math.abs(parseFloat(String(feeValue).replace(',', '.')));
                    console.log(`💰 [BingX CSV] Comisión detectada en columna '${feeHeader}':`, fees);
                    feeColumnFound = true;
                    break;
                }
            }
        }

        if (!feeColumnFound) {
            console.log('⚠️ [BingX CSV] No se encontró columna de comisión en:', Object.keys(headerMap));
        }

        let pl = (headerMap['p&l'] !== undefined && row[headerMap['p&l']] && String(row[headerMap['p&l']]).trim() !== "")
            ? parseFloat(String(row[headerMap['p&l']]).replace(',', '.'))
            : null;
        let result;

        if (isNaN(volume) || volume <= 0) {
            skippedOpsCount++;
            continue;
        }

        if ((pl === null || isNaN(pl)) && (isNaN(entry) || isNaN(exit))) {
            skippedOpsCount++;
            continue;
        }

        if (pl !== null && !isNaN(pl)) {
            result = pl > 0 ? 'win' : (pl < 0 ? 'loss' : 'breakeven');
        } else {
            if (isNaN(entry) || isNaN(exit)) {
                skippedOpsCount++;
                continue;
            }
            if (type === 'buy')
             pl = (exit - entry) * volume;
            else pl = (entry - exit) * volume;
            result = pl > 0 ? 'win' : (pl < 0 ? 'loss' : 'breakeven');
        }
        pl = parseFloat(pl.toFixed(5));

        // Obtener ID del CSV si existe
        const csvId = headerMap['id'] !== undefined && row[headerMap['id']] && String(row[headerMap['id']]).trim() !== ""
            ? String(row[headerMap['id']]).trim()
            : null;

        // Crear operación básica
        const baseOperation = {
            date: opDate,
            accountId: account.id,
            instrument,
            type,
            entry: isNaN(entry) ? null : entry,
            exit: isNaN(exit) ? null : exit,
            entryTime,
            exitTime,
            volume,
            result,
            pl,
            currency,
            notes,
            imageDatas: [],
            fees: fees || 0,
            manualPL: (headerMap['p&l'] !== undefined && row[headerMap['p&l']] && String(row[headerMap['p&l']]).trim() !== "" && !isNaN(parseFloat(String(row[headerMap['p&l']]).replace(',', '.'))))
                ? parseFloat(String(row[headerMap['p&l']]).replace(',', '.'))
                : null,
            session: session
        };

        // Generar ID usando la función centralizada
        baseOperation.id = generateUnifiedOperationId(baseOperation, 'bingx', csvId);

        rawOperations.push(baseOperation);
    }

    // Procesar operaciones usando las funciones centralizadas
    const newOperations = await processAndCleanOperations(rawOperations, 'bingx');
    const importedOpsCount = newOperations.length;

    if (newOperations.length > 0) {
        try {
            await dexieDB.operations.bulkAdd(newOperations);
            DB.operations.push(...newOperations);

            // SINCRONIZACIÓN AUTOMÁTICA CON SUPABASE
            console.log('🔍 Iniciando sincronización de operaciones importadas...');
            if (currentUser) {
                console.log('🔍 Usuario autenticado - sincronizando', newOperations.length, 'operaciones...');
                let successCount = 0;
                let errorCount = 0;

                for (const operation of newOperations) {
                    try {
                        await saveOperationToSupabase(operation);
                        successCount++;
                        console.log('✅ Operación sincronizada:', operation.id);
                    } catch (error) {
                        console.error('❌ Error sincronizando operación:', operation.id, error);
                        addToSyncQueue(operation, 'operation');
                        errorCount++;
                    }
                }

                console.log(`✅ Sincronización completada: ${successCount} exitosas, ${errorCount} en cola`);
                if (successCount > 0) {
                    showSyncNotification(`💾 ${successCount} operaciones guardadas exitosamente`, 'success');
                }
            } else {
                console.log('ℹ️ Usuario no autenticado - operaciones solo en local');
            }

            // Actualizar balances y vistas
            updateAccountBalances();
            refreshAllViews();

            showSyncNotification(`✅ ${importedOpsCount} operaciones importadas correctamente. ${skippedOpsCount > 0 ? skippedOpsCount + ' omitidas.' : ''}`, 'success');
        } catch (error) {
            console.error('Error guardando operaciones:', error);
            showSyncNotification('❌ Error guardando operaciones: ' + error.message, 'error');
        }
    } else {
        showSyncNotification(`❌ No se importaron operaciones. ${skippedOpsCount} filas omitidas por errores.`, 'error');
    }
}

// ============================================
// FUNCIONES PARA PRIMEXBT
// ============================================

function importPrimeXBTCSV() {
    // Crear input de archivo
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.csv';
    input.style.display = 'none';

    input.onchange = function(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = async function(e) {
            try {
                const csv = e.target.result;
                await processPrimeXBTCSV(csv);
            } catch (error) {
                console.error('Error procesando CSV:', error);
                showSyncNotification('❌ Error procesando archivo CSV', 'error');
            }
        };
        reader.readAsText(file);
    };

    document.body.appendChild(input);
    input.click();
    document.body.removeChild(input);
}

// Función para procesar CSV de PrimeXBT
async function processPrimeXBTCSV(csvContent) {
    console.log('📄 Procesando CSV para PrimeXBT Crypto...');
    
    const lines = csvContent.split('\n').map(line => line.trim()).filter(line => line);
    if (lines.length < 2) {
        showSyncNotification('El archivo CSV de PrimeXBT está vacío o no tiene datos.', 'error');
        return;
    }

    // Usar el método estándar de procesamiento CSV
    const splitLine = (line) => {
        const result = [];
        let current = '';
        let inQuotes = false;
        
        for (let i = 0; i < line.length; i++) {
            const char = line[i];
            if (char === '"') {
                inQuotes = !inQuotes;
            } else if (char === ',' && !inQuotes) {
                result.push(current.trim());
                current = '';
            } else {
                current += char;
            }
        }
        result.push(current.trim());
        return result;
    };

    const headers = splitLine(lines[0]);
    console.log('🔍 [PrimeXBT Crypto CSV] Headers detectados:', headers);

    // Normalizar headers para compatibilidad con el formato estándar
    const headerMap = {};
    headers.forEach((header, index) => {
        headerMap[header.toLowerCase().trim().replace(/\s+/g, ' ')] = index;
    });

    console.log('🔍 [PrimeXBT Crypto CSV] Headers normalizados:', Object.keys(headerMap));

    const rows = [];
    for (let i = 1; i < lines.length; i++) {
        const line = lines[i].trim();
        if (line === "") continue;
        const values = splitLine(line);
        if (values.length >= headers.length) {
            rows.push(values);
        } else {
            console.warn(`Línea CSV con número incorrecto de columnas: "${line}". Esperadas ${headers.length}, obtenidas ${values.length}.`);
        }
    }

    // Procesar filas de datos usando la lógica unificada
    const rawOperations = [];
    let skippedOpsCount = 0;
    
    for (const row of rows) {
        if (row.length < 8) continue; // Mínimo de columnas necesarias
        
        try {
            // Obtener nombre de cuenta del CSV
            const accountNameFromCsv = (headerMap['nombre cuenta'] !== undefined ? row[headerMap['nombre cuenta']] : row[0]) || '';
            if (!accountNameFromCsv || accountNameFromCsv.trim() === "") {
                skippedOpsCount++;
                continue;
            }

            // Buscar cuenta existente
            const account = DB.accounts.find(acc => acc.name.trim().toLowerCase() === accountNameFromCsv.trim().toLowerCase());
            if (!account) {
                console.warn(`Cuenta no encontrada: "${accountNameFromCsv}". Operación omitida.`);
                skippedOpsCount++;
                continue;
            }

            // Mapear datos usando headers normalizados o posiciones fijas
            const csvId = (headerMap['id'] !== undefined ? row[headerMap['id']] : row[1]) || null;
            const date = (headerMap['fecha'] !== undefined ? row[headerMap['fecha']] : row[2]) || new Date().toISOString().split('T')[0];
            const entryTime = (headerMap['hora entrada'] !== undefined ? row[headerMap['hora entrada']] : row[3]) || '09:00';
            const exitTime = (headerMap['hora salida'] !== undefined ? row[headerMap['hora salida']] : row[4]) || '09:00';
            const instrument = (headerMap['instrumento'] !== undefined ? row[headerMap['instrumento']] : row[5]) || 'Unknown';
            const type = (headerMap['tipo'] !== undefined ? row[headerMap['tipo']] : row[6]) || 'buy';
            const entry = parseFloat((headerMap['entrada'] !== undefined ? row[headerMap['entrada']] : row[7]) || 0);
            const exit = parseFloat((headerMap['salida'] !== undefined ? row[headerMap['salida']] : row[8]) || 0);
            const volume = parseFloat((headerMap['volumen'] !== undefined ? row[headerMap['volumen']] : row[9]) || 1);
            const currency = (headerMap['divisa'] !== undefined ? row[headerMap['divisa']] : row[11]) || 'USD';
            const fees = parseFloat((headerMap['tarifa/comision'] !== undefined ? row[headerMap['tarifa/comision']] : row[12]) || 0);
            const notes = (headerMap['notas'] !== undefined ? row[headerMap['notas']] : row[13]) || '';
            
            // Crear operación básica
            const baseOperation = {
                accountId: account.id, // Usar la cuenta encontrada del CSV
                date: date,
                entryTime: entryTime,
                exitTime: exitTime,
                instrument: instrument.toUpperCase(),
                type: type.toLowerCase(),
                entry: entry,
                exit: exit,
                volume: volume,
                currency: currency.toUpperCase(),
                fees: fees,
                notes: notes,
                imageDatas: [],
                session: detectTradingSession(entryTime) || ''
            };

            // Calcular P&L y result
            let pl = parseFloat((headerMap['p&l'] !== undefined ? row[headerMap['p&l']] : row[10]) || 0);
            if (pl === 0 && baseOperation.entry > 0 && baseOperation.exit > 0) {
                // Calcular P&L si no viene en el CSV
                if (baseOperation.type === 'buy') {
                    pl = (baseOperation.exit - baseOperation.entry) * baseOperation.volume;
                } else {
                    pl = (baseOperation.entry - baseOperation.exit) * baseOperation.volume;
                }
            }
            
            baseOperation.pl = parseFloat(pl.toFixed(5));
            baseOperation.result = pl > 0 ? 'win' : (pl < 0 ? 'loss' : 'breakeven');
            baseOperation.manualPL = pl;

            // Validar operación
            if (baseOperation.instrument && baseOperation.type && baseOperation.entry > 0) {
                // Determinar si es una operación parcial basándose en las notas
                let partialIndex = null;
                if (notes.toLowerCase().includes('parcial')) {
                    const match = notes.match(/parcial\s*(\d+)/i);
                    if (match) {
                        partialIndex = parseInt(match[1]);
                    }
                }

                // Generar ID usando la función centralizada
                baseOperation.id = generateUnifiedOperationId(baseOperation, 'primexbt-crypto', csvId, partialIndex);
                rawOperations.push(baseOperation);
            }
        } catch (error) {
            console.warn('Error procesando fila CSV:', error, row);
            skippedOpsCount++;
        }
    }

    if (rawOperations.length === 0) {
        showSyncNotification('No se pudieron procesar operaciones del CSV. Verifica el formato o que las cuentas existan.', 'error');
        console.warn('❌ No se procesaron operaciones. Headers disponibles:', Object.keys(headerMap));
        console.warn('❌ Ejemplo de primera fila:', rows[0]);
        console.warn(`❌ Operaciones omitidas: ${skippedOpsCount}`);
        return;
    }

    console.log(`📄 Procesadas ${rawOperations.length} operaciones de PrimeXBT Crypto (${skippedOpsCount} omitidas)`);
    console.log('🔍 Muestra de operaciones procesadas:', rawOperations.slice(0, 3));

    // Procesar operaciones usando las funciones centralizadas
    const newOperations = await processAndCleanOperations(rawOperations, 'primexbt-crypto');
    const importedCount = newOperations.length;

    if (newOperations.length > 0) {
        try {
            await dexieDB.operations.bulkAdd(newOperations);
            DB.operations.push(...newOperations);

            // SINCRONIZACIÓN AUTOMÁTICA CON SUPABASE
            console.log('🔍 Iniciando sincronización de operaciones importadas...');
            if (currentUser) {
                console.log('🔍 Usuario autenticado - sincronizando', newOperations.length, 'operaciones...');
                let successCount = 0;
                let errorCount = 0;

                for (const operation of newOperations) {
                    try {
                        await saveOperationToSupabase(operation);
                        successCount++;
                        console.log('✅ Operación sincronizada:', operation.id);
                    } catch (error) {
                        console.error('❌ Error sincronizando operación:', operation.id, error);
                        addToSyncQueue(operation, 'operation');
                        errorCount++;
                    }
                }

                if (errorCount > 0) {
                    console.log(`⚠️ ${errorCount} operaciones agregadas a la cola de sincronización`);
                }
                console.log(`📊 Sincronización completada: ${successCount} exitosas, ${errorCount} pendientes`);
            } else {
                console.log('⚠️ Usuario no autenticado - operaciones almacenadas localmente solamente');
            }

            // Actualizar vistas y mostrar resultado
            updateAccountBalances();
            refreshAllViews();
            
            showSyncNotification(`✅ Se importaron ${importedCount} operaciones de PrimeXBT Crypto desde CSV. ${skippedOpsCount} filas omitidas.`, 'success');
            console.log(`✅ Importación completada: ${importedCount} operaciones de PrimeXBT Crypto, ${skippedOpsCount} omitidas`);

        } catch (error) {
            console.error('❌ Error guardando operaciones:', error);
            showSyncNotification('❌ Error guardando operaciones importadas', 'error');
        }
    } else {
        showSyncNotification('ℹ️ No se encontraron operaciones nuevas para importar', 'info');
    }
}

// Función para corregir IDs de operaciones de PrimeXBT existentes
async function fixPrimeXBTOperationIDs() {
    console.log('🔧 Corrigiendo IDs de operaciones de PrimeXBT...');
    
    // Buscar todas las operaciones de PrimeXBT con IDs generados automáticamente
    const primeXBTOps = DB.operations.filter(op => 
        op.id.startsWith('primexbt_') && op.id.includes('_')
    );
    
    if (primeXBTOps.length === 0) {
        console.log('ℹ️ No se encontraron operaciones de PrimeXBT para corregir');
        return;
    }
    
    // Agrupar por fecha e instrumento para asignar el mismo ID
    const groupedByDateInstrument = {};
    primeXBTOps.forEach(op => {
        const key = `${op.date}_${op.instrument}`;
        if (!groupedByDateInstrument[key]) {
            groupedByDateInstrument[key] = [];
        }
        groupedByDateInstrument[key].push(op);
    });
    
    let correctedCount = 0;
    
    for (const [key, operations] of Object.entries(groupedByDateInstrument)) {
        // Usar la fecha como ID base para operaciones del mismo día/instrumento
        const [dateStr] = key.split('_');
        const newId = dateStr.replace(/-/g, '');
        
        console.log(`📝 Asignando ID ${newId} a ${operations.length} operaciones de ${key}`);
        
        for (const op of operations) {
            const oldId = op.id;
            op.id = newId;
            
            try {
                // Eliminar la operación con el ID antiguo
                await dexieDB.operations.delete(oldId);
                // Agregar la operación con el nuevo ID
                await dexieDB.operations.add(op);
                
                // Sincronizar con Supabase si está conectado
                if (currentUser) {
                    await saveOperationToSupabase(op);
                }
                
                correctedCount++;
            } catch (error) {
                console.error('Error actualizando operación:', error);
            }
        }
    }
    
    console.log(`✅ Se corrigieron ${correctedCount} operaciones de PrimeXBT`);
    
    // Actualizar vistas
    updateAccountBalances();
    refreshAllViews();
    
    showSyncNotification(`✅ Se corrigieron ${correctedCount} IDs de operaciones de PrimeXBT`, 'success');
}

// Exportar función al ámbito global
window.fixPrimeXBTOperationIDs = fixPrimeXBTOperationIDs;

// Función global para ejecutar corrección manualmente desde consola
window.fixPrimeXBTIDs = async function() {
    if (typeof fixPrimeXBTOperationIDs === 'function') {
        await fixPrimeXBTOperationIDs();
    } else {
        console.warn('⚠️ fixPrimeXBTOperationIDs no está disponible');
    }
};

// Función global para resetear la corrección (para testing)
window.resetPrimeXBTCorrection = function() {
    localStorage.removeItem('primexbt-id-correction-executed');
    console.log('✅ Flag de corrección reseteado. Recarga la página para ejecutar nuevamente.');
};

// Función global para resetear el contador de IDs (usar con precaución)
window.resetOperationIdCounter = function(startValue = 25000) {
    localStorage.setItem('operation-id-counter', startValue.toString());
    console.log(`✅ Contador de IDs reseteado a ${startValue}`);
};

// Función global para ver el contador actual
window.getOperationIdCounter = function() {
    const counter = localStorage.getItem('operation-id-counter') || '25000';
    console.log(`📊 Contador actual de IDs: ${counter}`);
    console.log(`📊 Próximo ID disponible: ${counter}`);
    return counter;
};

// ============================================
// FUNCIÓN PARA PROCESAR DATOS DE INTERFAZ BITGET
// ============================================

async function processBitgetInterfaceData(rawData, accountId) {
    console.log('📄 Procesando datos desde interfaz de Bitget...');
    
    if (!rawData || !rawData.trim()) {
        showSyncNotification('❌ No se proporcionaron datos para importar', 'error');
        return;
    }

    if (!accountId) {
        showSyncNotification('❌ Debes seleccionar una cuenta destino', 'error');
        return;
    }

    // Buscar la cuenta seleccionada
    const account = DB.accounts.find(acc => acc.id === accountId);
    if (!account) {
        showSyncNotification('❌ Cuenta no encontrada', 'error');
        return;
    }

    // Separar por tabulaciones y saltos de línea
    const allFields = rawData
        .split(/[\n\t]+/)
        .map(field => field.trim())
        .filter(field => field && field !== '');
    
    console.log('📋 Total de campos detectados:', allFields.length);
    console.log('📋 Primeros 20 campos:', allFields.slice(0, 20));
    
    if (allFields.length < 10) {
        showSyncNotification('❌ Los datos parecen incompletos. Asegúrate de copiar toda la información desde el Historial de Posición.', 'error');
        return;
    }

    const rawOperations = [];
    let fieldIndex = 0;
    let operationsCount = 0;
    let skippedOpsCount = 0;

    // Formato esperado del Historial de Posición de Bitget:
    // 0: Instrumento (ej: BTCUSDT)
    // 1: Tipo y Margen (ej: Short · Aislado o Long · Cruz)
    // 2: Fecha apertura (ej: 2025-08-23)
    // 3: Hora apertura (ej: 17:37:37)
    // 4: Precio apertura (ej: 114,818.1)
    // 5: Precio cierre (ej: 114,794.1)
    // 6: Volumen apertura (ej: 0.5565 BTC)
    // 7: Volumen cierre (ej: 0.5565 BTC)
    // 8: P&L (ej: -37.7531 USDT)
    // 9: Separador o ROE (ej: -- o +2.5%)
    // 10: Fecha cierre (ej: 2025-08-23)
    // 11: Hora cierre (ej: 17:58:12)
    // 12: Posible campo adicional (ej: --)

    while (fieldIndex < allFields.length) {
        try {
            // Verificar si tenemos suficientes campos (mínimo 12)
            if (fieldIndex + 11 >= allFields.length) {
                console.warn('⚠️ No hay suficientes campos para completar más operaciones');
                break;
            }

            // Extraer campos
            const instrument = (allFields[fieldIndex] || '').replace('/', '').toUpperCase();
            const typeAndMargin = (allFields[fieldIndex + 1] || '').toLowerCase();
            const openDate = allFields[fieldIndex + 2] || '';
            const openTime = allFields[fieldIndex + 3] || '';
            const openPriceStr = (allFields[fieldIndex + 4] || '0').replace(',', '.');
            const closePriceStr = (allFields[fieldIndex + 5] || '0').replace(',', '.');
            const volumeOpenStr = allFields[fieldIndex + 6] || '0';
            const volumeCloseStr = allFields[fieldIndex + 7] || '0';
            const plStr = allFields[fieldIndex + 8] || '0';
            
            // Los siguientes campos pueden variar
            let closeDate = '';
            let closeTime = '';
            
            // Buscar la fecha de cierre (formato YYYY-MM-DD)
            for (let i = fieldIndex + 9; i < Math.min(fieldIndex + 15, allFields.length); i++) {
                if (/^\d{4}-\d{2}-\d{2}$/.test(allFields[i])) {
                    closeDate = allFields[i];
                    // La hora de cierre debería estar justo después
                    if (i + 1 < allFields.length && /^\d{2}:\d{2}:\d{2}$/.test(allFields[i + 1])) {
                        closeTime = allFields[i + 1];
                        fieldIndex = i + 2; // Avanzar al siguiente registro
                    } else {
                        closeTime = openTime; // Usar hora de apertura si no hay hora de cierre
                        fieldIndex = i + 1;
                    }
                    break;
                }
            }

            if (!closeDate) {
                console.warn(`⚠️ No se encontró fecha de cierre para operación ${instrument}`);
                closeDate = openDate; // Usar fecha de apertura como fallback
                closeTime = openTime;
                fieldIndex += 13; // Saltar algunos campos
            }

            console.log(`📊 Procesando operación ${instrument}:`, {
                typeAndMargin,
                openDate,
                openTime,
                openPrice: openPriceStr,
                closePrice: closePriceStr,
                volume: volumeOpenStr,
                pl: plStr,
                closeDate,
                closeTime
            });

            // Validar datos mínimos
            if (!instrument || !openDate) {
                console.warn(`⚠️ Operación omitida (datos incompletos)`);
                skippedOpsCount++;
                continue;
            }

            // Determinar tipo (Long = buy, Short = sell)
            let type = '';
            if (typeAndMargin.includes('long')) {
                type = 'buy';
            } else if (typeAndMargin.includes('short')) {
                type = 'sell';
            } else {
                console.warn(`⚠️ Tipo de operación desconocido: ${typeAndMargin}`);
                skippedOpsCount++;
                continue;
            }

            // Parsear precios
            const openPrice = parseFloat(openPriceStr);
            const closePrice = parseFloat(closePriceStr);
            
            if (!openPrice || openPrice === 0) {
                console.warn(`⚠️ Precio de apertura inválido: ${openPriceStr}`);
                skippedOpsCount++;
                continue;
            }

            // Parsear volumen (extraer el número, ignorar la unidad)
            const volumeMatch = volumeOpenStr.match(/([\d,\.]+)/);
            const volume = volumeMatch ? parseFloat(volumeMatch[1].replace(',', '.')) : 0;
            
            if (!volume || volume === 0) {
                console.warn(`⚠️ Volumen inválido: ${volumeOpenStr}`);
                skippedOpsCount++;
                continue;
            }

            // Parsear P&L (formato: -37.7531 USDT o +50.25 USDT)
            const plMatch = plStr.match(/([+\-]?[\d,\.]+)/);
            const pl = plMatch ? parseFloat(plMatch[1].replace(',', '.')) : 0;

            // Extraer divisa del P&L
            const currencyMatch = plStr.match(/[A-Z]{3,4}$/);
            const currency = currencyMatch ? currencyMatch[0] : 'USDT';

            // Crear operación
            const operation = {
                accountId: accountId,
                date: openDate,
                entryTime: openTime,
                exitTime: closeTime,
                instrument: instrument,
                type: type,
                entry: openPrice,
                exit: closePrice || openPrice, // Si no hay precio de cierre, usar el de apertura
                volume: volume,
                currency: currency,
                fees: 0, // Bitget no muestra fees separados en el historial de posición
                notes: `Importado desde interfaz Bitget - ${typeAndMargin}`,
                imageDatas: [],
                session: detectTradingSession(openTime) || '',
                pl: pl,
                result: pl > 0 ? 'win' : (pl < 0 ? 'loss' : 'breakeven'),
                manualPL: pl
            };

            // Generar ID único
            operation.id = generateUnifiedOperationId(operation, 'bitget', `${instrument}-${openDate}-${openTime}`, null);

            rawOperations.push(operation);
            operationsCount++;
            console.log(`✅ Operación ${instrument} procesada correctamente`);

        } catch (error) {
            console.error('Error procesando operación:', error);
            skippedOpsCount++;
            fieldIndex += 5;
        }
    }

    if (rawOperations.length === 0) {
        showSyncNotification(`❌ No se pudieron procesar operaciones. ${skippedOpsCount} operaciones omitidas.`, 'error');
        return;
    }

    console.log(`📄 Procesadas ${rawOperations.length} operaciones desde interfaz Bitget (${skippedOpsCount} omitidas)`);

    // Guardar operaciones
    let addedCount = 0;
    const statusDiv = document.getElementById('bitget-interface-status');

    for (const operation of rawOperations) {
        // Verificar si ya existe
        const existingOp = DB.operations.find(op => op.id === operation.id);
        
        if (existingOp) {
            console.log(`⏭️ Operación ${operation.id} ya existe, omitida`);
            continue;
        }

        // Agregar a la base de datos
        DB.operations.push(operation);
        await dexieDB.operations.add(operation);

        // Sincronizar con Supabase si está conectado
        if (currentUser) {
            await saveOperationToSupabase(operation);
        }

        addedCount++;
    }

    if (addedCount > 0) {
        showSyncNotification(`✅ ${addedCount} operación(es) importada(s) desde Bitget`, 'success');
        statusDiv.textContent = `✅ ${addedCount} operación(es) importada(s) correctamente`;
        statusDiv.className = 'text-sm text-center text-green';
        
        // Refrescar dashboard si estamos ahí
        if (document.getElementById('dashboard').classList.contains('active')) {
            refreshDashboard();
        }
        
        // Cerrar modal después de 2 segundos
        setTimeout(() => {
            const modal = document.getElementById('bitget-interface-import-modal');
            modal.classList.add('hidden');
            modal.classList.remove('flex');
        }, 2000);
    } else {
        showSyncNotification('ℹ️ No se encontraron operaciones nuevas para importar', 'info');
        statusDiv.textContent = 'ℹ️ Todas las operaciones ya estaban importadas';
        statusDiv.className = 'text-sm text-center text-blue';
    }
}

// ============================================
// FUNCIONES PARA PRIMEXBT CFDs
// ============================================

async function processPrimeXBTCFDsCSV(csvContent) {
    console.log('📄 Procesando CSV para PrimeXBT CFDs...');
    
    // Buscar cuenta seleccionada o crear una por defecto para CFDs
    let selectedAccount = null;
    const primexbtCfdAccounts = DB.accounts.filter(acc => 
        acc.platform === 'primexbt-cfds' || (acc.platform === 'primexbt' && (acc.name.includes('CFD') || acc.name.includes('cfds')))
    );
    
    if (primexbtCfdAccounts.length > 0) {
        selectedAccount = primexbtCfdAccounts[0]; // Usar la primera cuenta de PrimeXBT CFDs
    } else {
        // Crear cuenta de PrimeXBT CFDs automáticamente
        selectedAccount = {
            id: generateId(),
            name: 'PrimeXBT CFDs - Cuenta Principal',
            currency: 'USD',
            platform: 'primexbt-cfds',
            initialBalance: 0,
            balance: 0
        };

        DB.accounts.push(selectedAccount);
        await dexieDB.accounts.add(selectedAccount);

        // Sincronizar con Supabase si está conectado
        if (currentUser) {
            await saveAccountToSupabase(selectedAccount);
        }
    }

    const lines = csvContent.split('\n').map(line => line.trim()).filter(line => line);
    if (lines.length < 2) {
        showSyncNotification('El archivo CSV de PrimeXBT CFDs está vacío o no tiene datos.', 'error');
        return;
    }

    // Usar el mismo método de procesamiento que PrimeXBT Crypto
    const splitLine = (line) => {
        const result = [];
        let current = '';
        let inQuotes = false;
        
        for (let i = 0; i < line.length; i++) {
            const char = line[i];
            if (char === '"') {
                inQuotes = !inQuotes;
            } else if (char === ',' && !inQuotes) {
                result.push(current.trim());
                current = '';
            } else {
                current += char;
            }
        }
        result.push(current.trim());
        return result;
    };

    const headers = splitLine(lines[0]);
    console.log('🔍 [PrimeXBT CFDs CSV] Headers detectados:', headers);

    const rawOperations = [];

    for (let i = 1; i < lines.length; i++) {
        const values = splitLine(lines[i]);
        if (values.length !== headers.length) {
            console.warn(`Línea ${i+1} tiene ${values.length} valores pero se esperaban ${headers.length}. Omitida.`);
            continue;
        }

        const row = {};
        headers.forEach((header, index) => {
            row[header.toLowerCase().trim()] = values[index];
        });

        // Obtener datos de la operación
        const csvId = row['id'] || '';
        const date = row['fecha'] || '';
        const entryTime = row['hora entrada'] || '';
        const exitTime = row['hora salida'] || '';
        const instrument = row['instrumento'] || '';
        const type = row['tipo'] || '';
        const entry = parseFloat(row['entrada'] || '0');
        const exit = parseFloat(row['salida'] || '0');
        const volume = parseFloat(row['volumen'] || '0');
        const pl = parseFloat(row['p&l'] || '0');
        const currency = row['divisa'] || 'USD';
        const fees = parseFloat(row['tarifa/comision'] || '0');
        const notes = row['notas'] || '';

        // Validaciones básicas
        if (!date || !instrument || !type || volume <= 0) {
            console.warn(`Línea ${i+1}: Datos insuficientes. Omitida.`);
            continue;
        }

        // Crear operación básica
        const baseOperation = {
            accountId: selectedAccount.id,
            date: date,
            entryTime: entryTime || '09:00',
            exitTime: exitTime || '09:00',
            instrument: instrument.toUpperCase(),
            type: type.toLowerCase(),
            entry: isNaN(entry) ? null : entry,
            exit: isNaN(exit) ? null : exit,
            volume: volume,
            pl: parseFloat(pl.toFixed(5)),
            result: pl > 0 ? 'win' : (pl < 0 ? 'loss' : 'breakeven'),
            currency: currency.toUpperCase(),
            notes: notes || `PrimeXBT CFDs - Importado ${new Date().toLocaleString()}`,
            imageDatas: [],
            fees: fees || 0,
            manualPL: pl,
            session: detectTradingSession(entryTime) || ''
        };

        // Generar ID usando la función centralizada
        baseOperation.id = generateUnifiedOperationId(baseOperation, 'primexbt-cfds', csvId || null);

        rawOperations.push(baseOperation);
    }

    if (rawOperations.length === 0) {
        showSyncNotification('❌ No se encontraron operaciones válidas en el CSV de PrimeXBT CFDs', 'error');
        return;
    }

    // Procesar operaciones usando las funciones centralizadas
    const newOperations = await processAndCleanOperations(rawOperations, 'primexbt-cfds');
    const importedCount = newOperations.length;

    if (newOperations.length > 0) {
        try {
            await dexieDB.operations.bulkAdd(newOperations);
            DB.operations.push(...newOperations);

            // SINCRONIZACIÓN AUTOMÁTICA CON SUPABASE
            console.log('🔍 Iniciando sincronización de operaciones importadas...');
            if (currentUser) {
                console.log('🔍 Usuario autenticado - sincronizando', newOperations.length, 'operaciones...');
                let successCount = 0;
                let errorCount = 0;

                for (const operation of newOperations) {
                    try {
                        await saveOperationToSupabase(operation);
                        successCount++;
                        console.log('✅ Operación sincronizada:', operation.id);
                    } catch (error) {
                        console.error('❌ Error sincronizando operación:', operation.id, error);
                        addToSyncQueue(operation, 'operation');
                        errorCount++;
                    }
                }

                if (errorCount > 0) {
                    console.log(`⚠️ ${errorCount} operaciones agregadas a la cola de sincronización`);
                }
                console.log(`📊 Sincronización completada: ${successCount} exitosas, ${errorCount} pendientes`);
            } else {
                console.log('⚠️ Usuario no autenticado - operaciones almacenadas localmente solamente');
            }

            // Actualizar vistas y mostrar resultado
            updateAccountBalances();
            refreshAllViews();
            
            showSyncNotification(`✅ Se importaron ${importedCount} operaciones de PrimeXBT CFDs desde CSV`, 'success');
            console.log(`✅ Importación completada: ${importedCount} operaciones de PrimeXBT CFDs`);
        } catch (error) {
            console.error('❌ Error guardando operaciones:', error);
            showSyncNotification('❌ Error guardando operaciones importadas', 'error');
        }
    } else {
        showSyncNotification('ℹ️ No se encontraron operaciones nuevas para importar', 'info');
    }
}

function importPrimeXBTCFDsCSV() {
    // Crear input de archivo
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.csv';
    input.style.display = 'none';

    input.onchange = function(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = async function(e) {
            try {
                const csv = e.target.result;
                await processPrimeXBTCFDsCSV(csv);
            } catch (error) {
                console.error('Error procesando CSV:', error);
                showSyncNotification('❌ Error procesando archivo CSV', 'error');
            }
        };
        reader.readAsText(file);
    };

    document.body.appendChild(input);
    input.click();
    document.body.removeChild(input);
}

// ============================================
// FUNCIONES PARA MEXC
// ============================================

function importMEXCCSV() {
    // Crear input de archivo
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.csv';
    input.style.display = 'none';

    input.onchange = function(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = async function(e) {
            try {
                const csv = e.target.result;
                await processMEXCCSV(csv);
            } catch (error) {
                console.error('Error procesando CSV:', error);
                showSyncNotification('❌ Error procesando archivo CSV', 'error');
            }
        };
        reader.readAsText(file);
    };

    document.body.appendChild(input);
    input.click();
    document.body.removeChild(input);
}

// Función para procesar CSV de MEXC
async function processMEXCCSV(csvContent) {
    console.log('📄 Procesando CSV para MEXC...');

    const parsedData = parseCSV(csvContent);

    if (!parsedData.headers || parsedData.rows.length === 0) {
        showSyncNotification('❌ CSV vacío o formato incorrecto', 'error');
        return;
    }

    const headerMap = {};
    parsedData.headers.forEach((header, index) => {
        headerMap[header.toLowerCase().trim().replace(/\s+/g, ' ')] = index;
    });

    console.log('🔍 [MEXC CSV] Headers normalizados detectados:', Object.keys(headerMap));

    const requiredHeaders = ['nombre cuenta', 'fecha', 'hora entrada', 'hora salida', 'instrumento', 'tipo', 'entrada', 'salida', 'volumen', 'divisa'];
    for (const reqHeader of requiredHeaders) {
        if (!(reqHeader in headerMap)) {
            showSyncNotification(`❌ Cabecera requerida no encontrada: '${reqHeader}'`, 'error');
            return;
        }
    }

    let skippedOpsCount = 0;
    const rawOperations = [];

    for (const row of parsedData.rows) {
        const accountNameFromCsv = row[headerMap['nombre cuenta']];
        if (!accountNameFromCsv || accountNameFromCsv.trim() === "") {
            skippedOpsCount++;
            continue;
        }

        const account = DB.accounts.find(acc => acc.name.trim().toLowerCase() === accountNameFromCsv.trim().toLowerCase());

        if (!account) {
            console.warn(`Cuenta no encontrada: "${accountNameFromCsv}". Operación omitida.`);
            skippedOpsCount++;
            continue;
        }

        const dateStr = row[headerMap['fecha']];
        let opDate;

        // Limpiar y validar la fecha
        const cleanDateStr = dateStr.trim();

        if (cleanDateStr.includes('-')) {
            // Formato YYYY-MM-DD
            const parts = cleanDateStr.split('-');
            if (parts.length === 3 && parts[0].length === 4) {
                const year = parts[0];
                const month = parts[1].padStart(2, '0');
                const day = parts[2].padStart(2, '0');
                opDate = `${year}-${month}-${day}`;
            }
        } else if (cleanDateStr.includes('/')) {
            // Formato DD/MM/YYYY
            const parts = cleanDateStr.split('/');
            if (parts.length === 3) {
                const day = parts[0].padStart(2, '0');
                const month = parts[1].padStart(2, '0');
                const year = parts[2];
                opDate = `${year}-${month}-${day}`;
            }
        }

        // Validar que la fecha sea válida
        if (!opDate) {
            console.warn(`Fecha inválida: "${dateStr}". Operación omitida.`);
            skippedOpsCount++;
            continue;
        }

        const testDate = new Date(opDate + "T12:00:00");
        if (isNaN(testDate.getTime())) {
            console.warn(`Fecha inválida después de parsear: "${opDate}". Operación omitida.`);
            skippedOpsCount++;
            continue;
        }

        const instrument = row[headerMap['instrumento']].toUpperCase().trim();
        const type = row[headerMap['tipo']].toLowerCase().trim();
        const entryStr = String(row[headerMap['entrada']]).replace(',', '.');
        const exitStr = String(row[headerMap['salida']]).replace(',', '.');
        const volumeStr = String(row[headerMap['volumen']]).replace(',', '.');

        const entryTime = row[headerMap['hora entrada']] || null;
        const exitTime = row[headerMap['hora salida']] || null;
        const session = headerMap['sesion'] !== undefined ? row[headerMap['sesion']].trim() : 'No especificado';

        const entry = parseFloat(entryStr);
        const exit = parseFloat(exitStr);
        const volume = parseFloat(volumeStr);

        const currency = row[headerMap['divisa']].toUpperCase().trim();
        const notes = headerMap['notas'] !== undefined ? row[headerMap['notas']] : '';

        // Procesar tarifa/comisiones - Buscar en todas las variantes posibles
        let fees = 0;
        const possibleFeeHeaders = [
            'tarifa/comision',
            'tarifa/comisión',
            'tarifa',
            'comision',
            'comisión',
            'fee',
            'fees',
            'commission'
        ];

        let feeColumnFound = false;
        for (const feeHeader of possibleFeeHeaders) {
            if (headerMap[feeHeader] !== undefined) {
                const feeValue = row[headerMap[feeHeader]];
                if (feeValue && String(feeValue).trim() !== "") {
                    fees = Math.abs(parseFloat(String(feeValue).replace(',', '.')));
                    console.log(`💰 [MEXC CSV] Comisión detectada en columna '${feeHeader}':`, fees);
                    feeColumnFound = true;
                    break;
                }
            }
        }

        if (!feeColumnFound) {
            console.log('⚠️ [MEXC CSV] No se encontró columna de comisión en:', Object.keys(headerMap));
        }

        let pl = (headerMap['p&l'] !== undefined && row[headerMap['p&l']] && String(row[headerMap['p&l']]).trim() !== "")
            ? parseFloat(String(row[headerMap['p&l']]).replace(',', '.'))
            : null;
        let result;

        if (isNaN(volume) || volume <= 0) {
            skippedOpsCount++;
            continue;
        }

        if ((pl === null || isNaN(pl)) && (isNaN(entry) || isNaN(exit))) {
            skippedOpsCount++;
            continue;
        }

        if (pl !== null && !isNaN(pl)) {
            result = pl > 0 ? 'win' : (pl < 0 ? 'loss' : 'breakeven');
        } else {
            if (isNaN(entry) || isNaN(exit)) {
                skippedOpsCount++;
                continue;
            }
            if (type === 'buy')
             pl = (exit - entry) * volume;
            else pl = (entry - exit) * volume;
            result = pl > 0 ? 'win' : (pl < 0 ? 'loss' : 'breakeven');
        }
        pl = parseFloat(pl.toFixed(5));

        // Obtener ID del CSV si existe
        const csvId = headerMap['id'] !== undefined && row[headerMap['id']] && String(row[headerMap['id']]).trim() !== ""
            ? String(row[headerMap['id']]).trim()
            : null;

        // Crear operación básica
        const baseOperation = {
            date: opDate,
            accountId: account.id,
            instrument,
            type,
            entry: isNaN(entry) ? null : entry,
            exit: isNaN(exit) ? null : exit,
            entryTime,
            exitTime,
            volume,
            result,
            pl,
            currency,
            notes,
            imageDatas: [],
            fees: fees || 0,
            manualPL: (headerMap['p&l'] !== undefined && row[headerMap['p&l']] && String(row[headerMap['p&l']]).trim() !== "" && !isNaN(parseFloat(String(row[headerMap['p&l']]).replace(',', '.'))))
                ? parseFloat(String(row[headerMap['p&l']]).replace(',', '.'))
                : null,
            session: session
        };

        // Generar ID usando la función centralizada
        baseOperation.id = generateUnifiedOperationId(baseOperation, 'mexc', csvId);

        rawOperations.push(baseOperation);
    }

    // Procesar operaciones usando las funciones centralizadas
    const newOperations = await processAndCleanOperations(rawOperations, 'mexc');
    const importedOpsCount = newOperations.length;

    if (newOperations.length > 0) {
        try {
            await dexieDB.operations.bulkAdd(newOperations);
            DB.operations.push(...newOperations);

            // SINCRONIZACIÓN AUTOMÁTICA CON SUPABASE
            console.log('🔍 Iniciando sincronización de operaciones importadas...');
            if (currentUser) {
                console.log('🔍 Usuario autenticado - sincronizando', newOperations.length, 'operaciones...');
                let successCount = 0;
                let errorCount = 0;

                for (const operation of newOperations) {
                    try {
                        await saveOperationToSupabase(operation);
                        successCount++;
                        console.log('✅ Operación sincronizada:', operation.id);
                    } catch (error) {
                        console.error('❌ Error sincronizando operación:', operation.id, error);
                        addToSyncQueue(operation, 'operation');
                        errorCount++;
                    }
                }

                if (errorCount > 0) {
                    console.log(`⚠️ ${errorCount} operaciones agregadas a la cola de sincronización`);
                }
                console.log(`📊 Sincronización completada: ${successCount} exitosas, ${errorCount} pendientes`);
            } else {
                console.log('⚠️ Usuario no autenticado - operaciones almacenadas localmente solamente');
            }

            updateAccountBalances();
            refreshAllViews();
            showSyncNotification(`✅ Se importaron ${importedOpsCount} operaciones de MEXC desde CSV. ${skippedOpsCount} filas omitidas.`, 'success');
            console.log(`✅ Importación completada: ${importedOpsCount} operaciones de MEXC, ${skippedOpsCount} omitidas`);

        } catch (error) {
            console.error('❌ Error guardando operaciones:', error);
            showSyncNotification('❌ Error guardando operaciones importadas', 'error');
        }
    } else {
        showSyncNotification('ℹ️ No se encontraron operaciones nuevas para importar', 'info');
        console.log(`📄 Procesamiento completado: ${skippedOpsCount} filas omitidas, 0 operaciones nuevas`);
    }
}

// ============================================
// FUNCIONES PARA BITUNIX
// ============================================

function importBitunixCSV() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.csv';
    input.style.display = 'none';

    input.onchange = function(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = async function(e) {
            try {
                const csv = e.target.result;
                await processBitunixCSV(csv);
            } catch (error) {
                console.error('Error procesando CSV:', error);
                showSyncNotification('❌ Error procesando archivo CSV', 'error');
            }
        };
        reader.readAsText(file);
    };

    document.body.appendChild(input);
    input.click();
    document.body.removeChild(input);
}

async function processBitunixCSV(csvContent) {
    console.log('📄 Procesando CSV para Bitunix...');
    const parsedData = parseCSV(csvContent);

    if (!parsedData.headers || parsedData.rows.length === 0) {
        showSyncNotification('❌ CSV vacío o formato incorrecto', 'error');
        return;
    }

    const headerMap = {};
    parsedData.headers.forEach((header, index) => {
        headerMap[header.toLowerCase().trim().replace(/\s+/g, ' ')] = index;
    });

    console.log('🔍 [Bitunix CSV] Headers:', Object.keys(headerMap));

    const requiredHeaders = ['nombre cuenta', 'fecha', 'hora entrada', 'hora salida', 'instrumento', 'tipo', 'entrada', 'salida', 'volumen', 'divisa'];
    for (const reqHeader of requiredHeaders) {
        if (!(reqHeader in headerMap)) {
            showSyncNotification(`❌ Cabecera requerida no encontrada: '${reqHeader}'`, 'error');
            return;
        }
    }

    showSyncNotification('⏳ Importando operaciones de Bitunix...', 'info');
    // El resto de la lógica es similar a MEXC
    showSyncNotification('✅ Importación de Bitunix completada (función en desarrollo)', 'success');
}

// ============================================
// FUNCIONES PARA LBANK
// ============================================

function importLBankCSV() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.csv';
    input.style.display = 'none';

    input.onchange = function(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = async function(e) {
            try {
                const csv = e.target.result;
                await processLBankCSV(csv);
            } catch (error) {
                console.error('Error procesando CSV:', error);
                showSyncNotification('❌ Error procesando archivo CSV', 'error');
            }
        };
        reader.readAsText(file);
    };

    document.body.appendChild(input);
    input.click();
    document.body.removeChild(input);
}

async function processLBankCSV(csvContent) {
    console.log('📄 Procesando CSV para LBank...');
    const parsedData = parseCSV(csvContent);

    if (!parsedData.headers || parsedData.rows.length === 0) {
        showSyncNotification('❌ CSV vacío o formato incorrecto', 'error');
        return;
    }

    const headerMap = {};
    parsedData.headers.forEach((header, index) => {
        headerMap[header.toLowerCase().trim().replace(/\s+/g, ' ')] = index;
    });

    console.log('🔍 [LBank CSV] Headers:', Object.keys(headerMap));

    const requiredHeaders = ['nombre cuenta', 'fecha', 'hora entrada', 'hora salida', 'instrumento', 'tipo', 'entrada', 'salida', 'volumen', 'divisa'];
    for (const reqHeader of requiredHeaders) {
        if (!(reqHeader in headerMap)) {
            showSyncNotification(`❌ Cabecera requerida no encontrada: '${reqHeader}'`, 'error');
            return;
        }
    }

    showSyncNotification('⏳ Importando operaciones de LBank...', 'info');
    // El resto de la lógica es similar a MEXC
    showSyncNotification('✅ Importación de LBank completada (función en desarrollo)', 'success');
}

// ============================================
// FUNCIONES PARA BLOFIN
// ============================================

function importBloFinCSV() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.csv';
    input.style.display = 'none';

    input.onchange = function(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = async function(e) {
            try {
                const csv = e.target.result;
                await processBloFinCSV(csv);
            } catch (error) {
                console.error('Error procesando CSV:', error);
                showSyncNotification('❌ Error procesando archivo CSV', 'error');
            }
        };
        reader.readAsText(file);
    };

    document.body.appendChild(input);
    input.click();
    document.body.removeChild(input);
}

async function processBloFinCSV(csvContent) {
    console.log('📄 Procesando CSV para BloFin...');
    const parsedData = parseCSV(csvContent);

    if (!parsedData.headers || parsedData.rows.length === 0) {
        showSyncNotification('❌ CSV vacío o formato incorrecto', 'error');
        return;
    }

    const headerMap = {};
    parsedData.headers.forEach((header, index) => {
        headerMap[header.toLowerCase().trim().replace(/\s+/g, ' ')] = index;
    });

    console.log('🔍 [BloFin CSV] Headers:', Object.keys(headerMap));

    const requiredHeaders = ['nombre cuenta', 'fecha', 'hora entrada', 'hora salida', 'instrumento', 'tipo', 'entrada', 'salida', 'volumen', 'divisa'];
    for (const reqHeader of requiredHeaders) {
        if (!(reqHeader in headerMap)) {
            showSyncNotification(`❌ Cabecera requerida no encontrada: '${reqHeader}'`, 'error');
            return;
        }
    }

    showSyncNotification('⏳ Importando operaciones de BloFin...', 'info');
    // El resto de la lógica es similar a MEXC
    showSyncNotification('✅ Importación de BloFin completada (función en desarrollo)', 'success');
}

// ============================================
// FUNCIONES PARA BITGET
// ============================================

function importBitgetCSV() {
    // Crear input de archivo
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.csv';
    input.style.display = 'none';

    input.onchange = function(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = async function(e) {
            try {
                const csv = e.target.result;
                await processBitgetCSV(csv);
            } catch (error) {
                console.error('Error procesando CSV:', error);
                showSyncNotification('❌ Error procesando archivo CSV', 'error');
            }
        };
        reader.readAsText(file);
    };

    document.body.appendChild(input);
    input.click();
    document.body.removeChild(input);
}

// Función para procesar CSV de Bitget
async function processBitgetCSV(csvContent) {
    console.log('📄 Procesando CSV para Bitget...');

    const parsedData = parseCSV(csvContent);

    if (!parsedData.headers || parsedData.rows.length === 0) {
        showSyncNotification('❌ CSV vacío o formato incorrecto', 'error');
        return;
    }

    const headerMap = {};
    parsedData.headers.forEach((header, index) => {
        headerMap[header.toLowerCase().trim().replace(/\s+/g, ' ')] = index;
    });

    console.log('🔍 [Bitget CSV] Headers normalizados detectados:', Object.keys(headerMap));

    const requiredHeaders = ['nombre cuenta', 'id', 'fecha', 'hora entrada', 'hora salida', 'instrumento', 'tipo', 'entrada', 'salida', 'volumen', 'divisa'];
    for (const reqHeader of requiredHeaders) {
        if (!(reqHeader in headerMap)) {
            showSyncNotification(`❌ Cabecera requerida no encontrada: '${reqHeader}'`, 'error');
            return;
        }
    }

    let skippedOpsCount = 0;
    const rawOperations = [];

    for (const row of parsedData.rows) {
        console.log('🔍 [Bitget CSV] Procesando fila:', row);
        
        const accountNameFromCsv = row[headerMap['nombre cuenta']];
        console.log('📋 [Bitget CSV] Nombre cuenta del CSV:', accountNameFromCsv);
        
        if (!accountNameFromCsv || accountNameFromCsv.trim() === "") {
            console.warn('⚠️ [Bitget CSV] Nombre de cuenta vacío, saltando operación');
            skippedOpsCount++;
            continue;
        }

        const account = DB.accounts.find(acc => acc.name.trim().toLowerCase() === accountNameFromCsv.trim().toLowerCase());
        console.log('🏦 [Bitget CSV] Cuentas disponibles:', DB.accounts.map(a => a.name));
        console.log('🔍 [Bitget CSV] Cuenta encontrada:', account);

        if (!account) {
            console.warn(`❌ [Bitget CSV] Cuenta no encontrada: "${accountNameFromCsv}". Creando automáticamente...`);
            
            // Crear cuenta automáticamente
            const newAccount = {
                id: generateId(),
                name: accountNameFromCsv.trim(),
                broker: 'Bitget',
                currency: 'USDT', // Asumir USDT por defecto para Bitget
                balance: 0,
                initialBalance: 0,
                isActive: true,
                imagelogo: '/logos/bitget-logo.png'
            };
            
            DB.accounts.push(newAccount);
            await dexieDB.accounts.add(newAccount);
            console.log('✅ [Bitget CSV] Cuenta creada automáticamente:', newAccount);
            
            // Usar la cuenta recién creada
            const createdAccount = newAccount;
            
            // Continuar con el procesamiento usando createdAccount en lugar de account
            const dateStr = row[headerMap['fecha']];
            let opDate;

            const cleanDateStr = dateStr.trim();
 
            if (cleanDateStr.includes('-')) {
                const parts = cleanDateStr.split('-');
                if (parts.length === 3 && parts[0].length === 4) {
                    const year = parts[0];
                    const month = parts[1].padStart(2, '0');
                    const day = parts[2].padStart(2, '0');
                    opDate = `${year}-${month}-${day}`;
                }
            } else if (cleanDateStr.includes('/')) {
                const parts = cleanDateStr.split('/');
                if (parts.length === 3) {
                    const day = parts[0].padStart(2, '0');
                    const month = parts[1].padStart(2, '0');
                    const year = parts[2];
                    opDate = `${year}-${month}-${day}`;
                }
            }

            if (!opDate) {
                console.warn(`Fecha inválida: "${dateStr}". Operación omitida.`);
                skippedOpsCount++;
                continue;
            }

            const testDate = new Date(opDate + "T12:00:00");
            if (isNaN(testDate.getTime())) {
                console.warn(`Fecha inválida después de parsear: "${opDate}". Operación omitida.`);
                skippedOpsCount++;
                continue;
            }

            const instrument = row[headerMap['instrumento']].toUpperCase().trim();
            const type = row[headerMap['tipo']].toLowerCase().trim();
            const entryStr = String(row[headerMap['entrada']]).replace(',', '.');
            const exitStr = String(row[headerMap['salida']]).replace(',', '.');
            const volumeStr = String(row[headerMap['volumen']]).replace(',', '.');

            const entryTime = row[headerMap['hora entrada']] || null;
            const exitTime = row[headerMap['hora salida']] || null;
            const session = headerMap['sesion'] !== undefined ? row[headerMap['sesion']].trim() : 'No especificado';

            const entry = parseFloat(entryStr);
            const exit = parseFloat(exitStr);
            const volume = parseFloat(volumeStr);

            const currency = row[headerMap['divisa']].toUpperCase().trim();
            const notes = headerMap['notas'] !== undefined ? row[headerMap['notas']] : '';

            // Procesar tarifa/comisiones
            let fees = 0;
            const possibleFeeHeaders = [
                'tarifa/comision',
                'tarifa/comisión',
                'tarifa',
                'comision',
                'comisión',
                'fee',
                'fees',
                'commission'
            ];

            let feeColumnFound = false;
            for (const feeHeader of possibleFeeHeaders) {
                if (headerMap[feeHeader] !== undefined) {
                    const feeValue = row[headerMap[feeHeader]];
                    if (feeValue && String(feeValue).trim() !== "") {
                        fees = Math.abs(parseFloat(String(feeValue).replace(',', '.')));
                        console.log(`💰 [Bitget CSV] Comisión detectada en columna '${feeHeader}':`, fees);
                        feeColumnFound = true;
                        break;
                    }
                }
            }

            if (!feeColumnFound) {
                console.log('⚠️ [Bitget CSV] No se encontró columna de comisión');
            }

            // Obtener ID del CSV para agrupación
            const csvId = headerMap['id'] !== undefined && row[headerMap['id']] && String(row[headerMap['id']]).trim() !== ""
                ? String(row[headerMap['id']]).trim()
                : null;

            let pl = (headerMap['p&l'] !== undefined && row[headerMap['p&l']] && String(row[headerMap['p&l']]).trim() !== "")
                ? parseFloat(String(row[headerMap['p&l']]).replace(',', '.'))
                : null;
            let result;

            if (isNaN(volume) || volume <= 0) {
                skippedOpsCount++;
                continue;
            }

            if ((pl === null || isNaN(pl)) && (isNaN(entry) || isNaN(exit))) {
                skippedOpsCount++;
                continue;
            }

            if (pl !== null && !isNaN(pl)) {
                result = pl > 0 ? 'win' : (pl < 0 ? 'loss' : 'breakeven');
            } else {
                if (isNaN(entry) || isNaN(exit)) {
                    skippedOpsCount++;
                    continue;
                }
                if (type === 'buy')
                    pl = (exit - entry) * volume;
                else
                    pl = (entry - exit) * volume;
                result = pl > 0 ? 'win' : (pl < 0 ? 'loss' : 'breakeven');
            }
            pl = parseFloat(pl.toFixed(5));

            // Crear operación básica
            const baseOperation = {
                date: opDate,
                accountId: createdAccount.id,
                instrument,
                type,
                entry: isNaN(entry) ? null : entry,
                exit: isNaN(exit) ? null : exit,
                entryTime,
                exitTime,
                volume,
                result,
                pl,
                currency,
                notes,
                imageDatas: [],
                fees: fees || 0,
                manualPL: (headerMap['p&l'] !== undefined && row[headerMap['p&l']] && String(row[headerMap['p&l']]).trim() !== "" && !isNaN(parseFloat(String(row[headerMap['p&l']]).replace(',', '.'))))
                    ? parseFloat(String(row[headerMap['p&l']]).replace(',', '.'))
                    : null,
                csvId,
                rawCsvData: row.slice(),
                platform: 'Bitget'
            };

            // Usar el ID unificado
            const operationId = generateUnifiedOperationId(baseOperation, csvId);
            baseOperation.id = operationId;

            rawOperations.push(baseOperation);
            continue;
        }

        const dateStr = row[headerMap['fecha']];
        let opDate;

        const cleanDateStr = dateStr.trim();

        if (cleanDateStr.includes('-')) {
            const parts = cleanDateStr.split('-');
            if (parts.length === 3 && parts[0].length === 4) {
                const year = parts[0];
                const month = parts[1].padStart(2, '0');
                const day = parts[2].padStart(2, '0');
                opDate = `${year}-${month}-${day}`;
            }
        } else if (cleanDateStr.includes('/')) {
            const parts = cleanDateStr.split('/');
            if (parts.length === 3) {
                const day = parts[0].padStart(2, '0');
                const month = parts[1].padStart(2, '0');
                const year = parts[2];
                opDate = `${year}-${month}-${day}`;
            }
        }

        if (!opDate) {
            console.warn(`Fecha inválida: "${dateStr}". Operación omitida.`);
            skippedOpsCount++;
            continue;
        }

        const testDate = new Date(opDate + "T12:00:00");
        if (isNaN(testDate.getTime())) {
            console.warn(`Fecha inválida después de parsear: "${opDate}". Operación omitida.`);
            skippedOpsCount++;
            continue;
        }

        const instrument = row[headerMap['instrumento']].toUpperCase().trim();
        const type = row[headerMap['tipo']].toLowerCase().trim();
        const entryStr = String(row[headerMap['entrada']]).replace(',', '.');
        const exitStr = String(row[headerMap['salida']]).replace(',', '.');
        const volumeStr = String(row[headerMap['volumen']]).replace(',', '.');

        const entryTime = row[headerMap['hora entrada']] || null;
        const exitTime = row[headerMap['hora salida']] || null;
        const session = headerMap['sesion'] !== undefined ? row[headerMap['sesion']].trim() : 'No especificado';

        const entry = parseFloat(entryStr);
        const exit = parseFloat(exitStr);
        const volume = parseFloat(volumeStr);

        const currency = row[headerMap['divisa']].toUpperCase().trim();
        const notes = headerMap['notas'] !== undefined ? row[headerMap['notas']] : '';

        // Procesar tarifa/comisiones
        let fees = 0;
        const possibleFeeHeaders = [
            'tarifa/comision',
            'tarifa/comisión',
            'tarifa',
            'comision',
            'comisión',
            'fee',
            'fees',
            'commission'
        ];

        let feeColumnFound = false;
        for (const feeHeader of possibleFeeHeaders) {
            if (headerMap[feeHeader] !== undefined) {
                const feeValue = row[headerMap[feeHeader]];
                if (feeValue && String(feeValue).trim() !== "") {
                    fees = Math.abs(parseFloat(String(feeValue).replace(',', '.')));
                    console.log(`💰 [Bitget CSV] Comisión detectada en columna '${feeHeader}':`, fees);
                    feeColumnFound = true;
                    break;
                }
            }
        }

        if (!feeColumnFound) {
            console.log('⚠️ [Bitget CSV] No se encontró columna de comisión');
        }

        // Obtener ID del CSV para agrupación
        const csvId = headerMap['id'] !== undefined && row[headerMap['id']] && String(row[headerMap['id']]).trim() !== ""
            ? String(row[headerMap['id']]).trim()
            : null;

        let pl = (headerMap['p&l'] !== undefined && row[headerMap['p&l']] && String(row[headerMap['p&l']]).trim() !== "")
            ? parseFloat(String(row[headerMap['p&l']]).replace(',', '.'))
            : null;
        let result;

        if (isNaN(volume) || volume <= 0) {
            skippedOpsCount++;
            continue;
        }

        if ((pl === null || isNaN(pl)) && (isNaN(entry) || isNaN(exit))) {
            skippedOpsCount++;
            continue;
        }

        if (pl !== null && !isNaN(pl)) {
            result = pl > 0 ? 'win' : (pl < 0 ? 'loss' : 'breakeven');
        } else {
            if (isNaN(entry) || isNaN(exit)) {
                skippedOpsCount++;
                continue;
            }
            if (type === 'buy')
                pl = (exit - entry) * volume;
            else
                pl = (entry - exit) * volume;
            result = pl > 0 ? 'win' : (pl < 0 ? 'loss' : 'breakeven');
        }
        pl = parseFloat(pl.toFixed(5));

        // Crear operación básica
        const baseOperation = {
            date: opDate,
            accountId: account.id,
            instrument,
            type,
            entry: isNaN(entry) ? null : entry,
            exit: isNaN(exit) ? null : exit,
            entryTime,
            exitTime,
            volume,
            result,
            pl,
            currency,
            notes,
            imageDatas: [],
            fees: fees || 0,
            manualPL: (headerMap['p&l'] !== undefined && row[headerMap['p&l']] && String(row[headerMap['p&l']]).trim() !== "" && !isNaN(parseFloat(String(row[headerMap['p&l']]).replace(',', '.'))))
                ? parseFloat(String(row[headerMap['p&l']]).replace(',', '.'))
                : null,
            session: session
        };

        // Generar ID usando la función centralizada
        baseOperation.id = generateUnifiedOperationId(baseOperation, 'bitget', csvId);

        rawOperations.push(baseOperation);
    }

    // Procesar operaciones usando las funciones centralizadas
    const newOperations = await processAndCleanOperations(rawOperations, 'bitget');
    const importedOpsCount = newOperations.length;

    if (newOperations.length > 0) {
        try {
            await dexieDB.operations.bulkAdd(newOperations);
            DB.operations.push(...newOperations);

            console.log('🔍 Iniciando sincronización de operaciones importadas...');
            if (currentUser) {
                console.log('🔍 Usuario autenticado - sincronizando', newOperations.length, 'operaciones...');
                let successCount = 0;
                let errorCount = 0;

                for (const operation of newOperations) {
                    try {
                        await saveOperationToSupabase(operation);
                        successCount++;
                        console.log('✅ Operación sincronizada:', operation.id);
                    } catch (error) {
                        console.error('❌ Error sincronizando operación:', operation.id, error);
                        addToSyncQueue(operation, 'operation');
                        errorCount++;
                    }
                }

                console.log(`✅ Sincronización completada: ${successCount} exitosas, ${errorCount} en cola`);
                if (successCount > 0) {
                    showSyncNotification(`💾 ${successCount} operaciones guardadas exitosamente`, 'success');
                }
            } else {
                console.log('ℹ️ Usuario no autenticado - operaciones solo en local');
            }

            updateAccountBalances();
            refreshAllViews();

            showSyncNotification(`✅ ${importedOpsCount} operaciones importadas correctamente. ${skippedOpsCount > 0 ? skippedOpsCount + ' omitidas.' : ''}`, 'success');
        } catch (error) {
            console.error('Error guardando operaciones:', error);
            showSyncNotification('❌ Error guardando operaciones: ' + error.message, 'error');
        }
    } else {
        showSyncNotification(`❌ No se importaron operaciones. ${skippedOpsCount} filas omitidas por errores.`, 'error');
    }
}

// Función para convertir trade de Bitget al formato de la aplicación
function convertBitgetTradeToAppFormat(bitgetTrade, accountId) {
    console.log('🔄 Convirtiendo trade Bitget:', bitgetTrade);
    
    // API V2 campos reales: tradeId, price, baseVolume, side, fee, profit
    const pnl = parseFloat(bitgetTrade.profit || 0);
    const result = pnl > 0 ? 'win' : (pnl < 0 ? 'loss' : 'breakeven');

    // API V2 usa cTime (creation time) en milliseconds
    const tradeDateObj = new Date(parseInt(bitgetTrade.cTime || bitgetTrade.timestamp || Date.now()));
    const tradeDate = getLocalDateString(tradeDateObj);

    const entryTime = new Date(parseInt(bitgetTrade.cTime || bitgetTrade.timestamp || Date.now())).toTimeString().split(' ')[0];
    const exitTime = bitgetTrade.uTime ?
        new Date(parseInt(bitgetTrade.uTime)).toTimeString().split(' ')[0] : entryTime;

    // API V2: tradeId es el ID único del trade
    const tradeId = bitgetTrade.tradeId || bitgetTrade.orderId || Date.now();

    const converted = {
        id: `bitget_${tradeId}`,
        date: tradeDate,
        accountId: accountId,
        instrument: bitgetTrade.symbol,
        type: (bitgetTrade.side || '').toLowerCase(), // "buy" or "sell"
        entry: parseFloat(bitgetTrade.price || 0),
        exit: parseFloat(bitgetTrade.price || 0),
        entryTime: entryTime,
        exitTime: exitTime,
        volume: parseFloat(bitgetTrade.baseVolume || 0),
        result: result,
        pl: pnl,
        fees: Math.abs(parseFloat(bitgetTrade.fee || 0)),
        currency: bitgetTrade.feeCcy || 'USDT',
        notes: `Importado de Bitget V2 - Trade ID: ${tradeId}`,
        imageDatas: [],
        manualPL: null,
        session: detectTradingSession(entryTime) || ''
    };
    
    console.log('✅ Trade convertido:', converted);
    return converted;
}

// Guardar credenciales de Bitget en Supabase
async function saveBitgetCredentialsToSupabase(apiKey, secretKey, passphrase, accountId) {
    if (!currentUser) {
        console.warn('❌ No current user - cannot save Bitget credentials to Supabase');
        return null;
    }

    try {
        console.log('💾 [saveBitget] Iniciando guardado en Supabase...');
        console.log('💾 [saveBitget] User ID:', currentUser.id);
        console.log('💾 [saveBitget] Account ID:', accountId);
        
        // Primero obtener las settings actuales
        console.log('📥 [saveBitget] Consultando settings existentes...');
        const { data: existingSettings, error: fetchError } = await supabase
            .from('user_settings')
            .select('api_keys')
            .eq('user_id', currentUser.id)
            .single();

        if (fetchError && fetchError.code !== 'PGRST116') {
            console.error('❌ [saveBitget] Error al consultar settings:', fetchError);
        }

        let apiKeys = existingSettings?.api_keys || {};
        console.log('📊 [saveBitget] API Keys existentes:', Object.keys(apiKeys));
        
        // Actualizar credenciales de Bitget
        apiKeys.bitget = {
            apiKey: apiKey,
            secretKey: secretKey,
            passphrase: passphrase,
            accountId: accountId,
            updatedAt: new Date().toISOString()
        };

        console.log('💾 [saveBitget] Ejecutando upsert...');
        // Guardar o actualizar
        const { data, error } = await supabase
            .from('user_settings')
            .upsert({
                user_id: currentUser.id,
                api_keys: apiKeys,
                updated_at: new Date().toISOString()
            }, {
                onConflict: 'user_id'
            });

        if (error) {
            console.error('❌ [saveBitget] Error en upsert:', error);
            console.error('❌ [saveBitget] Error code:', error.code);
            console.error('❌ [saveBitget] Error message:', error.message);
            throw error;
        }

        console.log('✅ [saveBitget] Credenciales Bitget guardadas exitosamente');
        console.log('✅ [saveBitget] Response:', data);
        return data;
    } catch (error) {
        console.error('❌ [saveBitget] Error en saveBitgetCredentialsToSupabase:', error);
        console.error('❌ [saveBitget] Stack:', error.stack);
        throw error;
    }
}

// Cargar credenciales de Bitget desde Supabase
async function loadBitgetCredentialsFromSupabase() {
    if (!currentUser) {
        console.log('ℹ️ No hay usuario autenticado para cargar credenciales Bitget');
        return null;
    }

    try {
        console.log('📥 Cargando credenciales Bitget de Supabase...');
        
        const { data, error } = await supabase
            .from('user_settings')
            .select('api_keys')
            .eq('user_id', currentUser.id)
            .single();

        if (error) {
            if (error.code === 'PGRST116') {
                console.log('ℹ️ No hay settings guardados aún');
                return null;
            }
            throw error;
        }

        const bitgetCreds = data?.api_keys?.bitget;
        if (bitgetCreds) {
            console.log('✅ Credenciales Bitget cargadas de Supabase');
            return {
                key: bitgetCreds.apiKey,
                secret: bitgetCreds.secretKey,
                passphrase: bitgetCreds.passphrase,
                accountId: bitgetCreds.accountId
            };
        }

        return null;
    } catch (error) {
        console.error('❌ Error cargando credenciales Bitget de Supabase:', error);
        return null;
    }
}

// Función para sincronizar trades desde Bitget
async function syncBitgetTrades() {
    // 1. Verificar si hay credenciales guardadas en Supabase
    if (!bitgetAPI && currentUser) {
        console.log('🔄 bitgetAPI no inicializada, cargando credenciales desde Supabase...');
        const savedCreds = await loadBitgetCredentialsFromSupabase();
        
        if (savedCreds && savedCreds.key && savedCreds.secret && savedCreds.passphrase) {
            console.log('✅ Credenciales encontradas, inicializando bitgetAPI...');
            console.log('🔑 [DEBUG] API Key:', savedCreds.key.substring(0, 10) + '...');
            console.log('🔑 [DEBUG] Secret:', savedCreds.secret ? '***SET***' : '***EMPTY***');
            console.log('🔑 [DEBUG] Passphrase:', savedCreds.passphrase ? '***SET***' : '***EMPTY***');
            bitgetAPI = new BitgetAPI(savedCreds.key, savedCreds.secret, savedCreds.passphrase);
        }
    }

    // 2. Si aún no hay API, mostrar error
    if (!bitgetAPI) {
        showSyncNotification('❌ Primero debes configurar y guardar tus credenciales de Bitget', 'error');
        updateBitgetStatus('error', 'No configurado', false);
        return;
    }
    
    // 3. DEBUG: Verificar que bitgetAPI tiene credenciales correctas
    console.log('🔍 [DEBUG] Verificando instancia bitgetAPI:');
    console.log('🔍 [DEBUG] API Key:', bitgetAPI.apiKey ? bitgetAPI.apiKey.substring(0, 10) + '...' : 'UNDEFINED');
    console.log('🔍 [DEBUG] Secret:', bitgetAPI.secretKey ? '***SET***' : 'UNDEFINED');
    console.log('🔍 [DEBUG] Passphrase:', bitgetAPI.passphrase ? '***SET***' : 'UNDEFINED');

    let selectedAccount = null;

    const accountDetailSelect = document.getElementById('bitget-account-detail');
    if (accountDetailSelect && accountDetailSelect.value) {
        selectedAccount = DB.accounts.find(acc => acc.id === accountDetailSelect.value);
    }

    if (!selectedAccount) {
        showSyncNotification('❌ Selecciona una cuenta para sincronizar', 'error');
        return;
    }

    updateBitgetStatus('syncing', 'Sincronizando...', true);
    showSyncNotification('🔄 Sincronizando trades de Bitget...', 'info');

    try {
        console.log('📡 Obteniendo trades de Bitget...');

        const tradesResponse = await bitgetAPI.getTradeHistory();

        // API V2 devuelve trades en data.fillList
        const bitgetTrades = tradesResponse?.data?.fillList || tradesResponse?.data || [];
        
        if (!Array.isArray(bitgetTrades) || bitgetTrades.length === 0) {
            console.log('📊 Respuesta de Bitget:', tradesResponse);
            showSyncNotification('ℹ️ No se encontraron trades en Bitget', 'info');
            updateBitgetStatus('connected', 'Conectado - Sin trades', false);
            showSyncNotification('✅ Bitget: Conectado - Sin trades nuevos', 'success');
            return;
        }

        console.log(`📊 Trades obtenidos: ${bitgetTrades.length}`);

        const existingTradeIds = new Set(
            DB.operations
                .filter(op => op.id.startsWith('bitget_'))
                .map(op => op.id)
        );

        let newTradesCount = 0;
        const newOperations = [];

        for (const trade of bitgetTrades) {
            const convertedTrade = convertBitgetTradeToAppFormat(trade, selectedAccount.id);

            if (!existingTradeIds.has(convertedTrade.id)) {
                newOperations.push(convertedTrade);
                newTradesCount++;
            }
        }

        if (newOperations.length > 0) {
            console.log(`💾 Guardando ${newOperations.length} nuevas operaciones en IndexedDB...`);
            console.log('📋 Operaciones a guardar:', newOperations);
            
            try {
                await dexieDB.operations.bulkAdd(newOperations);
                DB.operations.push(...newOperations);
                console.log('✅ Operaciones guardadas en IndexedDB');
            } catch (bulkError) {
                console.error('❌ Error BulkAdd:', bulkError);
                console.error('❌ Error details:', bulkError.failures);
                throw bulkError;
            }

            if (currentUser) {
                for (const operation of newOperations) {
                    try {
                        await saveOperationToSupabase(operation);
                    } catch (error) {
                        console.error('Error sincronizando operación:', error);
                        addToSyncQueue(operation, 'operation');
                    }
                }
            }

            updateAccountBalances();
            refreshAllViews();

            showSyncNotification(`✅ Bitget: ${newTradesCount} trades nuevos sincronizados`, 'success');
            updateBitgetStatus('connected', `Conectado - ${newTradesCount} trades`, true);
        } else {
            showSyncNotification('✅ Bitget: Conectado - Sin trades nuevos', 'success');
            updateBitgetStatus('connected', 'Conectado - Sin trades', true);
        }

        updateBitgetStatus('connected', newTradesCount > 0 ? `Conectado - ${newTradesCount} trades` : 'Conectado - Sin trades', true);
        addBitgetSyncHistory(newTradesCount, bitgetTrades.length - newTradesCount);

    } catch (error) {
        console.error('❌ Error sincronizando trades de Bitget:', error);
        console.error('❌ Stack trace:', error.stack);
        showSyncNotification(`❌ Error: ${error.message}`, 'error');
        updateBitgetStatus('error', 'Error en sincronización', false);
    }
}

// Actualizar estado visual de Bitget
function updateBitgetStatus(status, message, showProgress) {
    const statusIndicator = document.getElementById('bitget-status-indicator');
    const progressBar = document.getElementById('bitget-progress-bar');
    const connectionStatus = document.getElementById('bitget-connection-status');

    if (statusIndicator) {
        const statusColors = {
            'connected': 'text-green-400',
            'syncing': 'text-blue-400',
            'error': 'text-red-400',
            'disconnected': 'text-yellow-400'
        };

        statusIndicator.className = statusColors[status] || 'text-gray-400';
        statusIndicator.textContent = message;
    }

    if (progressBar) {
        progressBar.style.width = showProgress ? '100%' : '0%';
    }

    if (connectionStatus) {
        const bgColors = {
            'connected': 'bg-green-800 border-green-600',
            'syncing': 'bg-blue-800 border-blue-600',
            'error': 'bg-red-800 border-red-600',
            'disconnected': 'bg-yellow-800 border-yellow-600'
        };

        const icons = {
            'connected': 'fa-check-circle text-green-300',
            'syncing': 'fa-sync-alt fa-spin text-blue-300',
            'error': 'fa-exclamation-triangle text-red-300',
            'disconnected': 'fa-exclamation-triangle text-yellow-300'
        };

        connectionStatus.className = `p-4 rounded-md mb-4 ${bgColors[status] || 'bg-gray-800 border-gray-600'}`;
        connectionStatus.innerHTML = `
            <div class="flex items-center">
                <i class="fas ${icons[status] || 'fa-circle'} text-xl mr-3"></i>
                <div>
                    <p class="font-semibold">${message}</p>
                    <p class="text-sm mt-1">${status === 'connected' ? 'Listo para sincronizar trades' : status === 'syncing' ? 'Obteniendo datos...' : 'Verifica la configuración'}</p>
                </div>
            </div>
        `;
    }

    const lastSync = document.getElementById('bitget-last-sync');
    if (lastSync && status === 'connected') {
        const now = new Date();
        lastSync.textContent = `${now.toLocaleDateString()} ${now.toLocaleTimeString()}`;
    }
}

// Agregar entrada al historial de sincronización
function addBitgetSyncHistory(newTrades, skippedTrades) {
    const historyContainer = document.getElementById('bitget-sync-history');
    if (!historyContainer) return;

    if (historyContainer.querySelector('.text-center')) {
        historyContainer.innerHTML = '';
    }

    const now = new Date();
    const historyEntry = document.createElement('div');
    historyEntry.className = 'p-3 bg-surface-light rounded-md text-sm';
    historyEntry.innerHTML = `
        <div class="flex justify-between items-center">
            <div>
                <span class="font-semibold text-green-400">${newTrades} nuevas</span>
                <span class="text-text-secondary mx-2">|</span>
                <span class="text-text-secondary">${skippedTrades} existentes</span>
            </div>
            <span class="text-text-secondary text-xs">${now.toLocaleString()}</span>
        </div>
    `;

    historyContainer.insertBefore(historyEntry, historyContainer.firstChild);

    const entries = historyContainer.querySelectorAll('.p-3');
    if (entries.length > 10) {
        entries[entries.length - 1].remove();
    }
}

// Actualizar historial de importaciones de MEXC
function updateMEXCImportHistory() {
    const historyContainer = document.getElementById('mexc-import-history');
    if (!historyContainer) return;

    // Remover mensaje de "no hay importaciones"
    if (historyContainer.querySelector('.text-center')) {
        historyContainer.innerHTML = '';
    }

    const now = new Date();
    const historyEntry = document.createElement('div');
    historyEntry.className = 'p-3 bg-surface-light rounded-md text-sm';
    historyEntry.innerHTML = `
        <div class="flex justify-between items-center">
            <div>
                <i class="fas fa-file-csv text-blue-400 mr-2"></i>
                <span class="font-semibold text-green-400">CSV Importado</span>
                <span class="text-text-secondary mx-2">|</span>
                <span class="text-text-secondary">MEXC</span>
            </div>
            <span class="text-text-secondary text-xs">${now.toLocaleString()}</span>
        </div>
    `;

    historyContainer.insertBefore(historyEntry, historyContainer.firstChild);

    // Mantener solo las últimas 10 entradas
    const entries = historyContainer.querySelectorAll('.p-3');
    if (entries.length > 10) {
        entries[entries.length - 1].remove();
    }
}

// Cargar credenciales guardadas de Bitget
async function loadBitgetCredentials() {
    try {
        // Primero intentar cargar desde Supabase si hay usuario autenticado
        if (currentUser) {
            const supabaseCreds = await loadBitgetCredentialsFromSupabase();
            if (supabaseCreds) {
                const apiKeyDetail = document.getElementById('bitget-api-key-detail');
                const secretKeyDetail = document.getElementById('bitget-secret-key-detail');
                const passphraseDetail = document.getElementById('bitget-passphrase-detail');

                if (apiKeyDetail) apiKeyDetail.value = supabaseCreds.key || '';
                if (secretKeyDetail) secretKeyDetail.value = supabaseCreds.secret || '';
                if (passphraseDetail) passphraseDetail.value = supabaseCreds.passphrase || '';

                if (supabaseCreds.key && supabaseCreds.secret && supabaseCreds.passphrase) {
                    if (window.FORCE_OFFLINE_BITGET) {
                        bitgetAPI = new MockBitgetAPI();
                    } else {
                        bitgetAPI = new BitgetAPI(supabaseCreds.key, supabaseCreds.secret, supabaseCreds.passphrase);
                    }
                    
                    const credentials = {
                        id: 'bitget',
                        key: supabaseCreds.key,
                        secret: supabaseCreds.secret,
                        passphrase: supabaseCreds.passphrase,
                        accountId: supabaseCreds.accountId,
                        platform: 'bitget'
                    };
                    
                    DB.apiKeys.bitget = credentials;
                    await dexieDB.apiKeys.put(credentials);
                    
                    if (supabaseCreds.accountId) {
                        localStorage.setItem('bitget_account_id', supabaseCreds.accountId);
                    }
                    
                    updateBitgetStatus('connected', 'Conectado', false);
                    console.log('✅ Credenciales de Bitget cargadas desde Supabase');
                    return;
                }
            }
        }
        
        // Si no hay en Supabase, intentar cargar desde IndexedDB
        const savedKeys = await dexieDB.apiKeys.get('bitget');
        if (savedKeys) {
            const apiKeyDetail = document.getElementById('bitget-api-key-detail');
            const secretKeyDetail = document.getElementById('bitget-secret-key-detail');
            const passphraseDetail = document.getElementById('bitget-passphrase-detail');

            if (apiKeyDetail) apiKeyDetail.value = savedKeys.key || '';
            if (secretKeyDetail) secretKeyDetail.value = savedKeys.secret || '';
            if (passphraseDetail) passphraseDetail.value = savedKeys.passphrase || '';

            if (savedKeys.key && savedKeys.secret && savedKeys.passphrase) {
                if (window.FORCE_OFFLINE_BITGET) {
                    bitgetAPI = new MockBitgetAPI();
                } else {
                    bitgetAPI = new BitgetAPI(savedKeys.key, savedKeys.secret, savedKeys.passphrase);
                }
                DB.apiKeys.bitget = savedKeys;
                updateBitgetStatus('connected', 'Conectado', false);
                console.log('✅ Credenciales de Bitget cargadas desde IndexedDB');
            }
        } else {
            console.log('ℹ️ No hay credenciales guardadas de Bitget');
        }
    } catch (error) {
        console.error('❌ Error cargando credenciales de Bitget:', error);
    }
}

// Cargar lista de cuentas en select de Bitget
function populateBitgetAccountSelect() {
    const select = document.getElementById('bitget-account-detail');
    if (!select) {
        console.warn('⚠️ Select de cuentas de Bitget no encontrado');
        return;
    }

    select.innerHTML = '<option value="">Seleccionar cuenta...</option>';
    DB.accounts.forEach(account => {
        const option = document.createElement('option');
        option.value = account.id;
        option.textContent = `${account.name} (${account.balance} ${account.currency})`;
        select.appendChild(option);
    });

    // Intentar restaurar la cuenta guardada desde múltiples fuentes
    let savedAccountId = null;
    
    // 1. Prioridad: DB.apiKeys.bitget.accountId
    if (DB.apiKeys.bitget && DB.apiKeys.bitget.accountId) {
        savedAccountId = DB.apiKeys.bitget.accountId;
    }
    
    // 2. Fallback: localStorage
    if (!savedAccountId) {
        savedAccountId = localStorage.getItem('bitget_account_id');
    }
    
    // 3. Restaurar valor en el select
    if (savedAccountId) {
        select.value = savedAccountId;
        console.log('✅ Cuenta Bitget restaurada:', savedAccountId);
    } else if (DB.accounts.length > 0) {
        // Si no hay cuenta guardada, seleccionar la primera automáticamente
        select.value = DB.accounts[0].id;
        console.log('✅ Primera cuenta Bitget seleccionada automáticamente:', DB.accounts[0].name);
    }

    // Agregar listener para guardar cuando cambie la selección (solo una vez)
    select.removeEventListener('change', handleBitgetAccountChange);
    select.addEventListener('change', handleBitgetAccountChange);

    console.log('✅ Selector de cuentas Bitget poblado con', DB.accounts.length, 'cuentas');
}

// Handler separado para evitar duplicación de listeners
async function handleBitgetAccountChange(e) {
    const accountId = e.target.value;
    if (!accountId) return;
    
    console.log('💾 Guardando cuenta seleccionada de Bitget:', accountId);
    
    // Actualizar localStorage
    localStorage.setItem('bitget_account_id', accountId);
    
    // Actualizar DB.apiKeys.bitget
    if (!DB.apiKeys.bitget) {
        DB.apiKeys.bitget = {};
    }
    DB.apiKeys.bitget.accountId = accountId;
    
    // Guardar en IndexedDB
    try {
        const existingCreds = await dexieDB.apiKeys.get('bitget');
        if (existingCreds) {
            existingCreds.accountId = accountId;
            await dexieDB.apiKeys.put(existingCreds);
            console.log('✅ Cuenta guardada en IndexedDB');
        }
    } catch (error) {
        console.error('⚠️ Error guardando en IndexedDB:', error);
    }
    
    // Guardar en Supabase si hay usuario autenticado
    if (currentUser && DB.apiKeys.bitget && DB.apiKeys.bitget.key && DB.apiKeys.bitget.secret && DB.apiKeys.bitget.passphrase) {
        try {
            await saveBitgetCredentialsToSupabase(
                DB.apiKeys.bitget.key, 
                DB.apiKeys.bitget.secret, 
                DB.apiKeys.bitget.passphrase, 
                accountId
            );
            console.log('✅ Cuenta de Bitget guardada en Supabase');
        } catch (error) {
            console.error('⚠️ Error guardando cuenta en Supabase:', error);
        }
    }
}

// ============================================
// MEXC API FUNCTIONS
// ============================================

// Exportar funciones a window para acceso global
window.loadBitgetCredentials = loadBitgetCredentials;
window.populateBitgetAccountSelect = populateBitgetAccountSelect;
window.handleBitgetAccountChange = handleBitgetAccountChange;

// Probar conexión con MEXC
async function testMEXCConnection() {
    const apiKeyInput = document.getElementById('mexc-api-key-detail');
    const secretKeyInput = document.getElementById('mexc-secret-key-detail');

    const apiKey = apiKeyInput?.value.trim();
    const secretKey = secretKeyInput?.value.trim();

    if (!apiKey || !secretKey) {
        showSyncNotification('❌ Ingresa API Key y Secret Key', 'error');
        return;
    }

    try {
        showSyncNotification('🔄 Probando conexión con MEXC...', 'info');

        const testAPI = new MEXCAPI(apiKey, secretKey);
        const result = await testAPI.testConnection();

        showSyncNotification('✅ Conexión exitosa a MEXC', 'success');
        updateMEXCStatus('connected', 'Test exitoso', false);
        console.log('Test de conexión MEXC exitoso:', result);

        return true;
    } catch (error) {
        console.error('Error en test de conexión MEXC:', error);
        showSyncNotification(`❌ Error: ${error.message}`, 'error');
        updateMEXCStatus('error', 'Error en conexión', false);
        return false;
    }
}

// Conectar con MEXC
async function connectMEXC() {
    console.log('🔄 connectMEXC() iniciada');
    
    const apiKeyInput = document.getElementById('mexc-api-key-detail');
    const secretKeyInput = document.getElementById('mexc-secret-key-detail');
    const accountSelect = document.getElementById('mexc-account-detail');

    console.log('🔍 Elementos encontrados:', {
        apiKeyInput: !!apiKeyInput,
        secretKeyInput: !!secretKeyInput,
        accountSelect: !!accountSelect
    });

    const apiKey = apiKeyInput?.value.trim();
    const secretKey = secretKeyInput?.value.trim();
    const accountId = accountSelect?.value;

    console.log('🔍 Valores obtenidos:', {
        apiKey: apiKey ? `${apiKey.substring(0, 8)}...` : 'vacío',
        secretKey: secretKey ? 'presente' : 'vacío',
        accountId: accountId || 'vacío'
    });

    if (!apiKey || !secretKey) {
        console.error('❌ Faltan credenciales');
        showSyncNotification('❌ Ingresa todas las credenciales', 'error');
        return;
    }

    if (!accountId) {
        console.error('❌ Falta cuenta');
        showSyncNotification('❌ Selecciona una cuenta', 'error');
        return;
    }

    try {
        console.log('🔄 Iniciando proceso de conexión...');
        showSyncNotification('🔄 Conectando con MEXC...', 'info');
        updateMEXCStatus('connecting', 'Conectando...', true);

        // Crear instancia de API
        console.log('🔧 Creando instancia de MEXCAPI...');
        mexcAPI = new MEXCAPI(apiKey, secretKey);

        // Probar conexión
        console.log('🧪 Probando conexión...');
        await mexcAPI.testConnection();
        console.log('✅ Conexión exitosa');

        // Guardar credenciales en localStorage
        console.log('💾 Guardando en localStorage...');
        localStorage.setItem('mexc_api_key', apiKey);
        localStorage.setItem('mexc_secret_key', secretKey);
        localStorage.setItem('mexc_account_id', accountId);
        
        const credentials = {
            id: 'mexc',
            key: apiKey,
            secret: secretKey,
            accountId: accountId,
            platform: 'mexc'
        };

        // Guardar en IndexedDB
        console.log('💾 Guardando en IndexedDB...');
        await dexieDB.apiKeys.put(credentials);
        DB.apiKeys.mexc = credentials;
        console.log('✅ Guardado en IndexedDB');
        
        // Guardar en Supabase si el usuario está autenticado
        if (currentUser) {
            try {
                console.log('💾 Guardando credenciales MEXC en Supabase...');
                console.log('👤 Usuario actual:', currentUser.email);
                await saveMEXCCredentialsToSupabase(apiKey, secretKey, accountId);
                console.log('✅ Credenciales MEXC guardadas en Supabase');
            } catch (error) {
                console.error('⚠️ Error guardando credenciales en Supabase:', error);
                console.error('⚠️ Stack:', error.stack);
            }
        } else {
            console.warn('⚠️ No hay usuario autenticado, no se guardará en Supabase');
        }

        updateMEXCStatus('connected', 'Conectado exitosamente', false);
        showSyncNotification('✅ MEXC conectado exitosamente', 'success');

        console.log('✅ MEXC API conectada y credenciales guardadas');

    } catch (error) {
        console.error('Error conectando con MEXC:', error);
        showSyncNotification(`❌ Error: ${error.message}`, 'error');
        updateMEXCStatus('error', 'Error en conexión', false);
        mexcAPI = null;
    }
}

// Sincronizar trades de MEXC
async function syncMEXCTrades() {
    // 1. Verificar si hay credenciales guardadas en Supabase
    if (!mexcAPI && currentUser) {
        console.log('🔄 mexcAPI no inicializada, cargando credenciales desde Supabase...');
        const savedCreds = await loadMEXCCredentialsFromSupabase();
        
        if (savedCreds && savedCreds.key && savedCreds.secret) {
            console.log('✅ Credenciales encontradas, inicializando mexcAPI...');
            mexcAPI = new MEXCAPI(savedCreds.key, savedCreds.secret);
        }
    }

    // 2. Si aún no hay API, mostrar error
    if (!mexcAPI) {
        showSyncNotification('❌ Primero debes configurar y guardar tus credenciales de MEXC', 'error');
        updateMEXCStatus('error', 'No configurado', false);
        return;
    }

    let selectedAccount = null;

    const accountDetailSelect = document.getElementById('mexc-account-detail');
    if (accountDetailSelect && accountDetailSelect.value) {
        selectedAccount = DB.accounts.find(acc => acc.id === accountDetailSelect.value);
        console.log('📋 Cuenta seleccionada para sincronización MEXC:', selectedAccount.name);
    }

    if (!selectedAccount) {
        showSyncNotification('❌ Selecciona una cuenta para sincronizar', 'error');
        console.error('❌ No hay cuenta seleccionada. Valor del select:', accountDetailSelect?.value);
        return;
    }

    updateMEXCStatus('syncing', 'Sincronizando...', true);
    showSyncNotification(`🔄 Sincronizando trades de MEXC a cuenta: ${selectedAccount.name}`, 'info');

    try {
        console.log('📡 Obteniendo trades de MEXC...');
        console.log('📋 Cuenta destino:', selectedAccount);

        // Obtener trades de los últimos 30 días
        const endTime = Date.now();
        const startTime = endTime - (30 * 24 * 60 * 60 * 1000);

        console.log(`🕐 Rango de fechas: ${new Date(startTime).toLocaleString()} - ${new Date(endTime).toLocaleString()}`);

        const tradesResponse = await mexcAPI.getTradeHistory('', startTime, endTime);
        console.log(`📦 MEXC Response completa:`, tradesResponse);
        console.log(`📦 MEXC Response JSON:`, JSON.stringify(tradesResponse, null, 2));
        console.log(`📦 MEXC Response keys:`, Object.keys(tradesResponse));

        // Detectar error de whitelist de IP en sync
        if (tradesResponse?.code === 406 || tradesResponse?.message?.includes('whitelist')) {
            const ip = tradesResponse?._extend?.ip || 'desconocida';
            showSyncNotification(`⚠️ IP ${ip} NO está en whitelist de MEXC. Ve a MEXC → API Management → Edita tu API Key → Agrega IP: ${ip}`, 'error', 15000);
            updateMEXCStatus('error', 'Error: IP no autorizada', false);
            return;
        }

        // Detectar error de API Key expirada
        if (tradesResponse?.code === 402 || tradesResponse?.message?.includes('expired')) {
            showSyncNotification('⚠️ Tu API Key de MEXC expiró. Ve a MEXC → API Management → Genera una nueva API Key', 'error', 10000);
            updateMEXCStatus('error', 'Error: API Key expirada', false);
            return;
        }

        if (!tradesResponse || (!tradesResponse.data && !Array.isArray(tradesResponse))) {
            console.log(`⚠️ Respuesta vacía o sin data`);
            showSyncNotification('ℹ️ No se encontraron trades en MEXC', 'info');
            updateMEXCStatus('connected', 'Conectado - Sin trades', false);
            showSyncNotification('✅ MEXC: Conectado - Sin trades nuevos', 'success');
            return;
        }

        // MEXC puede retornar: { data: [...] } o { data: { data: [...] } } o directamente un array
        let mexcTrades = [];
        if (Array.isArray(tradesResponse)) {
            console.log(`📋 Respuesta es array directo con ${tradesResponse.length} elementos`);
            mexcTrades = tradesResponse;
        } else if (tradesResponse.data) {
            console.log(`📋 Respuesta tiene campo data:`, tradesResponse.data);
            // Verificar si data es un array o un objeto con data dentro
            if (Array.isArray(tradesResponse.data)) {
                console.log(`📋 data es array con ${tradesResponse.data.length} elementos`);
                mexcTrades = tradesResponse.data;
            } else if (tradesResponse.data.data) {
                console.log(`📋 data.data existe:`, tradesResponse.data.data);
                mexcTrades = tradesResponse.data.data;
            } else if (tradesResponse.data.resultList) {
                console.log(`📋 data.resultList existe:`, tradesResponse.data.resultList);
                mexcTrades = tradesResponse.data.resultList;
            } else {
                console.log(`⚠️ Estructura de data no reconocida:`, Object.keys(tradesResponse.data));
            }
        }

        console.log(`📊 Trades obtenidos: ${mexcTrades.length}`);

        const existingTradeIds = new Set(
            DB.operations
                .filter(op => op.id.startsWith('mexc_'))
                .map(op => op.id)
        );

        let newTradesCount = 0;
        const newOperations = [];

        for (const trade of mexcTrades) {
            console.log('📦 Trade MEXC raw:', trade);
            const convertedTrade = convertMEXCTradeToAppFormat(trade, selectedAccount.id);
            console.log('🔄 Trade convertido:', convertedTrade);

            if (!existingTradeIds.has(convertedTrade.id)) {
                newOperations.push(convertedTrade);
                newTradesCount++;
            }
        }

        console.log(`🆕 Nuevas operaciones a guardar: ${newOperations.length}`);

        if (newOperations.length > 0) {
            try {
                await dexieDB.operations.bulkAdd(newOperations);
                DB.operations.push(...newOperations);
                console.log(`✅ ${newOperations.length} operaciones guardadas en IndexedDB`);
            } catch (bulkError) {
                console.error('❌ Error en bulkAdd:', bulkError);
                console.log('🔄 Intentando guardar operaciones una por una...');
                
                // Intentar guardar una por una para identificar cuál falla
                for (const operation of newOperations) {
                    try {
                        await dexieDB.operations.add(operation);
                        DB.operations.push(operation);
                        console.log(`✅ Guardada: ${operation.id}`);
                    } catch (singleError) {
                        console.error(`❌ Error guardando ${operation.id}:`, singleError);
                        console.log('📋 Operación problemática:', operation);
                    }
                }
            }

            if (currentUser) {
                for (const operation of newOperations) {
                    try {
                        await saveOperationToSupabase(operation);
                    } catch (error) {
                        console.error('Error sincronizando operación:', error);
                        addToSyncQueue(operation, 'operation');
                    }
                }
            }

            updateAccountBalances();
            refreshAllViews();

            showSyncNotification(`✅ MEXC: ${newTradesCount} trades nuevos sincronizados`, 'success');
            updateMEXCStatus('connected', `Conectado - ${newTradesCount} trades`, true);
        } else {
            showSyncNotification('✅ MEXC: Conectado - Sin trades nuevos', 'success');
            updateMEXCStatus('connected', 'Conectado - Sin trades', true);
        }

        updateMEXCStatus('connected', newTradesCount > 0 ? `Conectado - ${newTradesCount} trades` : 'Conectado - Sin trades', true);
        addMEXCSyncHistory(newTradesCount, mexcTrades.length - newTradesCount);

    } catch (error) {
        console.error('Error sincronizando MEXC:', error);
        showSyncNotification(`❌ Error: ${error.message}`, 'error');
        updateMEXCStatus('error', 'Error en sincronización', false);
    }
}

// ============================================
// FUNCIONES SYNC PARA NUEVAS PLATAFORMAS
// ============================================

async function syncBitunixTrades() {
    console.log('🚀 Sincronización Bitunix iniciada');
    showSyncNotification('⏳ Sincronizando trades de Bitunix...', 'info');
    
    try {
        // TODO: Implementar lógica completa de sincronización
        await new Promise(resolve => setTimeout(resolve, 1000)); // Simular delay
        showSyncNotification('✅ Bitunix: Sincronización completada (función en desarrollo)', 'success');
    } catch (error) {
        console.error('Error sincronizando Bitunix:', error);
        showSyncNotification(`❌ Error: ${error.message}`, 'error');
    }
}

async function syncLBankTrades() {
    console.log('🚀 Sincronización LBank iniciada');
    showSyncNotification('⏳ Sincronizando trades de LBank...', 'info');
    
    try {
        // TODO: Implementar lógica completa de sincronización
        await new Promise(resolve => setTimeout(resolve, 1000)); // Simular delay
        showSyncNotification('✅ LBank: Sincronización completada (función en desarrollo)', 'success');
    } catch (error) {
        console.error('Error sincronizando LBank:', error);
        showSyncNotification(`❌ Error: ${error.message}`, 'error');
    }
}

async function syncBloFinTrades() {
    console.log('🚀 Sincronización BloFin iniciada');
    showSyncNotification('⏳ Sincronizando trades de BloFin...', 'info');
    
    try {
        // TODO: Implementar lógica completa de sincronización
        await new Promise(resolve => setTimeout(resolve, 1000)); // Simular delay
        showSyncNotification('✅ BloFin: Sincronización completada (función en desarrollo)', 'success');
    } catch (error) {
        console.error('Error sincronizando BloFin:', error);
        showSyncNotification(`❌ Error: ${error.message}`, 'error');
    }
}

// Desconectar MEXC y borrar credenciales
async function disconnectMEXC() {
    try {
        // Confirmar con el usuario
        if (!confirm('¿Estás seguro de que quieres desconectar MEXC y borrar las credenciales guardadas?')) {
            return;
        }

        // Borrar de localStorage
        localStorage.removeItem('mexc_api_key');
        localStorage.removeItem('mexc_secret_key');
        localStorage.removeItem('mexc_account_id');
        
        // Borrar de IndexedDB
        await dexieDB.apiKeys.delete('mexc');

        // Borrar de Supabase si el usuario está autenticado
        if (currentUser && DB.apiKeys.mexc?.accountId) {
            try {
                const account = DB.accounts.find(acc => acc.id === DB.apiKeys.mexc.accountId);
                if (account) {
                    account.apiKey = null;
                    account.apiSecret = null;
                    await saveAccountToSupabase(account);
                    console.log('✅ Credenciales MEXC borradas de Supabase');
                }
            } catch (error) {
                console.error('⚠️ Error borrando credenciales de Supabase:', error);
            }
        }

        // Limpiar de memoria
        DB.apiKeys.mexc = {};
        mexcAPI = null;

        // Limpiar campos del formulario
        const apiKeyInput = document.getElementById('mexc-api-key-detail');
        const secretKeyInput = document.getElementById('mexc-secret-key-detail');

        if (apiKeyInput) apiKeyInput.value = '';
        if (secretKeyInput) secretKeyInput.value = '';

        // Actualizar estado
        updateMEXCStatus('disconnected', 'Desconectado', false);
        showSyncNotification('✅ MEXC desconectado. Credenciales borradas.', 'success');

        console.log('✅ MEXC desconectado y credenciales borradas');
    } catch (error) {
        console.error('Error desconectando MEXC:', error);
        showSyncNotification(`❌ Error al desconectar: ${error.message}`, 'error');
    }
}

// Convertir trade de MEXC al formato de la aplicación
function convertMEXCTradeToAppFormat(mexcTrade, accountId) {
    // MEXC Futures usa estos campos
    const orderId = mexcTrade.orderId || mexcTrade.id;
    const price = parseFloat(mexcTrade.dealAvgPrice || mexcTrade.price || 0);
    const qty = parseFloat(mexcTrade.dealVol || mexcTrade.vol || 0);
    const commission = parseFloat(mexcTrade.totalFee || mexcTrade.takerFee || mexcTrade.makerFee || 0);
    const profit = parseFloat(mexcTrade.profit || 0);
    
    // side: 1=open long, 2=close short, 3=open short, 4=close long
    const side = mexcTrade.side;
    const isLong = side === 1 || side === 4;
    const type = isLong ? 'buy' : 'sell';
    
    // Calcular P/L
    const pnl = profit - commission;
    const result = pnl > 0 ? 'win' : (pnl < 0 ? 'loss' : 'breakeven');

    // Convertir timestamp a fecha
    const tradeDateObj = new Date(parseInt(mexcTrade.createTime || mexcTrade.updateTime));
    const tradeDate = getLocalDateString(tradeDateObj);
    const tradeTime = tradeDateObj.toTimeString().split(' ')[0];

    return {
        id: `mexc_${orderId}`,
        date: tradeDate,
        accountId: accountId,
        instrument: mexcTrade.symbol || '',
        type: type,
        entry: price,
        exit: price,
        entryTime: tradeTime,
        exitTime: tradeTime,
        volume: qty,
        result: result,
        pl: pnl,
        manualPL: pnl,
        fees: commission,
        currency: mexcTrade.feeCurrency || 'USDT',
        session: 'MEXC',
        notes: `Trade ID: ${orderId} | Leverage: ${mexcTrade.leverage || 1}x | Side: ${side}`,
        images: []
    };
}

// Actualizar indicadores de estado de MEXC
function updateMEXCStatus(status, message, showProgress = false) {
    const statusIndicator = document.getElementById('mexc-status-indicator');
    const connectionStatus = document.getElementById('mexc-connection-status');
    const progressBar = document.getElementById('mexc-progress-bar');

    if (statusIndicator) {
        statusIndicator.className = '';
        if (status === 'connected') {
            statusIndicator.className = 'text-green-400';
            statusIndicator.textContent = 'Conectado';
        } else if (status === 'syncing' || status === 'connecting') {
            statusIndicator.className = 'text-blue-400';
            statusIndicator.textContent = message;
        } else if (status === 'error') {
            statusIndicator.className = 'text-red-400';
            statusIndicator.textContent = 'Error';
        } else {
            statusIndicator.className = 'text-yellow-400';
            statusIndicator.textContent = 'No conectado';
        }
    }

    if (progressBar) {
        if (showProgress) {
            progressBar.style.width = '100%';
            progressBar.classList.add('animate-pulse');
        } else {
            progressBar.style.width = '0%';
            progressBar.classList.remove('animate-pulse');
        }
    }

    if (connectionStatus) {
        connectionStatus.className = 'p-4 border rounded-md mb-4';

        if (status === 'connected') {
            connectionStatus.className += ' bg-green-800 border-green-600';
            connectionStatus.innerHTML = `
                <div class="flex items-center">
                    <i class="fas fa-check-circle text-green-300 text-xl mr-3"></i>
                    <div>
                        <p class="font-semibold text-green-100">Conectado</p>
                        <p class="text-sm text-green-200 mt-1">${message}</p>
                    </div>
                </div>
            `;
        } else if (status === 'error') {
            connectionStatus.className += ' bg-red-800 border-red-600';
            connectionStatus.innerHTML = `
                <div class="flex items-center">
                    <i class="fas fa-times-circle text-red-300 text-xl mr-3"></i>
                    <div>
                        <p class="font-semibold text-red-100">Error</p>
                        <p class="text-sm text-red-200 mt-1">${message}</p>
                    </div>
                </div>
            `;
        } else {
            connectionStatus.className += ' bg-yellow-800 border-yellow-600';
            connectionStatus.innerHTML = `
                <div class="flex items-center">
                    <i class="fas fa-exclamation-triangle text-yellow-300 text-xl mr-3"></i>
                    <div>
                        <p class="font-semibold text-yellow-100">${status === 'syncing' ? 'Sincronizando' : 'No conectado'}</p>
                        <p class="text-sm text-yellow-200 mt-1">${message}</p>
                    </div>
                </div>
            `;
        }
    }

    const lastSync = document.getElementById('mexc-last-sync');
    if (lastSync && status === 'connected') {
        const now = new Date();
        lastSync.textContent = `${now.toLocaleDateString()} ${now.toLocaleTimeString()}`;
    }
}

// Agregar entrada al historial de sincronización de MEXC
function addMEXCSyncHistory(newTrades, skippedTrades) {
    const historyContainer = document.getElementById('mexc-import-history');
    if (!historyContainer) return;

    if (historyContainer.querySelector('.text-center')) {
        historyContainer.innerHTML = '';
    }

    const now = new Date();
    const historyEntry = document.createElement('div');
    historyEntry.className = 'p-3 bg-surface-light rounded-md text-sm';
    historyEntry.innerHTML = `
        <div class="flex justify-between items-center">
            <div>
                <i class="fas fa-sync-alt text-green-400 mr-2"></i>
                <span class="font-semibold text-green-400">${newTrades} nuevas</span>
                <span class="text-text-secondary mx-2">|</span>
                <span class="text-text-secondary">${skippedTrades} existentes</span>
            </div>
            <span class="text-text-secondary text-xs">${now.toLocaleString()}</span>
        </div>
    `;

    historyContainer.insertBefore(historyEntry, historyContainer.firstChild);

    const entries = historyContainer.querySelectorAll('.p-3');
    if (entries.length > 10) {
        entries[entries.length - 1].remove();
    }
}

// Cargar credenciales guardadas de MEXC
async function loadMEXCCredentials() {
    try {
        console.log('🔍 Cargando credenciales MEXC...');
        
        let apiKey = null;
        let secretKey = null;
        let accountId = null;
        
        // Prioridad 1: Supabase (si hay usuario autenticado)
        if (currentUser) {
            const supabaseCredentials = await loadMEXCCredentialsFromSupabase();
            if (supabaseCredentials) {
                apiKey = supabaseCredentials.apiKey;
                secretKey = supabaseCredentials.secretKey;
                accountId = supabaseCredentials.accountId;
                console.log('✅ Credenciales MEXC cargadas desde Supabase');
            }
        }
        
        // Prioridad 2: localStorage (más rápido para usuarios no autenticados)
        if (!apiKey || !secretKey) {
            apiKey = localStorage.getItem('mexc_api_key');
            secretKey = localStorage.getItem('mexc_secret_key');
            accountId = localStorage.getItem('mexc_account_id');
            if (apiKey && secretKey) {
                console.log('✅ Credenciales MEXC cargadas desde localStorage');
            }
        }
        
        // Prioridad 3: IndexedDB
        if (!apiKey || !secretKey) {
            if (dexieDB && dexieDB.apiKeys) {
                const savedKeys = await dexieDB.apiKeys.get('mexc');
                if (savedKeys) {
                    apiKey = savedKeys.key;
                    secretKey = savedKeys.secret;
                    accountId = savedKeys.accountId;
                    console.log('✅ Credenciales MEXC cargadas desde IndexedDB');
                }
            }
        }
        
        // Si encontramos credenciales, cargarlas en los campos
        if (apiKey && secretKey) {
            const apiKeyDetail = document.getElementById('mexc-api-key-detail');
            const secretKeyDetail = document.getElementById('mexc-secret-key-detail');
            const accountSelect = document.getElementById('mexc-account-detail');

            if (apiKeyDetail) apiKeyDetail.value = apiKey;
            if (secretKeyDetail) secretKeyDetail.value = secretKey;
            if (accountSelect && accountId) accountSelect.value = accountId;

            // Inicializar API
            mexcAPI = new MEXCAPI(apiKey, secretKey);
            DB.apiKeys.mexc = {
                id: 'mexc',
                key: apiKey,
                secret: secretKey,
                accountId: accountId,
                platform: 'mexc'
            };
            
            updateMEXCStatus('connected', 'Conectado', false);
            console.log('✅ Credenciales de MEXC cargadas y API inicializada');
        } else {
            console.log('ℹ️ No hay credenciales guardadas de MEXC');
        }
    } catch (error) {
        console.error('❌ Error cargando credenciales de MEXC:', error);
    }
}

// Poblar selector de cuentas de MEXC
function populateMEXCAccountSelect() {
    const accountSelect = document.getElementById('mexc-account-detail');
    if (!accountSelect) return;

    accountSelect.innerHTML = '<option value="">Seleccionar cuenta...</option>';

    DB.accounts.forEach(account => {
        const option = document.createElement('option');
        option.value = account.id;
        option.textContent = `${account.name} (${account.currency})`;
        accountSelect.appendChild(option);
    });

    // Intentar restaurar la cuenta guardada
    if (DB.apiKeys.mexc && DB.apiKeys.mexc.accountId) {
        accountSelect.value = DB.apiKeys.mexc.accountId;
        console.log('✅ Cuenta MEXC restaurada:', DB.apiKeys.mexc.accountId);
    } else if (DB.accounts.length > 0) {
        // Si no hay cuenta guardada, seleccionar la primera automáticamente
        accountSelect.value = DB.accounts[0].id;
        console.log('✅ Primera cuenta MEXC seleccionada automáticamente:', DB.accounts[0].name);
    }

    console.log('✅ Cuentas cargadas en select de MEXC:', DB.accounts.length);
}

// ============================================
// BITUNIX API FUNCTIONS
// ============================================

async function loadBitunixCredentials() {
    try {
        console.log('🔍 Cargando credenciales Bitunix...');
        
        let apiKey = null;
        let secretKey = null;
        let accountId = null;
        
        // Prioridad 1: localStorage
        apiKey = localStorage.getItem('bitunix_api_key');
        secretKey = localStorage.getItem('bitunix_secret_key');
        accountId = localStorage.getItem('bitunix_account_id');
        
        if (apiKey && secretKey) {
            console.log('✅ Credenciales Bitunix cargadas desde localStorage');
        }
        
        // Prioridad 2: IndexedDB
        if (!apiKey || !secretKey) {
            if (dexieDB && dexieDB.apiKeys) {
                const savedKeys = await dexieDB.apiKeys.get('bitunix');
                if (savedKeys) {
                    apiKey = savedKeys.key;
                    secretKey = savedKeys.secret;
                    accountId = savedKeys.accountId;
                    console.log('✅ Credenciales Bitunix cargadas desde IndexedDB');
                }
            }
        }
        
        // Si encontramos credenciales, cargarlas en los campos
        if (apiKey && secretKey) {
            const apiKeyDetail = document.getElementById('bitunix-api-key-detail');
            const secretKeyDetail = document.getElementById('bitunix-secret-key-detail');
            const accountSelect = document.getElementById('bitunix-account-detail');

            if (apiKeyDetail) apiKeyDetail.value = apiKey;
            if (secretKeyDetail) secretKeyDetail.value = secretKey;
            if (accountSelect && accountId) accountSelect.value = accountId;

            // Inicializar API
            bitunixAPI = new BitunixAPI(apiKey, secretKey);
            DB.apiKeys.bitunix = {
                id: 'bitunix',
                key: apiKey,
                secret: secretKey,
                accountId: accountId,
                platform: 'bitunix'
            };
            
            console.log('✅ Credenciales de Bitunix cargadas y API inicializada');
        } else {
            console.log('ℹ️ No hay credenciales guardadas de Bitunix');
        }
    } catch (error) {
        console.error('❌ Error cargando credenciales de Bitunix:', error);
    }
}

function populateBitunixAccountSelect() {
    console.log('🔄 Poblando selector de cuentas Bitunix...');
    const accountSelect = document.getElementById('bitunix-account-detail');
    if (!accountSelect) {
        console.warn('⚠️ Selector bitunix-account-detail no encontrado');
        return;
    }

    if (!DB || !DB.accounts) {
        console.warn('⚠️ DB.accounts no está disponible');
        return;
    }

    console.log(`📊 Cargando ${DB.accounts.length} cuentas en selector Bitunix`);
    accountSelect.innerHTML = '<option value="">Seleccionar cuenta...</option>';

    DB.accounts.forEach(account => {
        const option = document.createElement('option');
        option.value = account.id;
        option.textContent = `${account.name} (${account.currency})`;
        accountSelect.appendChild(option);
    });

    if (DB.apiKeys.bitunix && DB.apiKeys.bitunix.accountId) {
        accountSelect.value = DB.apiKeys.bitunix.accountId;
        console.log('✅ Cuenta pre-seleccionada:', DB.apiKeys.bitunix.accountId);
    } else if (DB.accounts.length > 0) {
        accountSelect.value = DB.accounts[0].id;
        console.log('✅ Primera cuenta seleccionada por defecto');
    }
    
    console.log('✅ Selector Bitunix poblado correctamente');
}

// ============================================
// LBANK API FUNCTIONS (RSA)
// ============================================

async function loadLBankCredentials() {
    try {
        console.log('🔍 Cargando credenciales LBank...');
        
        let apiKey = null;
        let privateKey = null;
        let accountId = null;
        
        // Prioridad 1: localStorage
        apiKey = localStorage.getItem('lbank_api_key');
        privateKey = localStorage.getItem('lbank_private_key');
        accountId = localStorage.getItem('lbank_account_id');
        
        if (apiKey && privateKey) {
            console.log('✅ Credenciales LBank cargadas desde localStorage');
        }
        
        // Prioridad 2: IndexedDB
        if (!apiKey || !privateKey) {
            if (dexieDB && dexieDB.apiKeys) {
                const savedKeys = await dexieDB.apiKeys.get('lbank');
                if (savedKeys) {
                    apiKey = savedKeys.key;
                    privateKey = savedKeys.secret; // Stored as 'secret' but it's the private key
                    accountId = savedKeys.accountId;
                    console.log('✅ Credenciales LBank cargadas desde IndexedDB');
                }
            }
        }
        
        // Si encontramos credenciales, cargarlas en los campos
        if (apiKey && privateKey) {
            const apiKeyDetail = document.getElementById('lbank-api-key-detail');
            const privateKeyDetail = document.getElementById('lbank-private-key-detail');
            const accountSelect = document.getElementById('lbank-account-detail');

            if (apiKeyDetail) apiKeyDetail.value = apiKey;
            if (privateKeyDetail) privateKeyDetail.value = privateKey;
            if (accountSelect && accountId) accountSelect.value = accountId;

            // Inicializar API
            lbankAPI = new LBankAPI(apiKey, privateKey);
            DB.apiKeys.lbank = {
                id: 'lbank',
                key: apiKey,
                secret: privateKey, // Store as 'secret' for consistency
                accountId: accountId,
                platform: 'lbank'
            };
            
            console.log('✅ Credenciales de LBank cargadas y API inicializada');
        } else {
            console.log('ℹ️ No hay credenciales guardadas de LBank');
        }
    } catch (error) {
        console.error('❌ Error cargando credenciales de LBank:', error);
    }
}

function populateLBankAccountSelect() {
    console.log('🔄 Poblando selector de cuentas LBank...');
    const accountSelect = document.getElementById('lbank-account-detail');
    if (!accountSelect) {
        console.warn('⚠️ Selector lbank-account-detail no encontrado');
        return;
    }

    if (!DB || !DB.accounts) {
        console.warn('⚠️ DB.accounts no está disponible');
        return;
    }

    console.log(`📊 Cargando ${DB.accounts.length} cuentas en selector LBank`);
    accountSelect.innerHTML = '<option value="">Seleccionar cuenta...</option>';

    DB.accounts.forEach(account => {
        const option = document.createElement('option');
        option.value = account.id;
        option.textContent = `${account.name} (${account.currency})`;
        accountSelect.appendChild(option);
    });

    if (DB.apiKeys.lbank && DB.apiKeys.lbank.accountId) {
        accountSelect.value = DB.apiKeys.lbank.accountId;
        console.log('✅ Cuenta pre-seleccionada:', DB.apiKeys.lbank.accountId);
    } else if (DB.accounts.length > 0) {
        accountSelect.value = DB.accounts[0].id;
        console.log('✅ Primera cuenta seleccionada por defecto');
    }
    
    console.log('✅ Selector LBank poblado correctamente');
}

// ============================================
// BLOFIN API FUNCTIONS
// ============================================

async function loadBloFinCredentials() {
    try {
        console.log('🔍 Cargando credenciales BloFin...');
        
        let apiKey = null;
        let secretKey = null;
        let passphrase = null;
        let accountId = null;
        
        // Prioridad 1: localStorage
        apiKey = localStorage.getItem('blofin_api_key');
        secretKey = localStorage.getItem('blofin_secret_key');
        passphrase = localStorage.getItem('blofin_passphrase');
        accountId = localStorage.getItem('blofin_account_id');
        
        if (apiKey && secretKey && passphrase) {
            console.log('✅ Credenciales BloFin cargadas desde localStorage');
        }
        
        // Prioridad 2: IndexedDB
        if (!apiKey || !secretKey || !passphrase) {
            if (dexieDB && dexieDB.apiKeys) {
                const savedKeys = await dexieDB.apiKeys.get('blofin');
                if (savedKeys) {
                    apiKey = savedKeys.key;
                    secretKey = savedKeys.secret;
                    passphrase = savedKeys.passphrase;
                    accountId = savedKeys.accountId;
                    console.log('✅ Credenciales BloFin cargadas desde IndexedDB');
                }
            }
        }
        
        // Si encontramos credenciales, cargarlas en los campos
        if (apiKey && secretKey && passphrase) {
            const apiKeyDetail = document.getElementById('blofin-api-key-detail');
            const secretKeyDetail = document.getElementById('blofin-secret-key-detail');
            const passphraseDetail = document.getElementById('blofin-passphrase-detail');
            const accountSelect = document.getElementById('blofin-account-detail');

            if (apiKeyDetail) apiKeyDetail.value = apiKey;
            if (secretKeyDetail) secretKeyDetail.value = secretKey;
            if (passphraseDetail) passphraseDetail.value = passphrase;
            if (accountSelect && accountId) accountSelect.value = accountId;

            // Inicializar API (cuando se implemente BloFinAPI class)
            // blofinAPI = new BloFinAPI(apiKey, secretKey, passphrase);
            DB.apiKeys.blofin = {
                id: 'blofin',
                key: apiKey,
                secret: secretKey,
                passphrase: passphrase,
                accountId: accountId,
                platform: 'blofin'
            };
            
            console.log('✅ Credenciales de BloFin cargadas');
        } else {
            console.log('ℹ️ No hay credenciales guardadas de BloFin');
        }
    } catch (error) {
        console.error('❌ Error cargando credenciales de BloFin:', error);
    }
}

function populateBloFinAccountSelect() {
    console.log('🔄 Poblando selector de cuentas BloFin...');
    const accountSelect = document.getElementById('blofin-account-detail');
    if (!accountSelect) {
        console.warn('⚠️ Selector blofin-account-detail no encontrado');
        return;
    }

    if (!DB || !DB.accounts) {
        console.warn('⚠️ DB.accounts no está disponible');
        return;
    }

    console.log(`📊 Cargando ${DB.accounts.length} cuentas en selector BloFin`);
    accountSelect.innerHTML = '<option value="">Seleccionar cuenta...</option>';

    DB.accounts.forEach(account => {
        const option = document.createElement('option');
        option.value = account.id;
        option.textContent = `${account.name} (${account.currency})`;
        accountSelect.appendChild(option);
    });

    if (DB.apiKeys.blofin && DB.apiKeys.blofin.accountId) {
        accountSelect.value = DB.apiKeys.blofin.accountId;
        console.log('✅ Cuenta pre-seleccionada:', DB.apiKeys.blofin.accountId);
    } else if (DB.accounts.length > 0) {
        accountSelect.value = DB.accounts[0].id;
        console.log('✅ Primera cuenta seleccionada por defecto');
    }
    
    console.log('✅ Selector BloFin poblado correctamente');
}

// ============================================
// TRADINGVIEW WEBHOOK FUNCTIONS
// ============================================

function loadTradingViewConfig() {
    console.log('📥 Cargando configuración de TradingView');
    
    // Cargar configuración guardada si existe
    if (DB.apiKeys.tradingview) {
        const accountSelect = document.getElementById('tradingview-account-select');
        if (accountSelect && DB.apiKeys.tradingview.accountId) {
            accountSelect.value = DB.apiKeys.tradingview.accountId;
            updateTradingViewAccountDisplay(DB.apiKeys.tradingview.accountId);
        }
        
        updateTradingViewStatus('✅ Configurado', 'success');
    } else {
        updateTradingViewStatus('⚠️ No configurado', 'warning');
    }
}

function populateTradingViewAccountSelect() {
    const accountSelect = document.getElementById('tradingview-account-select');
    if (!accountSelect) return;

    accountSelect.innerHTML = '<option value="">Selecciona una cuenta...</option>';

    DB.accounts.forEach(account => {
        const option = document.createElement('option');
        option.value = account.id;
        option.textContent = `${account.name} (${account.currency})`;
        accountSelect.appendChild(option);
    });

    // Listener para mostrar el Account ID cuando se selecciona una cuenta
    accountSelect.addEventListener('change', (e) => {
        const accountId = e.target.value;
        if (accountId) {
            updateTradingViewAccountDisplay(accountId);
        } else {
            document.getElementById('tradingview-account-id-section').style.display = 'none';
        }
    });

    // Restaurar cuenta guardada
    if (DB.apiKeys.tradingview && DB.apiKeys.tradingview.accountId) {
        accountSelect.value = DB.apiKeys.tradingview.accountId;
        updateTradingViewAccountDisplay(DB.apiKeys.tradingview.accountId);
    }

    console.log('✅ Cuentas cargadas en select de TradingView:', DB.accounts.length);
}

function updateTradingViewAccountDisplay(accountId) {
    const accountIdSection = document.getElementById('tradingview-account-id-section');
    const accountIdInput = document.getElementById('tradingview-account-id');
    const placeholder = document.getElementById('json-account-id-placeholder');
    
    if (accountId && accountIdSection && accountIdInput) {
        accountIdSection.style.display = 'block';
        accountIdInput.value = accountId;
        
        if (placeholder) {
            placeholder.textContent = accountId;
        }
    }
}

function updateTradingViewStatus(message, type = 'info') {
    const statusElements = [
        document.getElementById('tradingview-status'),
        document.getElementById('tradingview-detail-status')
    ];
    
    const indicator = document.getElementById('tradingview-detail-indicator');
    
    statusElements.forEach(el => {
        if (el) {
            el.textContent = message;
            el.className = type === 'success' ? 'text-positive' : 
                          type === 'error' ? 'text-negative' : 
                          'text-yellow-500';
        }
    });
    
    if (indicator) {
        indicator.className = 'w-4 h-4 rounded-full ' + 
            (type === 'success' ? 'bg-positive' : 
             type === 'error' ? 'bg-negative' : 
             'bg-yellow-500');
    }
}

async function saveTradingViewConfig() {
    try {
        const accountId = document.getElementById('tradingview-account-select').value;
        
        if (!accountId) {
            showSyncNotification('⚠️ Por favor selecciona una cuenta', 'error');
            return;
        }
        
        // Guardar configuración
        DB.apiKeys.tradingview = {
            accountId: accountId,
            webhookUrl: 'http://localhost:8003/webhook/tradingview',
            enabled: true,
            lastUpdated: new Date().toISOString()
        };
        
        await saveDB();
        
        updateTradingViewStatus('✅ Configurado', 'success');
        
        // Actualizar estado en tarjeta principal
        const webhookStatus = document.getElementById('tradingview-webhook-status');
        if (webhookStatus) {
            webhookStatus.textContent = `Cuenta: ${DB.accounts.find(a => a.id == accountId)?.name}`;
            webhookStatus.className = 'text-xs text-positive';
        }
        
        showSyncNotification('✅ Configuración de TradingView guardada', 'success');
        
    } catch (error) {
        console.error('❌ Error guardando configuración:', error);
        showSyncNotification('❌ Error al guardar configuración', 'error');
    }
}

async function testTradingViewWebhook() {
    try {
        const accountId = document.getElementById('tradingview-account-select').value;
        
        if (!accountId) {
            showSyncNotification('⚠️ Por favor selecciona una cuenta primero', 'error');
            return;
        }
        
        updateTradingViewStatus('🔄 Probando webhook...', 'info');
        
        // Enviar webhook de prueba
        const testData = {
            accountId: accountId,
            symbol: "BTCUSDT",
            action: "buy",
            contracts: 1,
            price: 50000,
            orderType: "market",
            timestamp: new Date().toISOString(),
            orderId: "TEST_" + Date.now(),
            comment: "Test trade from dashboard"
        };
        
        const response = await fetch('http://localhost:8003/webhook/tradingview', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(testData)
        });
        
        if (response.ok) {
            const result = await response.json();
            console.log('✅ Webhook test response:', result);
            
            updateTradingViewStatus('✅ Webhook funcionando', 'success');
            showSyncNotification('✅ Webhook test exitoso! Revisa la consola del servidor', 'success');
            
            // Añadir al log
            addWebhookToLog(testData, 'success');
        } else {
            throw new Error(`Server responded with ${response.status}`);
        }
        
    } catch (error) {
        console.error('❌ Error probando webhook:', error);
        updateTradingViewStatus('❌ Error en webhook', 'error');
        
        if (error.message.includes('Failed to fetch')) {
            const isDev = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
            const errorMsg = isDev 
                ? '❌ No se puede conectar al servidor. Asegúrate de que proxy-server.js esté corriendo en puerto 8003'
                : '❌ No se puede conectar al servidor de webhooks';
            showSyncNotification(errorMsg, 'error');
        } else {
            showSyncNotification('❌ Error al probar webhook: ' + error.message, 'error');
        }
        
        addWebhookToLog({ error: error.message }, 'error');
    }
}

function addWebhookToLog(data, status = 'info') {
    const logContainer = document.getElementById('tradingview-webhook-log');
    if (!logContainer) return;
    
    // Si es el primer webhook, limpiar mensaje placeholder
    if (logContainer.querySelector('p.text-center')) {
        logContainer.innerHTML = '';
    }
    
    const entry = document.createElement('div');
    entry.className = 'bg-surface-light p-3 rounded text-xs';
    
    const timestamp = new Date().toLocaleTimeString();
    const icon = status === 'success' ? '✅' : status === 'error' ? '❌' : 'ℹ️';
    
    entry.innerHTML = `
        <div class="flex justify-between items-start mb-1">
            <span class="font-bold">${icon} ${timestamp}</span>
            <span class="text-text-secondary">${data.symbol || 'Test'}</span>
        </div>
        <div class="text-text-secondary">
            ${data.action ? `${data.action.toUpperCase()} ${data.contracts} @ $${data.price}` : 
              data.error ? `Error: ${data.error}` : 'Test webhook'}
        </div>
    `;
    
    // Añadir al inicio del log
    logContainer.insertBefore(entry, logContainer.firstChild);
    
    // Limitar a 10 entradas
    while (logContainer.children.length > 10) {
        logContainer.removeChild(logContainer.lastChild);
    }
}

// ============================================
// TRADOVATE CSV IMPORT FUNCTIONS
// ============================================

let tradovateSelectedFile = null;

function loadTradovateConfig() {
    console.log('📥 Cargando Tradovate');
    updateTradovateStatus('✅ Listo para importar', 'success');
}

// ============================================
// NINJATRADER 8 FUNCTIONS
// ============================================

let ninjatraderAutoSyncInterval = null;

function loadNinjaTraderConfig() {
    console.log('📥 Cargando NinjaTrader');
    updateNinjaTraderStatus('⚠️ No conectado', 'warning');
}

function populateNinjaTraderAccountSelect() {
    const accountSelect = document.getElementById('ninjatrader-account-select');
    if (!accountSelect) return;

    accountSelect.innerHTML = '<option value="">Selecciona una cuenta...</option>';

    DB.accounts.forEach(account => {
        const option = document.createElement('option');
        option.value = account.id;
        option.textContent = `${account.name} - $${account.balance.toFixed(2)}`;
        accountSelect.appendChild(option);
    });
}

function updateNinjaTraderStatus(message, type) {
    const statusEl = document.getElementById('ninjatrader-detail-status');
    const indicatorEl = document.getElementById('ninjatrader-detail-indicator');
    
    if (statusEl) statusEl.textContent = message;
    
    if (indicatorEl) {
        indicatorEl.className = 'w-3 h-3 rounded-full mr-3 ' + 
            (type === 'success' ? 'bg-green-500' : 
             type === 'error' ? 'bg-red-500' : 
             'bg-yellow-500');
    }
}

async function testNinjaTraderConnection() {
    const port = document.getElementById('ninjatrader-port').value;
    const host = document.getElementById('ninjatrader-host').value;
    
    try {
        updateNinjaTraderStatus('🔌 Conectando...', 'warning');
        
        const response = await fetch(`http://localhost:8003/api/ninjatrader/test?port=${port}&host=${host}`);
        const data = await response.json();
        
        if (data.success && data.connected) {
            updateNinjaTraderStatus('✅ Conectado correctamente', 'success');
            document.getElementById('ninjatrader-version').textContent = data.version || 'NinjaTrader 8';
            document.getElementById('ninjatrader-sync-now').disabled = false;
            showSyncNotification('✅ ' + data.message, 'success');
            return true;
        } else {
            updateNinjaTraderStatus('❌ Error de conexión', 'error');
            showSyncNotification('❌ ' + (data.message || data.error), 'error');
            return false;
        }
    } catch (error) {
        console.error('❌ Error testing NinjaTrader:', error);
        updateNinjaTraderStatus('❌ Error de conexión', 'error');
        showSyncNotification('❌ Error: ' + error.message, 'error');
        return false;
    }
}

async function syncNinjaTraderNow() {
    const accountSelect = document.getElementById('ninjatrader-account-select');
    const accountId = accountSelect ? accountSelect.value : null;
    
    if (!accountId) {
        showSyncNotification('❌ Por favor selecciona una cuenta', 'error');
        return;
    }
    
    const account = DB.accounts.find(a => a.id === parseInt(accountId));
    if (!account) {
        showSyncNotification('❌ Cuenta no encontrada', 'error');
        return;
    }
    
    const port = document.getElementById('ninjatrader-port').value;
    const host = document.getElementById('ninjatrader-host').value;
    
    try {
        updateNinjaTraderStatus('📊 Sincronizando...', 'warning');
        
        const response = await fetch(`http://localhost:8003/api/ninjatrader/trades?port=${port}&host=${host}&account=Sim101`);
        const data = await response.json();
        
        if (!data.success) {
            throw new Error(data.error || 'Error desconocido');
        }
        
        console.log('📥 Trades recibidos de NinjaTrader:', data.trades);
        
        // Process and import trades
        let importedCount = 0;
        let totalPnL = 0;
        
        const tradesGrouped = groupNinjaTraderTrades(data.trades);
        
        for (const trade of tradesGrouped) {
            const newTrade = {
                id: Date.now() + Math.random(),
                accountId: parseInt(accountId),
                platform: 'NinjaTrader',
                symbol: trade.instrument,
                side: trade.side,
                quantity: trade.quantity,
                entryPrice: trade.entryPrice,
                exitPrice: trade.exitPrice,
                entryTime: trade.entryTime,
                exitTime: trade.exitTime,
                pnl: trade.pnl,
                status: 'closed',
                orderType: 'market',
                notes: `Importado desde NinjaTrader - Order ID: ${trade.orderId}`,
                createdAt: new Date().toISOString()
            };
            
            DB.trades.push(newTrade);
            totalPnL += trade.pnl;
            importedCount++;
        }
        
        // Update account balance
        account.balance += totalPnL;
        
        // Save to Dexie
        if (typeof dexieDB !== 'undefined') {
            await dexieDB.accounts.put(account);
        }
        
        // Show results
        document.getElementById('ninjatrader-sync-results').classList.remove('hidden');
        document.getElementById('ninjatrader-imported-count').textContent = importedCount;
        document.getElementById('ninjatrader-final-balance').textContent = formatCurrency(account.balance, account.currency);
        document.getElementById('ninjatrader-total-pnl').textContent = formatCurrency(totalPnL, account.currency);
        
        updateNinjaTraderStatus('✅ Sincronizado correctamente', 'success');
        showSyncNotification(`✅ ${importedCount} trades importados correctamente`, 'success');
        
        // Update last sync time
        document.getElementById('ninjatrader-last-auto-sync').textContent = new Date().toLocaleTimeString();
        
    } catch (error) {
        console.error('❌ Error syncing NinjaTrader:', error);
        updateNinjaTraderStatus('❌ Error de sincronización', 'error');
        showSyncNotification('❌ Error: ' + error.message, 'error');
    }
}

function groupNinjaTraderTrades(executions) {
    // Group executions into complete trades (entry + exit)
    const trades = [];
    const openPositions = {};
    
    executions.forEach(exec => {
        const key = exec.instrument;
        
        if (exec.action === 'BUY') {
            if (!openPositions[key]) {
                openPositions[key] = {
                    instrument: exec.instrument,
                    side: 'LONG',
                    quantity: exec.quantity,
                    entryPrice: exec.price,
                    entryTime: exec.time,
                    orderId: exec.orderId
                };
            }
        } else if (exec.action === 'SELL' && openPositions[key]) {
            // Complete the trade
            const position = openPositions[key];
            const pnl = (exec.price - position.entryPrice) * position.quantity;
            
            trades.push({
                instrument: position.instrument,
                side: position.side,
                quantity: position.quantity,
                entryPrice: position.entryPrice,
                exitPrice: exec.price,
                entryTime: position.entryTime,
                exitTime: exec.time,
                pnl: pnl,
                orderId: position.orderId
            });
            
            delete openPositions[key];
        }
    });
    
    return trades;
}

function toggleNinjaTraderAutoSync(enabled) {
    if (enabled) {
        // Start auto-sync
        // ===== AUTO-SYNC NINJATRADER ELIMINADO - SOLO CSV MANUAL =====
        console.log('⚠️ Auto-sync de NinjaTrader eliminado - Use importación CSV manual');
        showSyncNotification('⚠️ Auto-sync eliminado. Use el botón de importación CSV', 'warning');
        
        /* AUTO-SYNC ELIMINADO PERMANENTEMENTE
        document.getElementById('ninjatrader-auto-sync-status').classList.remove('hidden');
        
        ninjatraderAutoSyncInterval = setInterval(() => {
            syncNinjaTraderNow();
            
            // Update countdown
            let countdown = 1800; // 30 minutos en segundos
            const countdownInterval = setInterval(() => {
                countdown--;
                const minutes = Math.floor(countdown / 60);
                const seconds = countdown % 60;
                document.getElementById('ninjatrader-next-sync').textContent = `${minutes}m ${seconds}s`;
                if (countdown <= 0) clearInterval(countdownInterval);
            }, 1000);
        }, 1800000); // Cada 30 minutos (optimizado para Supabase Egress)
        
        showSyncNotification('✅ Auto-Sync activado - sincronizando cada 30 minutos', 'success');
        */
    } else {
        // Stop auto-sync
        if (ninjatraderAutoSyncInterval) {
            clearInterval(ninjatraderAutoSyncInterval);
            ninjatraderAutoSyncInterval = null;
        }
        
        document.getElementById('ninjatrader-auto-sync-status').classList.add('hidden');
        showSyncNotification('⏸️ Auto-Sync desactivado', 'info');
    }
}

function populateTradovateAccountSelect() {
    const accountSelect = document.getElementById('tradovate-account-select');
    if (!accountSelect) return;

    accountSelect.innerHTML = '<option value="">Selecciona una cuenta...</option>';

    DB.accounts.forEach(account => {
        const option = document.createElement('option');
        option.value = account.id;
        option.textContent = `${account.name} - $${account.balance.toFixed(2)}`;
        accountSelect.appendChild(option);
    });
}

function updateTradovateStatus(message, type) {
    const statusEl = document.getElementById('tradovate-detail-status');
    const indicatorEl = document.getElementById('tradovate-detail-indicator');
    
    if (statusEl) statusEl.textContent = message;
    
    if (indicatorEl) {
        indicatorEl.className = 'w-3 h-3 rounded-full mr-3 ' + 
            (type === 'success' ? 'bg-green-500' : 
             type === 'error' ? 'bg-red-500' : 
             'bg-yellow-500');
    }
}



async function parseTradovateCSV(csvText) {
    const lines = csvText.trim().split('\n');
    if (lines.length < 2) {
        throw new Error('El archivo CSV está vacío o no tiene datos');
    }
    
    const headers = lines[0].split(',').map(h => h.trim());
    const trades = [];
    
    for (let i = 1; i < lines.length; i++) {
        const values = parseCSVLine(lines[i]);
        
        if (values.length < headers.length) continue; // Skip empty lines
        
        const trade = {};
        headers.forEach((header, index) => {
            trade[header] = values[index] ? values[index].trim() : '';
        });
        
        // Parsear trade
        const parsedTrade = {
            symbol: trade.symbol || '',
            side: trade.buyPrice && trade.sellPrice ? 
                  (parseFloat(trade.sellPrice) > parseFloat(trade.buyPrice) ? 'LONG' : 'SHORT') : 'LONG',
            quantity: parseInt(trade.qty) || 1,
            entryPrice: parseFloat(trade.buyPrice) || 0,
            exitPrice: parseFloat(trade.sellPrice) || 0,
            pnl: parsePnL(trade.pnl),
            entryTime: parseDate(trade.boughtTimestamp),
            exitTime: parseDate(trade.soldTimestamp),
            duration: trade.duration || '',
            orderType: 'market',
            status: 'closed',
            platform: 'Tradovate',
            notes: `Importado desde CSV - ${trade.duration || ''}`
        };
        
        trades.push(parsedTrade);
    }
    
    return trades;
}

function parseCSVLine(line) {
    const values = [];
    let current = '';
    let inQuotes = false;
    
    for (let i = 0; i < line.length; i++) {
        const char = line[i];
        
        if (char === '"') {
            inQuotes = !inQuotes;
        } else if (char === ',' && !inQuotes) {
            values.push(current);
            current = '';
        } else {
            current += char;
        }
    }
    
    values.push(current);
    return values;
}

function parsePnL(pnlString) {
    if (!pnlString) return 0;
    // Remove $, commas, and parse
    return parseFloat(pnlString.replace(/[$,]/g, '')) || 0;
}

function parseDate(dateString) {
    if (!dateString) return new Date().toISOString();
    
    try {
        // Format: 12/08/2025 18:34:15
        const [datePart, timePart] = dateString.split(' ');
        const [month, day, year] = datePart.split('/');
        const [hours, minutes, seconds] = timePart.split(':');
        
        const date = new Date(year, month - 1, day, hours, minutes, seconds);
        return date.toISOString();
    } catch (e) {
        return new Date().toISOString();
    }
}

async function importTradovateCSV() {
    if (!tradovateSelectedFile) {
        showSyncNotification('❌ Por favor selecciona un archivo CSV', 'error');
        return;
    }
    
    console.log('🚀 Iniciando importación de Tradovate desde vista detallada...');
    
    try {
        // Show progress
        const progressDiv = document.getElementById('tradovate-import-progress');
        const resultsDiv = document.getElementById('tradovate-import-results');
        const importBtn = document.getElementById('tradovate-import-btn');
        
        if (progressDiv) progressDiv.classList.remove('hidden');
        if (resultsDiv) resultsDiv.classList.add('hidden');
        if (importBtn) importBtn.disabled = true;
        
        updateImportProgress(10, 'Leyendo archivo...');
        
        // Read file
        const csvText = await readFileAsText(tradovateSelectedFile);
        
        console.log(`✅ Archivo leído: ${csvText.length} caracteres`);
        
        // Detectar si es Position History de Tradovate
        if (!csvText.includes('Position ID') || !csvText.includes('Buy Price') || !csvText.includes('Sell Price')) {
            throw new Error('Este archivo no parece ser un Position History de Tradovate');
        }
        
        updateImportProgress(30, 'Parseando trades de Tradovate...');
        
        // Crear importador de Tradovate si no existe
        if (!window.tradovateFileSync) {
            window.tradovateFileSync = new window.NinjaTraderFileSync();
        }
        
        // Parsear CSV
        const trades = window.tradovateFileSync.parseCSV(csvText);
        
        if (!trades || trades.length === 0) {
            throw new Error('No se encontraron trades en el archivo CSV');
        }
        
        console.log(`📊 Trades parseados: ${trades.length}`);
        
        // Calcular balance por cuenta
        const accountBalances = new Map();
        const accountNames = new Set();
        
        trades.forEach(trade => {
            const accountName = trade.account_id;
            accountNames.add(accountName);
            if (!accountBalances.has(accountName)) {
                accountBalances.set(accountName, 0);
            }
            accountBalances.set(accountName, accountBalances.get(accountName) + (trade.pnl || 0));
        });
        
        console.log('💰 Balances calculados:', Object.fromEntries(accountBalances));
        
        updateImportProgress(50, `Importando ${trades.length} trades a Supabase...`);
        
        // Obtener usuario
        const { data: { user } } = await window.supabase.auth.getUser();
        if (!user) {
            throw new Error('Usuario no autenticado');
        }
        
        // Crear cuentas automáticamente
        const createdAccounts = new Set();
        let importedCount = 0;
        
        for (let i = 0; i < trades.length; i++) {
            const trade = trades[i];
            const accountName = trade.account_id;
            
            // Crear cuenta solo la primera vez
            if (!createdAccounts.has(accountName)) {
                const balance = accountBalances.get(accountName) || 0;
                
                console.log(`🏦 Creando/verificando cuenta: ${accountName} con balance: $${balance}`);
                
                await window.tradovateFileSync.ensureAccountExists(
                    user.id,
                    accountName,
                    trade.platform,
                    balance
                );
                
                createdAccounts.add(accountName);
            }
            
            // Importar trade
            await window.tradovateFileSync.importTrade(trade);
            importedCount++;
            
            // Update progress
            const progress = 50 + (importedCount / trades.length) * 40;
            updateImportProgress(progress, `Importando trade ${importedCount}/${trades.length}...`);
        }
        
        updateImportProgress(95, 'Recargando datos...');
        
        // Recargar cuentas y operaciones
        if (typeof loadAccountsFromSupabase === 'function') {
            await loadAccountsFromSupabase();
        }
        
        if (typeof loadOperationsFromSupabase === 'function') {
            await loadOperationsFromSupabase();
        }
        
        updateImportProgress(100, 'Completado!');
        
        // Show results
        const totalBalance = Array.from(accountBalances.values()).reduce((sum, bal) => sum + bal, 0);
        
        if (progressDiv) progressDiv.classList.add('hidden');
        if (resultsDiv) {
            resultsDiv.classList.remove('hidden');
            document.getElementById('tradovate-imported-count').textContent = importedCount;
            document.getElementById('tradovate-final-balance').textContent = formatCurrency(totalBalance, 'USD');
        }
        
        showSyncNotification(`✅ ${importedCount} trades importados. ${createdAccounts.size} cuenta(s) creada(s)`, 'success');
        
        console.log(`✅ Importación completada: ${importedCount} trades, ${createdAccounts.size} cuenta(s)`);
        
        // Clear file
        tradovateSelectedFile = null;
        document.getElementById('tradovate-csv-input').value = '';
        document.getElementById('tradovate-file-info').classList.add('hidden');
        
        if (importBtn) {
            importBtn.disabled = true;
        }
        
        // Refresh dashboard
        if (typeof refreshDashboard === 'function') {
            setTimeout(refreshDashboard, 500);
        }
        
        
    } catch (error) {
        console.error('❌ Error importando CSV:', error);
        showSyncNotification('❌ Error al importar: ' + error.message, 'error');
        
        const progressDiv = document.getElementById('tradovate-import-progress');
        const importBtn = document.getElementById('tradovate-import-btn');
        
        if (progressDiv) progressDiv.classList.add('hidden');
        if (importBtn) importBtn.disabled = false;
    }
}

function updateImportProgress(percent, text) {
    const progressBar = document.getElementById('tradovate-progress-bar-import');
    const progressText = document.getElementById('tradovate-progress-text');
    
    if (progressBar) progressBar.style.width = percent + '%';
    if (progressText) progressText.textContent = Math.round(percent) + '%';
}

function readFileAsText(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = e => resolve(e.target.result);
        reader.onerror = e => reject(new Error('Error leyendo archivo'));
        reader.readAsText(file);
    });
}

// Event Listeners para TradingView
document.addEventListener('DOMContentLoaded', () => {
    // Botón copiar webhook URL
    const copyWebhookBtn = document.getElementById('copy-webhook-url');
    if (copyWebhookBtn) {
        copyWebhookBtn.addEventListener('click', () => {
            const url = document.getElementById('tradingview-webhook-url').value;
            navigator.clipboard.writeText(url).then(() => {
                showSyncNotification('✅ URL del webhook copiada', 'success');
            });
        });
    }
    
    // Botón copiar Account ID
    const copyAccountIdBtn = document.getElementById('copy-account-id');
    if (copyAccountIdBtn) {
        copyAccountIdBtn.addEventListener('click', () => {
            const accountId = document.getElementById('tradingview-account-id').value;
            navigator.clipboard.writeText(accountId).then(() => {
                showSyncNotification('✅ Account ID copiado', 'success');
            });
        });
    }
    
    // Botón test webhook
    const testWebhookBtn = document.getElementById('tradingview-test-webhook');
    if (testWebhookBtn) {
        testWebhookBtn.addEventListener('click', testTradingViewWebhook);
    }
    
    // Botón guardar configuración
    const saveConfigBtn = document.getElementById('tradingview-save-config');
    if (saveConfigBtn) {
        saveConfigBtn.addEventListener('click', saveTradingViewConfig);
    }
    
    // Botón volver
    const backBtn = document.getElementById('back-to-platforms-tradingview');
    if (backBtn) {
        backBtn.addEventListener('click', () => {
            showSection('platforms');
        });
    }
    
    // ============================================
    // NINJATRADER FUNCTIONS
    // ============================================
    
    let ninjaSync = null;
    let ninjaCSVImporter = null;

    // Función de importación CSV de TopStepX
    window.importTopStepXCSV = async function() {
        // Crear input file
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.csv';
        
        input.onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            try {
                const csvText = await file.text();
                console.log('📄 Archivo CSV de TopStepX cargado');
                
                // Mostrar notificación de inicio
                showSyncNotification('📥 Importando operaciones de TopStepX...', 'info');
                
                // Parsear CSV
                const lines = csvText.trim().split('\n');
                if (lines.length < 2) {
                    throw new Error('El archivo CSV está vacío o no tiene datos');
                }
                
                // Extraer headers
                const headers = lines[0].split(',').map(h => h.trim());
                console.log('📋 Headers detectados:', headers);
                
                // Parsear trades
                const trades = [];
                const contractsFound = new Set();
                
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    
                    const values = parseCSVLine(line);
                    if (values.length < headers.length) continue;
                    
                    const tradeData = {};
                    headers.forEach((header, idx) => {
                        tradeData[header] = values[idx] ? values[idx].trim() : '';
                    });
                    
                    // Extraer información del trade
                    // Formato TopStepX: Id, ContractName, EnteredAt, ExitedAt, EntryPrice, ExitPrice, Fees, PnL, Size, Type, TradeDay, TradeDuration, Commissions
                    const contractName = tradeData['ContractName'] || '';
                    const entryTime = parseTopStepXDate(tradeData['EnteredAt']);
                    const exitTime = parseTopStepXDate(tradeData['ExitedAt']);
                    const entryPrice = parseFloat(tradeData['EntryPrice']) || 0;
                    const exitPrice = parseFloat(tradeData['ExitPrice']) || 0;
                    const pnl = parseFloat(tradeData['PnL']) || 0;
                    const size = parseFloat(tradeData['Size']) || 1;
                    const type = (tradeData['Type'] || '').toLowerCase();
                    const fees = parseFloat(tradeData['Fees']) || 0;
                    const commissions = parseFloat(tradeData['Commissions']) || 0;
                    const tradeId = tradeData['Id'] || `${i}`;
                    
                    if (!contractName || !entryTime || !exitTime) {
                        console.warn('⚠️ Trade incompleto en línea', i + 1);
                        continue;
                    }
                    
                    contractsFound.add(contractName);
                    
                    // Crear trade (sin asignar cuenta todavía)
                    const trade = {
                        contract: contractName,
                        symbol: contractName,
                        entry_time: entryTime,
                        exit_time: exitTime,
                        entry_price: entryPrice,
                        exit_price: exitPrice,
                        size: size,
                        type: type === 'long' ? 'long' : 'short',
                        pnl: pnl,
                        fees: fees + commissions,
                        platform: 'topstepx',
                        setup: '',
                        notes: `Trade ID: ${tradeId}`,
                        tradeId: tradeId
                    };
                    
                    trades.push(trade);
                }
                
                console.log(`📊 ${trades.length} trades parseados de TopStepX`);
                console.log(`🏦 Contratos encontrados: ${Array.from(contractsFound).join(', ')}`);
                
                if (trades.length === 0) {
                    throw new Error('No se encontraron trades válidos en el CSV');
                }
                
                // Obtener usuario autenticado
                const { data: { user } } = await window.supabase.auth.getUser();
                if (!user) {
                    throw new Error('Usuario no autenticado');
                }
                
                // Mostrar modal para seleccionar cuenta destino
                const selectedAccount = await showTopStepXAccountSelector(contractsFound, user.id);
                if (!selectedAccount) {
                    showSyncNotification('❌ Importación cancelada por el usuario', 'warning');
                    return;
                }
                
                // Si se seleccionó, usar esa cuenta para todos los trades
                console.log(`✅ Cuenta seleccionada: ${selectedAccount.name} (${selectedAccount.id})`);
                
                // Importar trades a Supabase usando la cuenta seleccionada
                let importedCount = 0;
                const processedTradeIds = new Set(); // Para evitar duplicados
                
                for (const trade of trades) {
                    try {
                        // Evitar duplicados basándonos en el tradeId
                        const uniqueKey = `${trade.tradeId}_${trade.entry_time}_${trade.exit_time}`;
                        if (processedTradeIds.has(uniqueKey)) {
                            console.log(`⚠️ Trade duplicado detectado, saltando: ${uniqueKey}`);
                            continue;
                        }
                        processedTradeIds.add(uniqueKey);
                        
                        // Convertir trade al formato de saveOperationToSupabase
                        const operationData = {
                            id: `topstepx_${trade.symbol}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                            accountId: selectedAccount.id, // Usar la cuenta seleccionada
                            date: trade.entry_time.split(' ')[0], // Solo la fecha
                            instrument: trade.symbol,
                            type: trade.type,
                            entry: trade.entry_price,
                            exit: trade.exit_price,
                            entryTime: trade.entry_time,
                            exitTime: trade.exit_time,
                            volume: trade.size,
                            result: trade.pnl >= 0 ? 'win' : 'loss',
                            pl: trade.pnl,
                            currency: 'USD',
                            notes: trade.notes || '',
                            imageDatas: [],
                            fees: trade.fees,
                            manualPL: trade.pnl,
                            session: 'No especificado'
                        };
                        
                        await saveOperationToSupabase(operationData);
                        importedCount++;
                    } catch (error) {
                        console.error('Error importando trade:', error);
                    }
                }
                
                console.log(`✅ ${importedCount} trades importados a Supabase`);
                
                // Recargar operaciones
                if (typeof loadOperationsFromSupabase === 'function') {
                    await loadOperationsFromSupabase();
                    console.log(`✅ Operaciones recargadas`);
                }
                
                // Actualizar dashboard
                if (typeof refreshDashboard === 'function') {
                    setTimeout(() => {
                        refreshDashboard();
                        console.log(`✅ Dashboard actualizado`);
                    }, 500);
                }
                
                // Mostrar mensaje de éxito
                const message = `✅ Importación completada:\n- ${importedCount} trades importados a la cuenta "${selectedAccount.name}"`;
                alert(message);
                
                // Mostrar notificación de éxito
                showSyncNotification(
                    `✅ ${importedCount} trades importados de TopStepX a ${selectedAccount.name}`,
                    'success'
                );
                
                // Actualizar estado de la plataforma
                const statusIndicator = document.getElementById('topstepx-status-indicator');
                const lastSync = document.getElementById('topstepx-last-sync');
                if (statusIndicator) statusIndicator.textContent = 'Importado';
                if (statusIndicator) statusIndicator.className = 'text-green-400';
                if (lastSync) lastSync.textContent = new Date().toLocaleString('es-ES');
                
            } catch (error) {
                console.error('❌ Error importando CSV de TopStepX:', error);
                showSyncNotification('❌ Error: ' + error.message, 'error');
            }
        };
        
        input.click();
    }
    
    // Función para mostrar modal de selección de cuenta TopStepX
    async function showTopStepXAccountSelector(contractsFound, userId) {
        return new Promise((resolve) => {
            // Crear overlay
            const overlay = document.createElement('div');
            overlay.className = 'fixed inset-0 bg-black/60 backdrop-blur-sm z-[99999] flex items-center justify-center';
            overlay.style.animation = 'fadeIn 0.3s ease';
            
            // Crear modal
            const modal = document.createElement('div');
            modal.className = 'bg-gray-800 rounded-lg p-6 max-w-md w-full mx-4 shadow-xl border border-gray-700';
            modal.style.animation = 'slideUp 0.3s ease';
            
            // Contenido del modal
            modal.innerHTML = `
                <h2 class="text-xl font-bold text-white mb-4">📥 Seleccionar Cuenta TopStepX</h2>
                <p class="text-gray-300 mb-4">
                    Contratos encontrados: <strong>${Array.from(contractsFound).join(', ')}</strong>
                </p>
                <p class="text-gray-400 mb-4 text-sm">
                    Selecciona una cuenta existente o crea una nueva para importar los trades.
                </p>
                
                <!-- Selector de cuenta -->
                <div class="mb-4">
                    <label class="block text-gray-300 mb-2">Cuenta Destino:</label>
                    <select id="topstepx-account-selector" class="w-full bg-gray-700 text-white rounded px-3 py-2 border border-gray-600 focus:border-blue-500 focus:outline-none">
                        <option value="new">➕ Crear nueva cuenta</option>
                    </select>
                </div>
                
                <!-- Campo para nombre de nueva cuenta (oculto inicialmente) -->
                <div id="new-account-name-container" class="mb-4 hidden">
                    <label class="block text-gray-300 mb-2">Nombre de la Nueva Cuenta:</label>
                    <input type="text" id="new-account-name" 
                        class="w-full bg-gray-700 text-white rounded px-3 py-2 border border-gray-600 focus:border-blue-500 focus:outline-none"
                        placeholder="TopStepX - NQH6"
                        value="TopStepX - ${Array.from(contractsFound)[0] || 'Nueva'}">
                </div>
                
                <!-- Botones -->
                <div class="flex gap-3 mt-6">
                    <button id="topstepx-confirm-btn" class="flex-1 bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded font-medium transition-colors">
                        ✅ Confirmar
                    </button>
                    <button id="topstepx-cancel-btn" class="flex-1 bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded font-medium transition-colors">
                        ❌ Cancelar
                    </button>
                </div>
            `;
            
            overlay.appendChild(modal);
            document.body.appendChild(overlay);
            
            // Poblar selector con cuentas existentes
            const selector = overlay.querySelector('#topstepx-account-selector');
            const newAccountContainer = overlay.querySelector('#new-account-name-container');
            
            DB.accounts.forEach(account => {
                const option = document.createElement('option');
                option.value = account.id;
                option.textContent = `${account.name} (${account.platform})`;
                selector.appendChild(option);
            });
            
            // Mostrar/ocultar campo de nuevo nombre
            selector.addEventListener('change', () => {
                if (selector.value === 'new') {
                    newAccountContainer.classList.remove('hidden');
                } else {
                    newAccountContainer.classList.add('hidden');
                }
            });
            
            // Botón confirmar
            overlay.querySelector('#topstepx-confirm-btn').addEventListener('click', async () => {
                const selectedValue = selector.value;
                
                if (selectedValue === 'new') {
                    // Crear nueva cuenta
                    const newAccountName = overlay.querySelector('#new-account-name').value.trim();
                    if (!newAccountName) {
                        alert('Por favor ingresa un nombre para la nueva cuenta');
                        return;
                    }
                    
                    try {
                        // Generar ID único
                        const accountId = `topstepx_${newAccountName.replace(/\s+/g, '_')}_${Date.now()}`;
                        
                        // Insertar en Supabase
                        const { data: newAccount, error } = await window.supabase
                            .from('accounts')
                            .insert({
                                id: accountId,
                                user_id: userId,
                                name: newAccountName,
                                platform: 'topstepx',
                                balance: 100000,
                                currency: 'USD',
                                created_at: new Date().toISOString(),
                                updated_at: new Date().toISOString()
                            })
                            .select()
                            .single();
                        
                        if (error) {
                            alert(`Error creando cuenta: ${error.message}`);
                            return;
                        }
                        
                        // Actualizar DB local
                        DB.accounts.push(newAccount);
                        
                        // Cerrar modal y resolver con la nueva cuenta
                        document.body.removeChild(overlay);
                        resolve(newAccount);
                    } catch (error) {
                        alert(`Error: ${error.message}`);
                    }
                } else {
                    // Usar cuenta existente
                    const account = DB.accounts.find(a => a.id === selectedValue);
                    if (account) {
                        document.body.removeChild(overlay);
                        resolve(account);
                    } else {
                        alert('Cuenta no encontrada');
                    }
                }
            });
            
            // Botón cancelar
            overlay.querySelector('#topstepx-cancel-btn').addEventListener('click', () => {
                document.body.removeChild(overlay);
                resolve(null);
            });
        });
    }
    
    // Función auxiliar para parsear fechas de TopStepX
    function parseTopStepXDate(dateStr) {
        if (!dateStr) return null;
        
        // Formato: "01/21/2026 17:31:35 +01:00"
        try {
            // Remover el timezone offset y parsear
            const datePart = dateStr.split('+')[0].trim().split('-')[0].trim();
            const [datePortion, timePortion] = datePart.split(' ');
            const [month, day, year] = datePortion.split('/');
            const [hours, minutes, seconds] = (timePortion || '00:00:00').split(':');
            
            const date = new Date(
                parseInt(year),
                parseInt(month) - 1,
                parseInt(day),
                parseInt(hours),
                parseInt(minutes),
                parseInt(seconds)
            );
            
            // Formato: YYYY-MM-DD HH:MM:SS (sin zona horaria para evitar problemas)
            const yyyy = date.getFullYear();
            const mm = String(date.getMonth() + 1).padStart(2, '0');
            const dd = String(date.getDate()).padStart(2, '0');
            const hh = String(date.getHours()).padStart(2, '0');
            const min = String(date.getMinutes()).padStart(2, '0');
            const ss = String(date.getSeconds()).padStart(2, '0');
            
            return `${yyyy}-${mm}-${dd} ${hh}:${min}:${ss}`;
        } catch (error) {
            console.error('Error parseando fecha:', dateStr, error);
            return null;
        }
    }
    
    // Función auxiliar para parsear líneas CSV (maneja comillas)
    function parseCSVLine(line) {
        const result = [];
        let current = '';
        let inQuotes = false;
        
        for (let i = 0; i < line.length; i++) {
            const char = line[i];
            
            if (char === '"') {
                inQuotes = !inQuotes;
            } else if (char === ',' && !inQuotes) {
                result.push(current);
                current = '';
            } else {
                current += char;
            }
        }
        
        result.push(current);
        return result;
    }

    window.importNinjaTraderCSV = function() {
        // Crear input file
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.csv';
        
        input.onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            try {
                const csvText = await file.text();
                
                // Crear modal de progreso
                const modal = createNinjaImportModal();
                document.body.appendChild(modal);

                // Crear importador si no existe
                if (!ninjaCSVImporter) {
                    ninjaCSVImporter = new window.NinjaTraderCSVImporter();
                }

                // Importar
                const result = await ninjaCSVImporter.import(csvText, (progress) => {
                    updateNinjaImportProgress(progress);
                });

                if (result.success) {
                    showNinjaImportResults(result);
                    
                    // Recargar operaciones desde Supabase
                    console.log('🔄 Recargando operaciones después de importar...');
                    
                    setTimeout(async () => {
                        if (typeof loadOperationsFromSupabase === 'function') {
                            await loadOperationsFromSupabase();
                        }
                        
                        if (typeof refreshDashboard === 'function') {
                            refreshDashboard();
                        }
                    }, 500);
                }

            } catch (error) {
                console.error('Error importando CSV:', error);
                alert('Error: ' + error.message);
            }
        };

        input.click();
    }

    window.createNinjaImportModal = function() {
        const modal = document.createElement('div');
        modal.id = 'ninja-import-modal';
        modal.className = 'fixed inset-0 z-50 flex items-center justify-center p-4';
        modal.style.backgroundColor = 'rgba(0,0,0,0.95)';
        
        modal.innerHTML = `
            <div class="relative bg-surface border border-border rounded-lg shadow-lg p-8 w-full max-w-2xl">
                <div class="mb-6">
                    <div class="flex items-center gap-3 mb-2">
                        <div class="w-12 h-12 rounded-lg bg-green-600 flex items-center justify-center">
                            <i class="fas fa-file-csv text-white text-xl"></i>
                        </div>
                        <h2 class="text-2xl font-bold">Importar CSV de NinjaTrader</h2>
                    </div>
                </div>

                <div id="ninja-import-progress" class="text-center py-8">
                    <div class="inline-block">
                        <i class="fas fa-spinner fa-spin text-primary text-5xl mb-4"></i>
                    </div>
                    <h3 id="ninja-import-title" class="text-xl font-semibold mb-2">Procesando...</h3>
                    <p id="ninja-import-message" class="text-text-secondary mb-4">Iniciando...</p>
                    
                    <div class="bg-surface-light rounded-full h-3 w-full max-w-md mx-auto overflow-hidden mb-2">
                        <div id="ninja-import-bar" class="h-full bg-primary transition-all duration-300" style="width: 0%"></div>
                    </div>
                    
                    <p id="ninja-import-stats" class="text-sm text-text-secondary">0 / 0</p>
                </div>

                <div id="ninja-import-results" class="hidden text-center py-6">
                    <div class="inline-block w-20 h-20 rounded-full bg-primary bg-opacity-20 flex items-center justify-center mb-4">
                        <i class="fas fa-check text-primary text-4xl"></i>
                    </div>
                    <h3 class="text-2xl font-bold mb-2">¡Importación Completada!</h3>
                    
                    <div class="grid grid-cols-2 gap-4 max-w-md mx-auto my-6">
                        <div class="bg-surface-light rounded-lg p-4">
                            <div class="text-3xl font-bold text-primary" id="ninja-import-result-trades">0</div>
                            <div class="text-sm text-text-secondary">Trades Importados</div>
                        </div>
                        <div class="bg-surface-light rounded-lg p-4">
                            <div class="text-3xl font-bold text-accent" id="ninja-import-result-accounts">0</div>
                            <div class="text-sm text-text-secondary">Cuentas Detectadas</div>
                        </div>
                    </div>

                    <div id="ninja-import-accounts-list" class="text-left bg-surface-light rounded-lg p-4 max-w-md mx-auto mb-4">
                        <!-- Se llenará dinámicamente -->
                    </div>

                    <button id="ninja-import-close-btn" class="btn-primary">
                        <i class="fas fa-check mr-2"></i>Cerrar
                    </button>
                </div>
            </div>
        `;

        // Event listener para cerrar
        setTimeout(() => {
            const closeBtn = document.getElementById('ninja-import-close-btn');
            if (closeBtn) {
                closeBtn.addEventListener('click', () => modal.remove());
            }
        }, 100);

        return modal;
    }

    window.updateNinjaImportProgress = function(progress) {
        const title = document.getElementById('ninja-import-title');
        const message = document.getElementById('ninja-import-message');
        const progressBar = document.getElementById('ninja-import-bar');
        const stats = document.getElementById('ninja-import-stats');
        
        if (title) title.textContent = progress.message || 'Procesando...';
        if (message) message.textContent = progress.status || '';
        
        if (progress.current && progress.total) {
            const percentage = (progress.current / progress.total) * 100;
            if (progressBar) progressBar.style.width = percentage + '%';
            if (stats) stats.textContent = `${progress.current} / ${progress.total}`;
        }
    }

    window.showNinjaImportResults = function(result) {
        document.getElementById('ninja-import-progress').style.display = 'none';
        document.getElementById('ninja-import-results').classList.remove('hidden');
        
        document.getElementById('ninja-import-result-trades').textContent = result.imported || 0;
        document.getElementById('ninja-import-result-accounts').textContent = result.accounts?.length || 0;
        
        const accountsList = document.getElementById('ninja-import-accounts-list');
        if (accountsList && result.accounts) {
            accountsList.innerHTML = `
                <div class="text-sm font-semibold mb-2">Cuentas detectadas:</div>
                ${result.accounts.map(account => `
                    <div class="flex items-center gap-2 py-1">
                        <i class="fas fa-check-circle text-primary text-xs"></i>
                        <span class="text-sm">${account}</span>
                    </div>
                `).join('')}
            `;
        }

        // Mostrar notificación
        if (typeof showToast === 'function') {
            showToast('Importación completada', `${result.imported} trades importados`, 'success');
        }

        // Actualizar indicadores
        const statusIndicator = document.getElementById('ninjatrader-status-indicator');
        if (statusIndicator) {
            statusIndicator.textContent = 'Conectado';
            statusIndicator.className = 'text-primary';
        }

        const lastSync = document.getElementById('ninjatrader-last-sync');
        if (lastSync) {
            lastSync.textContent = 'Hace unos segundos';
        }
    }

    window.showNinjaTraderSyncModal = function() {
        // Verificar soporte del navegador
        if (!window.NinjaTraderFileSync || !window.NinjaTraderFileSync.isSupported()) {
            alert('Tu navegador no soporta esta función.\n\nPor favor usa Chrome o Edge (versión reciente).');
            return;
        }

        // Crear instancia si no existe
        if (!ninjaSync) {
            ninjaSync = new window.NinjaTraderFileSync();
        }

        const modal = document.createElement('div');
        modal.id = 'ninja-sync-modal';
        modal.className = 'fixed inset-0 z-50 flex items-center justify-center p-4';
        modal.style.backgroundColor = 'rgba(0,0,0,0.95)';
        
        modal.innerHTML = `
            <div class="relative bg-surface border border-border rounded-lg shadow-lg p-8 w-full max-w-2xl">
                <button id="close-ninja-sync-modal" class="absolute top-4 right-4 p-2 rounded-full hover:bg-surface-light">
                    <i class="fas fa-times"></i>
                </button>
                
                <div class="mb-6">
                    <div class="flex items-center gap-3 mb-2">
                        <div class="w-12 h-12 rounded-lg bg-orange-600 flex items-center justify-center">
                            <i class="fas fa-sync-alt text-white text-xl"></i>
                        </div>
                        <h2 class="text-2xl font-bold">Sincronizar NinjaTrader</h2>
                    </div>
                    <p class="text-text-secondary">Importa tus trades automáticamente desde los archivos de NinjaTrader</p>
                </div>

                <div id="ninja-sync-content">
                    <!-- Paso 1: Seleccionar carpeta -->
                    <div id="ninja-step-select" class="step-content">
                        <div class="bg-surface-light border border-border rounded-lg p-6 mb-4">
                            <div class="flex items-start gap-4">
                                <div class="w-12 h-12 rounded-full bg-primary text-background flex items-center justify-center font-bold text-xl flex-shrink-0">
                                    1
                                </div>
                                <div class="flex-1">
                                    <h3 class="text-lg font-semibold mb-2">Selecciona la carpeta de NinjaTrader</h3>
                                    <p class="text-sm text-text-secondary mb-4">
                                        Normalmente está en:<br>
                                        <code class="text-xs bg-background px-2 py-1 rounded">C:\\\\Users\\\\TuUsuario\\\\Documents\\\\NinjaTrader 8\\\\db\\\\execution</code>
                                    </p>
                                    <button id="ninja-select-folder-btn" class="btn-primary">
                                        <i class="fas fa-folder-open mr-2"></i>Seleccionar Carpeta
                                    </button>
                                </div>
                            </div>
                        </div>

                        <div class="bg-primary bg-opacity-10 border border-primary rounded-lg p-4">
                            <div class="flex items-start gap-3">
                                <i class="fas fa-info-circle text-primary mt-1"></i>
                                <div class="text-sm">
                                    <p class="font-semibold text-primary mb-1">Primera vez solamente</p>
                                    <p class="text-text-secondary">Solo necesitas hacer esto una vez. Después podrás sincronizar con un solo click.</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Paso 2: Progreso -->
                    <div id="ninja-step-progress" class="step-content" style="display: none;">
                        <div class="text-center py-8">
                            <div class="inline-block">
                                <i class="fas fa-sync-alt fa-spin text-primary text-5xl mb-4"></i>
                            </div>
                            <h3 id="ninja-progress-title" class="text-xl font-semibold mb-2">Escaneando archivos...</h3>
                            <p id="ninja-progress-message" class="text-text-secondary mb-4">Iniciando...</p>
                            
                            <div class="bg-surface-light rounded-full h-3 w-full max-w-md mx-auto overflow-hidden mb-2">
                                <div id="ninja-progress-bar" class="h-full bg-primary transition-all duration-300" style="width: 0%"></div>
                            </div>
                            
                            <p id="ninja-progress-stats" class="text-sm text-text-secondary">0 / 0</p>
                        </div>
                    </div>

                    <!-- Paso 3: Resultados -->
                    <div id="ninja-step-results" class="step-content" style="display: none;">
                        <div class="text-center py-6">
                            <div class="inline-block w-20 h-20 rounded-full bg-primary bg-opacity-20 flex items-center justify-center mb-4">
                                <i class="fas fa-check text-primary text-4xl"></i>
                            </div>
                            <h3 class="text-2xl font-bold mb-2">¡Sincronización Completada!</h3>
                            
                            <div class="grid grid-cols-2 gap-4 max-w-md mx-auto my-6">
                                <div class="bg-surface-light rounded-lg p-4">
                                    <div class="text-3xl font-bold text-primary" id="ninja-result-trades">0</div>
                                    <div class="text-sm text-text-secondary">Trades Importados</div>
                                </div>
                                <div class="bg-surface-light rounded-lg p-4">
                                    <div class="text-3xl font-bold text-accent" id="ninja-result-accounts">0</div>
                                    <div class="text-sm text-text-secondary">Cuentas Detectadas</div>
                                </div>
                            </div>

                            <div id="ninja-accounts-list" class="text-left bg-surface-light rounded-lg p-4 max-w-md mx-auto mb-4">
                                <!-- Se llenará dinámicamente -->
                            </div>

                            <button id="ninja-view-operations-btn" class="btn-primary">
                                <i class="fas fa-chart-line mr-2"></i>Ver Operaciones
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        // Event Listeners
        document.getElementById('close-ninja-sync-modal').addEventListener('click', () => {
            modal.remove();
        });
        
        document.getElementById('ninja-select-folder-btn').addEventListener('click', async () => {
            try {
                const folderHandle = await ninjaSync.selectFolder();
                
                if (folderHandle) {
                    // Iniciar sincronización
                    document.getElementById('ninja-step-select').style.display = 'none';
                    document.getElementById('ninja-step-progress').style.display = 'block';
                    
                    const result = await ninjaSync.sync((progress) => {
                        updateNinjaProgress(progress);
                    });
                    
                    if (result.success) {
                        showNinjaResults(result);
                    }
                }
            } catch (error) {
                console.error('Error en sincronización:', error);
                alert('Error: ' + error.message);
                modal.remove();
            }
        });
        
        document.getElementById('ninja-view-operations-btn')?.addEventListener('click', () => {
            modal.remove();
            // Ir a la sección de operaciones
            document.querySelectorAll('.nav-item').forEach(item => {
                if (item.dataset.target === 'operations') {
                    item.click();
                }
            });
        });
    }

    function updateNinjaProgress(progress) {
        const title = document.getElementById('ninja-progress-title');
        const message = document.getElementById('ninja-progress-message');
        const progressBar = document.getElementById('ninja-progress-bar');
        const stats = document.getElementById('ninja-progress-stats');
        
        if (title) title.textContent = progress.message || 'Procesando...';
        if (message) message.textContent = progress.status || '';
        
        if (progress.current && progress.total) {
            const percentage = (progress.current / progress.total) * 100;
            if (progressBar) progressBar.style.width = percentage + '%';
            if (stats) stats.textContent = `${progress.current} / ${progress.total}`;
        }
    }

    function showNinjaResults(result) {
        document.getElementById('ninja-step-progress').style.display = 'none';
        document.getElementById('ninja-step-results').style.display = 'block';
        
        document.getElementById('ninja-result-trades').textContent = result.imported || 0;
        document.getElementById('ninja-result-accounts').textContent = result.accounts?.length || 0;
        
        const accountsList = document.getElementById('ninja-accounts-list');
        if (accountsList && result.accounts) {
            accountsList.innerHTML = `
                <div class="text-sm font-semibold mb-2">Cuentas detectadas:</div>
                ${result.accounts.map(account => `
                    <div class="flex items-center gap-2 py-1">
                        <i class="fas fa-check-circle text-primary text-xs"></i>
                        <span class="text-sm">${account}</span>
                    </div>
                `).join('')}
            `;
        }
        
        // Mostrar notificación
        if (typeof showToast === 'function') {
            showToast('Sincronización completada', `${result.imported} trades importados`, 'success');
        }
        
        // Actualizar indicador en la tarjeta
        const statusIndicator = document.getElementById('ninjatrader-status-indicator');
        if (statusIndicator) {
            statusIndicator.textContent = 'Conectado';
            statusIndicator.className = 'text-primary';
        }
        
        const lastSync = document.getElementById('ninjatrader-last-sync');
        if (lastSync) {
            lastSync.textContent = 'Hace unos segundos';
        }
        
        // Actualizar vista detallada si está abierta
        const detailStatus = document.getElementById('ninjatrader-detail-status');
        if (detailStatus) {
            detailStatus.textContent = 'Configurado';
        }
        
        const detailIndicator = document.getElementById('ninjatrader-detail-indicator');
        if (detailIndicator) {
            detailIndicator.className = 'w-3 h-3 rounded-full bg-green-500 mr-3';
        }
        
        const lastSyncDetail = document.getElementById('ninjatrader-last-sync-detail');
        if (lastSyncDetail) {
            lastSyncDetail.textContent = 'Hace unos segundos';
        }
        
        // Mostrar sección de carpeta configurada
        const folderSelected = document.getElementById('ninja-folder-selected');
        if (folderSelected) {
            folderSelected.classList.remove('hidden');
        }
        
        // Mostrar y actualizar sección de cuentas
        const accountsSection = document.getElementById('ninja-accounts-section');
        const accountsGrid = document.getElementById('ninja-accounts-grid');
        if (accountsSection && accountsGrid && result.accounts && result.accounts.length > 0) {
            accountsSection.classList.remove('hidden');
            accountsGrid.innerHTML = result.accounts.map(account => `
                <div class="p-3 bg-surface-light rounded-lg border border-border">
                    <div class="flex items-center gap-2">
                        <i class="fas fa-user-circle text-accent"></i>
                        <span class="font-medium text-sm">${account}</span>
                    </div>
                </div>
            `).join('');
        }
        
        // Mostrar y actualizar estadísticas
        const statsSection = document.getElementById('ninja-stats-section');
        if (statsSection) {
            statsSection.classList.remove('hidden');
            
            const statTrades = document.getElementById('ninja-stat-trades');
            const statAccounts = document.getElementById('ninja-stat-accounts');
            const statFiles = document.getElementById('ninja-stat-files');
            
            if (statTrades) statTrades.textContent = result.imported || 0;
            if (statAccounts) statAccounts.textContent = result.accounts?.length || 0;
            if (statFiles) statFiles.textContent = result.total || 0;
        }
    }
    
    // ============================================
    // TRADOVATE CSV IMPORT
    // ============================================
    
    let tradovateFileSync = null;

    window.importTradovateCSV = function() {
        console.log('🚀 Iniciando importación CSV de Tradovate...');
        
        // Verificar que NinjaTraderFileSync esté disponible
        if (!window.NinjaTraderFileSync) {
            console.error('❌ NinjaTraderFileSync no está disponible');
            alert('Error: Sistema de importación no cargado. Recarga la página.');
            return;
        }
        
        // Crear input file
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.csv';
        
        input.onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) {
                console.log('⚠️ No se seleccionó archivo');
                return;
            }

            console.log(`📄 Archivo seleccionado: ${file.name}`);

            try {
                const csvText = await file.text();
                console.log(`✅ Archivo leído: ${csvText.length} caracteres`);
                
                // Detectar si es Position History de Tradovate
                if (!csvText.includes('Position ID') || !csvText.includes('Buy Price') || !csvText.includes('Sell Price')) {
                    console.error('❌ Formato incorrecto: No es Position History de Tradovate');
                    alert('⚠️ Este archivo no parece ser un Position History de Tradovate.\\n\\nAsegúrate de exportar el archivo "Position History" desde Tradovate.');
                    return;
                }
                
                console.log('✅ Formato detectado: Tradovate Position History');
                
                // Crear modal de progreso
                const modal = createTradovateImportModal();
                document.body.appendChild(modal);

                // Crear importador de Tradovate si no existe
                if (!tradovateFileSync) {
                    console.log('📝 Creando instancia de NinjaTraderFileSync...');
                    tradovateFileSync = new window.NinjaTraderFileSync();
                }

                // Parsear CSV de Tradovate
                updateTradovateImportProgress({ 
                    status: 'parsing', 
                    message: 'Parseando Position History de Tradovate...' 
                });
                
                console.log('🔄 Parseando CSV...');
                const trades = tradovateFileSync.parseCSV(csvText);
                
                if (!trades || trades.length === 0) {
                    console.warn('⚠️ No se encontraron trades');
                    alert('⚠️ No se encontraron trades en el archivo CSV');
                    modal.remove();
                    return;
                }

                console.log(`📊 Trades de Tradovate parseados: ${trades.length}`);

                // Calcular balance por cuenta
                const accountBalances = new Map();
                trades.forEach(trade => {
                    const accountName = trade.account_id;
                    if (!accountBalances.has(accountName)) {
                        accountBalances.set(accountName, 0);
                    }
                    accountBalances.set(accountName, accountBalances.get(accountName) + (trade.pnl || 0));
                });

                console.log('💰 Balances calculados por cuenta:', Object.fromEntries(accountBalances));

                // Importar trades
                updateTradovateImportProgress({ 
                    status: 'importing', 
                    message: `Importando ${trades.length} trades...`,
                    total: trades.length
                });

                let imported = 0;
                const accounts = new Set();
                const errors = [];
                const createdAccounts = new Set();

                for (let i = 0; i < trades.length; i++) {
                    try {
                        // Crear cuenta con balance solo la primera vez
                        const accountName = trades[i].account_id;
                        if (!createdAccounts.has(accountName)) {
                            const balance = accountBalances.get(accountName) || 0;
                            
                            console.log(`🏦 Creando cuenta: ${accountName} con balance: $${balance}`);
                            
                            // Obtener usuario
                            const { data: { user } } = await window.supabase.auth.getUser();
                            if (user) {
                                await tradovateFileSync.ensureAccountExists(
                                    user.id, 
                                    accountName, 
                                    trades[i].platform,
                                    balance
                                );
                                createdAccounts.add(accountName);
                            }
                        }
                        
                        await tradovateFileSync.importTrade(trades[i]);
                        imported++;
                        accounts.add(accountName);
                        
                        updateTradovateImportProgress({
                            status: 'importing',
                            current: i + 1,
                            total: trades.length,
                            message: `Importando ${i + 1} de ${trades.length}...`
                        });
                    } catch (error) {
                        console.error(`❌ Error importando trade ${i + 1}:`, error);
                        errors.push({ trade: trades[i], error: error.message });
                    }
                }

                const result = {
                    success: true,
                    imported,
                    total: trades.length,
                    accounts: Array.from(accounts),
                    errors
                };

                console.log('✅ Importación completada:', result);
                showTradovateImportResults(result);
                
                // Recargar operaciones desde Supabase
                console.log('🔄 Recargando operaciones después de importar...');
                
                setTimeout(async () => {
                    if (typeof loadOperationsFromSupabase === 'function') {
                        await loadOperationsFromSupabase();
                    }
                    
                    if (typeof refreshDashboard === 'function') {
                        refreshDashboard();
                    }
                }, 500);

            } catch (error) {
                console.error('❌ Error importando CSV de Tradovate:', error);
                alert('Error: ' + error.message);
            }
        };

        console.log('📂 Abriendo selector de archivos...');
        input.click();
    }

    window.createTradovateImportModal = function() {
        const modal = document.createElement('div');
        modal.id = 'tradovate-import-modal';
        modal.className = 'fixed inset-0 z-50 flex items-center justify-center p-4';
        modal.style.backgroundColor = 'rgba(0,0,0,0.95)';
        
        modal.innerHTML = `
            <div class="relative bg-surface border border-border rounded-lg shadow-lg p-8 w-full max-w-2xl">
                <div class="mb-6">
                    <div class="flex items-center gap-3 mb-2">
                        <div class="w-12 h-12 rounded-lg bg-green-600 flex items-center justify-center">
                            <i class="fas fa-file-csv text-white text-xl"></i>
                        </div>
                        <h2 class="text-2xl font-bold">Importar CSV de Tradovate</h2>
                    </div>
                    <p class="text-text-secondary text-sm">Importando Position History...</p>
                </div>

                <div id="tradovate-import-progress" class="text-center py-8">
                    <div class="inline-block">
                        <i class="fas fa-spinner fa-spin text-primary text-5xl mb-4"></i>
                    </div>
                    <h3 id="tradovate-import-title" class="text-xl font-semibold mb-2">Procesando...</h3>
                    <p id="tradovate-import-message" class="text-text-secondary mb-4">Iniciando...</p>
                    
                    <div class="bg-surface-light rounded-full h-3 w-full max-w-md mx-auto overflow-hidden mb-2">
                        <div id="tradovate-import-bar" class="h-full bg-primary transition-all duration-300" style="width: 0%"></div>
                    </div>
                    
                    <p id="tradovate-import-stats" class="text-sm text-text-secondary">0 / 0</p>
                </div>

                <div id="tradovate-import-results" class="hidden text-center py-6">
                    <div class="inline-block w-20 h-20 rounded-full bg-primary bg-opacity-20 flex items-center justify-center mb-4">
                        <i class="fas fa-check text-primary text-4xl"></i>
                    </div>
                    <h3 class="text-2xl font-bold mb-2">¡Importación Completada!</h3>
                    
                    <div class="grid grid-cols-2 gap-4 max-w-md mx-auto my-6">
                        <div class="bg-surface-light rounded-lg p-4">
                            <div class="text-3xl font-bold text-primary" id="tradovate-import-result-trades">0</div>
                            <div class="text-sm text-text-secondary">Trades Importados</div>
                        </div>
                        <div class="bg-surface-light rounded-lg p-4">
                            <div class="text-3xl font-bold text-accent" id="tradovate-import-result-accounts">0</div>
                            <div class="text-sm text-text-secondary">Cuentas Detectadas</div>
                        </div>
                    </div>

                    <div id="tradovate-import-accounts-list" class="text-left bg-surface-light rounded-lg p-4 max-w-md mx-auto mb-4">
                        <!-- Se llenará dinámicamente -->
                    </div>

                    <button id="tradovate-import-close-btn" class="btn-primary">
                        <i class="fas fa-check mr-2"></i>Cerrar
                    </button>
                </div>
            </div>
        `;

        // Event listener para cerrar
        setTimeout(() => {
            const closeBtn = document.getElementById('tradovate-import-close-btn');
            if (closeBtn) {
                closeBtn.addEventListener('click', () => modal.remove());
            }
        }, 100);

        return modal;
    }

    window.updateTradovateImportProgress = function(progress) {
        const title = document.getElementById('tradovate-import-title');
        const message = document.getElementById('tradovate-import-message');
        const progressBar = document.getElementById('tradovate-import-bar');
        const stats = document.getElementById('tradovate-import-stats');
        
        if (title) title.textContent = progress.message || 'Procesando...';
        if (message) message.textContent = progress.status || '';
        
        if (progress.current && progress.total) {
            const percentage = (progress.current / progress.total) * 100;
            if (progressBar) progressBar.style.width = percentage + '%';
            if (stats) stats.textContent = `${progress.current} / ${progress.total}`;
        }
    }

    window.showTradovateImportResults = function(result) {
        document.getElementById('tradovate-import-progress').style.display = 'none';
        document.getElementById('tradovate-import-results').classList.remove('hidden');
        
        document.getElementById('tradovate-import-result-trades').textContent = result.imported || 0;
        document.getElementById('tradovate-import-result-accounts').textContent = result.accounts?.length || 0;
        
        const accountsList = document.getElementById('tradovate-import-accounts-list');
        if (accountsList && result.accounts) {
            accountsList.innerHTML = `
                <div class="text-sm font-semibold mb-2">Cuentas detectadas:</div>
                ${result.accounts.map(account => `
                    <div class="flex items-center gap-2 py-1">
                        <i class="fas fa-check-circle text-primary text-xs"></i>
                        <span class="text-sm">${account}</span>
                    </div>
                `).join('')}
            `;
        }

        // Mostrar notificación
        if (typeof showToast === 'function') {
            showToast('Importación completada', `${result.imported} trades de Tradovate importados`, 'success');
        }

        // Actualizar indicadores
        const statusIndicator = document.getElementById('tradovate-status-indicator');
        if (statusIndicator) {
            statusIndicator.textContent = 'Conectado';
            statusIndicator.className = 'text-primary';
        }

        const lastSync = document.getElementById('tradovate-last-sync');
        if (lastSync) {
            lastSync.textContent = 'Hace unos segundos';
        }
    }
    
    // ============================================
    // NINJATRADER EVENT LISTENERS
    // ============================================
    
    // Back button
    const backBtnNinjaTrader = document.getElementById('back-to-platforms-ninjatrader');
    if (backBtnNinjaTrader) {
        backBtnNinjaTrader.addEventListener('click', () => {
            showSection('platforms');
        });
    }
    
    // Main sync button in detail view
    const ninjaSyncMainBtn = document.getElementById('ninjatrader-sync-main');
    if (ninjaSyncMainBtn) {
        ninjaSyncMainBtn.addEventListener('click', () => {
            showNinjaTraderSyncModal();
        });
    }
    
    // ============================================
    // TRADOVATE EVENT LISTENERS
    // ============================================
    
    // Back button
    const backBtnTradovate = document.getElementById('back-to-platforms-tradovate');
    if (backBtnTradovate) {
        backBtnTradovate.addEventListener('click', () => {
            showSection('platforms');
        });
    }
    
    // File dropzone click
    const dropzone = document.getElementById('tradovate-csv-dropzone');
    const fileInput = document.getElementById('tradovate-csv-input');
    
    if (dropzone && fileInput) {
        dropzone.addEventListener('click', () => {
            fileInput.click();
        });
        
        // File selected
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                tradovateSelectedFile = file;
                
                // Show file info
                document.getElementById('tradovate-file-name').textContent = file.name;
                document.getElementById('tradovate-file-size').textContent = (file.size / 1024).toFixed(2) + ' KB';
                document.getElementById('tradovate-file-info').classList.remove('hidden');
                document.getElementById('tradovate-import-btn').disabled = false;
            }
        });
        
        // Drag and drop
        dropzone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropzone.classList.add('border-primary');
        });
        
        dropzone.addEventListener('dragleave', () => {
            dropzone.classList.remove('border-primary');
        });
        
        dropzone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropzone.classList.remove('border-primary');
            
            const file = e.dataTransfer.files[0];
            if (file && file.name.endsWith('.csv')) {
                tradovateSelectedFile = file;
                
                // Show file info
                document.getElementById('tradovate-file-name').textContent = file.name;
                document.getElementById('tradovate-file-size').textContent = (file.size / 1024).toFixed(2) + ' KB';
                document.getElementById('tradovate-file-info').classList.remove('hidden');
                document.getElementById('tradovate-import-btn').disabled = false;
            }
        });
    }
    
    // Remove file
    const removeFileBtn = document.getElementById('tradovate-remove-file');
    if (removeFileBtn) {
        removeFileBtn.addEventListener('click', () => {
            tradovateSelectedFile = null;
            document.getElementById('tradovate-csv-input').value = '';
            document.getElementById('tradovate-file-info').classList.add('hidden');
            document.getElementById('tradovate-import-btn').disabled = true;
        });
    }
    
    // Import button
    const importBtn = document.getElementById('tradovate-import-btn');
    if (importBtn) {
        importBtn.addEventListener('click', importTradovateCSV);
    }
});

// ============================================
// FUNCIONES PARA cTrader
// ============================================

// Función de importación directa - Como MT5
function importCTraderHTML() {
    console.log('🎯 IMPORTACIÓN DIRECTA CTRADER INICIADA');
    
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.html,.htm';
    input.style.display = 'none';

    input.onchange = function(event) {
        const file = event.target.files[0];
        if (!file) return;

        console.log('📁 Archivo seleccionado:', file.name);

        const reader = new FileReader();
        reader.onload = async function(e) {
            try {
                const htmlContent = e.target.result;
                console.log('📄 Contenido leído, parseando...');
                
                await parseCTraderHTMLDirect(htmlContent);
                
            } catch (error) {
                console.error('❌ Error:', error);
                showSyncNotification(`❌ Error: ${error.message}`, 'error');
            }
        };
        reader.readAsText(file);
    };

    document.body.appendChild(input);
    input.click();
    document.body.removeChild(input);
}

// Parser directo - SIN VISTA PREVIA
async function parseCTraderHTMLDirect(htmlContent) {
    console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
    console.log('🔍 PARSEANDO CTRADER HTML STATEMENT');
    console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
    
    const parser = new DOMParser();
    const doc = parser.parseFromString(htmlContent, 'text/html');
    
    // Extraer información de la cuenta
    let accountNumber = '';
    let accountCurrency = 'USD';
    
    const allTables = doc.querySelectorAll('table');
    for (const table of allTables) {
        const rows = table.querySelectorAll('tr');
        for (const row of rows) {
            const cells = row.querySelectorAll('td');
            if (cells.length >= 2) {
                const label = cells[0]?.textContent.trim() || '';
                const value = cells[1]?.textContent.trim() || '';
                
                if (label.toLowerCase().includes('cuenta') || label.toLowerCase().includes('account')) {
                    // Extraer solo números del valor
                    const numberMatch = value.match(/\d{7,}/);
                    if (numberMatch) {
                        accountNumber = numberMatch[0];
                        console.log('✅ Número de cuenta detectado:', accountNumber);
                    }
                }
                if (label.toLowerCase().includes('divisa') || label.toLowerCase().includes('currency')) {
                    accountCurrency = value;
                    console.log('✅ Divisa detectada:', accountCurrency);
                }
            }
        }
    }
    
    // Buscar la tabla de operaciones - MÉTODO MEJORADO
    let historyTable = null;
    
    // Buscar tabla con clase específica de cTrader
    for (const table of allTables) {
        // Buscar por strong/th que contenga "Historial"
        const titleCells = table.querySelectorAll('td strong, th strong, td b, th b');
        for (const cell of titleCells) {
            const text = cell.textContent.toLowerCase();
            if (text.includes('historial') || text.includes('history')) {
                historyTable = table;
                console.log('✅ Tabla de historial encontrada por título');
                break;
            }
        }
        if (historyTable) break;
    }
    
    // Método alternativo: buscar por contenido
    if (!historyTable) {
        for (const table of allTables) {
            const text = table.textContent.toLowerCase();
            if ((text.includes('símbolo') || text.includes('symbol')) && 
                (text.includes('dirección') || text.includes('side')) &&
                (text.includes('cantidad') || text.includes('volume'))) {
                historyTable = table;
                console.log('✅ Tabla de historial encontrada por contenido');
                break;
            }
        }
    }
    
    if (!historyTable) {
        throw new Error('No se encontró la tabla de operaciones en el HTML');
    }
    
    console.log('🔍 Buscando operaciones en la tabla...');
    
    const allRows = historyTable.querySelectorAll('tr');
    console.log(`📊 Total filas: ${allRows.length}`);
    
    const operations = [];
    
    // Buscar filas que tengan exactamente 9 celdas (formato cTrader)
    const dataRows = Array.from(allRows).filter(row => {
        const cells = row.querySelectorAll('td');
        return cells.length === 9;
    });
    
    console.log(`✅ Filas con 9 celdas encontradas: ${dataRows.length}`);
    
    if (dataRows.length === 0) {
        throw new Error('No se encontraron filas de datos en la tabla');
    }
    
    // Debug: Mostrar primeras 3 filas para confirmar estructura
    for (let i = 0; i < Math.min(3, dataRows.length); i++) {
        const row = dataRows[i];
        const cells = row.querySelectorAll('td');
        const cellTexts = Array.from(cells).map(c => c.textContent.trim());
        console.log(`🔍 Fila ${i}:`, cellTexts.join(' | '));
    }
    
    for (const row of dataRows) {
        const cells = row.querySelectorAll('td');
        const cellTexts = Array.from(cells).map(c => c.textContent.trim());
        
        // Saltar fila de header (contiene "Símbolo")
        if (cellTexts.some(c => c.includes('Símbolo') || c.includes('Symbol'))) {
            continue;
        }
        
        // Columna 1: Símbolo (EURUSD, XAUUSD, etc.) - ¡columna 0 está vacía!
        const symbol = cellTexts[1];
        
        // Validar que sea un símbolo válido
        if (!symbol || symbol.length < 5 || !/^[A-Z0-9]+$/.test(symbol)) {
            continue;
        }
        
        // Columna 2: Dirección (Sell/Buy)
        const side = cellTexts[2];
        
        // Columna 3: Hora de cierre
        const closeTime = cellTexts[3];
        
        // Columna 4: Precio de entrada
        const entryPrice = parseFloat(cellTexts[4].replace(/,/g, ''));
        
        // Columna 5: Precio de cierre  
        const closePrice = parseFloat(cellTexts[5].replace(/,/g, ''));
        
        // Columna 6: Cantidad (Lotes)
        const volumeText = cellTexts[6].replace(/[^0-9.]/g, '');
        const volume = parseFloat(volumeText);
        
        // Columna 7: USD neto (P&L)
        const plText = cellTexts[7].replace(/,/g, '').replace(/\s/g, '');
        const pl = parseFloat(plText);
        
        // Parsear fecha: "12/11/2025 07:34:53.531"
        let date = '';
        let exitTime = '';
        if (closeTime && closeTime.includes('/')) {
            const parts = closeTime.split(' ');
            if (parts.length >= 2) {
                const dateParts = parts[0].split('/');
                if (dateParts.length === 3) {
                    date = `${dateParts[2]}-${dateParts[1].padStart(2,'0')}-${dateParts[0].padStart(2,'0')}`;
                }
                const timeParts = parts[1].split(':');
                if (timeParts.length >= 2) {
                    exitTime = `${timeParts[0].padStart(2,'0')}:${timeParts[1].padStart(2,'0')}`;
                }
            }
        }
        
        const type = side.toLowerCase().includes('buy') ? 'buy' : 'sell';
        
        operations.push({
            instrument: symbol,
            type: type,
            date: date,
            entryTime: exitTime,
            exitTime: exitTime,
            entry: entryPrice,
            exit: closePrice,
            volume: volume,
            pl: pl,
            currency: accountCurrency,
            commission: 0,
            notes: `Importado de cTrader - ${side}`
        });
        
        if (operations.length <= 2) {
            console.log(`✅ Op ${operations.length}:`, symbol, type, date, 'P&L:', pl);
        }
    }
    
    console.log(`✅ ${operations.length} operaciones parseadas`);
    
    if (operations.length === 0) {
        throw new Error('No se encontraron operaciones en el archivo');
    }
    
    // BUSCAR O CREAR CUENTA
    let ctraderAccount = null;
    
    // 1. Buscar por número de cuenta
    if (accountNumber) {
        ctraderAccount = DB.accounts.find(acc => acc.name.includes(accountNumber));
        if (ctraderAccount) {
            console.log(`✅ Cuenta encontrada por número: ${ctraderAccount.name}`);
        }
    }
    
    // 2. Buscar cualquier cuenta cTrader
    if (!ctraderAccount) {
        ctraderAccount = DB.accounts.find(acc => acc.platform === 'ctrader');
        if (ctraderAccount) {
            console.log(`✅ Cuenta cTrader encontrada: ${ctraderAccount.name}`);
        }
    }
    
    // 3. CREAR CUENTA SI NO EXISTE
    if (!ctraderAccount) {
        const accountName = accountNumber ? `cTrader ${accountNumber}` : 'cTrader Account';
        console.log(`⚠️ No existe cuenta. Creando: "${accountName}"`);
        
        ctraderAccount = {
            id: generateId(),
            name: accountName,
            balance: 0,
            currency: accountCurrency,
            platform: 'ctrader'
        };
        
        DB.accounts.push(ctraderAccount);
        await dexieDB.accounts.add(ctraderAccount);
        
        if (currentUser) {
            try {
                await saveAccountToSupabase(ctraderAccount);
            } catch (error) {
                console.warn('⚠️ No se pudo sincronizar cuenta:', error);
            }
        }
        
        console.log(`✅ Nueva cuenta creada: "${ctraderAccount.name}"`);
    }
    
    // IMPORTAR OPERACIONES
    let imported = 0;
    let duplicates = 0;
    
    for (const op of operations) {
        const isDuplicate = DB.operations.some(existing => 
            existing.instrument === op.instrument &&
            existing.date === op.date &&
            existing.exitTime === op.exitTime &&
            existing.pl === op.pl &&
            existing.accountId === ctraderAccount.id
        );
        
        if (isDuplicate) {
            duplicates++;
            continue;
        }
        
        const newOp = {
            id: generateId(),
            accountId: ctraderAccount.id,
            accountName: ctraderAccount.name,
            date: op.date,
            instrument: op.instrument,
            type: op.type,
            entry: op.entry,
            exit: op.exit,
            entryTime: op.entryTime,
            exitTime: op.exitTime,
            volume: op.volume,
            pl: op.pl,
            manualPL: op.pl,
            result: op.pl > 0 ? 'win' : (op.pl < 0 ? 'loss' : 'breakeven'),
            currency: op.currency,
            commission: op.commission,
            notes: op.notes,
            source: 'ctrader',
            importDate: new Date().toISOString()
        };

        // Calcular MAE/MFE estimados
        const maemfe = calculateEstimatedMAEMFE(newOp);
        newOp.mae = maemfe.mae;
        newOp.mfe = maemfe.mfe;

        DB.operations.push(newOp);
        await dexieDB.operations.add(newOp);
        
        if (currentUser) {
            try {
                await saveOperationToSupabase(newOp);
            } catch (error) {
                console.warn('⚠️ No se pudo sincronizar operación:', error);
            }
        }
        
        imported++;
    }
    
    console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
    console.log(`✅ IMPORTACIÓN COMPLETADA`);
    console.log(`   📊 Nuevas: ${imported}`);
    console.log(`   ⚠️  Duplicadas: ${duplicates}`);
    console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
    
    showSyncNotification(`✅ ${imported} operaciones importadas${duplicates > 0 ? `, ${duplicates} duplicadas omitidas` : ''}`, 'success');
    
    // Refrescar dashboard
    if (typeof refreshDashboard === 'function') {
        refreshDashboard();
    }
    if (typeof refreshOperationsTable === 'function') {
        refreshOperationsTable();
    }
}

function populateCTraderAccountSelect() {
    const accountSelect = document.getElementById('ctrader-account-select');
    if (!accountSelect) {
        console.log('⚠️ Select de cuentas cTrader no encontrado');
        return;
    }

    accountSelect.innerHTML = '<option value="">Seleccionar cuenta...</option>';

    DB.accounts.forEach(account => {
        const option = document.createElement('option');
        option.value = account.id;
        option.textContent = `${account.name} (${account.currency})`;
        accountSelect.appendChild(option);
    });

    // Si solo hay una cuenta, seleccionarla automáticamente
    if (DB.accounts.length === 1) {
        accountSelect.value = DB.accounts[0].id;
        console.log('✅ Cuenta cTrader seleccionada automáticamente:', DB.accounts[0].name, 'ID:', DB.accounts[0].id);
    } else if (DB.accounts.length > 1) {
        console.log('📋 Cuentas disponibles para cTrader:', DB.accounts.length);
        DB.accounts.forEach(acc => {
            console.log(`  - ${acc.name} (${acc.currency}) - ID: ${acc.id}`);
        });
    }

    console.log('✅ Cuentas cargadas en select de cTrader:', DB.accounts.length);
}

// Función para parsear HTML Statement de cTrader
function parseCTraderHTML(htmlContent) {
    console.log('🔍 Iniciando parseo de cTrader HTML Statement...');
    const parser = new DOMParser();
    const doc = parser.parseFromString(htmlContent, 'text/html');
    
    // Extraer información de la cuenta del header
    let accountNumber = '';
    let accountCurrency = 'USD';
    
    console.log('📋 Buscando información de cuenta...');
    // Buscar número de cuenta y divisa en todas las tablas
    const allTables = doc.querySelectorAll('table');
    for (const table of allTables) {
        const rows = table.querySelectorAll('tr');
        for (const row of rows) {
            const cells = row.querySelectorAll('td');
            if (cells.length >= 2) {
                const label = cells[0]?.textContent.trim() || '';
                const value = cells[1]?.textContent.trim() || '';
                
                if (label.toLowerCase().includes('cuenta') || label.toLowerCase().includes('account')) {
                    accountNumber = value;
                    console.log('✅ Número de cuenta detectado:', accountNumber);
                }
                if (label.toLowerCase().includes('divisa') || label.toLowerCase().includes('currency')) {
                    accountCurrency = value;
                    console.log('✅ Divisa detectada:', accountCurrency);
                }
            }
        }
    }
    
    console.log('🔍 Buscando tabla de operaciones...');
    // Buscar la tabla de Historial (History) - Búsqueda más flexible
    let historyTable = null;
    
    // Método 1: Buscar por clase dataTable
    const dataTables = doc.querySelectorAll('table.dataTable');
    for (const table of dataTables) {
        const titleCell = table.querySelector('td strong, th strong, td.title-style strong');
        if (titleCell) {
            const title = titleCell.textContent.toLowerCase();
            if (title.includes('historial') || title.includes('history') || title.includes('closed positions')) {
                historyTable = table;
                console.log('✅ Tabla de historial encontrada (método 1)');
                break;
            }
        }
    }
    
    // Método 2: Buscar por contenido de texto en headers
    if (!historyTable) {
        console.log('⚠️ Método 1 falló, intentando método 2...');
        for (const table of allTables) {
            const text = table.textContent.toLowerCase();
            // Buscar keywords que indican que es la tabla de operaciones
            if ((text.includes('símbolo') || text.includes('symbol')) && 
                (text.includes('dirección') || text.includes('side') || text.includes('buy') || text.includes('sell')) &&
                (text.includes('cantidad') || text.includes('volume') || text.includes('lotes'))) {
                historyTable = table;
                console.log('✅ Tabla de historial encontrada (método 2)');
                break;
            }
        }
    }
    
    if (!historyTable) {
        console.error('❌ No se encontró la tabla de Historial');
        throw new Error('No se encontró la tabla de operaciones en el archivo HTML. Asegúrate de exportar el HTML Statement desde cTrader.');
    }
    
    console.log('📊 Procesando filas de operaciones...');
    const operations = [];
    const rows = historyTable.querySelectorAll('tr');
    
    // Buscar la fila de encabezados de manera flexible
    let headerRowIndex = -1;
    let headerMap = {}; // Mapa de columnas: {symbol: 0, side: 1, ...}
    
    for (let i = 0; i < rows.length; i++) {
        const row = rows[i];
        const cells = row.querySelectorAll('td, th');
        
        // Verificar si esta fila contiene encabezados
        let hasHeaders = false;
        const cellsText = Array.from(cells).map(c => c.textContent.toLowerCase().trim());
        
        if (cellsText.some(t => t.includes('símbolo') || t.includes('symbol')) &&
            cellsText.some(t => t.includes('dirección') || t.includes('side'))) {
            headerRowIndex = i;
            hasHeaders = true;
            
            // Crear mapa de columnas
            cellsText.forEach((text, idx) => {
                if (text.includes('símbolo') || text.includes('symbol')) headerMap.symbol = idx;
                if (text.includes('dirección') || text.includes('side') || text.includes('tipo')) headerMap.side = idx;
                if (text.includes('hora de cierre') || text.includes('close time') || text.includes('fecha')) headerMap.closeTime = idx;
                if (text.includes('precio de entrada') || text.includes('entry price') || text.includes('open price')) headerMap.entryPrice = idx;
                if (text.includes('precio de cierre') || text.includes('close price') || text.includes('exit price')) headerMap.closePrice = idx;
                if (text.includes('cantidad') || text.includes('volume') || text.includes('lotes')) headerMap.volume = idx;
                if (text.includes('neto') || text.includes('p&l') || text.includes('profit') || text.includes('ganancia')) headerMap.pl = idx;
            });
            
            console.log('✅ Encabezados encontrados en fila', i);
            console.log('📋 Mapa de columnas:', headerMap);
            break;
        }
    }
    
    if (headerRowIndex === -1) {
        console.error('❌ No se encontraron encabezados');
        throw new Error('No se encontraron encabezados en la tabla de operaciones');
    }
    
    // Procesar filas de datos
    let processedCount = 0;
    for (let i = headerRowIndex + 1; i < rows.length; i++) {
        const row = rows[i];
        
        // Saltar filas de totales o resumen
        const rowText = row.textContent.toLowerCase();
        if (rowText.includes('total') || rowText.includes('suma') || 
            row.style.background === '#000' || row.style.background === 'rgb(0, 0, 0)' ||
            row.querySelector('.totals-title')) {
            console.log('⚠️ Fila de totales detectada, finalizando parseo');
            break;
        }
        
        const cells = row.querySelectorAll('td');
        if (cells.length < Math.max(...Object.values(headerMap))) {
            console.log(`⚠️ Fila ${i} ignorada (células insuficientes)`);
            continue;
        }
        
        // Extraer datos usando el mapa de columnas
        const symbolCell = cells[headerMap.symbol]?.textContent.trim() || '';
        const sideCell = cells[headerMap.side]?.textContent.trim() || '';
        const closeTimeCell = cells[headerMap.closeTime]?.textContent.trim() || '';
        const entryPriceCell = cells[headerMap.entryPrice]?.textContent.trim() || '0';
        const closePriceCell = cells[headerMap.closePrice]?.textContent.trim() || '0';
        const volumeCell = cells[headerMap.volume]?.textContent.trim() || '0';
        const plCell = cells[headerMap.pl]?.textContent.trim() || '0';
        
        // Validar que tenga datos mínimos
        if (!symbolCell || !closeTimeCell) {
            console.log(`⚠️ Fila ${i} ignorada (datos incompletos)`);
            continue;
        }
        
        // Parsear valores numéricos
        const entryPrice = parseFloat(entryPriceCell.replace(/[^0-9.-]/g, '')) || 0;
        const exitPrice = parseFloat(closePriceCell.replace(/[^0-9.-]/g, '')) || 0;
        const volume = parseFloat(volumeCell.replace(/[^0-9.-]/g, '')) || 0;
        const pl = parseFloat(plCell.replace(/[^0-9.-]/g, '')) || 0;
        
        // Parsear fecha y hora - Soportar múltiples formatos
        let date = '';
        let exitTime = '';
        
        // Formato 1: "12/11/2025 07:34:53.531"
        // Formato 2: "2025-11-12 07:34:53"
        // Formato 3: "12-Nov-2025 07:34"
        const dateTimeParts = closeTimeCell.split(' ');
        if (dateTimeParts.length >= 2) {
            const datePart = dateTimeParts[0];
            const timePart = dateTimeParts[1];
            
            // Intentar parsear fecha
            if (datePart.includes('/')) {
                // Formato DD/MM/YYYY
                const pieces = datePart.split('/');
                if (pieces.length === 3) {
                    const [day, month, year] = pieces;
                    date = `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
                }
            } else if (datePart.includes('-')) {
                const pieces = datePart.split('-');
                if (pieces.length === 3 && pieces[0].length === 4) {
                    // Ya está en formato YYYY-MM-DD
                    date = datePart;
                } else if (pieces.length === 3) {
                    // Formato DD-MM-YYYY
                    const [day, month, year] = pieces;
                    if (month.match(/[a-z]/i)) {
                        // Mes en texto, convertir
                        const monthMap = {jan:1,feb:2,mar:3,apr:4,may:5,jun:6,jul:7,aug:8,sep:9,oct:10,nov:11,dec:12,ene:1,abr:4,ago:8,dic:12};
                        const monthNum = monthMap[month.toLowerCase().slice(0,3)] || month;
                        date = `${year}-${String(monthNum).padStart(2,'0')}-${day.padStart(2,'0')}`;
                    } else {
                        date = `${year}-${month.padStart(2,'0')}-${day.padStart(2,'0')}`;
                    }
                }
            }
            
            // Parsear hora HH:MM
            const timePieces = timePart.split(':');
            if (timePieces.length >= 2) {
                exitTime = `${timePieces[0].padStart(2,'0')}:${timePieces[1].padStart(2,'0')}`;
            }
        }
        
        // Determinar tipo (buy/sell)
        const sideLower = sideCell.toLowerCase();
        const type = sideLower.includes('buy') || sideLower.includes('comprar') || sideLower.includes('long') ? 'buy' : 'sell';
        
        const operation = {
            instrument: symbolCell,
            type: type,
            date: date,
            entryTime: exitTime,
            exitTime: exitTime,
            entry: entryPrice,
            exit: exitPrice,
            volume: volume,
            pl: pl,
            currency: accountCurrency,
            commission: 0,
            notes: `Importado de cTrader - ${sideCell}`
        };
        
        operations.push(operation);
        processedCount++;
        
        if (processedCount <= 3) {
            console.log(`✅ Operación ${processedCount} procesada:`, {
                symbol: symbolCell,
                type,
                date,
                pl
            });
        }
    }
    
    console.log(`✅ Parseo completado: ${operations.length} operaciones extraídas`);
    
    if (operations.length === 0) {
        throw new Error('No se encontraron operaciones en el archivo HTML. Verifica que el archivo contenga operaciones cerradas.');
    }
    
    return {
        operations: operations,
        accountInfo: {
            number: accountNumber,
            currency: accountCurrency
        }
    };
}

// Event listener para importar CSV/HTML de cTrader
// Variables globales para cTrader
let ctraderPendingOperations = [];
let ctraderSelectedAccountId = '';

function showCTraderPreview(operations, accountId) {
    console.log('👁️ Mostrando vista previa de cTrader');
    console.log('📊 Operaciones a previsualizar:', operations.length);
    console.log('👤 Account ID recibido:', accountId);
    
    // Verificar que la cuenta existe
    const account = DB.accounts.find(acc => acc.id === accountId);
    if (!account) {
        console.error('❌ Cuenta no encontrada en DB.accounts:', accountId);
        console.log('📋 Cuentas disponibles:');
        DB.accounts.forEach(acc => {
            console.log(`  - ${acc.name} (${acc.id})`);
        });
        showSyncNotification('❌ Cuenta no encontrada. Por favor selecciona una cuenta válida.', 'error');
        return;
    }
    
    console.log('✅ Cuenta encontrada:', account.name, '(', account.currency, ')');
    
    ctraderPendingOperations = operations;
    ctraderSelectedAccountId = accountId;
    
    console.log('💾 Variables globales actualizadas:');
    console.log('  - ctraderPendingOperations:', ctraderPendingOperations.length, 'ops');
    console.log('  - ctraderSelectedAccountId:', ctraderSelectedAccountId);
    
    const previewContainer = document.getElementById('ctrader-preview-container');
    const tbody = document.getElementById('ctrader-preview-tbody');
    const countEl = document.getElementById('ctrader-preview-count');
    
    if (!previewContainer || !tbody || !countEl) {
        console.error('❌ Elementos de vista previa no encontrados');
        return;
    }
    
    tbody.innerHTML = '';
    
    operations.forEach(op => {
        const row = document.createElement('tr');
        row.className = 'border-b border-border';
        
        const plClass = op.pl >= 0 ? 'text-positive' : 'text-negative';
        
        row.innerHTML = `
            <td class="px-3 py-2">${op.instrument}</td>
            <td class="px-3 py-2">${op.type === 'buy' ? 'Long' : 'Short'}</td>
            <td class="px-3 py-2">${op.date}</td>
            <td class="px-3 py-2 text-right">${op.entry.toFixed(5)}</td>
            <td class="px-3 py-2 text-right">${op.exit.toFixed(5)}</td>
            <td class="px-3 py-2 text-right">${op.volume.toFixed(2)}</td>
            <td class="px-3 py-2 text-right ${plClass}">${op.pl >= 0 ? '+' : ''}${op.pl.toFixed(2)}</td>
        `;
        
        tbody.appendChild(row);
    });
    
    countEl.textContent = operations.length;
    previewContainer.style.display = 'block';
    
    console.log('✅ Vista previa renderizada exitosamente');
    showSyncNotification(`✅ ${operations.length} operaciones detectadas. Revisa la vista previa.`, 'success');
}

function confirmCTraderImport() {
    console.log('🔄 Iniciando confirmación de importación cTrader...');
    console.log('📊 Operaciones pendientes:', ctraderPendingOperations.length);
    console.log('👤 Cuenta seleccionada:', ctraderSelectedAccountId);
    
    if (ctraderPendingOperations.length === 0) {
        showSyncNotification('⚠️ No hay operaciones para importar', 'warning');
        return;
    }
    
    const account = DB.accounts.find(acc => acc.id === ctraderSelectedAccountId);
    if (!account) {
        console.error('❌ Cuenta no encontrada:', ctraderSelectedAccountId);
        showSyncNotification('❌ Cuenta no encontrada', 'error');
        return;
    }
    
    console.log('✅ Cuenta encontrada:', account.name);
    
    let imported = 0;
    let duplicates = 0;
    
    ctraderPendingOperations.forEach((op, index) => {
        console.log(`📝 Procesando operación ${index + 1}/${ctraderPendingOperations.length}:`, op.instrument);
        
        // Verificar duplicados (mismo instrumento, fecha, hora y P&L)
        const isDuplicate = DB.operations.some(existing => 
            existing.instrument === op.instrument &&
            existing.date === op.date &&
            existing.exitTime === op.exitTime &&
            existing.pl === op.pl &&
            existing.accountId === ctraderSelectedAccountId
        );
        
        if (isDuplicate) {
            console.log(`⚠️ Operación duplicada detectada: ${op.instrument} ${op.date}`);
            duplicates++;
            return;
        }
        
        // Crear operación
        const newOperation = {
            id: generateId(),
            accountId: ctraderSelectedAccountId,
            accountName: account.name,
            date: op.date,
            instrument: op.instrument,
            type: op.type,
            entry: op.entry,
            exit: op.exit,
            entryTime: op.entryTime,
            exitTime: op.exitTime,
            volume: op.volume,
            pl: op.pl,
            manualPL: op.pl,
            result: op.pl > 0 ? 'win' : (op.pl < 0 ? 'loss' : 'breakeven'),
            currency: op.currency || account.currency,
            commission: op.commission || 0,
            notes: op.notes || '',
            source: 'ctrader',
            importDate: new Date().toISOString()
        };

        // Calcular MAE/MFE estimados
        const maemfe = calculateEstimatedMAEMFE(newOperation);
        newOperation.mae = maemfe.mae;
        newOperation.mfe = maemfe.mfe;

        console.log('✅ Creando nueva operación:', newOperation.id, newOperation.instrument);
        DB.operations.push(newOperation);
        imported++;
    });
    
    console.log('💾 Guardando base de datos...');
    console.log('📊 Total operaciones en DB antes de guardar:', DB.operations.length);
    saveDB();
    console.log('✅ Base de datos guardada');
    
    // Actualizar historial de importaciones
    updateCTraderImportHistory(imported, duplicates);
    
    // Limpiar vista previa
    const previewContainer = document.getElementById('ctrader-preview-container');
    if (previewContainer) {
        previewContainer.style.display = 'none';
    }
    
    const fileInput = document.getElementById('ctrader-csv-file-input');
    if (fileInput) {
        fileInput.value = '';
    }
    
    ctraderPendingOperations = [];
    
    console.log(`✅ Importación completada: ${imported} nuevas, ${duplicates} duplicadas`);
    showSyncNotification(`✅ Importación completada: ${imported} operaciones nuevas${duplicates > 0 ? `, ${duplicates} duplicadas omitidas` : ''}`, 'success');
    
    // Refrescar la vista de operaciones
    console.log('🔄 Refrescando vista de operaciones...');
    if (typeof refreshOperationsTable === 'function') {
        refreshOperationsTable();
    }
    
    // Refrescar dashboard si está activo
    if (document.getElementById('dashboard')?.classList.contains('active')) {
        console.log('🔄 Refrescando dashboard...');
        refreshDashboard();
    }
}

function updateCTraderImportHistory(imported, duplicates) {
    const historyContainer = document.getElementById('ctrader-import-history');
    if (!historyContainer) return;
    
    const now = new Date();
    const dateStr = now.toLocaleDateString('es-ES');
    const timeStr = now.toLocaleTimeString('es-ES');
    
    const historyItem = document.createElement('div');
    historyItem.className = 'p-3 bg-surface-light rounded border border-border';
    historyItem.innerHTML = `
        <div class="flex justify-between items-center">
            <div>
                <p class="font-semibold text-sm">
                    <i class="fas fa-file-import mr-2 text-primary"></i>
                    Importación cTrader
                </p>
                <p class="text-xs text-text-secondary mt-1">${dateStr} ${timeStr}</p>
            </div>
            <div class="text-right">
                <p class="text-sm">
                    <span class="text-success font-semibold">${imported}</span> nuevas
                </p>
                ${duplicates > 0 ? `<p class="text-xs text-text-secondary">${duplicates} duplicadas</p>` : ''}
            </div>
        </div>
    `;
    
    // Remover mensaje de "no hay importaciones"
    const emptyMsg = historyContainer.querySelector('p.text-text-secondary');
    if (emptyMsg) {
        emptyMsg.remove();
    }
    
    // Agregar al inicio
    historyContainer.insertBefore(historyItem, historyContainer.firstChild);
    
    // Mantener solo las últimas 10 importaciones
    while (historyContainer.children.length > 10) {
        historyContainer.removeChild(historyContainer.lastChild);
    }
}

// ============================================
// FUNCIONES PARA METATRADER 5
// ============================================

function importMT5HTMLReport() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.html,.htm';
    input.style.display = 'none';

    input.onchange = function(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = async function(e) {
            try {
                const html = e.target.result;
                await parseMT5HTMLReport(html);
            } catch (error) {
                console.error('Error procesando informe MT5:', error);
                showSyncNotification('❌ Error procesando informe HTML de MT5', 'error');
            }
        };
        reader.readAsText(file);
    };

    document.body.appendChild(input);
    input.click();
    document.body.removeChild(input);
}

async function parseMT5HTMLReport(htmlContent) {
    console.log('📄 Procesando informe HTML de MetaTrader 5...');

    try {
        // Parsear HTML
        const parser = new DOMParser();
        const doc = parser.parseFromString(htmlContent, 'text/html');

        // ========================================
        // EXTRAER INFORMACIÓN COMPLETA DE LA CUENTA
        // ========================================
        let accountInfo = {
            name: null,
            number: null,
            broker: null,
            currency: 'USD',
            accountType: 'demo', // demo o real
            platform: 'meta-trader-5',
            initialBalance: 0,
            currentBalance: 0
        };

        // Buscar todas las filas de información de la cuenta
        const infoRows = doc.querySelectorAll('tr');
        
        for (const row of infoRows) {
            const cells = row.querySelectorAll('th, td');
            if (cells.length >= 2) {
                const label = cells[0]?.textContent.trim().toLowerCase() || '';
                const value = cells[1]?.textContent.trim() || '';
                
                // Extraer Nombre
                if (label.includes('nombre') || label.includes('name')) {
                    const nameElement = cells[1].querySelector('b');
                    if (nameElement) {
                        accountInfo.name = nameElement.textContent.trim();
                    }
                }
                
                // Extraer Cuenta (número, divisa, broker, tipo)
                // Ejemplo: "721626 (USD, BlackBullMarkets-Demo, demo, Hedge)"
                if (label.includes('cuenta') || label.includes('account')) {
                    const accountElement = cells[1].querySelector('b');
                    if (accountElement) {
                        const accountText = accountElement.textContent.trim();
                        
                        // Extraer número de cuenta
                        const numberMatch = accountText.match(/^(\d+)/);
                        if (numberMatch) {
                            accountInfo.number = numberMatch[1];
                        }
                        
                        // Extraer divisa
                        const currencyMatch = accountText.match(/\((USD|EUR|GBP|USDT|AUD|CAD|JPY|CHF)/i);
                        if (currencyMatch) {
                            accountInfo.currency = currencyMatch[1].toUpperCase();
                        }
                        
                        // Extraer broker
                        const brokerMatch = accountText.match(/,\s*([^,]+?)(?:-Demo|-Real|-Live)?(?:,|$)/);
                        if (brokerMatch) {
                            accountInfo.broker = brokerMatch[1].trim();
                        }
                        
                        // Determinar tipo de cuenta (demo o real)
                        if (accountText.toLowerCase().includes('demo') || accountText.toLowerCase().includes('demostración')) {
                            accountInfo.accountType = 'demo';
                        } else if (accountText.toLowerCase().includes('real') || accountText.toLowerCase().includes('live')) {
                            accountInfo.accountType = 'real';
                        }
                    }
                }
                
                // Extraer Empresa/Broker
                if ((label.includes('empresa') || label.includes('company') || label.includes('broker')) && !accountInfo.broker) {
                    const brokerElement = cells[1].querySelector('b');
                    if (brokerElement) {
                        accountInfo.broker = brokerElement.textContent.trim();
                    }
                }
                
                // Extraer Balance Inicial (Depósito/Withdrawal o Initial Deposit)
                if (label.includes('depósito inicial') || label.includes('initial deposit') || label.includes('balance inicial')) {
                    const balanceText = value.replace(/[^0-9.-]/g, '');
                    const balance = parseFloat(balanceText);
                    if (!isNaN(balance) && balance > 0) {
                        accountInfo.initialBalance = balance;
                    }
                }
                
                // Extraer Balance Actual/Final
                if (label.includes('balance') || label.includes('patrimonio') || label.includes('equity')) {
                    const balanceText = value.replace(/[^0-9.-]/g, '');
                    const balance = parseFloat(balanceText);
                    if (!isNaN(balance)) {
                        accountInfo.currentBalance = balance;
                    }
                }
            }
        }

        // Si no se encontró nombre, usar valor por defecto
        if (!accountInfo.name) {
            const accountNameElement = doc.querySelector('th b');
            accountInfo.name = accountNameElement ? accountNameElement.textContent.trim() : 'MT5 Account';
        }

        // Determinar plataforma según el título
        const titleElement = doc.querySelector('title');
        const title = titleElement ? titleElement.textContent.toLowerCase() : '';
        if (title.includes('metatrader 4') || title.includes('mt4')) {
            accountInfo.platform = 'meta-trader-4';
        } else if (title.includes('metatrader 5') || title.includes('mt5')) {
            accountInfo.platform = 'meta-trader-5';
        }

        console.log('📊 Información de cuenta extraída:');
        console.log(`   👤 Nombre: ${accountInfo.name}`);
        console.log(`   🔢 Número: ${accountInfo.number}`);
        console.log(`   🏢 Broker: ${accountInfo.broker}`);
        console.log(`   💱 Divisa: ${accountInfo.currency}`);
        console.log(`   📋 Tipo: ${accountInfo.accountType}`);
        console.log(`   🖥️ Plataforma: ${accountInfo.platform}`);

        // Buscar la tabla de Posiciones o Órdenes (closed trades)
        let positionsTable = null;
        let tableType = null; // 'positions' o 'orders'
        const tables = doc.querySelectorAll('table');

        console.log(`🔍 Buscando tablas en el informe... Total tablas encontradas: ${tables.length}`);

        for (const table of tables) {
            // Buscar por el header específico de la tabla de Posiciones u Órdenes
            const headers = table.querySelectorAll('th');
            
            for (const header of headers) {
                const text = header.textContent.trim();
                console.log(`📋 Header encontrado: "${text}"`);
                
                // Buscar tabla de Posiciones (closed positions)
                if (text === 'Posiciones' || text === 'Positions' || text === 'Closed Positions') {
                    const dataRows = table.querySelectorAll('tr[bgcolor]');
                    if (dataRows.length > 0) {
                        positionsTable = table;
                        tableType = 'positions';
                        console.log('✅ Tabla de Posiciones encontrada con', dataRows.length, 'filas');
                        break;
                    }
                }
                
                // Buscar tabla de Órdenes (orders history)
                if (text === 'Órdenes' || text === 'Orders' || text === 'Order History' || text === 'Historial de órdenes') {
                    const dataRows = table.querySelectorAll('tr[bgcolor]');
                    if (dataRows.length > 0) {
                        positionsTable = table;
                        tableType = 'orders';
                        console.log('✅ Tabla de Órdenes encontrada con', dataRows.length, 'filas');
                        break;
                    }
                }
            }
            
            if (positionsTable) break;
        }

        if (!positionsTable) {
            console.error('❌ No se encontró tabla de Posiciones ni Órdenes');
            showSyncNotification('❌ No se encontró la tabla de Posiciones u Órdenes en el informe', 'error');
            return;
        }
        
        console.log(`📊 Procesando tabla de tipo: ${tableType}`);

        // Extraer filas de datos (las que tienen bgcolor - son las operaciones)
        const rows = positionsTable.querySelectorAll('tr[bgcolor]');
        console.log(`📊 Encontradas ${rows.length} filas en la tabla`);

        if (rows.length === 0) {
            showSyncNotification('ℹ️ El informe no contiene datos', 'info');
            return;
        }

        const newOperations = [];
        let skippedCount = 0;
        
        // Debug: Mostrar headers de la tabla
        const headers = positionsTable.querySelectorAll('th');
        console.log(`📋 Headers de la tabla (${headers.length}):`, 
            Array.from(headers).map((h, i) => `[${i}]="${h.textContent.trim()}"`).join(' | '));

        console.log(`🔍 Cuentas disponibles (${DB.accounts.length}):`, DB.accounts.map(a => ({
            name: a.name, 
            platform: a.platform,
            number: a.accountNumber || 'sin número',
            broker: a.broker || 'sin broker'
        })));
        
        // ========================================
        // BUSCAR O CREAR CUENTA AUTOMÁTICAMENTE
        // ========================================
        let mt5Account = null;
        let accountCreated = false;
        
        console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
        console.log('🔍 BUSCANDO CUENTA EXISTENTE...');
        console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
        
        // 1. Buscar por número de cuenta (más específico)
        if (accountInfo.number) {
            console.log(`📌 Buscando por número de cuenta: ${accountInfo.number}`);
            mt5Account = DB.accounts.find(acc => 
                // Buscar en el campo accountNumber
                (acc.accountNumber && acc.accountNumber === accountInfo.number) ||
                // Buscar en el nombre de la cuenta
                (acc.name && acc.name.includes(accountInfo.number))
            );
            if (mt5Account) {
                console.log(`✅ ENCONTRADA por número ${accountInfo.number}`);
                console.log(`   📝 Cuenta: "${mt5Account.name}" (ID: ${mt5Account.id})`);
            } else {
                console.log(`   ❌ No encontrada por número`);
            }
        }
        
        // 2. Si no encontró, buscar por broker + número (muy preciso)
        if (!mt5Account && accountInfo.broker && accountInfo.number) {
            console.log(`📌 Buscando por broker + número: ${accountInfo.broker} #${accountInfo.number}`);
            mt5Account = DB.accounts.find(acc => {
                const hasBroker = acc.broker && acc.broker.toLowerCase() === accountInfo.broker.toLowerCase();
                const hasNumber = (acc.accountNumber === accountInfo.number) || (acc.name && acc.name.includes(accountInfo.number));
                return hasBroker && hasNumber;
            });
            if (mt5Account) {
                console.log(`✅ ENCONTRADA por broker + número`);
                console.log(`   📝 Cuenta: "${mt5Account.name}" (ID: ${mt5Account.id})`);
            } else {
                console.log(`   ❌ No encontrada por broker + número`);
            }
        }
        
        // 3. Buscar por nombre que contenga el broker y número
        if (!mt5Account && accountInfo.broker && accountInfo.number) {
            console.log(`📌 Buscando por nombre similar: *${accountInfo.broker}*${accountInfo.number}*`);
            const brokerLower = accountInfo.broker.toLowerCase();
            mt5Account = DB.accounts.find(acc => {
                const nameLower = acc.name.toLowerCase();
                return nameLower.includes(brokerLower) && nameLower.includes(accountInfo.number);
            });
            if (mt5Account) {
                console.log(`✅ ENCONTRADA por nombre similar`);
                console.log(`   📝 Cuenta: "${mt5Account.name}" (ID: ${mt5Account.id})`);
            } else {
                console.log(`   ❌ No encontrada por nombre similar`);
            }
        }
        
        // 4. Si NO existe la cuenta, crear automáticamente con toda la información
        if (!mt5Account) {
            console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
            console.log('🆕 CREANDO CUENTA AUTOMÁTICAMENTE');
            console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
            
            // Construir nombre descriptivo de la cuenta
            let accountName = '';
            if (accountInfo.number && accountInfo.broker) {
                accountName = `${accountInfo.broker} #${accountInfo.number} (${accountInfo.accountType.toUpperCase()})`;
            } else if (accountInfo.number) {
                accountName = `MT5 #${accountInfo.number} (${accountInfo.accountType.toUpperCase()})`;
            } else if (accountInfo.name) {
                accountName = accountInfo.name;
            } else {
                accountName = `${accountInfo.broker || 'MT5'} ${accountInfo.accountType.toUpperCase()}`;
            }
            
            // Determinar balance inicial - usar del reporte o calcular desde el balance actual
            let initialBalance;
            let currentBalance = accountInfo.currentBalance;
            
            // Si tenemos balance actual pero no inicial, calcular el inicial desde las operaciones
            if (currentBalance && !accountInfo.initialBalance) {
                // Calcular P/L total de las operaciones que vamos a importar
                const totalPL = parsedOps.reduce((sum, op) => sum + (op.pl || 0), 0);
                initialBalance = currentBalance - totalPL; // Balance inicial = balance actual - ganancias/pérdidas
                console.log(`💡 Balance inicial calculado: ${initialBalance} = ${currentBalance} (actual) - ${totalPL} (P/L)`);
            } else {
                // Si no hay balance actual ni inicial, usar el balance actual o un default
                initialBalance = accountInfo.initialBalance || currentBalance || 10000;
            }
            
            mt5Account = {
                id: generateId(),
                name: accountName,
                initialBalance: initialBalance,
                balance: currentBalance || initialBalance,
                currency: accountInfo.currency,
                platform: accountInfo.platform,
                accountNumber: accountInfo.number,
                broker: accountInfo.broker
            };
            
            console.log(`📝 Cuenta a crear:`, mt5Account);
            
            DB.accounts.push(mt5Account);
            await dexieDB.accounts.add(mt5Account);
            accountCreated = true;
            
            // Sincronizar con Supabase si hay usuario
            if (currentUser) {
                try {
                    await saveAccountToSupabase(mt5Account);
                    console.log('✅ Cuenta sincronizada con Supabase');
                } catch (error) {
                    console.warn('⚠️ No se pudo sincronizar cuenta con Supabase:', error);
                }
            }
            
            console.log(`✅ Nueva cuenta creada: "${mt5Account.name}"`);
            console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
        }
        
        // ========================================
        // MENSAJE AL USUARIO
        // ========================================
        console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
        console.log(`✅ CUENTA ${accountCreated ? 'CREADA' : 'ENCONTRADA'}: "${mt5Account.name}"`);
        console.log(`   🆔 ID: ${mt5Account.id}`);
        console.log(`   💱 Divisa: ${mt5Account.currency}`);
        console.log(`   🏢 Broker: ${mt5Account.broker || 'No especificado'}`);
        console.log(`   🔢 Número: ${mt5Account.accountNumber || 'No especificado'}`);
        console.log(`   🖥️ Plataforma: ${mt5Account.platform}`);
        console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
        
        // Mostrar notificación según el caso
        if (accountCreated) {
            const brokerInfo = accountInfo.broker ? ` - ${accountInfo.broker}` : '';
            showSyncNotification(
                `🆕 Cuenta creada: ${mt5Account.name}${brokerInfo}`, 
                'success'
            );
        } else {
            showSyncNotification(
                `✅ Importando a: ${mt5Account.name}`, 
                'info'
            );
        }

        // Procesar según tipo de tabla
        if (tableType === 'orders') {
            // PROCESAMIENTO DE TABLA DE ÓRDENES (Orders History)
            console.log('📋 Procesando tabla de Órdenes...');
            console.log(`📊 Total de filas a procesar: ${rows.length}`);
            
            // En tabla de órdenes, necesitamos agrupar pares buy/sell
            const ordersBySymbol = {};
            let processedRows = 0;
            
            for (const row of rows) {
                processedRows++;
                try {
                    const cells = row.querySelectorAll('td');
                    
                    // Debug: mostrar primeras 3 filas completas
                    if (processedRows <= 3) {
                        console.log(`🔍 Fila ${processedRows} - ${cells.length} celdas:`, 
                            Array.from(cells).map((c, i) => `[${i}]="${c.textContent.trim()}"`).join(' | '));
                    }
                    
                    if (cells.length < 9) {
                        console.log(`⏭️ Fila ${processedRows}: solo ${cells.length} celdas, omitiendo`);
                        skippedCount++;
                        continue;
                    }
                    
                    const openDateTime = cells[0].textContent.trim();
                    const orderId = cells[1].textContent.trim();
                    const symbol = cells[2].textContent.trim();
                    const typeRaw = cells[3].textContent.trim().toLowerCase();
                    const volumeRaw = cells[4].textContent.trim();
                    const priceRaw = cells[5].textContent.trim();
                    
                    // Buscar el estado en las columnas 9, 10, 11
                    let stateRaw = '';
                    let stateColumnIndex = -1;
                    for (let i = 9; i <= Math.min(cells.length - 1, 11); i++) {
                        const cellText = cells[i]?.textContent.trim().toLowerCase() || '';
                        if (cellText.includes('filled') || cellText.includes('ejecutado') || cellText.includes('completado')) {
                            stateRaw = cellText;
                            stateColumnIndex = i;
                            break;
                        }
                    }
                    
                    // Debug: mostrar estado encontrado en primeras 3 filas
                    if (processedRows <= 3) {
                        console.log(`   Estado en columna ${stateColumnIndex}: "${stateRaw}"`);
                    }
                    
                    // Solo procesar órdenes filled (ejecutadas)
                    if (!stateRaw.includes('filled') && !stateRaw.includes('ejecutado') && !stateRaw.includes('completado')) {
                        if (processedRows <= 10) {
                            console.log(`⏭️ Fila ${processedRows} - Orden ${orderId}: estado no es "filled": col[9]="${cells[9]?.textContent.trim()}" col[10]="${cells[10]?.textContent.trim() || 'N/A'}"`);
                        }
                        skippedCount++;
                        continue;
                    }
                    
                    // Detectar tipo de operación (buy o sell)
                    if (!typeRaw.includes('buy') && !typeRaw.includes('sell') && !typeRaw.includes('compra') && !typeRaw.includes('venta')) {
                        console.log(`⏭️ Tipo de orden no válido: "${typeRaw}"`);
                        skippedCount++;
                        continue;
                    }
                    
                    const type = (typeRaw.includes('buy') || typeRaw.includes('compra')) ? 'buy' : 'sell';
                    
                    // Parsear volumen y precio
                    const volume = parseFloat(volumeRaw.split('/')[0].trim().replace(',', '.')) || 0;
                    let price = parseFloat(priceRaw.replace(/\s/g, '').replace(',', '.')) || 0;
                    
                    // Si el precio es 0 o inválido, buscar en columnas siguientes
                    if (price === 0 || priceRaw.toLowerCase().includes('market')) {
                        // Para órdenes market, el precio puede estar en otra columna
                        for (let i = 5; i < 9; i++) {
                            const testPrice = parseFloat(cells[i]?.textContent.replace(/\s/g, '').replace(',', '.')) || 0;
                            if (testPrice > 0 && testPrice < 1000000) {
                                price = testPrice;
                                break;
                            }
                        }
                    }
                    
                    // Validar que tengamos datos mínimos
                    if (!symbol || volume === 0 || price === 0) {
                        console.log(`⏭️ Datos incompletos: symbol="${symbol}", vol=${volume}, price=${price}`);
                        skippedCount++;
                        continue;
                    }
                    
                    // Parsear fecha
                    const [dateStr, timeStr] = openDateTime.split(' ');
                    const operationDate = dateStr.replace(/\./g, '-');
                    
                    console.log(`✅ Orden ${orderId}: ${symbol} ${type} ${volume} @ ${price} | ${operationDate} ${timeStr || 'sin hora'}`);
                    
                    // Agrupar por símbolo para emparejar
                    if (!ordersBySymbol[symbol]) {
                        ordersBySymbol[symbol] = [];
                    }
                    
                    ordersBySymbol[symbol].push({
                        orderId,
                        type,
                        volume,
                        price,
                        date: operationDate,
                        time: timeStr,
                        datetime: openDateTime
                    });
                    
                } catch (error) {
                    console.error(`Error procesando fila ${processedRows}:`, error);
                    skippedCount++;
                }
            }
            
            console.log(`📊 Resumen de procesamiento: ${processedRows} filas procesadas, ${Object.keys(ordersBySymbol).length} símbolos encontrados`);
            
            // Ahora emparejar órdenes para crear operaciones completas
            for (const symbol in ordersBySymbol) {
                const orders = ordersBySymbol[symbol].sort((a, b) => {
                    // Ordenar por fecha/hora
                    return a.datetime.localeCompare(b.datetime);
                });
                
                const buys = orders.filter(o => o.type === 'buy');
                const sells = orders.filter(o => o.type === 'sell');
                
                console.log(`🔄 ${symbol}: ${buys.length} compras, ${sells.length} ventas`);
                
                // Emparejar FIFO (First In First Out)
                const minPairs = Math.min(buys.length, sells.length);
                
                if (minPairs === 0) {
                    console.warn(`⚠️ ${symbol}: No se pueden emparejar (${buys.length} buys, ${sells.length} sells)`);
                    skippedCount += orders.length;
                    continue;
                }
                
                for (let i = 0; i < minPairs; i++) {
                    const buyOrder = buys[i];
                    const sellOrder = sells[i];
                    
                    // Usar la fecha de cierre (sell) como fecha de operación
                    const closeDate = sellOrder.date;
                    
                    // Calcular P&L basado en la dirección
                    // Si abrimos con BUY y cerramos con SELL = operación LONG
                    let profit = (sellOrder.price - buyOrder.price) * buyOrder.volume;
                    
                    // Redondear a 2 decimales
                    profit = Math.round(profit * 100) / 100;
                    
                    // Determinar resultado
                    let result;
                    if (profit > 0.01) result = 'win';
                    else if (profit < -0.01) result = 'loss';
                    else result = 'breakeven';
                    
                    const operation = {
                        id: `mt5_${buyOrder.orderId}_${sellOrder.orderId}`,
                        date: closeDate,
                        accountId: mt5Account.id,
                        instrument: symbol,
                        type: 'buy', // La dirección de la operación (LONG)
                        entry: buyOrder.price,
                        exit: sellOrder.price,
                        entryTime: buyOrder.time || null,
                        exitTime: sellOrder.time || null,
                        volume: buyOrder.volume,
                        result: result,
                        pl: profit,
                        currency: mt5Account.currency,
                        notes: `Importado de MT5 - Órdenes #${buyOrder.orderId}/#${sellOrder.orderId}`,
                        imageDatas: [],
                        fees: 0,
                        manualPL: profit,
                        session: detectTradingSession(entryTime) || ''
                    };

                    // Calcular MAE/MFE estimados
                    const maemfe = calculateEstimatedMAEMFE(operation);
                    operation.mae = maemfe.mae;
                    operation.mfe = maemfe.mfe;

                    // Verificar duplicados
                    if (DB.operations.some(op => op.id === operation.id)) {
                        console.log(`⏭️ Operación ${operation.id} ya existe`);
                        skippedCount++;
                        continue;
                    }

                    console.log(`✅ Operación ${symbol}: BUY@${buyOrder.price} → SELL@${sellOrder.price} = $${profit.toFixed(2)}`);
                    newOperations.push(operation);
                }
                
                // Reportar órdenes no emparejadas
                const unpaired = orders.length - (minPairs * 2);
                if (unpaired > 0) {
                    console.warn(`⚠️ ${symbol}: ${unpaired} órdenes sin emparejar`);
                    skippedCount += unpaired;
                }
            }
            
        } else {
            // PROCESAMIENTO DE TABLA DE POSICIONES (Closed Positions)
            console.log('📋 Procesando tabla de Posiciones...');
            
            for (const row of rows) {
                try {
                    const allCells = row.querySelectorAll('td');
                    const cells = Array.from(allCells).filter(cell => {
                        return !cell.classList.contains('hidden') && !cell.hasAttribute('class') || cell.className !== 'hidden';
                    });

                    console.log(`🔍 Fila con ${allCells.length} celdas totales, ${cells.length} visibles`);

                    if (cells.length < 12) {
                        console.warn(`⚠️ Fila con solo ${cells.length} celdas visibles, omitiendo`);
                        skippedCount++;
                        continue;
                    }

                    const openDateTime = cells[0].textContent.trim();
                    const positionId = cells[1].textContent.trim();
                    const symbol = cells[2].textContent.trim();
                    const type = cells[3].textContent.trim().toLowerCase();

                    console.log(`📝 Pos#${positionId}: ${symbol} ${type}`);

                    if (!symbol || symbol === '' || !type || type === '') {
                        console.log(`⏭️ Omitiendo fila sin símbolo o tipo`);
                        skippedCount++;
                        continue;
                    }

                    if (type !== 'buy' && type !== 'sell') {
                        console.log(`⏭️ Omitiendo operación tipo "${type}"`);
                        skippedCount++;
                        continue;
                    }

                    const volume = parseFloat(cells[4].textContent.replace(/\s/g, '').replace(',', '.')) || 0;
                    const entryPrice = parseFloat(cells[5].textContent.replace(/\s/g, '').replace(',', '.')) || 0;
                    const exitPrice = parseFloat(cells[9].textContent.replace(/\s/g, '').replace(',', '.')) || 0;
                    const closeDateTime = cells[8].textContent.trim();

                    const commissionRaw = parseFloat(cells[10].textContent.replace(/\s/g, '').replace(',', '.')) || 0;
                    const swapRaw = parseFloat(cells[11].textContent.replace(/\s/g, '').replace(',', '.')) || 0;

                    let profit = 0;
                    for (let i = cells.length - 1; i >= 12; i--) {
                        const text = cells[i].textContent.replace(/\s/g, '').replace(',', '.');
                        const value = parseFloat(text);
                        if (!isNaN(value)) {
                            profit = value;
                            break;
                        }
                    }

                    console.log(`💰 ${symbol} - Vol=${volume}, Entry=${entryPrice}, Exit=${exitPrice}, P&L=${profit}, Comm=${commissionRaw}, Swap=${swapRaw}`);

                    // Solo omitir si faltan datos esenciales (no por P&L bajo)
                    if (entryPrice === 0 || exitPrice === 0) {
                        console.log(`⏭️ Omitiendo ${symbol}: Entry=${entryPrice}, Exit=${exitPrice} (precios inválidos)`);
                        skippedCount++;
                        continue;
                    }
                    
                    // PERMITIR operaciones con P&L=0 (breakeven) - son operaciones válidas
                    // Solo advertir si el P&L es exactamente 0 con diferencia de precio
                    if (profit === 0 && entryPrice !== exitPrice) {
                        console.warn(`⚠️ ${symbol}: P&L=0 pero Entry≠Exit (${entryPrice} vs ${exitPrice}) - Puede ser error de cálculo`);
                    }

                    // Parsear fechas y horas
                    const [openDateStr, openTimeStr] = openDateTime.split(' ');
                    const [closeDateStr, closeTimeStr] = closeDateTime.split(' ');

                    // Convertir fecha de MT5 (YYYY.MM.DD) a formato estándar (YYYY-MM-DD)
                    const operationDate = closeDateStr ? closeDateStr.replace(/\./g, '-') : null;

                    // Validar que las fechas sean válidas
                    if (!operationDate || operationDate.includes('NaN') || operationDate === '--') {
                        console.error(`❌ Fecha inválida para operación #${positionId}: closeDateStr="${closeDateStr}", operationDate="${operationDate}"`);
                        skippedCount++;
                        continue;
                    }

                    // Validar formato YYYY-MM-DD
                    const datePattern = /^\d{4}-\d{2}-\d{2}$/;
                    if (!datePattern.test(operationDate)) {
                        console.error(`❌ Formato de fecha incorrecto para operación #${positionId}: "${operationDate}"`);
                        skippedCount++;
                        continue;
                    }

                    // Calcular fees total - validar que sean valores razonables
                    let totalFees = 0;

                    if (Math.abs(commissionRaw) < 100) {
                        totalFees += Math.abs(commissionRaw);
                    } else {
                        console.warn(`⚠️ Comisión sospechosa ($${commissionRaw}) en operación #${positionId}, ignorando`);
                    }

                    if (Math.abs(swapRaw) < 100) {
                        totalFees += Math.abs(swapRaw);
                    } else {
                        console.warn(`⚠️ Swap sospechoso ($${swapRaw}) en operación #${positionId}, ignorando`);
                    }

                    // Determinar resultado
                    let result;
                    if (profit > 0) result = 'win';
                    else if (profit < 0) result = 'loss';
                    else result = 'breakeven';

                    // Crear operación
                    const operation = {
                        id: `mt5_${positionId}`,
                        date: operationDate,
                        accountId: mt5Account.id,
                        instrument: symbol,
                        type: type,
                        entry: entryPrice,
                        exit: exitPrice,
                        entryTime: openTimeStr || null,
                        exitTime: closeTimeStr || null,
                        volume: volume,
                        result: result,
                        pl: profit,
                        currency: mt5Account.currency,
                        notes: `Importado de MT5 - Posición #${positionId}`,
                        imageDatas: [],
                        fees: totalFees,
                        manualPL: profit,
                        session: detectTradingSession(openTimeStr) || ''
                    };

                    // Calcular MAE/MFE estimados
                    const maemfe = calculateEstimatedMAEMFE(operation);
                    operation.mae = maemfe.mae;
                    operation.mfe = maemfe.mfe;

                    console.log(`✅ Operación procesada: ${symbol} ${type} | Date: ${operationDate} | P&L: $${profit} | Fees: $${totalFees}`);

                    // Verificar si ya existe esta operación (evitar duplicados)
                    const exists = DB.operations.some(op => op.id === operation.id);
                    if (exists) {
                        console.log(`⏭️ Operación #${positionId} ya existe, omitiendo`);
                        skippedCount++;
                        continue;
                    }

                    newOperations.push(operation);

                } catch (error) {
                    console.error('Error procesando fila:', error);
                    skippedCount++;
                }
            }
        }

        if (newOperations.length === 0) {
            showSyncNotification('❌ No se pudieron procesar las operaciones del informe', 'error');
            return;
        }

        // Guardar operaciones en DB local primero
        try {
            // Guardar en Dexie (base de datos local)
            await dexieDB.operations.bulkAdd(newOperations);
            DB.operations.push(...newOperations);
            
            console.log(`✅ ${newOperations.length} operaciones guardadas localmente`);

            // Sincronizar con Supabase en segundo plano (sin bloquear)
            if (currentUser) {
                console.log('� Sincronizando con Supabase en segundo plano...');
                
                // Hacer la sincronización de forma asíncrona sin esperar
                setTimeout(async () => {
                    let successCount = 0;
                    let errorCount = 0;

                    for (const operation of newOperations) {
                        try {
                            await saveOperationToSupabase(operation);
                            successCount++;
                        } catch (error) {
                            // Encolar para reintento posterior
                            if (!error.message?.includes('duplicate')) {
                                addToSyncQueue(operation, 'operation');
                                errorCount++;
                            }
                        }
                    }

                    if (successCount > 0) {
                        console.log(`✅ ${successCount} operaciones sincronizadas con Supabase`);
                    }
                    if (errorCount > 0) {
                        console.log(`⚠️ ${errorCount} operaciones encoladas para sincronización posterior`);
                    }
                }, 100);
            }

            // Actualizar vistas inmediatamente con datos locales
            console.log('📊 Actualizando vistas...');
            updateAccountBalances();
            
            // Forzar actualización de todas las vistas
            refreshAllViews();
            
            // Actualizar también la vista de operaciones si está activa
            if (document.querySelector('.nav-tab.active')?.dataset.target === 'operations') {
                refreshOperationsTable();
            }
            
            // Actualizar dashboard si está activo
            if (document.querySelector('.nav-tab.active')?.dataset.target === 'dashboard') {
                refreshDashboard();
            }

            const message = `✅ ${newOperations.length} operaciones importadas a cuenta "${mt5Account.name}"${skippedCount > 0 ? ` (${skippedCount} omitidas)` : ''}`;
            
            showSyncNotification(message, 'success');
            
            console.log(`✅ Importación completada: ${newOperations.length} operaciones guardadas en cuenta ${mt5Account.id}, ${skippedCount} omitidas`);
            console.log(`📍 Cuenta: ${mt5Account.name} | Total operaciones en DB: ${DB.operations.length}`);

        } catch (error) {
            console.error('Error guardando operaciones:', error);
            showSyncNotification('❌ Error guardando operaciones: ' + error.message, 'error');
        }

    } catch (error) {
        console.error('Error parseando informe MT5:', error);
        showSyncNotification('❌ Error procesando informe HTML', 'error');
    }
}

// Función para limpiar operaciones MT5 con errores (P&L=0 o comisiones incorrectas)
async function cleanMT5Operations() {
    try {
        console.log('🧹 Iniciando limpieza de operaciones MT5...');

        // Buscar todas las operaciones MT5 (id comienza con mt5_)
        const mt5Operations = DB.operations.filter(op => op.id && op.id.startsWith('mt5_'));

        if (mt5Operations.length === 0) {
            showSyncNotification('ℹ️ No hay operaciones MT5 para limpiar', 'info');
            return;
        }

        console.log(`📊 Encontradas ${mt5Operations.length} operaciones MT5`);

        // Identificar operaciones con problemas
        const problematicOps = mt5Operations.filter(op => {
            // Operaciones con P&L = 0
            const hasZeroPL = op.pl === 0 || op.manualPL === 0;

            // Operaciones con comisiones sospechosamente altas (más del 50% del P&L)
            const hasSuspiciousFees = op.fees && Math.abs(op.pl) > 0 && (op.fees / Math.abs(op.pl)) > 0.5;

            return hasZeroPL || hasSuspiciousFees;
        });

        if (problematicOps.length === 0) {
            showSyncNotification('✅ No se encontraron operaciones MT5 con problemas', 'success');
            return;
        }

        console.log(`❌ Encontradas ${problematicOps.length} operaciones con problemas:`, problematicOps);

        // Confirmar con el usuario
        const confirmed = confirm(
            `Se encontraron ${problematicOps.length} operaciones MT5 con problemas:\n\n` +
            `- Operaciones con P&L = 0\n` +
            `- Operaciones con comisiones incorrectas\n\n` +
            `¿Deseas eliminarlas? Esta acción no se puede deshacer.`
        );

        if (!confirmed) {
            showSyncNotification('ℹ️ Limpieza cancelada', 'info');
            return;
        }

        // Eliminar operaciones problemáticas
        let deletedCount = 0;

        for (const op of problematicOps) {
            try {
                // Eliminar de IndexedDB
                await dexieDB.operations.delete(op.id);

                // Eliminar de Supabase si hay usuario autenticado
                if (currentUser) {
                    await deleteOperationFromSupabase(op.id);
                }

                // Eliminar del array en memoria
                const index = DB.operations.findIndex(o => o.id === op.id);
                if (index !== -1) {
                    DB.operations.splice(index, 1);
                }

                deletedCount++;

            } catch (error) {
                console.error(`Error eliminando operación ${op.id}:`, error);
            }
        }

        // Actualizar vistas
        updateAccountBalances();
        refreshAllViews();

        showSyncNotification(
            `✅ Limpieza completada: ${deletedCount} operaciones eliminadas`,
            'success'
        );

        console.log(`✅ Limpieza completada: ${deletedCount} operaciones eliminadas`);

    } catch (error) {
        console.error('Error en limpieza MT5:', error);
        showSyncNotification('❌ Error en limpieza: ' + error.message, 'error');
    }
}

// Función para convertir trade de BingX al formato de la aplicación
function convertBingXTradeToAppFormat(bingxTrade, accountId) {
    // Determinar si fue ganancia o pérdida
    const pnl = parseFloat(bingxTrade.profit || 0);
    const result = pnl > 0 ? 'win' : (pnl < 0 ? 'loss' : 'breakeven');

    // Convertir timestamp a fecha usando zona horaria local
    const tradeDateObj = new Date(parseInt(bingxTrade.time));
    const tradeDate = getLocalDateString(tradeDateObj);

    // Extraer hora de entrada y salida
    const entryTime = new Date(parseInt(bingxTrade.time)).toTimeString().split(' ')[0];
    const exitTime = bingxTrade.updateTime ?
        new Date(parseInt(bingxTrade.updateTime)).toTimeString().split(' ')[0] : entryTime;

    return {
        id: `bingx_${bingxTrade.orderId}`,
        date: tradeDate,
        accountId: accountId,
        instrument: bingxTrade.symbol,
        type: bingxTrade.side.toLowerCase(), // 'BUY' -> 'buy', 'SELL' -> 'sell'
        entry: parseFloat(bingxTrade.avgPrice || bingxTrade.price),
        exit: parseFloat(bingxTrade.avgPrice || bingxTrade.price), // Para órdenes ejecutadas
        entryTime: entryTime,
        exitTime: exitTime,
        volume: parseFloat(bingxTrade.origQty),
        result: result,
        pl: pnl,
        fees: Math.abs(parseFloat(bingxTrade.commission || 0)), // Extraer fees de BingX
        currency: 'USDT', // BingX generalmente usa USDT
        notes: `Importado de BingX - Order ID: ${bingxTrade.orderId}`,
        imageDatas: [],
        manualPL: null,
        session: detectTradingSession(entryTime) || ''
    };
}

// Función para sincronizar trades desde BingX
async function syncBingXTrades() {
    // 1. Verificar si hay credenciales guardadas en Supabase
    if (!bingxAPI && currentUser) {
        console.log('🔄 bingxAPI no inicializada, cargando credenciales desde Supabase...');
        const savedCreds = await loadBingXCredentialsFromSupabase();
        
        if (savedCreds && savedCreds.key && savedCreds.secret) {
            console.log('✅ Credenciales encontradas, inicializando bingxAPI...');
            bingxAPI = new BingXAPI(savedCreds.key, savedCreds.secret);
        }
    }

    // 2. Si aún no hay API, mostrar error
    if (!bingxAPI) {
        showSyncNotification('❌ BingX: Primero debes configurar y guardar tus credenciales', 'error');
        updateBingXStatus('error', 'No configurado', false);
        return;
    }

    // Buscar cuenta seleccionada en cualquiera de las interfaces
    let selectedAccount = null;
    const accountSelect = document.getElementById('bingx-account');
    const accountDetailSelect = document.getElementById('bingx-account-detail');

    if (accountDetailSelect && accountDetailSelect.value) {
        selectedAccount = accountDetailSelect.value;
    } else if (accountSelect && accountSelect.value) {
        selectedAccount = accountSelect.value;
    } else if (DB.apiKeys.bingx && DB.apiKeys.bingx.accountId) {
        selectedAccount = DB.apiKeys.bingx.accountId;
    }

    if (!selectedAccount) {
        // showSyncNotification('❌ Selecciona una cuenta para sincronizar', 'error');
        return;
    }

    showLoading(true);
    updateBingXStatus('syncing', 'Sincronizando...', false);

    try {
        // showSyncNotification('🔄 Sincronizando trades desde BingX...', 'info');

        // Primero probar con información de cuenta para verificar autenticación
        console.log('🔍 Verificando autenticación con BingX...');
        const accountResponse = await bingxAPI.getAccountInfo();
        console.log('📊 Respuesta de cuenta:', JSON.stringify(accountResponse, null, 2));

        if (accountResponse.code !== 0) {
            throw new Error(`Error de autenticación: ${accountResponse.msg}`);
        }

        // Obtener historial de trades
        console.log('📈 Obteniendo historial de trades...');
        const tradesResponse = await bingxAPI.getTradeHistory('', 100); // Reducir a 100 trades
        console.log('📊 Respuesta de trades:', JSON.stringify(tradesResponse, null, 2));

        if (tradesResponse.code !== 0) {
            throw new Error(tradesResponse.msg || 'Error obteniendo trades');
        }

        const bingxTrades = tradesResponse.data?.orders || [];

        // Filtrar solo trades ejecutados
        const executedTrades = bingxTrades.filter(trade =>
            trade.status === 'FILLED' && trade.profit !== undefined
        );

        // Buscar cuenta de BingX en la aplicación
        let bingxAccount = DB.accounts.find(acc => acc.platform === 'bingx');

        if (!bingxAccount) {
            // Crear cuenta de BingX automáticamente
            bingxAccount = {
                id: generateId(),
                name: 'BingX - Cuenta Principal',
                currency: 'USDT',
                platform: 'bingx',
                initialBalance: 0,
                balance: 0
            };

            DB.accounts.push(bingxAccount);
            await dexieDB.accounts.add(bingxAccount);

            // Sincronizar con Supabase si está conectado
            if (currentUser) {
                await saveAccountToSupabase(bingxAccount);
            }
        }

        // Convertir trades al formato de la aplicación
        let newTrades = 0;
        let skippedTrades = 0;

        for (const bingxTrade of executedTrades) {
            const appTrade = convertBingXTradeToAppFormat(bingxTrade, bingxAccount.id);

            // Verificar si el trade ya existe
            const existingTrade = DB.operations.find(op => op.id === appTrade.id);

            if (!existingTrade) {
                // Guardar localmente
                DB.operations.push(appTrade);
                await dexieDB.operations.add(appTrade);

                // Sincronizar con Supabase si está conectado
                if (currentUser) {
                    await saveOperationToSupabase(appTrade);
                }

                newTrades++;
            } else {
                skippedTrades++;
            }
        }

        // Actualizar balance de la cuenta si se encontraron nuevos trades
        if (newTrades > 0) {
            updateAccountBalances();
            refreshAllViews();
            showSyncNotification(`✅ BingX: ${newTrades} trades nuevos sincronizados`, 'success');
            updateBingXStatus('connected', `Conectado - ${newTrades} trades`, true);
        } else {
            showSyncNotification('✅ BingX: Conectado - Sin trades nuevos', 'success');
            updateBingXStatus('connected', 'Conectado - Sin trades', true);
        }

        const message = `✅ Sincronización completa: ${newTrades} trades nuevos, ${skippedTrades} ya existían`;
        console.log(message);
        updateBingXStatus('connected', newTrades > 0 ? `Conectado - ${newTrades} trades` : 'Conectado - Sin trades', true);

    } catch (error) {
        console.error('Error sincronizando trades BingX:', error);
        const errorMessage = `❌ BingX: Error de sincronización - ${error.message}`;
        showSyncNotification(errorMessage, 'error');
        updateBingXStatus('error', 'Error de sincronización', false);
    } finally {
        showLoading(false);
    }
}

// Función para cargar credenciales guardadas
function loadBingXCredentials() {
    console.log('🔍 Cargando credenciales BingX...');

    // Primero intentar cargar desde localStorage
    const savedApiKey = localStorage.getItem('bingx-api-key');
    const savedSecretKey = localStorage.getItem('bingx-secret-key');
    const savedAccountId = localStorage.getItem('bingx-account-id');

    console.log('📁 Credenciales en localStorage:', {
        apiKey: savedApiKey ? `${savedApiKey.substring(0, 10)}...` : 'No encontrada',
        secretKey: savedSecretKey ? `${savedSecretKey.substring(0, 10)}...` : 'No encontrada',
        accountId: savedAccountId || 'No encontrada'
    });

    // Configurar credenciales proporcionadas por el usuario como respaldo
    const providedApiKey = 'sw8hglph1M6HWzoqswDdjX7YTh3mcruPKynFi1ZBz8zDXCHxnEchw7oRWgYysFVLFuD7bkYomRHxSh8gdtNBg';
    const providedSecretKey = '7hUYF1GhJ6QixdE2mfDEdDMovcKVpUc3OnqbAfiAcbrT6XzFfMF4ywd0K06JgJCt0Zsa6MYxuSslDKr5XJfYA';

    // Verificar si existen los elementos antes de actualizar
    const bingxApiKeyEl = document.getElementById('bingx-api-key');
    const bingxSecretEl = document.getElementById('bingx-api-secret');

    // Usar credenciales guardadas o las proporcionadas
    const apiKeyToUse = savedApiKey || providedApiKey;
    const secretKeyToUse = savedSecretKey || providedSecretKey;
    const accountIdToUse = savedAccountId || 'main';

    console.log('💾 Cargando credenciales en campos...');

    if (bingxApiKeyEl) {
        bingxApiKeyEl.value = apiKeyToUse;
        console.log('✅ API Key cargada en campo básico');
    }
    if (bingxSecretEl) {
        bingxSecretEl.value = secretKeyToUse;
        console.log('✅ Secret Key cargada en campo básico');
    }

    // Actualizar DB solo si está disponible
    if (typeof DB !== 'undefined' && DB.apiKeys) {
        DB.apiKeys.bingx = {
            key: apiKeyToUse,
            secret: secretKeyToUse,
            mode: 'real',
        };
    }

    // Intentar reconectar automáticamente
    if (typeof DB !== 'undefined' && DB.apiKeys && DB.apiKeys.bingx && DB.apiKeys.bingx.key && DB.apiKeys.bingx.secret) {
        bingxAPI = new BingXAPI(DB.apiKeys.bingx.key, DB.apiKeys.bingx.secret);
        console.log('🔗 BingX API reconectada automáticamente');

        // Poblar cuentas cuando se reconecta
        populateBingXAccounts();

        // Actualizar estado visual
        setTimeout(() => {
            updateBingXStatus('connected', 'Credenciales cargadas', true);
        }, 500);
    }
}

// Función para verificar el estado del proxy
async function checkProxyStatus() {
    try {
        const proxyCheckUrl = window.PROXY_URL || 'http://127.0.0.1:8003';
        const response = await fetch(`${proxyCheckUrl}/health`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
            }
        });

        if (response.ok) {
            console.log('✅ Servidor proxy BingX funcionando correctamente');
            return true;
        } else {
            console.warn('⚠️ Servidor proxy BingX no responde correctamente');
            return false;
        }
    } catch (error) {
        console.error('❌ Error conectando al servidor proxy BingX:', error);
        // Notificación eliminada - no molestar al usuario
        return false;
    }
}

// Event listeners para BingX
document.addEventListener('DOMContentLoaded', function() {
    console.log('🚀 Inicializando BingX - DOMContentLoaded');

    // CARGAR CREDENCIALES INMEDIATAMENTE
    loadBingXCredentials();
    loadBingXCredentialsInDetail();

    // Verificar proxy y cargar credenciales al inicio
    setTimeout(async () => {
        console.log('🔄 Verificando proxy y recargando credenciales...');
        const proxyOk = await checkProxyStatus();

        // VOLVER A CARGAR CREDENCIALES DESPUÉS DE VERIFICAR PROXY
        loadBingXCredentials();
        loadBingXCredentialsInDetail();
        loadLastSyncInfo();
        updateBingXDetailStatus();

        if (proxyOk) {
            console.log('BingX: Sistema inicializado correctamente');
        }
        // No mostrar mensaje si el proxy no está disponible

        // TERCER INTENTO DE CARGA DESPUÉS DE 2 SEGUNDOS MÁS
        setTimeout(() => {
            console.log('🔄 Carga final de credenciales...');
            loadBingXCredentials();
            loadBingXCredentialsInDetail();
        }, 2000);

    }, 1000);

    // Event listeners (verificar si existen los elementos)
    const bingxTestBtn = document.getElementById('test-bingx-connection-detail');
    const bingxConnectBtn = document.getElementById('connect-bingx-detail');
    const bingxSyncBtn = document.getElementById('sync-bingx-trades-detail');

    // Event listeners para campos de credenciales - guardar automáticamente
    const apiKeyDetail = document.getElementById('bingx-api-key-detail');
    const secretKeyDetail = document.getElementById('bingx-secret-key-detail');
    const apiKeyOld = document.getElementById('bingx-api-key');
    const secretKeyOld = document.getElementById('bingx-api-secret');

    // Función para guardar credenciales automáticamente
    const saveCredentialsAuto = async () => {
        const apiKey = (apiKeyDetail?.value || apiKeyOld?.value || '').trim();
        const secretKey = (secretKeyDetail?.value || secretKeyOld?.value || '').trim();

        if (apiKey && secretKey) {
            console.log('💾 Auto-guardando credenciales...');
            try {
                // Guardar en localStorage inmediatamente
                localStorage.setItem('bingx-api-key', apiKey);
                localStorage.setItem('bingx-secret-key', secretKey);
                localStorage.setItem('bingx-account-id', 'main');
                localStorage.setItem('bingx-last-auto-save', Date.now().toString());

                // Guardar en DB también
                DB.apiKeys.bingx = { key: apiKey, secret: secretKey, mode: 'real', accountId: 'main' };
                await dexieDB.generalData.put({ key: 'apiKeys', value: DB.apiKeys });

                // Guardar en Supabase si el usuario está autenticado
                if (currentUser) {
                    await saveBingXCredentialsToSupabase(apiKey, secretKey, 'main');
                }

                console.log('✅ Credenciales auto-guardadas');
            } catch (error) {
                console.error('❌ Error auto-guardando:', error);
            }
        }
    };

    // Agregar listeners a todos los campos de credenciales
    if (apiKeyDetail) {
        apiKeyDetail.addEventListener('input', saveCredentialsAuto);
        apiKeyDetail.addEventListener('blur', saveCredentialsAuto);
    }
    if (secretKeyDetail) {
        secretKeyDetail.addEventListener('input', saveCredentialsAuto);
        secretKeyDetail.addEventListener('blur', saveCredentialsAuto);
    }
    if (apiKeyOld) {
        apiKeyOld.addEventListener('input', saveCredentialsAuto);
        apiKeyOld.addEventListener('blur', saveCredentialsAuto);
    }
    if (secretKeyOld) {
        secretKeyOld.addEventListener('input', saveCredentialsAuto);
        secretKeyOld.addEventListener('blur', saveCredentialsAuto);
    }

    if (bingxTestBtn) bingxTestBtn.addEventListener('click', testBingXConnection);
    if (bingxConnectBtn) bingxConnectBtn.addEventListener('click', connectBingX);
    if (bingxSyncBtn) bingxSyncBtn.addEventListener('click', syncBingXTrades);

    // Event listener for quick sync button on platform card
    const bingxQuickSyncBtn = document.getElementById('bingx-quick-sync');
    if (bingxQuickSyncBtn) {
        bingxQuickSyncBtn.addEventListener('click', async (e) => {
            e.stopPropagation(); // Prevent card click event
            console.log('🚀 Quick sync iniciado desde plataforma');

            // Disable button and show loading state
            const originalText = bingxQuickSyncBtn.innerHTML;
            bingxQuickSyncBtn.disabled = true;
            bingxQuickSyncBtn.innerHTML = '<i class="fas fa-spinner fa-spin text-xs"></i><span>Sync...</span>';
            bingxQuickSyncBtn.classList.add('opacity-75', 'cursor-not-allowed');

            try {
                await syncBingXTrades();
            } finally {
                // Restore button state
                setTimeout(() => {
                    bingxQuickSyncBtn.disabled = false;
                    bingxQuickSyncBtn.innerHTML = originalText;
                    bingxQuickSyncBtn.classList.remove('opacity-75', 'cursor-not-allowed');
                }, 1000);
            }
        });
    }

    // Event listener for CSV import button
    const bingxImportCsvBtn = document.getElementById('bingx-import-csv');
    if (bingxImportCsvBtn) {
        bingxImportCsvBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            importBingXCSV();
        });
    }

    // Event listener for MEXC quick sync button
    const mexcQuickSyncBtn = document.getElementById('mexc-quick-sync');
    if (mexcQuickSyncBtn) {
        mexcQuickSyncBtn.addEventListener('click', async (e) => {
            e.stopPropagation(); // Prevent card click event
            console.log('🚀 Quick sync MEXC iniciado desde plataforma');

            // Check if connected
            if (!mexcAPI) {
                showSyncNotification('❌ Primero configura las credenciales API de MEXC', 'error');
                showPlatformDetail('mexc'); // Open MEXC panel to configure
                return;
            }

            // Disable button and show loading state
            const originalText = mexcQuickSyncBtn.innerHTML;
            mexcQuickSyncBtn.disabled = true;
            mexcQuickSyncBtn.innerHTML = '<i class="fas fa-spinner fa-spin text-xs"></i><span>Sync...</span>';
            mexcQuickSyncBtn.classList.add('opacity-75', 'cursor-not-allowed');

            try {
                await syncMEXCTrades();
            } finally {
                // Restore button state
                setTimeout(() => {
                    mexcQuickSyncBtn.disabled = false;
                    mexcQuickSyncBtn.innerHTML = originalText;
                    mexcQuickSyncBtn.classList.remove('opacity-75', 'cursor-not-allowed');
                }, 1000);
            }
        });
    }

    // Event listener para botón CSV de MEXC en tarjeta
    const mexcImportCsvCardBtn = document.getElementById('mexc-import-csv');
    if (mexcImportCsvCardBtn) {
        mexcImportCsvCardBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            importMEXCCSV(); // Usar la función específica de MEXC
        });
    }

    // Event listener for NinjaTrader CSV import button
    const ninjaImportCsvBtn = document.getElementById('ninjatrader-import-csv');
    if (ninjaImportCsvBtn) {
        ninjaImportCsvBtn.addEventListener('click', async (e) => {
            e.stopPropagation();
            console.log('📥 Importación CSV de NinjaTrader iniciada');
            importNinjaTraderCSV();
        });
    }

    // Event listener for TopStepX CSV import button
    const topstepxImportCsvBtn = document.getElementById('topstepx-import-csv');
    if (topstepxImportCsvBtn) {
        topstepxImportCsvBtn.addEventListener('click', async (e) => {
            e.stopPropagation();
            console.log('📥 Importación CSV de TopStepX iniciada');
            importTopStepXCSV();
        });
    }

    // Event listener for Bitunix CSV import button
    const bitunixImportCsvBtn = document.getElementById('bitunix-import-csv');
    if (bitunixImportCsvBtn) {
        bitunixImportCsvBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            importBitunixCSV();
        });
    }

    // Event listener for Bitunix quick sync button
    const bitunixQuickSyncBtn = document.getElementById('bitunix-quick-sync');
    if (bitunixQuickSyncBtn) {
        bitunixQuickSyncBtn.addEventListener('click', async (e) => {
            e.stopPropagation();
            console.log('🚀 Quick sync Bitunix iniciado desde plataforma');

            // Check if connected
            if (!bitunixAPI) {
                showSyncNotification('❌ Primero configura las credenciales API de Bitunix', 'error');
                showPlatformDetail('bitunix');
                return;
            }

            const originalText = bitunixQuickSyncBtn.innerHTML;
            bitunixQuickSyncBtn.disabled = true;
            bitunixQuickSyncBtn.innerHTML = '<i class="fas fa-spinner fa-spin text-xs"></i><span>Sync...</span>';
            bitunixQuickSyncBtn.classList.add('opacity-75', 'cursor-not-allowed');

            try {
                await syncBitunixTrades();
            } finally {
                setTimeout(() => {
                    bitunixQuickSyncBtn.disabled = false;
                    bitunixQuickSyncBtn.innerHTML = originalText;
                    bitunixQuickSyncBtn.classList.remove('opacity-75', 'cursor-not-allowed');
                }, 1000);
            }
        });
    }

    // Event listener for LBank CSV import button
    const lbankImportCsvBtn = document.getElementById('lbank-import-csv');
    if (lbankImportCsvBtn) {
        lbankImportCsvBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            importLBankCSV();
        });
    }

    // Event listener for LBank quick sync button
    const lbankQuickSyncBtn = document.getElementById('lbank-quick-sync');
    if (lbankQuickSyncBtn) {
        lbankQuickSyncBtn.addEventListener('click', async (e) => {
            e.stopPropagation();
            console.log('🚀 Quick sync LBank iniciado desde plataforma');

            // Check if connected
            if (!lbankAPI) {
                showSyncNotification('❌ Primero configura las credenciales API de LBank', 'error');
                showPlatformDetail('lbank');
                return;
            }

            const originalText = lbankQuickSyncBtn.innerHTML;
            lbankQuickSyncBtn.disabled = true;
            lbankQuickSyncBtn.innerHTML = '<i class="fas fa-spinner fa-spin text-xs"></i><span>Sync...</span>';
            lbankQuickSyncBtn.classList.add('opacity-75', 'cursor-not-allowed');

            try {
                await syncLBankTrades();
            } finally {
                setTimeout(() => {
                    lbankQuickSyncBtn.disabled = false;
                    lbankQuickSyncBtn.innerHTML = originalText;
                    lbankQuickSyncBtn.classList.remove('opacity-75', 'cursor-not-allowed');
                }, 1000);
            }
        });
    }

    // Event listener for BloFin CSV import button
    const blofinImportCsvBtn = document.getElementById('blofin-import-csv');
    if (blofinImportCsvBtn) {
        blofinImportCsvBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            importBloFinCSV();
        });
    }

    // Event listener for BloFin quick sync button
    const blofinQuickSyncBtn = document.getElementById('blofin-quick-sync');
    if (blofinQuickSyncBtn) {
        blofinQuickSyncBtn.addEventListener('click', async (e) => {
            e.stopPropagation();
            console.log('🚀 Quick sync BloFin iniciado desde plataforma');

            // Check if connected
            if (!blofinAPI) {
                showSyncNotification('❌ Primero configura las credenciales API de BloFin', 'error');
                showPlatformDetail('blofin');
                return;
            }

            const originalText = blofinQuickSyncBtn.innerHTML;
            blofinQuickSyncBtn.disabled = true;
            blofinQuickSyncBtn.innerHTML = '<i class="fas fa-spinner fa-spin text-xs"></i><span>Sync...</span>';
            blofinQuickSyncBtn.classList.add('opacity-75', 'cursor-not-allowed');

            try {
                await syncBloFinTrades();
            } finally {
                setTimeout(() => {
                    blofinQuickSyncBtn.disabled = false;
                    blofinQuickSyncBtn.innerHTML = originalText;
                    blofinQuickSyncBtn.classList.remove('opacity-75', 'cursor-not-allowed');
                }, 1000);
            }
        });
    }

    // Sync de NinjaTrader eliminado - Solo CSV manual
    /* Botón eliminado para evitar egress
    const ninjaQuickSyncBtn = document.getElementById('ninjatrader-quick-sync');
    if (ninjaQuickSyncBtn) {
        ninjaQuickSyncBtn.addEventListener('click', async (e) => {
            e.stopPropagation();
            console.log('🚀 Sincronización de NinjaTrader iniciada');
            showNinjaTraderSyncModal();
        });
    }
    */

    // Event listener for Tradovate CSV import button
    const tradovateImportCsvBtn = document.getElementById('tradovate-import-csv');
    if (tradovateImportCsvBtn) {
        tradovateImportCsvBtn.addEventListener('click', async (e) => {
            e.stopPropagation();
            console.log('📥 Importación CSV de Tradovate iniciada');
            importTradovateCSV();
        });
    }

    // Event listener para botón CSV de PrimeXBT
    const primexbtImportCsvBtn = document.getElementById('primexbt-import-csv');
    if (primexbtImportCsvBtn) {
        primexbtImportCsvBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            importPrimeXBTCSV();
        });
    }

    // Event listeners para botones CSV de PrimeXBT Crypto y CFDs
    const primexbtCryptoImportCsvBtn = document.getElementById('primexbt-crypto-import-csv');
    if (primexbtCryptoImportCsvBtn) {
        primexbtCryptoImportCsvBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            importPrimeXBTCSV();
        });
    }

    // Event listener para botón de importar desde interfaz de PrimeXBT Crypto
    const primexbtCryptoImportInterfaceBtn = document.getElementById('primexbt-crypto-import-interface');
    if (primexbtCryptoImportInterfaceBtn) {
        primexbtCryptoImportInterfaceBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            openPrimeXBTInterfaceModal();
        });
    }

    const primexbtCfdsImportCsvBtn = document.getElementById('primexbt-cfds-import-csv');
    if (primexbtCfdsImportCsvBtn) {
        primexbtCfdsImportCsvBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            importPrimeXBTCFDsCSV(); // Usar función específica para CFDs
        });
    }

    // Event listener para botón HTML de MetaTrader 5
    const mt5ImportHtmlBtn = document.getElementById('mt5-import-html');
    if (mt5ImportHtmlBtn) {
        mt5ImportHtmlBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            importMT5HTMLReport();
        });
    }

    // Event listener para botón de limpieza MT5
    const mt5CleanBtn = document.getElementById('mt5-clean-operations');
    if (mt5CleanBtn) {
        mt5CleanBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            cleanMT5Operations();
        });
    }

    // Event listener para botón HTML de MetaTrader 4
    const mt4ImportHtmlBtn = document.getElementById('mt4-import-html');
    if (mt4ImportHtmlBtn) {
        mt4ImportHtmlBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            importMT5HTMLReport(); // Usar la misma función que MT5
        });
    }

    // Event listener para botón de limpieza MT4
    const mt4CleanBtn = document.getElementById('mt4-clean-operations');
    if (mt4CleanBtn) {
        mt4CleanBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            cleanMT5Operations(); // Usar la misma función que MT5
        });
    }

    // Event listener para botón HTML de cTrader
    const ctraderImportHtmlBtn = document.getElementById('ctrader-import-html');
    if (ctraderImportHtmlBtn) {
        ctraderImportHtmlBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            importCTraderHTML();
        });
    }

    // ============================================
    // EVENT LISTENERS PARA cTrader
    // ============================================
    
    console.log('🔧 Inicializando event listeners de cTrader con delegación...');
    
    // Usar delegación de eventos en el document para que funcione incluso si el elemento no existe aún
    document.addEventListener('click', (e) => {
        // Importar archivo HTML
        if (e.target.id === 'ctrader-import-csv-btn' || e.target.closest('#ctrader-import-csv-btn')) {
            e.preventDefault();
            e.stopPropagation();
            
            console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
            console.log('🎯 IMPORTACIÓN CTRADER HTML INICIADA');
            console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
            
            const ctraderFileInput = document.getElementById('ctrader-csv-file-input');
            const file = ctraderFileInput?.files[0];
            
            if (!file) {
                console.error('❌ PASO 1 FALLIDO: No se seleccionó ningún archivo');
                showSyncNotification('⚠️ Por favor selecciona un archivo HTML primero', 'warning');
                return;
            }
            
            console.log('✅ PASO 1: Archivo seleccionado');
            console.log('   📁 Nombre:', file.name);
            console.log('   📊 Tamaño:', (file.size / 1024).toFixed(2), 'KB');
            console.log('   📝 Tipo:', file.type || 'desconocido');
            
            const accountSelect = document.getElementById('ctrader-account-select');
            const selectedAccountId = accountSelect?.value;
            
            if (!selectedAccountId) {
                console.error('❌ PASO 2 FALLIDO: No se seleccionó cuenta');
                showSyncNotification('⚠️ Por favor selecciona una cuenta destino', 'warning');
                return;
            }
            
            const account = DB.accounts.find(acc => acc.id === selectedAccountId);
            if (!account) {
                console.error('❌ PASO 2 FALLIDO: Cuenta no encontrada en DB');
                console.error('   ID buscado:', selectedAccountId);
                console.error('   Cuentas disponibles:', DB.accounts.map(a => ({id: a.id, name: a.name})));
                showSyncNotification('❌ La cuenta seleccionada no existe', 'error');
                return;
            }
            
            console.log('✅ PASO 2: Cuenta destino validada');
            console.log('   👤 ID:', selectedAccountId);
            console.log('   📝 Nombre:', account.name);
            console.log('   💱 Divisa:', account.currency);
            
            console.log('🔄 PASO 3: Leyendo archivo...');
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const content = e.target.result;
                    console.log('✅ Archivo leído exitosamente');
                    console.log('   📄 Caracteres:', content.length);
                    console.log('   📝 Primeros 100 caracteres:', content.substring(0, 100));
                    
                    const isHTML = file.name.toLowerCase().endsWith('.html') || 
                                   file.name.toLowerCase().endsWith('.htm') ||
                                   content.trim().startsWith('<!DOCTYPE') ||
                                   content.trim().startsWith('<html');
                    
                    if (!isHTML) {
                        console.error('❌ PASO 4 FALLIDO: No es un archivo HTML válido');
                        console.error('   Extensión del archivo:', file.name.split('.').pop());
                        console.error('   Inicio del contenido:', content.substring(0, 50));
                        showSyncNotification('⚠️ Solo se aceptan archivos HTML Statement de cTrader (.html o .htm)', 'warning');
                        return;
                    }
                    
                    console.log('✅ PASO 4: Archivo HTML válido');
                    console.log('🔄 PASO 5: Parseando operaciones...');
                    
                    const result = parseCTraderHTML(content);
                    
                    console.log('✅ PASO 5: Parseo completado');
                    console.log('   📊 Operaciones extraídas:', result.operations.length);
                    console.log('   💱 Divisa detectada:', result.accountInfo.currency);
                    console.log('   🆔 Número de cuenta:', result.accountInfo.number);
                    
                    if (result.operations.length > 0) {
                        console.log('   🔍 Primera operación:', result.operations[0]);
                    }
                    
                    if (result.operations.length === 0) {
                        console.warn('⚠️ ADVERTENCIA: No se encontraron operaciones');
                        showSyncNotification('⚠️ No se encontraron operaciones en el archivo HTML', 'warning');
                        return;
                    }
                    
                    console.log('🔄 PASO 6: Mostrando vista previa...');
                    showCTraderPreview(result.operations, selectedAccountId);
                    console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
                    
                } catch (error) {
                    console.error('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
                    console.error('❌ ERROR EN EL PARSEO');
                    console.error('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
                    console.error('Mensaje:', error.message);
                    console.error('Stack:', error.stack);
                    console.error('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
                    showSyncNotification(`❌ Error: ${error.message}`, 'error');
                }
            };
            
            reader.onerror = (error) => {
                console.error('❌ Error al leer el archivo:', error);
                showSyncNotification('❌ Error al leer el archivo', 'error');
            };
            
            reader.readAsText(file);
        }
        
        // Confirmar importación
        if (e.target.id === 'ctrader-confirm-import-btn' || e.target.closest('#ctrader-confirm-import-btn')) {
            e.preventDefault();
            e.stopPropagation();
            
            console.log('✅ Click en confirmar importación cTrader (delegación)');
            confirmCTraderImport();
        }
    });
    
    console.log('✅ Event listeners de cTrader configurados con delegación de eventos');

    // ============================================
    // EVENT LISTENERS PARA MODAL DE INTERFAZ PRIMEXBT
    // ============================================

    // Función para abrir el modal de importación desde interfaz
    function openPrimeXBTInterfaceModal() {
        const modal = document.getElementById('primexbt-interface-import-modal');
        const accountSelect = document.getElementById('primexbt-interface-account');
        const dataTextarea = document.getElementById('primexbt-interface-data');
        const statusDiv = document.getElementById('primexbt-interface-status');
        
        // Limpiar campos
        dataTextarea.value = '';
        statusDiv.textContent = '';
        statusDiv.className = 'text-sm text-center';
        
        // Cargar cuentas de PrimeXBT Crypto
        accountSelect.innerHTML = '<option value="">Selecciona una cuenta...</option>';
        const primexbtAccounts = DB.accounts.filter(acc => 
            acc.platform === 'primexbt-crypto' || acc.platform === 'primexbt'
        );
        
        if (primexbtAccounts.length === 0) {
            accountSelect.innerHTML += '<option value="" disabled>No hay cuentas de PrimeXBT disponibles</option>';
        } else {
            primexbtAccounts.forEach(acc => {
                const option = document.createElement('option');
                option.value = acc.id;
                option.textContent = `${acc.name} (${acc.currency})`;
                accountSelect.appendChild(option);
            });
        }
        
        // Mostrar modal
        modal.classList.remove('hidden');
        modal.classList.add('flex');
        
        // Focus en el textarea
        setTimeout(() => dataTextarea.focus(), 100);
    }

    // Event listener para cerrar el modal (botón X)
    const primexbtInterfaceCloseBtn = document.getElementById('primexbt-interface-close-btn');
    if (primexbtInterfaceCloseBtn) {
        primexbtInterfaceCloseBtn.addEventListener('click', () => {
            const modal = document.getElementById('primexbt-interface-import-modal');
            modal.classList.add('hidden');
            modal.classList.remove('flex');
        });
    }

    // Event listener para botón Cancelar
    const primexbtInterfaceCancelBtn = document.getElementById('primexbt-interface-cancel-btn');
    if (primexbtInterfaceCancelBtn) {
        primexbtInterfaceCancelBtn.addEventListener('click', () => {
            const modal = document.getElementById('primexbt-interface-import-modal');
            modal.classList.add('hidden');
            modal.classList.remove('flex');
        });
    }

    // Event listener para botón Importar - Clonar para eliminar listeners previos
    const primexbtInterfaceImportBtn = document.getElementById('primexbt-interface-import-btn');
    if (primexbtInterfaceImportBtn) {
        // Clonar botón para eliminar todos los event listeners previos
        const newImportBtn = primexbtInterfaceImportBtn.cloneNode(true);
        primexbtInterfaceImportBtn.parentNode.replaceChild(newImportBtn, primexbtInterfaceImportBtn);
        
        // Agregar UN SOLO event listener
        newImportBtn.addEventListener('click', function() {
            if (typeof window.handlePrimeXBTInterfaceImport === 'function') {
                window.handlePrimeXBTInterfaceImport();
            } else {
                console.error('❌ handlePrimeXBTInterfaceImport no está disponible aún');
            }
        });
        console.log('✅ Event listener botón importar agregado');
    }

    // ============================================
    // EVENT LISTENERS PARA BITGET
    // ============================================

    // Función para abrir el modal de importación desde interfaz de Bitget
    function openBitgetInterfaceModal() {
        const modal = document.getElementById('bitget-interface-import-modal');
        const accountSelect = document.getElementById('bitget-interface-account');
        const dataTextarea = document.getElementById('bitget-interface-data');
        const statusDiv = document.getElementById('bitget-interface-status');
        
        // Limpiar campos
        dataTextarea.value = '';
        statusDiv.textContent = '';
        statusDiv.className = 'text-sm text-center';
        
        // Cargar cuentas de Bitget
        accountSelect.innerHTML = '<option value="">Selecciona una cuenta...</option>';
        const bitgetAccounts = DB.accounts.filter(acc => 
            acc.platform === 'bitget' || acc.broker === 'Bitget'
        );
        
        if (bitgetAccounts.length === 0) {
            accountSelect.innerHTML += '<option value="" disabled>No hay cuentas de Bitget disponibles</option>';
        } else {
            bitgetAccounts.forEach(acc => {
                const option = document.createElement('option');
                option.value = acc.id;
                option.textContent = `${acc.name} (${acc.currency})`;
                accountSelect.appendChild(option);
            });
        }
        
        // Mostrar modal
        modal.classList.remove('hidden');
        modal.classList.add('flex');
        
        // Focus en el textarea
        setTimeout(() => dataTextarea.focus(), 100);
    }

    // Event listener para botón que abre el modal
    const bitgetInterfaceOpenBtn = document.getElementById('bitget-interface-import-btn');
    if (bitgetInterfaceOpenBtn) {
        bitgetInterfaceOpenBtn.addEventListener('click', () => {
            openBitgetInterfaceModal();
        });
    }

    // Event listener para cerrar el modal (botón X)
    const bitgetInterfaceCloseBtn = document.getElementById('bitget-interface-close-btn');
    if (bitgetInterfaceCloseBtn) {
        bitgetInterfaceCloseBtn.addEventListener('click', () => {
            const modal = document.getElementById('bitget-interface-import-modal');
            modal.classList.add('hidden');
            modal.classList.remove('flex');
        });
    }

    // Event listener para botón Cancelar
    const bitgetInterfaceCancelBtn = document.getElementById('bitget-interface-cancel-btn');
    if (bitgetInterfaceCancelBtn) {
        bitgetInterfaceCancelBtn.addEventListener('click', () => {
            const modal = document.getElementById('bitget-interface-import-modal');
            modal.classList.add('hidden');
            modal.classList.remove('flex');
        });
    }

    // Event listener para botón Importar
    const bitgetInterfaceImportBtn = document.getElementById('bitget-interface-import-btn-modal');
    if (bitgetInterfaceImportBtn) {
        bitgetInterfaceImportBtn.addEventListener('click', async () => {
            const accountSelect = document.getElementById('bitget-interface-account');
            const dataTextarea = document.getElementById('bitget-interface-data');
            const statusDiv = document.getElementById('bitget-interface-status');
            
            const accountId = accountSelect.value;
            const rawData = dataTextarea.value.trim();
            
            // Validar datos
            if (!accountId) {
                statusDiv.textContent = '❌ Debes seleccionar una cuenta destino';
                statusDiv.className = 'text-sm text-center text-red';
                return;
            }
            
            if (!rawData) {
                statusDiv.textContent = '❌ Debes pegar los datos de las operaciones';
                statusDiv.className = 'text-sm text-center text-red';
                return;
            }
            
            // Mostrar indicador de procesamiento
            statusDiv.textContent = '⏳ Procesando operaciones...';
            statusDiv.className = 'text-sm text-center text-yellow';
            bitgetInterfaceImportBtn.disabled = true;
            bitgetInterfaceImportBtn.textContent = 'Procesando...';
            
            try {
                // Procesar los datos
                await processBitgetInterfaceData(rawData, accountId);
                
                // Restablecer botón
                bitgetInterfaceImportBtn.disabled = false;
                bitgetInterfaceImportBtn.innerHTML = '<i class="fas fa-upload mr-2"></i>Importar Operaciones';
                
            } catch (error) {
                console.error('Error al importar:', error);
                statusDiv.textContent = `❌ Error: ${error.message}`;
                statusDiv.className = 'text-sm text-center text-red';
                
                // Restablecer botón
                bitgetInterfaceImportBtn.disabled = false;
                bitgetInterfaceImportBtn.innerHTML = '<i class="fas fa-upload mr-2"></i>Importar Operaciones';
            }
        });
    }

    // Cerrar modal al hacer clic fuera de él
    const bitgetInterfaceModal = document.getElementById('bitget-interface-import-modal');
    if (bitgetInterfaceModal) {
        bitgetInterfaceModal.addEventListener('click', (e) => {
            if (e.target === bitgetInterfaceModal) {
                bitgetInterfaceModal.classList.add('hidden');
                bitgetInterfaceModal.classList.remove('flex');
            }
        });
    }

    // Event listener para botón CSV de Bitget (en tarjeta)
    const bitgetImportCsvBtn = document.getElementById('bitget-import-csv');
    if (bitgetImportCsvBtn) {
        bitgetImportCsvBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            importBitgetCSV();
        });
    }

    // Event listener para botón de sincronización API de Bitget (en tarjeta)
    const bitgetQuickSyncBtn = document.getElementById('bitget-quick-sync');
    if (bitgetQuickSyncBtn) {
        bitgetQuickSyncBtn.addEventListener('click', async (e) => {
            e.stopPropagation();

            if (!bitgetAPI) {
                showSyncNotification('❌ Primero debes configurar las credenciales API en el panel de Bitget', 'error');
                // Abrir panel de detalles de Bitget
                showPlatformDetail('bitget');
                return;
            }

            await syncBitgetTrades();
        });
    }

    // Event listener para botón GUARDAR CREDENCIALES en panel de detalles
    const saveBitgetCredentialsBtn = document.getElementById('save-bitget-credentials');
    if (saveBitgetCredentialsBtn) {
        saveBitgetCredentialsBtn.addEventListener('click', async () => {
            const apiKeyInput = document.getElementById('bitget-api-key-detail');
            const secretKeyInput = document.getElementById('bitget-secret-key-detail');
            const passphraseInput = document.getElementById('bitget-passphrase-detail');
            const accountSelect = document.getElementById('bitget-account-detail');

            const apiKey = apiKeyInput?.value.trim();
            const secretKey = secretKeyInput?.value.trim();
            const passphrase = passphraseInput?.value.trim();
            const accountId = accountSelect?.value;

            if (!apiKey || !secretKey || !passphrase) {
                showSyncNotification('❌ Ingresa API Key, Secret y Passphrase', 'error');
                return;
            }

            if (!accountId) {
                showSyncNotification('❌ Selecciona una cuenta', 'error');
                return;
            }

            try {
                // 1. Guardar en Supabase PRIMERO (persistencia en la nube)
                if (currentUser) {
                    try {
                        console.log('💾 Guardando credenciales Bitget en Supabase...');
                        await saveBitgetCredentialsToSupabase(apiKey, secretKey, passphrase, accountId);
                        console.log('✅ Credenciales Bitget guardadas en Supabase');
                    } catch (error) {
                        console.error('⚠️ Error guardando credenciales en Supabase:', error);
                        showSyncNotification('⚠️ Error guardando en Supabase: ' + error.message, 'error');
                        return; // No continuar si falla Supabase
                    }
                } else {
                    showSyncNotification('⚠️ Debes iniciar sesión para guardar credenciales', 'error');
                    return;
                }

                // 2. Guardar en localStorage (cache local)
                localStorage.setItem('bitget_api_key', apiKey);
                localStorage.setItem('bitget_secret_key', secretKey);
                localStorage.setItem('bitget_passphrase', passphrase);
                localStorage.setItem('bitget_account_id', accountId);

                // 3. Guardar en IndexedDB
                const credentials = {
                    id: 'bitget',
                    key: apiKey,
                    secret: secretKey,
                    passphrase: passphrase,
                    accountId: accountId,
                    platform: 'bitget'
                };
                DB.apiKeys.bitget = credentials;
                await dexieDB.apiKeys.put(credentials);

                // 4. Crear instancia de la API con las credenciales guardadas
                if (window.FORCE_OFFLINE_BITGET) {
                    bitgetAPI = new MockBitgetAPI();
                } else {
                    bitgetAPI = new BitgetAPI(apiKey, secretKey, passphrase);
                }

                // 5. Probar conexión automáticamente
                try {
                    console.log('🔌 Probando conexión con Bitget...');
                    await bitgetAPI.testConnection();
                    showSyncNotification('✅ Credenciales guardadas y conexión verificada', 'success');
                    updateBitgetStatus('connected', 'Conectado ✓', false);
                } catch (testError) {
                    console.error('⚠️ Error probando conexión:', testError);
                    showSyncNotification('⚠️ Credenciales guardadas pero conexión falló: ' + testError.message, 'warning');
                    updateBitgetStatus('warning', 'Guardado - Conexión fallida', false);
                }
            } catch (error) {
                console.error('Error guardando credenciales:', error);
                showSyncNotification('❌ Error: ' + error.message, 'error');
            }
        });
    }

    // Event listener para botón Probar Conexión
    const testBitgetConnectionBtn = document.getElementById('test-bitget-connection-detail');
    if (testBitgetConnectionBtn) {
        testBitgetConnectionBtn.addEventListener('click', async () => {
            const apiKeyInput = document.getElementById('bitget-api-key-detail');
            const secretKeyInput = document.getElementById('bitget-secret-key-detail');
            const passphraseInput = document.getElementById('bitget-passphrase-detail');

            const apiKey = apiKeyInput?.value.trim();
            const secretKey = secretKeyInput?.value.trim();
            const passphrase = passphraseInput?.value.trim();

            if (!apiKey || !secretKey || !passphrase) {
                showSyncNotification('❌ Ingresa todas las credenciales', 'error');
                return;
            }

            try {
                const testAPI = window.FORCE_OFFLINE_BITGET ? new MockBitgetAPI() : new BitgetAPI(apiKey, secretKey, passphrase);
                const result = await testAPI.testConnection();

                showSyncNotification('✅ Conexión exitosa a Bitget', 'success');
                console.log('Test de conexión exitoso:', result);
            } catch (error) {
                console.error('Error en test de conexión:', error);
                showSyncNotification(`❌ Error: ${error.message}`, 'error');
            }
        });
    }

    // Event listener para botón Sincronizar Trades
    const syncBitgetTradesBtn = document.getElementById('sync-bitget-trades-detail');
    if (syncBitgetTradesBtn) {
        syncBitgetTradesBtn.addEventListener('click', async () => {
            await syncBitgetTrades();
        });
    }

    // Event listener para importar CSV desde panel de detalles
    const bitgetCsvBtn = document.getElementById('bitget-import-csv-btn');
    if (bitgetCsvBtn) {
        bitgetCsvBtn.addEventListener('click', async () => {
            const fileInput = document.getElementById('bitget-csv-file-input');
            const file = fileInput?.files[0];

            if (!file) {
                showSyncNotification('❌ Selecciona un archivo CSV primero', 'error');
                return;
            }

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    await processBitgetCSV(e.target.result);
                } catch (error) {
                    console.error('Error procesando CSV:', error);
                    showSyncNotification('❌ Error procesando CSV', 'error');
                }
            };
            reader.readAsText(file);
        });
    }

    // Event listener para botón Volver de BingX
    const bingxBackBtn = document.getElementById('back-to-platforms-bingx');
    if (bingxBackBtn) {
        bingxBackBtn.addEventListener('click', () => {
            showSection('platforms');
        });
    }

    // Event listener para botón Volver de Bitget
    const bitgetBackBtn = document.getElementById('back-to-platforms-bitget');
    if (bitgetBackBtn) {
        bitgetBackBtn.addEventListener('click', () => {
            showSection('platforms');
        });
    }

    // ============================================
    // BINGX - EVENT LISTENER GUARDAR CREDENCIALES
    // ============================================
    
    const saveBingXCredentialsBtn = document.getElementById('save-bingx-credentials');
    if (saveBingXCredentialsBtn) {
        saveBingXCredentialsBtn.addEventListener('click', async () => {
            const apiKeyInput = document.getElementById('bingx-api-key-detail');
            const secretKeyInput = document.getElementById('bingx-secret-key-detail');
            const accountSelect = document.getElementById('bingx-account-detail');

            const apiKey = apiKeyInput?.value.trim();
            const secretKey = secretKeyInput?.value.trim();
            const accountId = accountSelect?.value;

            if (!apiKey || !secretKey) {
                showSyncNotification('❌ Ingresa API Key y Secret', 'error');
                return;
            }

            if (!accountId) {
                showSyncNotification('❌ Selecciona una cuenta', 'error');
                return;
            }

            try {
                // 1. Guardar en Supabase PRIMERO
                if (currentUser) {
                    try {
                        console.log('💾 Guardando credenciales BingX en Supabase...');
                        await saveBingXCredentialsToSupabase(apiKey, secretKey, accountId);
                        console.log('✅ Credenciales BingX guardadas en Supabase');
                    } catch (error) {
                        console.error('⚠️ Error guardando credenciales en Supabase:', error);
                        showSyncNotification('⚠️ Error guardando en Supabase: ' + error.message, 'error');
                        return;
                    }
                } else {
                    showSyncNotification('⚠️ Debes iniciar sesión para guardar credenciales', 'error');
                    return;
                }

                // 2. Guardar en localStorage
                localStorage.setItem('bingx_api_key', apiKey);
                localStorage.setItem('bingx_api_secret', secretKey);
                localStorage.setItem('bingx_account_id', accountId);

                // 3. Guardar en IndexedDB
                const credentials = {
                    id: 'bingx',
                    key: apiKey,
                    secret: secretKey,
                    accountId: accountId,
                    platform: 'bingx'
                };
                DB.apiKeys.bingx = credentials;
                await dexieDB.apiKeys.put(credentials);

                // 4. Crear instancia de la API
                bingxAPI = new BingXAPI(apiKey, secretKey);

                // 5. Probar conexión automáticamente
                try {
                    console.log('🔌 Probando conexión con BingX...');
                    await bingxAPI.testConnection();
                    showSyncNotification('✅ Credenciales guardadas y conexión verificada', 'success');
                    updateBingXStatus('connected', 'Conectado ✓', false);
                } catch (testError) {
                    console.error('⚠️ Error probando conexión:', testError);
                    showSyncNotification('⚠️ Credenciales guardadas pero conexión falló: ' + testError.message, 'warning');
                    updateBingXStatus('warning', 'Guardado - Conexión fallida', false);
                }
            } catch (error) {
                console.error('Error guardando credenciales:', error);
                showSyncNotification('❌ Error: ' + error.message, 'error');
            }
        });
    }

    // ============================================
    // MEXC - EVENT LISTENER GUARDAR CREDENCIALES
    // ============================================
    
    const saveMEXCCredentialsBtn = document.getElementById('save-mexc-credentials');
    if (saveMEXCCredentialsBtn) {
        saveMEXCCredentialsBtn.addEventListener('click', async () => {
            const apiKeyInput = document.getElementById('mexc-api-key-detail');
            const secretKeyInput = document.getElementById('mexc-secret-key-detail');
            const accountSelect = document.getElementById('mexc-account-detail');

            const apiKey = apiKeyInput?.value.trim();
            const secretKey = secretKeyInput?.value.trim();
            const accountId = accountSelect?.value;

            if (!apiKey || !secretKey) {
                showSyncNotification('❌ Ingresa API Key y Secret', 'error');
                return;
            }

            if (!accountId) {
                showSyncNotification('❌ Selecciona una cuenta', 'error');
                return;
            }

            try {
                // 1. Guardar en Supabase PRIMERO
                if (currentUser) {
                    try {
                        console.log('💾 Guardando credenciales MEXC en Supabase...');
                        await saveMEXCCredentialsToSupabase(apiKey, secretKey, accountId);
                        console.log('✅ Credenciales MEXC guardadas en Supabase');
                    } catch (error) {
                        console.error('⚠️ Error guardando credenciales en Supabase:', error);
                        showSyncNotification('⚠️ Error guardando en Supabase: ' + error.message, 'error');
                        return;
                    }
                } else {
                    showSyncNotification('⚠️ Debes iniciar sesión para guardar credenciales', 'error');
                    return;
                }

                // 2. Guardar en localStorage
                localStorage.setItem('mexc_api_key', apiKey);
                localStorage.setItem('mexc_api_secret', secretKey);
                localStorage.setItem('mexc_account_id', accountId);

                // 3. Guardar en IndexedDB
                const credentials = {
                    id: 'mexc',
                    key: apiKey,
                    secret: secretKey,
                    accountId: accountId,
                    platform: 'mexc'
                };
                DB.apiKeys.mexc = credentials;
                await dexieDB.apiKeys.put(credentials);

                // 4. Crear instancia de la API
                mexcAPI = new MEXCAPI(apiKey, secretKey);

                // 5. Probar conexión automáticamente
                try {
                    console.log('🔌 Probando conexión con MEXC...');
                    await mexcAPI.testConnection();
                    showSyncNotification('✅ Credenciales guardadas y conexión verificada', 'success');
                    updateMEXCStatus('connected', 'Conectado ✓', false);
                } catch (testError) {
                    console.error('⚠️ Error probando conexión:', testError);
                    
                    // Mostrar mensaje específico para errores conocidos
                    let errorMessage = testError.message;
                    if (errorMessage.includes('IP NO AUTORIZADA')) {
                        // Ya viene formateado desde testConnection
                        showSyncNotification(errorMessage, 'warning', 15000);
                    } else {
                        showSyncNotification('⚠️ Credenciales guardadas pero conexión falló: ' + errorMessage, 'warning');
                    }
                    updateMEXCStatus('warning', 'Guardado - Conexión fallida', false);
                }
            } catch (error) {
                console.error('Error guardando credenciales:', error);
                showSyncNotification('❌ Error: ' + error.message, 'error');
            }
        });
    }

    // ============================================
    // MEXC API Event Listeners (CONSOLIDADO)
    // ============================================

    // Inicializar MEXC
    console.log('🔍 Inicializando MEXC...');

    // Cargar credenciales de MEXC con delay para asegurar que DB esté lista
    setTimeout(() => {
        loadMEXCCredentials().catch(err => {
            console.warn('No se pudieron cargar credenciales de MEXC:', err);
        });
        populateMEXCAccountSelect();
    }, 1000);

    // Event listeners para MEXC
    const testMexcBtn = document.getElementById('test-mexc-connection-detail');
    const connectMexcBtn = document.getElementById('connect-mexc-detail');
    const syncMexcBtn = document.getElementById('sync-mexc-trades-detail');
    const disconnectMexcBtn = document.getElementById('disconnect-mexc-detail');

    console.log('🔍 Botones MEXC encontrados:', {
        test: !!testMexcBtn,
        connect: !!connectMexcBtn,
        sync: !!syncMexcBtn,
        disconnect: !!disconnectMexcBtn
    });

    if (testMexcBtn) {
        testMexcBtn.addEventListener('click', async () => {
            console.log('🔘 Click en Test MEXC');
            await testMEXCConnection();
        });
    }
    
    if (connectMexcBtn) {
        connectMexcBtn.addEventListener('click', async () => {
            console.log('🔘 Click en Connect MEXC');
            await connectMEXC();
        });
    }
    
    if (syncMexcBtn) {
        syncMexcBtn.addEventListener('click', async () => {
            console.log('🔘 Click en Sync MEXC');
            await syncMEXCTrades();
        });
    }
    
    if (disconnectMexcBtn) {
        disconnectMexcBtn.addEventListener('click', () => {
            console.log('🔘 Click en Disconnect MEXC');
            disconnectMEXC();
        });
    }
    // MEXC CSV Import
    const mexcCsvBtn = document.getElementById('mexc-import-csv-btn');
    if (mexcCsvBtn) {
        mexcCsvBtn.addEventListener('click', async () => {
            const fileInput = document.getElementById('mexc-csv-file-input');
            const statusDiv = document.getElementById('mexc-csv-import-status');

            if (!fileInput.files[0]) {
                statusDiv.textContent = 'Por favor selecciona un archivo CSV';
                statusDiv.className = 'text-sm text-negative';
                return;
            }

            try {
                statusDiv.textContent = 'Procesando archivo...';
                statusDiv.className = 'text-sm text-blue-400';

                const file = fileInput.files[0];
                const csvContent = await file.text();
                await processMEXCCSV(csvContent);

                statusDiv.textContent = '✅ CSV importado exitosamente';
                statusDiv.className = 'text-sm text-positive';
                fileInput.value = '';

                // Actualizar historial
                updateMEXCImportHistory();

            } catch (error) {
                console.error('Error procesando CSV de MEXC:', error);
                statusDiv.textContent = `❌ Error: ${error.message}`;
                statusDiv.className = 'text-sm text-negative';
            }
        });
    }

    // Botón back de MEXC
    const mexcBackBtn = document.getElementById('back-to-platforms-mexc');
    if (mexcBackBtn) {
        mexcBackBtn.addEventListener('click', () => {
            showSection('platforms');
        });
    }

    const ctraderBackBtn = document.getElementById('back-to-platforms-ctrader');
    if (ctraderBackBtn) {
        ctraderBackBtn.addEventListener('click', () => {
            showSection('platforms');
        });
    }

    // Botón back de Bitunix
    const bitunixBackBtn = document.getElementById('back-to-platforms-bitunix');
    if (bitunixBackBtn) {
        bitunixBackBtn.addEventListener('click', () => {
            showSection('platforms');
        });
    }

    // Botón back de LBank
    const lbankBackBtn = document.getElementById('back-to-platforms-lbank');
    if (lbankBackBtn) {
        lbankBackBtn.addEventListener('click', () => {
            showSection('platforms');
        });
    }

    // Botón back de BloFin
    const blofinBackBtn = document.getElementById('back-to-platforms-blofin');
    if (blofinBackBtn) {
        blofinBackBtn.addEventListener('click', () => {
            showSection('platforms');
        });
    }

    // ============================================
    // BITUNIX API Event Listeners
    // ============================================

    const saveBitunixCredentialsBtn = document.getElementById('save-bitunix-credentials');
    if (saveBitunixCredentialsBtn) {
        saveBitunixCredentialsBtn.addEventListener('click', async () => {
            const apiKeyInput = document.getElementById('bitunix-api-key-detail');
            const secretKeyInput = document.getElementById('bitunix-secret-key-detail');
            const accountSelect = document.getElementById('bitunix-account-detail');

            const apiKey = apiKeyInput?.value.trim();
            const secretKey = secretKeyInput?.value.trim();
            const accountId = accountSelect?.value;

            if (!apiKey || !secretKey) {
                showSyncNotification('❌ Ingresa API Key y Secret', 'error');
                return;
            }

            if (!accountId) {
                showSyncNotification('❌ Selecciona una cuenta', 'error');
                return;
            }

            try {
                // Guardar en localStorage
                localStorage.setItem('bitunix_api_key', apiKey);
                localStorage.setItem('bitunix_secret_key', secretKey);
                localStorage.setItem('bitunix_account_id', accountId);

                // Guardar en IndexedDB
                const credentials = {
                    id: 'bitunix',
                    key: apiKey,
                    secret: secretKey,
                    accountId: accountId,
                    platform: 'bitunix'
                };
                DB.apiKeys.bitunix = credentials;
                await dexieDB.apiKeys.put(credentials);

                // Crear instancia de la API
                bitunixAPI = new BitunixAPI(apiKey, secretKey);

                showSyncNotification('✅ Credenciales de Bitunix guardadas', 'success');
            } catch (error) {
                console.error('Error guardando credenciales Bitunix:', error);
                showSyncNotification('❌ Error: ' + error.message, 'error');
            }
        });
    }

    const testBitunixBtn = document.getElementById('test-bitunix-connection-detail');
    if (testBitunixBtn) {
        testBitunixBtn.addEventListener('click', async () => {
            if (!bitunixAPI) {
                showSyncNotification('❌ Configura y guarda las credenciales primero', 'error');
                return;
            }

            try {
                testBitunixBtn.disabled = true;
                testBitunixBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>Probando...';
                
                await bitunixAPI.testConnection();
                showSyncNotification('✅ Conexión exitosa con Bitunix', 'success');
            } catch (error) {
                console.error('Error probando conexión Bitunix:', error);
                showSyncNotification('❌ Error: ' + error.message, 'error');
            } finally {
                testBitunixBtn.disabled = false;
                testBitunixBtn.innerHTML = '<i class="fas fa-plug mr-2"></i>Probar Conexión';
            }
        });
    }

    const syncBitunixBtn = document.getElementById('sync-bitunix-trades-detail');
    if (syncBitunixBtn) {
        syncBitunixBtn.addEventListener('click', async () => {
            if (!bitunixAPI) {
                showSyncNotification('❌ Configura las credenciales primero', 'error');
                showPlatformDetail('bitunix');
                return;
            }
            
            syncBitunixBtn.disabled = true;
            syncBitunixBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>Sincronizando...';
            
            try {
                await syncBitunixTrades();
            } finally {
                syncBitunixBtn.disabled = false;
                syncBitunixBtn.innerHTML = '<i class="fas fa-sync-alt mr-2"></i>Sincronizar Trades';
            }
        });
    }

    const disconnectBitunixBtn = document.getElementById('disconnect-bitunix-detail');
    if (disconnectBitunixBtn) {
        disconnectBitunixBtn.addEventListener('click', () => {
            if (confirm('¿Eliminar credenciales de Bitunix?')) {
                localStorage.removeItem('bitunix_api_key');
                localStorage.removeItem('bitunix_secret_key');
                localStorage.removeItem('bitunix_account_id');
                
                if (dexieDB && dexieDB.apiKeys) {
                    dexieDB.apiKeys.delete('bitunix');
                }
                
                bitunixAPI = null;
                DB.apiKeys.bitunix = null;
                
                document.getElementById('bitunix-api-key-detail').value = '';
                document.getElementById('bitunix-secret-key-detail').value = '';
                document.getElementById('bitunix-account-detail').value = '';
                
                showSyncNotification('✅ Credenciales de Bitunix eliminadas', 'success');
            }
        });
    }

    const bitunixCsvBtn = document.getElementById('bitunix-import-csv-btn-detail');
    if (bitunixCsvBtn) {
        bitunixCsvBtn.addEventListener('click', () => {
            importBitunixCSV();
        });
    }

    // ============================================
    // LBANK API Event Listeners
    // ============================================

    const saveLBankCredentialsBtn = document.getElementById('save-lbank-credentials');
    if (saveLBankCredentialsBtn) {
        saveLBankCredentialsBtn.addEventListener('click', async () => {
            const apiKeyInput = document.getElementById('lbank-api-key-detail');
            const privateKeyInput = document.getElementById('lbank-private-key-detail');
            const accountSelect = document.getElementById('lbank-account-detail');

            const apiKey = apiKeyInput?.value.trim();
            const privateKey = privateKeyInput?.value.trim();
            const accountId = accountSelect?.value;

            if (!apiKey || !privateKey) {
                showSyncNotification('❌ Ingresa API Key y Private Key', 'error');
                return;
            }

            if (!accountId) {
                showSyncNotification('❌ Selecciona una cuenta', 'error');
                return;
            }

            try {
                // Guardar en localStorage
                localStorage.setItem('lbank_api_key', apiKey);
                localStorage.setItem('lbank_private_key', privateKey);
                localStorage.setItem('lbank_account_id', accountId);

                // Guardar en IndexedDB
                const credentials = {
                    id: 'lbank',
                    key: apiKey,
                    secret: privateKey, // Store private key as 'secret' for consistency
                    accountId: accountId,
                    platform: 'lbank'
                };
                DB.apiKeys.lbank = credentials;
                await dexieDB.apiKeys.put(credentials);

                // Crear instancia de la API
                lbankAPI = new LBankAPI(apiKey, privateKey);

                showSyncNotification('✅ Credenciales de LBank guardadas', 'success');
            } catch (error) {
                console.error('Error guardando credenciales LBank:', error);
                showSyncNotification('❌ Error: ' + error.message, 'error');
            }
        });
    }

    const testLBankBtn = document.getElementById('test-lbank-connection-detail');
    if (testLBankBtn) {
        testLBankBtn.addEventListener('click', async () => {
            if (!lbankAPI) {
                showSyncNotification('❌ Configura y guarda las credenciales primero', 'error');
                return;
            }

            try {
                testLBankBtn.disabled = true;
                testLBankBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>Probando...';
                
                await lbankAPI.testConnection();
                showSyncNotification('✅ Conexión exitosa con LBank', 'success');
            } catch (error) {
                console.error('Error probando conexión LBank:', error);
                showSyncNotification('❌ Error: ' + error.message, 'error');
            } finally {
                testLBankBtn.disabled = false;
                testLBankBtn.innerHTML = '<i class="fas fa-plug mr-2"></i>Probar Conexión';
            }
        });
    }

    const syncLBankBtn = document.getElementById('sync-lbank-trades-detail');
    if (syncLBankBtn) {
        syncLBankBtn.addEventListener('click', async () => {
            if (!lbankAPI) {
                showSyncNotification('❌ Configura las credenciales primero', 'error');
                showPlatformDetail('lbank');
                return;
            }
            
            syncLBankBtn.disabled = true;
            syncLBankBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>Sincronizando...';
            
            try {
                await syncLBankTrades();
            } finally {
                syncLBankBtn.disabled = false;
                syncLBankBtn.innerHTML = '<i class="fas fa-sync-alt mr-2"></i>Sincronizar Trades';
            }
        });
    }

    const disconnectLBankBtn = document.getElementById('disconnect-lbank-detail');
    if (disconnectLBankBtn) {
        disconnectLBankBtn.addEventListener('click', () => {
            if (confirm('¿Eliminar credenciales de LBank?')) {
                localStorage.removeItem('lbank_api_key');
                localStorage.removeItem('lbank_private_key');
                localStorage.removeItem('lbank_account_id');
                
                if (dexieDB && dexieDB.apiKeys) {
                    dexieDB.apiKeys.delete('lbank');
                }
                
                lbankAPI = null;
                DB.apiKeys.lbank = null;
                
                document.getElementById('lbank-api-key-detail').value = '';
                document.getElementById('lbank-private-key-detail').value = '';
                document.getElementById('lbank-account-detail').value = '';
                
                showSyncNotification('✅ Credenciales de LBank eliminadas', 'success');
            }
        });
    }

    const lbankCsvBtn = document.getElementById('lbank-import-csv-btn-detail');
    if (lbankCsvBtn) {
        lbankCsvBtn.addEventListener('click', () => {
            importLBankCSV();
        });
    }

    // ============================================
    // BLOFIN API Event Listeners
    // ============================================

    const saveBloFinCredentialsBtn = document.getElementById('save-blofin-credentials');
    if (saveBloFinCredentialsBtn) {
        saveBloFinCredentialsBtn.addEventListener('click', async () => {
            const apiKeyInput = document.getElementById('blofin-api-key-detail');
            const secretKeyInput = document.getElementById('blofin-secret-key-detail');
            const passphraseInput = document.getElementById('blofin-passphrase-detail');
            const accountSelect = document.getElementById('blofin-account-detail');

            const apiKey = apiKeyInput?.value.trim();
            const secretKey = secretKeyInput?.value.trim();
            const passphrase = passphraseInput?.value.trim();
            const accountId = accountSelect?.value;

            if (!apiKey || !secretKey || !passphrase) {
                showSyncNotification('❌ Ingresa API Key, Secret y Passphrase', 'error');
                return;
            }

            if (!accountId) {
                showSyncNotification('❌ Selecciona una cuenta', 'error');
                return;
            }

            try {
                // Guardar en localStorage
                localStorage.setItem('blofin_api_key', apiKey);
                localStorage.setItem('blofin_secret_key', secretKey);
                localStorage.setItem('blofin_passphrase', passphrase);
                localStorage.setItem('blofin_account_id', accountId);

                // Guardar en IndexedDB
                const credentials = {
                    id: 'blofin',
                    key: apiKey,
                    secret: secretKey,
                    passphrase: passphrase,
                    accountId: accountId,
                    platform: 'blofin'
                };
                DB.apiKeys.blofin = credentials;
                await dexieDB.apiKeys.put(credentials);

                // Crear instancia de la API (cuando se implemente)
                // blofinAPI = new BloFinAPI(apiKey, secretKey, passphrase);

                showSyncNotification('✅ Credenciales de BloFin guardadas', 'success');
            } catch (error) {
                console.error('Error guardando credenciales BloFin:', error);
                showSyncNotification('❌ Error: ' + error.message, 'error');
            }
        });
    }

    const testBloFinBtn = document.getElementById('test-blofin-connection-detail');
    if (testBloFinBtn) {
        testBloFinBtn.addEventListener('click', async () => {
            if (!blofinAPI) {
                showSyncNotification('❌ Configura y guarda las credenciales primero', 'error');
                return;
            }

            try {
                testBloFinBtn.disabled = true;
                testBloFinBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>Probando...';
                
                // await blofinAPI.testConnection();
                showSyncNotification('✅ BloFin: Función en desarrollo', 'info');
            } catch (error) {
                console.error('Error probando conexión BloFin:', error);
                showSyncNotification('❌ Error: ' + error.message, 'error');
            } finally {
                testBloFinBtn.disabled = false;
                testBloFinBtn.innerHTML = '<i class="fas fa-plug mr-2"></i>Probar Conexión';
            }
        });
    }

    const syncBloFinBtn = document.getElementById('sync-blofin-trades-detail');
    if (syncBloFinBtn) {
        syncBloFinBtn.addEventListener('click', async () => {
            if (!blofinAPI && !DB.apiKeys.blofin) {
                showSyncNotification('❌ Configura las credenciales primero', 'error');
                showPlatformDetail('blofin');
                return;
            }
            
            syncBloFinBtn.disabled = true;
            syncBloFinBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>Sincronizando...';
            
            try {
                await syncBloFinTrades();
            } finally {
                syncBloFinBtn.disabled = false;
                syncBloFinBtn.innerHTML = '<i class="fas fa-sync-alt mr-2"></i>Sincronizar Trades';
            }
        });
    }

    const disconnectBloFinBtn = document.getElementById('disconnect-blofin-detail');
    if (disconnectBloFinBtn) {
        disconnectBloFinBtn.addEventListener('click', () => {
            if (confirm('¿Eliminar credenciales de BloFin?')) {
                localStorage.removeItem('blofin_api_key');
                localStorage.removeItem('blofin_secret_key');
                localStorage.removeItem('blofin_passphrase');
                localStorage.removeItem('blofin_account_id');
                
                if (dexieDB && dexieDB.apiKeys) {
                    dexieDB.apiKeys.delete('blofin');
                }
                
                blofinAPI = null;
                DB.apiKeys.blofin = null;
                
                document.getElementById('blofin-api-key-detail').value = '';
                document.getElementById('blofin-secret-key-detail').value = '';
                document.getElementById('blofin-passphrase-detail').value = '';
                document.getElementById('blofin-account-detail').value = '';
                
                showSyncNotification('✅ Credenciales de BloFin eliminadas', 'success');
            }
        });
    }

    const blofinCsvBtn = document.getElementById('blofin-import-csv-btn-detail');
    if (blofinCsvBtn) {
        blofinCsvBtn.addEventListener('click', () => {
            importBloFinCSV();
        });
    }

    // ============================================
    // MEXC API Event Listeners
    // ============================================

    // Cargar credenciales al inicio
    console.log('🔄 Cargando credenciales de Bitget al iniciar...');
    loadBitgetCredentials();

    // OBSERVER PARA RECARGAR CREDENCIALES CUANDO LOS CAMPOS SE HAGAN VISIBLES
    const observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
            if (mutation.type === 'attributes' || mutation.type === 'childList') {
                // Verificar si algún campo de BingX se hizo visible
                const bingxFields = [
                    'bingx-api-key-detail',
                    'bingx-secret-key-detail',
                    'bingx-api-key',
                    'bingx-api-secret'
                ];

                bingxFields.forEach(fieldId => {
                    const field = document.getElementById(fieldId);
                    if (field && field.offsetParent !== null && !field.value) {
                        console.log(`🔄 Campo ${fieldId} visible y vacío, recargando credenciales`);
                        setTimeout(() => {
                            loadBingXCredentials();
                            loadBingXCredentialsInDetail();
                        }, 100);
                    }
                });
            }
        });
    });

    // Observar cambios en todo el documento
    observer.observe(document.body, {
        childList: true,
        subtree: true,
        attributes: true,
        attributeFilter: ['style', 'class']
    });
});

// ===== AUTO-RELOAD DESACTIVADO PARA REDUCIR EGRESS =====
// FUNCIÓN ADICIONAL: Recargar credenciales cada 10 segundos como fallback
/*
setInterval(() => {
    const anyFieldEmpty = [
        'bingx-api-key-detail',
        'bingx-secret-key-detail',
        'bingx-api-key',
        'bingx-api-secret'
    ].some(fieldId => {
        const field = document.getElementById(fieldId);
        return field && field.offsetParent !== null && !field.value;
    });

    if (anyFieldEmpty) {
        console.log('🔄 Fallback: recargando credenciales por campos vacíos');
        loadBingXCredentials();
        loadBingXCredentialsInDetail();
    }
}, 10000); // Cada 10 segundos
*/

// Función para configurar sincronización automática manual
function startBingXAutoSync(intervalMinutes = 30) {
    // ===== SINCRONIZACIÓN AUTOMÁTICA DESACTIVADA =====
    // Solo sincronización MANUAL para reducir Egress de Supabase
    console.log('⚠️ Sincronización automática de BingX desactivada. Use sincronización manual.');
    showSyncNotification('ℹ️ Sincronización automática desactivada. Use el botón de sincronización manual.', 'info');
    
    // NO iniciar el intervalo automático
    /* CÓDIGO DESACTIVADO
    if (window.bingxAutoSyncInterval) {
        clearInterval(window.bingxAutoSyncInterval);
    }

    window.bingxAutoSyncInterval = setInterval(async () => {
        if (bingxAPI && DB.apiKeys.bingx && DB.apiKeys.bingx.key) {
            console.log('🔄 Sincronización automática BingX...');
            await syncBingXTrades();
        }
    }, intervalMinutes * 60 * 1000);

    showSyncNotification(`✅ Sincronización automática activada cada ${intervalMinutes} minutos`, 'success');
    */
}

function stopBingXAutoSync() {
    if (window.bingxAutoSyncInterval) {
        clearInterval(window.bingxAutoSyncInterval);
        window.bingxAutoSyncInterval = null;
        showSyncNotification('⏸️ Sincronización automática desactivada', 'info');
    }
}

// =====================================================
// GESTIÓN DE PLATAFORMAS
// =====================================================

function initPlatforms() {
    console.log('🚀 Iniciando initPlatforms...');
    
    // Event listeners para las tarjetas de plataformas
    const platformCards = document.querySelectorAll('.platform-card:not(.disabled)');
    console.log('📱 Tarjetas encontradas:', platformCards.length);
    
    platformCards.forEach(card => {
        const platform = card.dataset.platform;
        console.log('🔗 Agregando listener a:', platform);
        
        card.addEventListener('click', function() {
            console.log('🎯 Click en plataforma:', platform);
            
            if (platform === 'bingx') {
                showPlatformDetail('bingx');
            } else if (platform === 'bitget') {
                showPlatformDetail('bitget');
            } else if (platform === 'mexc') {
                showPlatformDetail('mexc');
            } else if (platform === 'bitunix') {
                showPlatformDetail('bitunix');
            } else if (platform === 'lbank') {
                showPlatformDetail('lbank');
            } else if (platform === 'blofin') {
                showPlatformDetail('blofin');
            } else if (platform === 'tradingview') {
                showPlatformDetail('tradingview');
            } else if (platform === 'ninjatrader') {
                showPlatformDetail('ninjatrader');
            } else if (platform === 'tradovate') {
                showPlatformDetail('tradovate');
            } else if (platform === 'ctrader') {
                // showPlatformDetail('ctrader'); // DESHABILITADO - Ahora se usa botón HTML directo
                showSyncNotification('✅ cTrader: Usa el botón HTML para importar operaciones', 'info');
            } else if (platform === 'primexbtcrypto') {
                showSyncNotification('PrimeXBT Crypto: Usa los botones CSV o Interfaz para importar operaciones', 'info');
            } else if (platform === 'primexbtcfds') {
                showSyncNotification('PrimeXBT CFDs: Usa el botón CSV para importar operaciones', 'info');
            } else if (platform === 'metatrader5') {
                showSyncNotification('MetaTrader 5: Usa el botón HTML para importar operaciones', 'info');
            } else {
                showSyncNotification('Esta plataforma estará disponible próximamente', 'info');
            }
        });
    });

    console.log('✅ initPlatforms completado');
    
    // Inicializar tabs de plataformas con mensaje de confirmación visual
    console.log('🔧 Llamando a window.initPlatformTabs()...');
    window.initPlatformTabs();
    
    // Verificar que los tabs se inicializaron correctamente
    const tabCount = document.querySelectorAll('.platform-tab').length;
    console.log(`✅ ${tabCount} botones de pestañas inicializados`);
    
    // Mostrar notificación de debug en consola
    setTimeout(() => {
        console.log('📢 SISTEMA DE PESTAÑAS ACTIVADO - Si no funcionan las pestañas, abre la consola (F12) y reporta los mensajes');
    }, 1000);

    // Botón de regreso a plataformas (funciona para todas las plataformas)
    const backButtons = document.querySelectorAll('[id^="back-to-platforms"]');
    backButtons.forEach(btn => {
        btn.addEventListener('click', function() {
            showSection('platforms');
        });
    });

    // Duplicar funcionalidad de BingX para la nueva interfaz
    updateAccountSelect('bingx-account-detail');

    // Event listeners para botones de BingX en la nueva interfaz
    const testBtn = document.getElementById('test-bingx-connection-detail');
    const testAuthBtn = document.getElementById('test-auth-only');
    const connectBtn = document.getElementById('connect-bingx-detail');
    const syncBtn = document.getElementById('sync-bingx-trades-detail');

    if (testBtn) testBtn.addEventListener('click', testBingXConnection);
    if (testAuthBtn) testAuthBtn.addEventListener('click', testBingXAuth);
    if (connectBtn) connectBtn.addEventListener('click', connectBingX);
    if (syncBtn) syncBtn.addEventListener('click', syncBingXTrades);

    // Event listener para el botón CSV en la página de configuración
    const bingxCsvBtn = document.getElementById('bingx-import-csv-btn');
    if (bingxCsvBtn) {
        bingxCsvBtn.addEventListener('click', async () => {
            const fileInput = document.getElementById('bingx-csv-file-input');
            const statusDiv = document.getElementById('bingx-csv-import-status');

            if (!fileInput.files[0]) {
                statusDiv.textContent = 'Por favor selecciona un archivo CSV';
                statusDiv.className = 'text-sm text-negative';
                return;
            }

            try {
                statusDiv.textContent = 'Procesando archivo...';
                statusDiv.className = 'text-sm text-blue-400';

                const file = fileInput.files[0];
                await processCSVFile(file, statusDiv);

                statusDiv.textContent = 'CSV importado exitosamente';
                statusDiv.className = 'text-sm text-positive';
                fileInput.value = '';
            } catch (error) {
                console.error('Error procesando CSV:', error);
                statusDiv.textContent = `Error: ${error.message}`;
                statusDiv.className = 'text-sm text-negative';
            }
        });
    }

    // Cargar credenciales en la nueva interfaz
    loadBingXCredentialsInDetail();

    // Sincronizar datos entre las dos interfaces
    syncBingXData();

    // Event listener para CSV de MEXC
    const mexcCsvBtn = document.getElementById('mexc-import-csv-btn');
    if (mexcCsvBtn) {
        mexcCsvBtn.addEventListener('click', async () => {
            const fileInput = document.getElementById('mexc-csv-file-input');
            const statusDiv = document.getElementById('mexc-csv-import-status');

            if (!fileInput.files[0]) {
                statusDiv.textContent = 'Por favor selecciona un archivo CSV';
                statusDiv.className = 'text-sm text-negative';
                return;
            }

            try {
                statusDiv.textContent = 'Procesando archivo...';
                statusDiv.className = 'text-sm text-blue-400';

                const file = fileInput.files[0];
                await processCSVFile(file, statusDiv);

                statusDiv.textContent = 'CSV importado exitosamente';
                statusDiv.className = 'text-sm text-positive';
                fileInput.value = '';
            } catch (error) {
                console.error('Error procesando CSV:', error);
                statusDiv.textContent = `Error: ${error.message}`;
                statusDiv.className = 'text-sm text-negative';
            }
        });
    }

    console.log('✅ MEXC inicializado');
}

console.log('📢 ===== DEFINIENDO FUNCIONES GLOBALES DE PESTAÑAS =====');

// Inicializar tabs de plataformas - DEFINIR EN SCOPE GLOBAL
window.initPlatformTabs = function() {
    console.log('🔧 Iniciando window.initPlatformTabs...');
    console.log('📍 Función llamada desde:', new Error().stack.split('\n')[2]);
    
    // Obtener todos los botones de tab
    const tabButtons = document.querySelectorAll('.platform-tab');
    console.log(`📊 Encontrados ${tabButtons.length} botones de tab`);
    
    // Remover event listeners previos (si existen)
    tabButtons.forEach(button => {
        const newButton = button.cloneNode(true);
        button.parentNode.replaceChild(newButton, button);
    });
    
    // Obtener los nuevos botones después de clonar
    const newTabButtons = document.querySelectorAll('.platform-tab');
    
    newTabButtons.forEach(button => {
        button.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            
            const targetTab = this.dataset.tab;
            console.log('🖱️ CLICK EN TAB:', targetTab);
            
            const section = this.closest('section');
            if (!section) {
                console.error('❌ No se encontró section padre');
                return;
            }
            
            const platformId = section.id.replace('platform-', '');
            console.log(`🎯 Plataforma: ${platformId}, Tab destino: ${targetTab}`);
            
            // Desactivar todos los tabs
            section.querySelectorAll('.platform-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Activar el tab clickeado
            this.classList.add('active');
            
            // Ocultar TODO el contenido
            section.querySelectorAll('.platform-tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // Mostrar el contenido correcto
            const targetContentId = `${platformId}-tab-${targetTab}`;
            const targetContent = document.getElementById(targetContentId);
            
            console.log(`🔍 Buscando: #${targetContentId}`);
            console.log('📦 Elemento encontrado:', targetContent);
            
            if (targetContent) {
                targetContent.classList.add('active');
                console.log('✅✅✅ TAB CAMBIADO EXITOSAMENTE A:', targetTab);
            } else {
                console.error('❌ NO SE ENCONTRÓ:', targetContentId);
                const allContentIds = Array.from(section.querySelectorAll('.platform-tab-content')).map(c => c.id);
                console.log('📋 IDs disponibles:', allContentIds);
            }
        });
    });
    
    console.log('✅ initPlatformTabs completado con', newTabButtons.length, 'tabs');
};

console.log('✅ window.initPlatformTabs DEFINIDA');
console.log('🔍 Verificación: typeof window.initPlatformTabs =', typeof window.initPlatformTabs);

// Alias para compatibilidad
initPlatformTabs = window.initPlatformTabs;
console.log('✅ Alias initPlatformTabs creado');
console.log('📢 ===== FIN DEFINICIÓN FUNCIONES PESTAÑAS =====');

// Función de debug global para testear pestañas manualmente
window.testPlatformTabs = function() {
    console.log('🧪 TEST DE PESTAÑAS INICIADO');
    console.log('='.repeat(50));
    
    const allTabs = document.querySelectorAll('.platform-tab');
    console.log(`📊 Total de botones encontrados: ${allTabs.length}`);
    
    const activeSections = document.querySelectorAll('section.section-container.active');
    console.log(`👁️ Secciones activas: ${activeSections.length}`);
    activeSections.forEach(section => {
        console.log(`  - ${section.id}`);
        const tabs = section.querySelectorAll('.platform-tab');
        const contents = section.querySelectorAll('.platform-tab-content');
        console.log(`    Tabs: ${tabs.length}, Contenidos: ${contents.length}`);
        contents.forEach(content => {
            const isActive = content.classList.contains('active');
            const display = window.getComputedStyle(content).display;
            console.log(`    - ${content.id}: active=${isActive}, display=${display}`);
        });
    });
    
    console.log('='.repeat(50));
    console.log('💡 Para re-inicializar: initPlatformTabs()');
};

// Auto-ejecutar test al cargar
setTimeout(() => {
    console.log('🔍 Ejecutando test automático de pestañas...');
    console.log('🔍 window.testPlatformTabs existe:', typeof window.testPlatformTabs);
    console.log('🔍 window.initPlatformTabs existe:', typeof window.initPlatformTabs);
    if (window.testPlatformTabs) window.testPlatformTabs();
    
    // Forzar inicialización si no se ha hecho
    if (typeof window.initPlatformTabs === 'function') {
        const tabCount = document.querySelectorAll('.platform-tab').length;
        if (tabCount > 0) {
            console.log('🔧 Forzando inicialización de pestañas al cargar...');
            window.initPlatformTabs();
        }
    }
}, 2000);

function loadBingXCredentialsInDetail() {
    console.log('🔍 Cargando credenciales BingX en campos detallados...');

    // Primero intentar cargar desde localStorage
    const savedApiKey = localStorage.getItem('bingx-api-key');
    const savedSecretKey = localStorage.getItem('bingx-secret-key');
    const savedAccountId = localStorage.getItem('bingx-account-id');

    console.log('📁 Credenciales para campos detallados:', {
        apiKey: savedApiKey ? `${savedApiKey.substring(0, 10)}...` : 'No encontrada',
        secretKey: savedSecretKey ? `${savedSecretKey.substring(0, 10)}...` : 'No encontrada',
        accountId: savedAccountId || 'No encontrada'
    });

    // Configurar credenciales proporcionadas por el usuario como respaldo
    const providedApiKey = 'sw8hglph1M6HWzoqswDdjX7YTh3mcruPKynFi1ZBz8zDXCHxnEchw7oRWgYysFVLFuD7bkYomRHxSh8gdtNBg';
    const providedSecretKey = '7hUYF1GhJ6QixdE2mfDEdDMovcKVpUc3OnqbAfiAcbrT6XzFfMF4ywd0K06JgJCt0Zsa6MYxuSslDKr5XJfYA';

    const apiKeyDetailEl = document.getElementById('bingx-api-key-detail');
    const secretDetailEl = document.getElementById('bingx-secret-key-detail');
    const accountDetailEl = document.getElementById('bingx-account-detail');

    // Usar credenciales guardadas o las proporcionadas
    const apiKeyToUse = savedApiKey || providedApiKey;
    const secretKeyToUse = savedSecretKey || providedSecretKey;
    const accountIdToUse = savedAccountId || 'main';

    console.log('💾 Cargando credenciales en campos detallados...');

    if (apiKeyDetailEl) {
        apiKeyDetailEl.value = apiKeyToUse;
        apiKeyDetailEl.type = 'text'; // Hacer visible para edición si es necesario
        console.log('✅ API Key cargada en campo detallado');
    }
    if (secretDetailEl) {
        secretDetailEl.value = secretKeyToUse;
        secretDetailEl.type = 'text'; // Hacer visible para edición si es necesario
        console.log('✅ Secret Key cargada en campo detallado');
    }
    if (accountDetailEl) {
        accountDetailEl.value = accountIdToUse;
        console.log('✅ Account ID cargada en campo detallado');
    }

    // Actualizar DB si está disponible
    if (typeof DB !== 'undefined' && DB) {
        if (!DB.apiKeys) DB.apiKeys = {};
        DB.apiKeys.bingx = {
            key: apiKeyToUse,
            secret: secretKeyToUse,
            mode: 'real',
            accountId: accountIdToUse
        };
    }

    // También actualizar los campos básicos si existen
    const bingxApiKeyEl = document.getElementById('bingx-api-key');
    const bingxSecretEl = document.getElementById('bingx-api-secret');

    if (bingxApiKeyEl && !bingxApiKeyEl.value) {
        bingxApiKeyEl.value = apiKeyToUse;
        console.log('✅ API Key sincronizada con campo básico');
    }
    if (bingxSecretEl && !bingxSecretEl.value) {
        bingxSecretEl.value = secretKeyToUse;
        console.log('✅ Secret Key sincronizada con campo básico');
    }

    // Inicializar API automáticamente si hay credenciales
    if (apiKeyToUse && secretKeyToUse) {
        try {
            // Verificar que la clase BingXAPI esté definida
            if (typeof BingXAPI !== 'undefined') {
                bingxAPI = new BingXAPI(apiKeyToUse, secretKeyToUse);
                console.log('✅ BingX API inicializada automáticamente');
                // Poblar las cuentas cuando se inicializa la API
                populateBingXAccounts();
            } else {
                console.warn('⚠️ BingXAPI no está definida aún. Se inicializará más tarde.');
            }
        } catch (error) {
            console.error('❌ Error inicializando BingX API:', error);
        }
    }
}

function showPlatformDetail(platform) {
    // Ocultar TODAS las secciones primero
    document.querySelectorAll('.section-container').forEach(s => {
        s.classList.remove('active');
    });

    if (platform === 'bingx') {
        console.log('🎯 Abriendo sección BingX - recargando credenciales');

        // Cargar credenciales antes de mostrar la interfaz
        loadBingXCredentials();
        loadBingXCredentialsInDetail();

        // Poblar cuentas de BingX
        populateBingXAccounts();

        // Recargar credenciales después de un breve delay para asegurar que los campos estén listos
        setTimeout(() => {
            console.log('🔄 Recarga adicional de credenciales en BingX');
            loadBingXCredentials();
            loadBingXCredentialsInDetail();
        }, 500);

        // Sincronizar datos actuales
        syncBingXData();

        // Mostrar SOLO la sección de BingX
        document.getElementById('platform-bingx').classList.add('active');

        // Actualizar estado de la conexión después de cargar credenciales
        setTimeout(() => {
            updateBingXDetailStatus();
        }, 500);

    } else if (platform === 'bitget') {
        console.log('🎯 Abriendo sección Bitget - recargando credenciales');

        // Cargar credenciales antes de mostrar la interfaz y esperar a que termine
        loadBitgetCredentials()
            .then(() => {
                // Poblar cuentas de Bitget DESPUÉS de cargar credenciales
                console.log('✅ loadBitgetCredentials completado, poblando selector...');
                populateBitgetAccountSelect();
                console.log('✅ Credenciales y cuentas Bitget cargadas');
            })
            .catch((error) => {
                console.error('❌ Error en loadBitgetCredentials:', error);
            });

        // Recargar credenciales después de un breve delay para asegurar que los campos estén listos
        setTimeout(async () => {
            console.log('🔄 Recarga adicional de credenciales en Bitget (timeout 500ms)');
            try {
                await loadBitgetCredentials();
                console.log('✅ Recarga completada, poblando selector de nuevo...');
                populateBitgetAccountSelect();
            } catch (error) {
                console.error('❌ Error en recarga:', error);
            }
        }, 500);

        // Mostrar SOLO la sección de Bitget
        document.getElementById('platform-bitget').classList.add('active');

        console.log('✅ Panel de Bitget cargado');
    } else if (platform === 'mexc') {
        console.log('🎯 Abriendo sección MEXC');

        // Cargar credenciales de forma asíncrona
        loadMEXCCredentials().catch(err => {
            console.error('Error cargando credenciales MEXC:', err);
        });

        // Poblar cuentas
        populateMEXCAccountSelect();

        // Mostrar SOLO la sección de MEXC
        document.getElementById('platform-mexc').classList.add('active');

        console.log('✅ Panel de MEXC cargado');
    } else if (platform === 'tradingview') {
        console.log('🎯 Abriendo sección TradingView');

        // Cargar configuración de TradingView
        loadTradingViewConfig();

        // Poblar select de cuentas
        populateTradingViewAccountSelect();

        // Mostrar SOLO la sección de TradingView
        document.getElementById('platform-tradingview').classList.add('active');

        console.log('✅ Panel de TradingView cargado');
    } else if (platform === 'ninjatrader') {
        console.log('🎯 Abriendo sección NinjaTrader');

        // Cargar configuración de NinjaTrader
        loadNinjaTraderConfig();

        // Poblar select de cuentas
        populateNinjaTraderAccountSelect();

        // Mostrar SOLO la sección de NinjaTrader
        document.getElementById('platform-ninjatrader').classList.add('active');

        console.log('✅ Panel de NinjaTrader cargado');
    } else if (platform === 'tradovate') {
        console.log('🎯 Abriendo sección Tradovate');

        // Cargar configuración de Tradovate
        loadTradovateConfig();

        // Poblar select de cuentas
        populateTradovateAccountSelect();

        // Mostrar SOLO la sección de Tradovate
        document.getElementById('platform-tradovate').classList.add('active');

        console.log('✅ Panel de Tradovate cargado');
    } else if (platform === 'ctrader') {
        console.log('🎯 Abriendo sección cTrader');

        // Poblar select de cuentas
        populateCTraderAccountSelect();

        // Mostrar SOLO la sección de cTrader
        document.getElementById('platform-ctrader').classList.add('active');

        console.log('✅ Panel de cTrader cargado');
    } else if (platform === 'bitunix') {
        console.log('🎯 Abriendo sección Bitunix');

        // Cargar credenciales de forma asíncrona
        loadBitunixCredentials().catch(err => {
            console.error('Error cargando credenciales Bitunix:', err);
        });

        // Poblar cuentas
        populateBitunixAccountSelect();

        // Mostrar SOLO la sección de Bitunix
        document.getElementById('platform-bitunix').classList.add('active');

        console.log('✅ Panel de Bitunix cargado');
    } else if (platform === 'lbank') {
        console.log('🎯 Abriendo sección LBank');

        // Cargar credenciales de forma asíncrona
        loadLBankCredentials().catch(err => {
            console.error('Error cargando credenciales LBank:', err);
        });

        // Poblar cuentas
        populateLBankAccountSelect();

        // Mostrar SOLO la sección de LBank
        document.getElementById('platform-lbank').classList.add('active');

        console.log('✅ Panel de LBank cargado');
    } else if (platform === 'blofin') {
        console.log('🎯 Abriendo sección BloFin');

        // Cargar credenciales de forma asíncrona
        loadBloFinCredentials().catch(err => {
            console.error('Error cargando credenciales BloFin:', err);
        });

        // Poblar cuentas
        populateBloFinAccountSelect();

        // Mostrar SOLO la sección de BloFin
        document.getElementById('platform-blofin').classList.add('active');

        console.log('✅ Panel de BloFin cargado');
    }
}

function syncBingXData() {
    // Sincronizar claves API
    const apiKey = document.getElementById('bingx-api-key')?.value || '';
    const secretKey = document.getElementById('bingx-api-secret')?.value || '';
    const selectedAccount = document.getElementById('bingx-account')?.value || '';

    if (document.getElementById('bingx-api-key-detail')) {
        document.getElementById('bingx-api-key-detail').value = apiKey;
    }
    if (document.getElementById('bingx-secret-key-detail')) {
        document.getElementById('bingx-secret-key-detail').value = secretKey;
    }
    if (document.getElementById('bingx-account-detail')) {
        document.getElementById('bingx-account-detail').value = selectedAccount;
    }
}

function updateBingXDetailStatus() {
    const statusElement = document.getElementById('bingx-connection-status');
    const proxyElement = document.getElementById('bingx-proxy-status-detail');

    // Verificar si hay credenciales guardadas
    const hasLocalCredentials = localStorage.getItem('bingx-api-key') && localStorage.getItem('bingx-secret-key');
    const hasDbCredentials = DB.apiKeys.bingx && DB.apiKeys.bingx.key && DB.apiKeys.bingx.secret;

    if ((bingxAPI && bingxAPI.apiKey) || hasLocalCredentials || hasDbCredentials) {
        // Conectado (banner oculto por CSS)

        // Actualizar indicadores en la tarjeta de plataforma
        const statusIndicator = document.getElementById('bingx-status-indicator');
        const progressBar = document.getElementById('bingx-progress-bar');

        if (statusIndicator) {
            statusIndicator.textContent = 'Conectado';
            statusIndicator.className = 'text-green-400';
        }
        if (progressBar) {
            progressBar.style.width = '100%';
        }

        // Mostrar botones de sincronización
        const syncBtn = document.getElementById('bingx-sync');
        if (syncBtn) syncBtn.style.display = 'inline-block';

    } else {
        // No conectado
        // Not connected (banner is hidden)

        // Actualizar indicadores en la tarjeta de plataforma
        const statusIndicator = document.getElementById('bingx-status-indicator');
        const progressBar = document.getElementById('bingx-progress-bar');

        if (statusIndicator) {
            statusIndicator.textContent = 'No conectado';
            statusIndicator.className = 'text-yellow-400';
        }
        if (progressBar) {
            progressBar.style.width = '0%';
        }

        // Ocultar botón de sincronización
        const syncBtn = document.getElementById('bingx-sync');
        if (syncBtn) syncBtn.style.display = 'none';
    }
}

// Función personalizada para conectar BingX desde la nueva interfaz
// FUNCIÓN DUPLICADA - COMENTADA (ya existe versión async en línea 31770)
/*
function connectBingX() {
    let apiKey, secretKey, selectedAccount;

    // Verificar desde qué interfaz se está llamando
    const detailApiKey = document.getElementById('bingx-api-key-detail');
    const oldApiKey = document.getElementById('bingx-api-key');

    if (detailApiKey && detailApiKey.value) {
        // Llamada desde la nueva interfaz de plataformas
        apiKey = detailApiKey.value;
        secretKey = document.getElementById('bingx-secret-key-detail').value;
        selectedAccount = document.getElementById('bingx-account-detail').value;
    } else if (oldApiKey && oldApiKey.value) {
        // Llamada desde la interfaz antigua de configuración
        apiKey = oldApiKey.value;
        secretKey = document.getElementById('bingx-api-secret').value;
        selectedAccount = document.getElementById('bingx-account').value;
    }

    if (!apiKey || !secretKey) {
        alert('Por favor, introduce tanto la clave API como el secret de BingX.');
        return;
    }

    if (!selectedAccount) {
        alert('Por favor, selecciona una cuenta para sincronizar.');
        return;
    }

    // Sincronizar valores entre ambas interfaces
    if (detailApiKey) {
        detailApiKey.value = apiKey;
        document.getElementById('bingx-secret-key-detail').value = secretKey;
        document.getElementById('bingx-account-detail').value = selectedAccount;
    }
    if (oldApiKey) {
        oldApiKey.value = apiKey;
        document.getElementById('bingx-api-secret').value = secretKey;
        document.getElementById('bingx-account').value = selectedAccount;
    }

    // Inicializar BingX API
    bingxAPI = new BingXAPI(apiKey, secretKey);
    DB.apiKeys.bingx = { key: apiKey, secret: secretKey, mode: 'real', accountId: selectedAccount };

    // Actualizar estado
    updateBingXDetailStatus();

    // showSyncNotification('✅ BingX conectado exitosamente', 'success');
}
*/

console.log('✅ Sistema de autenticación inicializado');
console.log('✅ Integración BingX inicializada');

// =============================================
// GRÁFICOS - Gráficas adicionales del informe
// =============================================
let graficosCharts = {};

function destroyGraficosCharts() {
    Object.values(graficosCharts).forEach(chart => { if (chart) chart.destroy(); });
    graficosCharts = {};
}

window.refreshGraficosCharts = function() {
        console.log("--- Refreshing Graficos Charts ---");
        destroyGraficosCharts();

        let operations = applyDateFilterToData(DB.operations);
        const selectedAccountEl = document.getElementById('informe-account-select');
        const selectedAccount = selectedAccountEl ? selectedAccountEl.value : 'all';

        console.log(`[Graficos] Total operations after date filter: ${operations.length}`);
        console.log(`[Graficos] Selected account: '${selectedAccount}'`);

        if (selectedAccount !== 'all') {
            operations = operations.filter(op => op.accountId === selectedAccount);
            console.log(`[Graficos] After account filter: ${operations.length}`);
        }
        operations = applyInformeFilters(operations);

        console.log(`[Graficos] Final operations for calculation: ${operations.length}`);
        if(operations.length > 0) {
            console.log("[Graficos] First 3 operations:", operations.slice(0,3).map(op => ({
                date: op.date,
                instrument: op.instrument,
                pl: op.pl,
                plType: typeof op.pl
            })));
        }

        // Preparar datos de semanas y meses
        const weekMap = {};
        const monthMap = {};
        
        operations.forEach(op => {
            // Asegurar que pl sea un número
            const plValue = parseFloat(op.pl) || 0;
            
            // Semanas
            const d = new Date(op.date + 'T00:00:00');
            const week = getWeekNumber(d);
            const year = d.getUTCFullYear();
            const weekKey = `${year}-W${week}`;
            if (!weekMap[weekKey]) weekMap[weekKey] = { pl: 0, count: 0 };
            weekMap[weekKey].pl += plValue;
            weekMap[weekKey].count++;
            
            // Meses
            const monthKey = op.date.substring(0, 7); // YYYY-MM
            if (!monthMap[monthKey]) monthMap[monthKey] = 0;
            monthMap[monthKey] += plValue;
        });
        
        const sortedWeeks = Object.keys(weekMap).sort();
        const weekLabels = sortedWeeks;
        const weekData = sortedWeeks.map(key => weekMap[key].pl);
        const sortedMonths = Object.keys(monthMap).sort();
        const monthLabels = sortedMonths;
        const monthData = sortedMonths.map(key => monthMap[key]);
        const sortedOps = [...operations].sort((a, b) => new Date(a.date + 'T' + (a.entryTime || '00:00')) - new Date(b.date + 'T' + (b.entryTime || '00:00')));

        console.log(`[Graficos] Week data:`, weekData);
        console.log(`[Graficos] Month data:`, monthData);

        // 1. Ganancias por Semana
        const bestWeek = weekData.length > 0 ? Math.max(...weekData) : 0;
        const worstWeek = weekData.length > 0 ? Math.min(...weekData) : 0;
        const bestWeekEl = document.getElementById('best-week-value');
        const worstWeekEl = document.getElementById('worst-week-value');
        if (bestWeekEl) {
            bestWeekEl.textContent = `$${bestWeek.toFixed(2)}`;
            bestWeekEl.className = bestWeek >= 0 ? 'text-xl font-bold text-green' : 'text-xl font-bold text-red';
        }
        if (worstWeekEl) {
            worstWeekEl.textContent = `$${worstWeek.toFixed(2)}`;
            worstWeekEl.className = worstWeek >= 0 ? 'text-xl font-bold text-green' : 'text-xl font-bold text-red';
        }
        
        const gananciasSemanaCanvas = document.getElementById('ganancias-semana-chart');
        console.log('[Graficos] Ganancias Semana Canvas:', gananciasSemanaCanvas ? 'Found' : 'NOT FOUND');
        if (gananciasSemanaCanvas) {
            const gananciasSemanaCtx = gananciasSemanaCanvas.getContext('2d');
            if (gananciasSemanaCtx) {
                graficosCharts.gananciasSemana = new Chart(gananciasSemanaCtx, {
                type: 'bar',
                data: { labels: weekLabels, datasets: [{ label: 'Ganancia Semanal', data: weekData, backgroundColor: weekData.map(v => v >= 0 ? '#00FF00' : '#FF0000'), borderColor: weekData.map(v => v >= 0 ? 'rgba(57, 255, 20, 1)' : 'rgba(255, 65, 54, 1)'), borderWidth: 2 }] },
                options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } }, scales: { y: { ticks: { color: '#a0a0a0' }, grid: { color: '#2a2a2a' } }, x: { ticks: { color: '#a0a0a0' }, grid: { color: '#2a2a2a' } } } }
            });
                console.log('[Graficos] ✅ Ganancias Semana chart created');
            }
        }

        // 2. Ganancias por Mes
        const bestMonth = monthData.length > 0 ? Math.max(...monthData) : 0;
        const worstMonth = monthData.length > 0 ? Math.min(...monthData) : 0;
        const bestMonthEl = document.getElementById('best-month-value');
        const worstMonthEl = document.getElementById('worst-month-value');
        if (bestMonthEl) {
            bestMonthEl.textContent = `$${bestMonth.toFixed(2)}`;
            bestMonthEl.className = bestMonth >= 0 ? 'text-xl font-bold text-green' : 'text-xl font-bold text-red';
        }
        if (worstMonthEl) {
            worstMonthEl.textContent = `$${worstMonth.toFixed(2)}`;
            worstMonthEl.className = worstMonth >= 0 ? 'text-xl font-bold text-green' : 'text-xl font-bold text-red';
        }
        
        const gananciasMesCanvas = document.getElementById('ganancias-mes-chart');
        console.log('[Graficos] Ganancias Mes Canvas:', gananciasMesCanvas ? 'Found' : 'NOT FOUND');
        if (gananciasMesCanvas) {
            const gananciasMesCtx = gananciasMesCanvas.getContext('2d');
            if (gananciasMesCtx) {
                graficosCharts.gananciasMes = new Chart(gananciasMesCtx, {
                type: 'bar',
                data: { labels: monthLabels, datasets: [{ label: 'Ganancia Mensual', data: monthData, backgroundColor: monthData.map(v => v >= 0 ? '#00FF00' : '#FF0000'), borderColor: monthData.map(v => v >= 0 ? 'rgba(57, 255, 20, 1)' : 'rgba(255, 65, 54, 1)'), borderWidth: 2 }] },
                options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } }, scales: { y: { ticks: { color: '#a0a0a0' }, grid: { color: '#2a2a2a' } }, x: { ticks: { color: '#a0a0a0' }, grid: { color: '#2a2a2a' } } } }
            });
                console.log('[Graficos] ✅ Ganancias Mes chart created');
            }
        }

        // 3. Posición (Largo vs Corto)
        let longTrades = 0, shortTrades = 0;
        operations.forEach(op => {
            if (op.type === 'buy') longTrades++;
            else if (op.type === 'sell') shortTrades++;
        });
        
        // Actualizar valores de resumen para posiciones
        const longCountEl = document.getElementById('long-count');
        const shortCountEl = document.getElementById('short-count');
        if (longCountEl) longCountEl.textContent = longTrades;
        if (shortCountEl) shortCountEl.textContent = shortTrades;
        
        const posicionCtx = document.getElementById('posicion-chart')?.getContext('2d');
        if (posicionCtx) {
            graficosCharts.posicion = new Chart(posicionCtx, {
                type: 'doughnut',
                data: { labels: ['Largo', 'Corto'], datasets: [{ data: [longTrades, shortTrades], backgroundColor: ['#00FF00', '#FF0000'], borderColor: '#0a0a0a', borderWidth: 2 }] },
                options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { position: 'bottom', labels: { color: '#ffffff', padding: 15, font: { size: 12 } } } } }
            });
        }

        // 5. Operaciones por Hora del Día
        const horas = Array(24).fill(0);
        operations.forEach(op => {
            if (op.entryTime) {
                try {
                    const hour = parseInt(op.entryTime.split(':')[0], 10);
                    if (!isNaN(hour)) horas[hour]++;
                } catch(e) {}
            }
        });
        
        // Actualizar valores de resumen para horarios
        const maxHourValue = Math.max(...horas);
        const mostActiveHourIndex = horas.indexOf(maxHourValue);
        const mostActiveHourEl = document.getElementById('most-active-hour');
        const hourlyTotalOpsEl = document.getElementById('hourly-total-ops');
        if (mostActiveHourEl) mostActiveHourEl.textContent = maxHourValue > 0 ? `${mostActiveHourIndex}:00` : '--:--';
        if (hourlyTotalOpsEl) hourlyTotalOpsEl.textContent = operations.length;
        
        const horaDiaCtx = document.getElementById('hora-dia-chart')?.getContext('2d');
        if (horaDiaCtx) {
            graficosCharts.horaDia = new Chart(horaDiaCtx, {
                type: 'bar',
                data: { labels: horas.map((_, i) => i + ':00'), datasets: [{ label: 'Operaciones por Hora', data: horas, backgroundColor: 'rgba(57,152,219,0.7)', borderColor: 'rgba(57,152,219,1)', borderWidth: 2 }] },
                options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } }, scales: { y: { beginAtZero: true, ticks: { color: '#a0a0a0', stepSize: 1 }, grid: { color: '#2a2a2a' } }, x: { ticks: { color: '#a0a0a0' }, grid: { color: '#2a2a2a' } } } }
            });
        }

        // 6. Drawdown Máximo (acumulado)
        let maxDrawdown = 0, peak = 0, equity = 0;
        const drawdownArr = [];
        sortedOps.forEach(op => {
            const plValue = parseFloat(op.pl) || 0;
            equity += plValue;
            if (equity > peak) peak = equity;
            const dd = equity - peak;
            if (dd < maxDrawdown) maxDrawdown = dd;
            drawdownArr.push(dd);
        });
        
        // Actualizar valores de resumen para drawdown
        const recoveryPct = peak > 0 ? ((equity / peak) * 100) : 100;
        const maxDrawdownEl = document.getElementById('max-drawdown-value');
        const drawdownRecoveryEl = document.getElementById('drawdown-recovery');
        if (maxDrawdownEl) maxDrawdownEl.textContent = `$${maxDrawdown.toFixed(2)}`;
        if (drawdownRecoveryEl) drawdownRecoveryEl.textContent = `${recoveryPct.toFixed(1)}%`;
        
        const drawdownCtx = document.getElementById('drawdown-chart')?.getContext('2d');
        if (drawdownCtx) {
            graficosCharts.drawdown = new Chart(drawdownCtx, {
                type: 'line',
                data: { labels: sortedOps.map(op => op.date), datasets: [{ label: 'Drawdown', data: drawdownArr, borderColor: 'rgba(255,65,54,1)', backgroundColor: 'rgba(255,65,54,0.2)', fill: true, tension: 0.4, pointRadius: 0, borderWidth: 2 }] },
                options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } }, scales: { y: { ticks: { color: '#a0a0a0' }, grid: { color: '#2a2a2a' } }, x: { ticks: { color: '#a0a0a0', display: false }, grid: { color: '#2a2a2a' } } } }
            });
        }

        // 5. Evolución del Balance (Equity Curve)
        let runningBalance = 0;
        const balanceEvolution = sortedOps.map(op => {
            const plValue = parseFloat(op.pl) || 0;
            runningBalance += plValue;
            return runningBalance;
        });
        const balanceLabels = sortedOps.map(op => op.date);
        
        // Actualizar valores de resumen para balance
        const initialBalance = 0; // Siempre empieza en 0 para P&L acumulado
        const currentBalance = balanceEvolution.length > 0 ? balanceEvolution[balanceEvolution.length - 1] : 0;
        const initialBalanceEl = document.getElementById('initial-balance-value');
        const currentBalanceEl = document.getElementById('current-balance-value');
        if (initialBalanceEl) initialBalanceEl.textContent = `$${initialBalance.toFixed(2)}`;
        if (currentBalanceEl) {
            currentBalanceEl.textContent = `$${currentBalance.toFixed(2)}`;
            currentBalanceEl.className = currentBalance >= 0 ? 'text-xl font-bold text-green' : 'text-xl font-bold text-red';
        }
        
        const balanceEvolutionCtx = document.getElementById('balance-evolution-chart')?.getContext('2d');
        if (balanceEvolutionCtx) {
            graficosCharts.balanceEvolution = new Chart(balanceEvolutionCtx, {
                type: 'line',
                data: {
                    labels: balanceLabels,
                    datasets: [{
                        label: 'Balance Acumulado',
                        data: balanceEvolution,
                        borderColor: 'rgba(57, 255, 20, 1)',
                        backgroundColor: 'rgba(57, 255, 20, 0.1)',
                        fill: true,
                        tension: 0.3,
                        pointRadius: 1,
                        pointHoverRadius: 4,
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (context) => `Balance: $${context.parsed.y.toFixed(2)}`
                            }
                        }
                    },
                    scales: {
                        y: {
                            ticks: { color: '#a0a0a0' },
                            grid: { color: '#2a2a2a' }
                        },
                        x: {
                            ticks: { color: '#a0a0a0', display: false },
                            grid: { color: '#2a2a2a' }
                        }
                    }
                }
            });
        }
        
        // ===== NUEVAS MÉTRICAS: CONSISTENCIA Y VOLATILIDAD =====
        
        // 10. Volatilidad de Retornos Mensuales
        const monthlyVolatilityCtx = document.getElementById('graficos-monthly-volatility-chart')?.getContext('2d');
        if (monthlyVolatilityCtx) {
            if (monthData.length > 0) {
                const avgMonthlyReturn = monthData.reduce((a,b) => a+b, 0) / monthData.length;
                const variance = monthData.reduce((sum, ret) => sum + Math.pow(ret - avgMonthlyReturn, 2), 0) / monthData.length;
                const stdDev = Math.sqrt(variance);
                
                const deviations = monthData.map(ret => Math.abs(ret - avgMonthlyReturn));
                
                // Actualizar valores de las métricas en el DOM
                const volatilityValueEl = document.getElementById('volatility-value');
                const volatilityAvgEl = document.getElementById('volatility-avg');
                if (volatilityValueEl) volatilityValueEl.textContent = `$${stdDev.toFixed(2)}`;
                if (volatilityAvgEl) volatilityAvgEl.textContent = `$${avgMonthlyReturn.toFixed(2)}`;
                
                graficosCharts.monthlyVolatility = new Chart(monthlyVolatilityCtx, {
                    type: 'bar',
                    data: {
                        labels: monthLabels,
                        datasets: [{
                            label: 'Desviación del Promedio',
                            data: deviations,
                            backgroundColor: 'rgba(57,152,219,0.7)',
                            borderColor: 'rgba(57,152,219,1)',
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            title: {
                                display: false
                            }
                        },
                        scales: {
                            y: { 
                                beginAtZero: true,
                                ticks: { color: '#a0a0a0' },
                                grid: { color: '#2a2a2a' }
                            },
                            x: {
                                ticks: { color: '#a0a0a0' },
                                grid: { color: '#2a2a2a' }
                            }
                        }
                    }
                });
            } else {
                // Sin datos mensuales
                graficosCharts.monthlyVolatility = new Chart(monthlyVolatilityCtx, {
                    type: 'bar',
                    data: {
                        labels: ['Sin datos'],
                        datasets: [{
                            label: 'Volatilidad',
                            data: [0],
                            backgroundColor: 'rgba(100,100,100,0.5)'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            title: {
                                display: true,
                                text: 'Sin suficientes datos mensuales',
                                color: '#a0a0a0',
                                font: { size: 12 }
                            }
                        },
                        scales: {
                            y: { ticks: { color: '#a0a0a0' }, grid: { color: '#2a2a2a' } },
                            x: { ticks: { color: '#a0a0a0' }, grid: { color: '#2a2a2a' } }
                        }
                    }
                });
            }
        }
        
        // 11. Resultado Final vs Stop Loss (Distribución de Salidas)
        const resultVsSlCtx = document.getElementById('graficos-result-vs-sl-chart')?.getContext('2d');
        if (resultVsSlCtx) {
            const exitTypes = {
                'TP Hit': 0,
                'SL Hit': 0,
                'Manual Win': 0,
                'Manual Loss': 0
            };
            
            operations.forEach(op => {
                const pl = parseFloat(op.pl) || 0;
                const hasTP = op.takeProfit && parseFloat(op.takeProfit) > 0;
                const hasSL = op.stopLoss && parseFloat(op.stopLoss) > 0;
                
                if (pl > 0) {
                    if (hasTP) exitTypes['TP Hit']++;
                    else exitTypes['Manual Win']++;
                } else {
                    if (hasSL) exitTypes['SL Hit']++;
                    else exitTypes['Manual Loss']++;
                }
            });
            
            // Actualizar contadores en el DOM
            const tpHitEl = document.getElementById('tp-hit-count');
            const slHitEl = document.getElementById('sl-hit-count');
            const manualCloseEl = document.getElementById('manual-close-count');
            if (tpHitEl) tpHitEl.textContent = exitTypes['TP Hit'];
            if (slHitEl) slHitEl.textContent = exitTypes['SL Hit'];
            if (manualCloseEl) manualCloseEl.textContent = exitTypes['Manual Win'] + exitTypes['Manual Loss'];
            
            graficosCharts.resultVsSl = new Chart(resultVsSlCtx, {
                type: 'doughnut',
                data: {
                    labels: Object.keys(exitTypes),
                    datasets: [{
                        data: Object.values(exitTypes),
                        backgroundColor: [
                            '#00FF00',    // TP Hit - verde
                            '#FF0000',    // SL Hit - rojo
                            'rgba(57,152,219,0.7)',   // Manual Win - azul
                            'rgba(150,150,150,0.7)'   // Manual Loss - gris
                        ],
                        borderColor: '#0a0a0a',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: { color: '#ffffff', padding: 10 }
                        },
                        tooltip: {
                            callbacks: {
                                label: (ctx) => {
                                    const total = Object.values(exitTypes).reduce((a,b) => a+b, 0);
                                    const pct = total > 0 ? ((ctx.parsed / total) * 100).toFixed(1) : 0;
                                    return `${ctx.label}: ${ctx.parsed} (${pct}%)`;
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // 12. Evolución de Win Rate (Rolling Average)
        const winrateEvolutionCtx = document.getElementById('graficos-winrate-evolution-chart')?.getContext('2d');
        if (winrateEvolutionCtx && sortedOps.length > 0) {
            const windowSize = Math.min(20, Math.floor(sortedOps.length / 5)) || 10;
            const winRates = [];
            const labels = [];
            
            for (let i = windowSize - 1; i < sortedOps.length; i++) {
                const window = sortedOps.slice(i - windowSize + 1, i + 1);
                const wins = window.filter(op => op.result === 'win').length;
                const winRate = (wins / windowSize) * 100;
                winRates.push(winRate);
                labels.push(sortedOps[i].date);
            }
            
            graficosCharts.winrateEvolution = new Chart(winrateEvolutionCtx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: `Win Rate (${windowSize} trades)`,
                        data: winRates,
                        borderColor: 'rgba(57,255,20,1)',
                        backgroundColor: 'rgba(57,255,20,0.1)',
                        fill: true,
                        tension: 0.4,
                        pointRadius: 2,
                        pointHoverRadius: 5,
                        borderWidth: 2
                    }, {
                        label: '50% Línea',
                        data: Array(winRates.length).fill(50),
                        borderColor: 'rgba(255,255,255,0.3)',
                        borderWidth: 1,
                        borderDash: [5, 5],
                        pointRadius: 0,
                        fill: false
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            labels: { color: '#ffffff' }
                        },
                        tooltip: {
                            callbacks: {
                                label: (ctx) => `${ctx.dataset.label}: ${ctx.parsed.y.toFixed(1)}%`
                            }
                        }
                    },
                    scales: {
                        y: {
                            min: 0,
                            max: 100,
                            ticks: {
                                color: '#a0a0a0',
                                callback: (value) => value + '%'
                            },
                            grid: { color: '#2a2a2a' }
                        },
                        x: {
                            ticks: { color: '#a0a0a0', display: false },
                            grid: { color: '#2a2a2a' }
                        }
                    }
                }
            });
        }
    };

console.log('✅ refreshGraficosCharts definida y disponible globalmente');

// ===== EXPORTAR FUNCIONES AL ÁMBITO GLOBAL =====
// Esto permite que el segundo bloque <script> y el resto del código acceda a estas funciones
window.initializeSupabase = initializeSupabase;
window.supabase = supabase;
window.currentUser = null;

// Funciones de operaciones
window.saveOperationToSupabase = saveOperationToSupabase;
window.loadOperationsFromSupabase = loadOperationsFromSupabase;
window.deleteOperationFromSupabase = deleteOperationFromSupabase;
window.addToSyncQueue = addToSyncQueue;

// Funciones de cuentas
window.saveAccountToSupabase = saveAccountToSupabase;
window.loadAccountsFromSupabase = loadAccountsFromSupabase;
window.deleteAccountFromSupabase = deleteAccountFromSupabase;

// Funciones de funded accounts
window.saveFundedAccountToSupabase = saveFundedAccountToSupabase;
window.loadFundedAccountsFromSupabase = loadFundedAccountsFromSupabase;
window.deleteFundedAccountFromSupabase = deleteFundedAccountFromSupabase;

// Funciones de retiros de funded accounts
window.openWithdrawalModal = openWithdrawalModal;
window.closeWithdrawalModal = closeWithdrawalModal;
window.saveWithdrawal = saveWithdrawal;

// Funciones de setups
window.saveSetupToSupabase = saveSetupToSupabase;
window.loadSetupsFromSupabase = loadSetupsFromSupabase;
window.deleteSetupFromSupabase = deleteSetupFromSupabase;

// Funciones de finanzas
window.saveFinanceToSupabase = saveFinanceToSupabase;
window.updateFinanceInSupabase = updateFinanceInSupabase;
window.loadFinancesFromSupabase = loadFinancesFromSupabase;
window.deleteFinanceFromSupabase = deleteFinanceFromSupabase;

// Funciones de configuración
window.saveUserSettingsToSupabase = saveUserSettingsToSupabase;
window.loadUserSettingsFromSupabase = loadUserSettingsFromSupabase;
window.syncDataFromSupabase = syncDataFromSupabase;
window.toggleUserMenu = toggleUserMenu;

// ===== NUEVAS FUNCIONES: CHARTBOOK =====
async function saveChartbookImageToSupabase(imageData) {
    if (!currentUser) {
        console.error('❌ No hay usuario autenticado');
        return null;
    }

    try {
        const dataToSave = {
            id: imageData.id || `chartbook-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
            user_id: currentUser.id,
            account_id: imageData.accountId || null,
            date: imageData.date,
            image_data: imageData.imageData,
            notes: imageData.notes || '',
            tags: imageData.tags || []
        };

        const { data, error } = await supabase
            .from('chartbook_images')
            .upsert(dataToSave, { onConflict: 'id' });

        if (error) throw error;
        console.log('✅ Imagen de Chartbook guardada en Supabase');
        return data;
    } catch (error) {
        console.error('❌ Error guardando imagen de Chartbook:', error);
        throw error;
    }
}

async function loadChartbookImagesFromSupabase() {
    if (!currentUser) {
        console.error('❌ No hay usuario autenticado');
        return [];
    }

    try {
        // Cargar solo imágenes de los últimos 6 meses (imágenes grandes consumen mucho Egress)
        const sixMonthsAgo = new Date();
        sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
        
        const { data, error } = await supabase
            .from('chartbook_images')
            .select('*')
            .eq('user_id', currentUser.id)
            .gte('date', sixMonthsAgo.toISOString())
            .order('date', { ascending: false });

        if (error) throw error;
        console.log(`✅ ${data.length} imágenes de Chartbook cargadas desde Supabase`);
        return data.map(img => ({
            id: img.id,
            accountId: img.account_id,
            date: img.date,
            imageData: img.image_data,
            notes: img.notes,
            tags: img.tags || []
        }));
    } catch (error) {
        console.error('❌ Error cargando imágenes de Chartbook:', error);
        return [];
    }
}

async function deleteChartbookImageFromSupabase(imageId) {
    if (!currentUser) {
        console.error('❌ No hay usuario autenticado');
        return false;
    }

    try {
        const { error } = await supabase
            .from('chartbook_images')
            .delete()
            .eq('id', imageId)
            .eq('user_id', currentUser.id);

        if (error) throw error;
        console.log('✅ Imagen de Chartbook eliminada de Supabase');
        return true;
    } catch (error) {
        console.error('❌ Error eliminando imagen de Chartbook:', error);
        return false;
    }
}

// ===== NUEVAS FUNCIONES: DAILY JOURNAL =====
async function saveJournalEntryToSupabase(entryData) {
    if (!currentUser) {
        console.error('❌ No hay usuario autenticado');
        return null;
    }

    try {
        const dataToSave = {
            id: entryData.id || `journal-${entryData.date}-${currentUser.id}`,
            user_id: currentUser.id,
            account_id: entryData.accountId || null,
            date: entryData.date,
            mood: entryData.mood || null,
            emotions: entryData.emotions || [],
            pre_trading_note: entryData.preTradingNote || '',
            post_trading_note: entryData.postTradingNote || '',
            lessons_learned: entryData.lessonsLearned || '',
            image_data: entryData.imageData || null,
            daily_pnl: parseFloat(entryData.dailyPnl) || 0,
            trades_count: parseInt(entryData.tradesCount) || 0,
            win_rate: parseFloat(entryData.winRate) || 0
        };

        const { data, error } = await supabase
            .from('daily_journal_entries')
            .upsert(dataToSave, { onConflict: 'id' });

        if (error) throw error;
        console.log('✅ Entrada de Daily Journal guardada en Supabase');
        return data;
    } catch (error) {
        console.error('❌ Error guardando entrada de Daily Journal:', error);
        throw error;
    }
}

async function loadJournalEntriesFromSupabase() {
    if (!currentUser) {
        console.error('❌ No hay usuario autenticado');
        return [];
    }

    try {
        // Cargar solo entradas de journal de los últimos 12 meses para reducir Egress
        const twelveMonthsAgo = new Date();
        twelveMonthsAgo.setMonth(twelveMonthsAgo.getMonth() - 12);
        
        const { data, error } = await supabase
            .from('daily_journal_entries')
            .select('*')
            .eq('user_id', currentUser.id)
            .gte('date', twelveMonthsAgo.toISOString())
            .order('date', { ascending: false });

        if (error) throw error;
        console.log(`✅ ${data.length} entradas de Daily Journal cargadas desde Supabase`);
        return data.map(entry => ({
            id: entry.id,
            accountId: entry.account_id,
            date: entry.date,
            mood: entry.mood,
            emotions: entry.emotions || [],
            preTradingNote: entry.pre_trading_note,
            postTradingNote: entry.post_trading_note,
            lessonsLearned: entry.lessons_learned,
            imageData: entry.image_data,
            dailyPnl: entry.daily_pnl,
            tradesCount: entry.trades_count,
            winRate: entry.win_rate
        }));
    } catch (error) {
        console.error('❌ Error cargando entradas de Daily Journal:', error);
        return [];
    }
}

async function deleteJournalEntryFromSupabase(entryId) {
    if (!currentUser) {
        console.error('❌ No hay usuario autenticado');
        return false;
    }

    try {
        const { error } = await supabase
            .from('daily_journal_entries')
            .delete()
            .eq('id', entryId)
            .eq('user_id', currentUser.id);

        if (error) throw error;
        console.log('✅ Entrada de Daily Journal eliminada de Supabase');
        return true;
    } catch (error) {
        console.error('❌ Error eliminando entrada de Daily Journal:', error);
        return false;
    }
}

// Exportar nuevas funciones
window.saveChartbookImageToSupabase = saveChartbookImageToSupabase;
window.loadChartbookImagesFromSupabase = loadChartbookImagesFromSupabase;
window.deleteChartbookImageFromSupabase = deleteChartbookImageFromSupabase;
window.saveJournalEntryToSupabase = saveJournalEntryToSupabase;
window.loadJournalEntriesFromSupabase = loadJournalEntriesFromSupabase;
window.deleteJournalEntryFromSupabase = deleteJournalEntryFromSupabase;

console.log('✅ Todas las funciones de Supabase exportadas al ámbito global');

</script>

<script>
// =============================================
// COMISIONES - ANÁLISIS DE COSTOS
// =============================================
let comisionesCharts = {};

function destroyComisionesCharts() {
    Object.values(comisionesCharts).forEach(chart => { if (chart) chart.destroy(); });
    comisionesCharts = {};
}

function refreshComisiones() {
    console.log("--- Refreshing Comisiones ---");
    destroyComisionesCharts();
    
    let operations = applyDateFilterToData(DB.operations);
    const selectedAccount = document.getElementById('informe-account-select')?.value;
    const displayCurrency = DB.settings.defaultCurrency;

        if (selectedAccount !== 'all') {
            operations = operations.filter(op => op.accountId === selectedAccount);
        }
        operations = applyInformeFilters(operations);

        console.log(`[Comisiones] Processing ${operations.length} operations for account: ${selectedAccount}`);

        // Calcular métricas de comisiones
        let totalCommissions = 0;
        let totalPL = 0;
        let commissionsBySymbol = {};
        let commissionsByMonth = {};
        let commissionsArray = [];
        let tradesImpacted = 0; // Trades que pasaron de ganancia a pérdida por comisiones

        operations.forEach(op => {
            // Calcular comisión: Usar el campo 'fees' que es el estándar en el sistema
            let commission = 0;
            
            if (op.fees && op.fees !== 0) {
                // Si existe fees guardado, usarlo
                commission = Math.abs(op.fees);
            } else if (op.commission && op.commission !== 0) {
                // Fallback a commission si existe
                commission = Math.abs(op.commission);
            } else {
                // Estimar comisión basada en volumen y precio de entrada como último recurso
                // Tasa típica: 0.04% del valor nominal para futuros (puede variar)
                const volume = op.volume || 0;
                const entry = op.entry || 0;
                const nominalValue = volume * entry;
                commission = nominalValue * 0.0004; // 0.04% promedio para futuros
            }
            
            const commissionUSD = convertCurrency(commission, op.currency, displayCurrency);
            const pl = convertCurrency(op.pl, op.currency, displayCurrency);
            
            totalCommissions += commissionUSD;
            totalPL += pl;
            commissionsArray.push(commissionUSD);

            // Por símbolo
            const symbol = (op.instrument || 'UNKNOWN').toUpperCase();
            if (!commissionsBySymbol[symbol]) {
                commissionsBySymbol[symbol] = { total: 0, pl: 0, count: 0 };
            }
            commissionsBySymbol[symbol].total += commissionUSD;
            commissionsBySymbol[symbol].pl += pl;
            commissionsBySymbol[symbol].count++;

            // Por mes
            const month = op.date.substring(0, 7); // YYYY-MM
            if (!commissionsByMonth[month]) {
                commissionsByMonth[month] = { commissions: 0, pl: 0 };
            }
            commissionsByMonth[month].commissions += commissionUSD;
            commissionsByMonth[month].pl += pl;

            // Detectar impacto en winrate (trade que sin fees sería ganancia)
            if ((pl + commissionUSD) > 0 && pl <= 0) {
                tradesImpacted++;
            }
        });

        const avgCommission = operations.length > 0 ? totalCommissions / operations.length : 0;
        const ratioCommissionPL = totalPL > 0 ? (totalCommissions / Math.abs(totalPL)) * 100 : 0;
        const maxCommission = commissionsArray.length > 0 ? Math.max(...commissionsArray) : 0;
        const minCommission = commissionsArray.length > 0 ? Math.min(...commissionsArray) : 0;

        console.log(`📊 [Comisiones] Total: $${totalCommissions.toFixed(2)}, Avg: $${avgCommission.toFixed(2)}, Ratio: ${ratioCommissionPL.toFixed(2)}%`);

        // Calcular promedios diarios y mensuales
        const uniqueDays = [...new Set(operations.map(op => op.date))].length;
        const uniqueMonths = Object.keys(commissionsByMonth).length;
        const commissionsPerDay = uniqueDays > 0 ? totalCommissions / uniqueDays : 0;
        const commissionsPerMonth = uniqueMonths > 0 ? totalCommissions / uniqueMonths : 0;

        // Actualizar métricas escritas (con validación)
        const updateElement = (id, value) => {
            const el = document.getElementById(id);
            if (el) el.textContent = value;
            else console.warn(`[Comisiones] Elemento no encontrado: ${id}`);
        };
        
        updateElement('comisiones-total', `$${totalCommissions.toFixed(2)}`);
        updateElement('comisiones-avg-trade', `$${avgCommission.toFixed(2)}`);
        updateElement('comisiones-avg-trade-inline', `$${avgCommission.toFixed(2)}`);
        updateElement('comisiones-ratio-total', `${ratioCommissionPL.toFixed(2)}%`);
        updateElement('comisiones-impact-winrate', tradesImpacted);
        updateElement('comisiones-per-day', `$${commissionsPerDay.toFixed(2)}`);
        updateElement('comisiones-per-month', `$${commissionsPerMonth.toFixed(2)}`);
        updateElement('comisiones-max', `$${maxCommission.toFixed(2)}`);
        updateElement('comisiones-min', `$${minCommission.toFixed(2)}`);
        updateElement('comisiones-total-trades', operations.length);
        updateElement('comisiones-symbols-count', Object.keys(commissionsBySymbol).length);
        
        console.log(`✅ [Comisiones] Métricas actualizadas: Total=$${totalCommissions.toFixed(2)}, Avg=$${avgCommission.toFixed(2)}, Trades=${operations.length}`);

        // Gráfica 1: Comisiones por Símbolo
        const ctx1 = document.getElementById('comisiones-by-symbol-chart')?.getContext('2d');
        if (ctx1) {
            const sortedSymbols = Object.entries(commissionsBySymbol)
                .sort(([,a], [,b]) => b.total - a.total)
                .slice(0, 15);

            comisionesCharts.bySymbol = new Chart(ctx1, {
                type: 'bar',
                data: {
                    labels: sortedSymbols.map(([symbol]) => symbol),
                    datasets: [{
                        label: 'Comisiones Totales',
                        data: sortedSymbols.map(([, data]) => data.total),
                        backgroundColor: 'rgba(255,193,7,0.7)',
                        borderColor: 'rgba(255,193,7,1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (ctx) => `Comisiones: $${ctx.parsed.x.toFixed(2)}`
                            }
                        }
                    },
                    scales: {
                        x: { beginAtZero: true, grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0' } },
                        y: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0', font: { size: 9 } } }
                    }
                }
            });
        }

        // Gráfica 2: Ratio Comisión/P/L por Símbolo
        const ctx2 = document.getElementById('comisiones-ratio-symbol-chart')?.getContext('2d');
        if (ctx2) {
            const ratios = {};
            Object.entries(commissionsBySymbol).forEach(([symbol, data]) => {
                if (Math.abs(data.pl) > 0) {
                    ratios[symbol] = (data.total / Math.abs(data.pl)) * 100;
                }
            });

            const sortedRatios = Object.entries(ratios)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 15);

            comisionesCharts.ratioSymbol = new Chart(ctx2, {
                type: 'bar',
                data: {
                    labels: sortedRatios.map(([symbol]) => symbol),
                    datasets: [{
                        label: 'Ratio %',
                        data: sortedRatios.map(([, ratio]) => ratio),
                        backgroundColor: sortedRatios.map(([, ratio]) =>
                            ratio > 30 ? 'rgba(239,68,68,0.7)' :
                            ratio > 15 ? 'rgba(255,193,7,0.7)' :
                            '#00FF00'
                        )
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (ctx) => `${ctx.parsed.x.toFixed(1)}% de P/L en comisiones`
                            }
                        }
                    },
                    scales: {
                        x: { beginAtZero: true, grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0', callback: (v) => v + '%' } },
                        y: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0', font: { size: 9 } } }
                    }
                }
            });
        }

        // Gráfica 3: Comisiones por Mes
        const ctx3 = document.getElementById('comisiones-monthly-chart')?.getContext('2d');
        if (ctx3) {
            const sortedMonths = Object.keys(commissionsByMonth).sort();
            const monthlyCommissions = sortedMonths.map(month => commissionsByMonth[month].commissions);

            comisionesCharts.monthly = new Chart(ctx3, {
                type: 'line',
                data: {
                    labels: sortedMonths,
                    datasets: [{
                        label: 'Comisiones Mensuales',
                        data: monthlyCommissions,
                        borderColor: 'rgba(255,193,7,1)',
                        backgroundColor: 'rgba(255,193,7,0.2)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (ctx) => `Comisiones: $${ctx.parsed.y.toFixed(2)}`
                            }
                        }
                    },
                    scales: {
                        y: { beginAtZero: true, grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0' } },
                        x: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0' } }
                    }
                }
            });
        }

        // Gráfica 4: Comisiones vs P/L Neto
        const ctx4 = document.getElementById('comisiones-vs-pl-chart')?.getContext('2d');
        if (ctx4) {
            const sortedMonths = Object.keys(commissionsByMonth).sort();
            const monthlyPL = sortedMonths.map(month => commissionsByMonth[month].pl);
            const monthlyComm = sortedMonths.map(month => commissionsByMonth[month].commissions);

            comisionesCharts.vsPL = new Chart(ctx4, {
                type: 'bar',
                data: {
                    labels: sortedMonths,
                    datasets: [
                        {
                            label: 'P/L Bruto',
                            data: monthlyPL,
                            backgroundColor: 'rgba(57,255,20,0.5)',
                            borderColor: 'rgba(57,255,20,1)',
                            borderWidth: 1
                        },
                        {
                            label: 'Comisiones',
                            data: monthlyComm,
                            backgroundColor: 'rgba(255,193,7,0.5)',
                            borderColor: 'rgba(255,193,7,1)',
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: true, labels: { color: '#ffffff' } }
                    },
                    scales: {
                        y: { beginAtZero: true, grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0' } },
                        x: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0' } }
                    }
                }
            });
        }

        // Gráfica 5: Distribución de Comisiones
        const ctx5 = document.getElementById('comisiones-distribution-chart')?.getContext('2d');
        if (ctx5) {
            const ranges = {
                '< $1': 0,
                '$1-5': 0,
                '$5-10': 0,
                '$10-25': 0,
                '> $25': 0
            };

            commissionsArray.forEach(comm => {
                if (comm < 1) ranges['< $1']++;
                else if (comm < 5) ranges['$1-5']++;
                else if (comm < 10) ranges['$5-10']++;
                else if (comm < 25) ranges['$10-25']++;
                else ranges['> $25']++;
            });

            comisionesCharts.distribution = new Chart(ctx5, {
                type: 'pie',
                data: {
                    labels: Object.keys(ranges),
                    datasets: [{
                        data: Object.values(ranges),
                        backgroundColor: [
                            '#00FF00',
                            'rgba(135,206,250,0.7)',
                            'rgba(255,193,7,0.7)',
                            'rgba(255,140,0,0.7)',
                            '#FF0000'
                        ],
                        borderColor: '#0a0a0a',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { position: 'right', labels: { color: '#ffffff' } }
                    }
                }
            });
        }

        // Gráfica 6: P/L Neto por Símbolo (después de comisiones)
        const ctx6 = document.getElementById('comisiones-net-pl-symbol-chart')?.getContext('2d');
        if (ctx6) {
            const netPL = {};
            Object.entries(commissionsBySymbol).forEach(([symbol, data]) => {
                netPL[symbol] = data.pl - data.total;
            });

            const sortedNetPL = Object.entries(netPL)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 15);

            comisionesCharts.netPL = new Chart(ctx6, {
                type: 'bar',
                data: {
                    labels: sortedNetPL.map(([symbol]) => symbol),
                    datasets: [{
                        label: 'P/L Neto',
                        data: sortedNetPL.map(([, pl]) => pl),
                        backgroundColor: sortedNetPL.map(([, pl]) => pl >= 0 ? '#00FF00' : '#FF0000')
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (ctx) => `P/L Neto: $${ctx.parsed.x.toFixed(2)}`
                            }
                        }
                    },
                    scales: {
                        x: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0' } },
                        y: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#a0a0a0', font: { size: 9 } } }
                    }
                }
            });
        }
        
        // Gráfica 7: Commission Impact (Barras apiladas)
        const ctx7 = document.getElementById('commission-impact-chart')?.getContext('2d');
        if (ctx7) {
            // Agrupar por mes
            const monthlyData = {};
            
            operations.forEach(op => {
                if (!op.date) return;
                const monthKey = op.date.substring(0, 7); // YYYY-MM
                
                if (!monthlyData[monthKey]) {
                    monthlyData[monthKey] = {
                        grossPL: 0,
                        commissions: 0,
                        netPL: 0
                    };
                }
                
                const pl = op.pl || 0;
                const fee = op.fee || op.fees || 0;
                
                monthlyData[monthKey].grossPL += pl;
                monthlyData[monthKey].commissions += fee;
                monthlyData[monthKey].netPL += (pl - fee);
            });
            
            // Ordenar por fecha
            const sortedMonths = Object.keys(monthlyData).sort();
            const labels = sortedMonths.map(m => {
                const [year, month] = m.split('-');
                const monthNames = ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'];
                return `${monthNames[parseInt(month) - 1]} ${year}`;
            });
            
            const grossPLData = sortedMonths.map(m => monthlyData[m].grossPL);
            const netPLData = sortedMonths.map(m => monthlyData[m].netPL);
            const commissionsData = sortedMonths.map(m => -monthlyData[m].commissions); // Negativo para mostrar como pérdida
            
            comisionesCharts.impact = new Chart(ctx7, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'P/L Bruto',
                            data: grossPLData,
                            backgroundColor: '#00FF00',
                            borderColor: 'rgba(57,255,20,1)',
                            borderWidth: 1
                        },
                        {
                            label: 'Comisiones',
                            data: commissionsData,
                            backgroundColor: '#FF0000',
                            borderColor: 'rgba(255,65,54,1)',
                            borderWidth: 1
                        },
                        {
                            label: 'P/L Neto',
                            data: netPLData,
                            backgroundColor: 'rgba(135,206,250,0.7)',
                            borderColor: 'rgba(135,206,250,1)',
                            borderWidth: 1,
                            type: 'line',
                            fill: false,
                            tension: 0.3,
                            pointRadius: 4,
                            pointHoverRadius: 6
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: { color: '#ffffff', font: { size: 12 } }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) label += ': ';
                                    label += '$' + Math.abs(context.parsed.y).toFixed(2);
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            ticks: {
                                color: '#a0a0a0',
                                callback: (value) => '$' + value.toFixed(0)
                            }
                        },
                        x: {
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            ticks: { color: '#a0a0a0', maxRotation: 45, minRotation: 0 }
                        }
                    }
                }
            });
        }
}

// Hook into tab switching cuando el DOM esté listo
document.addEventListener('DOMContentLoaded', function() {
    const informeSubTabs = document.querySelectorAll('.informe-sub-tab');
    informeSubTabs.forEach(tab => {
        tab.addEventListener('click', () => {
            if (tab.dataset.target === 'informe-comisiones-content') {
                setTimeout(refreshComisiones, 50);
            }
        });
    });
});

// =============================================
// CHARTBOOK - GALERÍA DE TRADES CON IMÁGENES
// =============================================
(function() {
    console.log('📊 INICIANDO CHARTBOOK...');
    
    function refreshChartbook() {
        console.log('--- Refreshing Chartbook ---');
        
        // Verificar que DB esté disponible
        if (typeof DB === 'undefined' || !DB.operations) {
            console.error('❌ DB no está disponible');
            return;
        }
        
        console.log('📊 Total operations in DB:', DB.operations.length);
        
        const selectedAccount = document.getElementById('chartbook-account-select')?.value || 'all';
        const filter = document.getElementById('chartbook-filter')?.value || 'all';
        
        let operations = [...DB.operations];
        console.log('📊 Operations after copy:', operations.length);
        
        // Filtrar por cuenta
        if (selectedAccount !== 'all') {
            operations = operations.filter(op => op.accountId === selectedAccount);
            console.log('📊 After account filter:', operations.length);
        }
        
        // Filtrar por tipo
        if (filter === 'wins') {
            operations = operations.filter(op => op.result === 'win');
        } else if (filter === 'losses') {
            operations = operations.filter(op => op.result === 'loss');
        } else if (filter === 'with-images') {
            operations = operations.filter(op => op.imageDatas && op.imageDatas.length > 0);
        }
        console.log('📊 After filter:', filter, '- operations:', operations.length);
        
        // Función helper para extraer solo la hora de un string que puede contener fecha+hora
        const extractTime = (timeStr) => {
            if (!timeStr) return '00:00:00';
            
            // Si contiene una barra "/" es probable que tenga una fecha completa
            if (timeStr.includes('/')) {
                // Extraer solo la parte después del último espacio (la hora)
                const parts = timeStr.trim().split(' ');
                const timePart = parts[parts.length - 1];
                return timePart || '00:00:00';
            }
            
            // Si ya es solo hora, retornarla
            // Asegurar formato HH:MM:SS
            const timeParts = timeStr.split(':');
            if (timeParts.length === 2) {
                return timeStr + ':00'; // Agregar segundos si faltan
            } else if (timeParts.length === 3) {
                // Asegurar que los segundos tengan 2 dígitos
                const [h, m, s] = timeParts;
                return `${h}:${m}:${s.padStart(2, '0')}`;
            }
            
            return timeStr;
        };
        
        // Ordenar por fecha descendente (más reciente primero)
        operations.sort((a, b) => {
            try {
                // Limpiar las fechas y horas
                const cleanDateA = a.date || '2000-01-01';
                const cleanDateB = b.date || '2000-01-01';
                const cleanTimeA = extractTime(a.entryTime);
                const cleanTimeB = extractTime(b.entryTime);
                
                // Crear fechas completas
                const dateA = new Date(cleanDateA + 'T' + cleanTimeA);
                const dateB = new Date(cleanDateB + 'T' + cleanTimeB);
                
                // Si las fechas son válidas, comparar
                if (!isNaN(dateA.getTime()) && !isNaN(dateB.getTime())) {
                    return dateB.getTime() - dateA.getTime();
                }
                
                // Fallback: comparar solo por fecha string si el parsing falla
                return cleanDateB.localeCompare(cleanDateA);
            } catch (error) {
                console.error('Error al ordenar:', error);
                return 0;
            }
        });
        
        console.log('📊 First 5 operations after sort:', operations.slice(0, 5).map(op => ({
            id: op.id.substring(0, 8),
            date: op.date,
            entryTime: op.entryTime,
            instrument: op.instrument,
            pl: op.pl
        })));
        
        // Actualizar estadísticas
        const totalTrades = operations.length;
        const withImages = operations.filter(op => op.imageDatas && op.imageDatas.length > 0).length;
        const wins = operations.filter(op => op.result === 'win').length;
        const losses = operations.filter(op => op.result === 'loss').length;
        
        document.getElementById('chartbook-total-trades').textContent = totalTrades;
        document.getElementById('chartbook-with-images').textContent = withImages;
        document.getElementById('chartbook-wins').textContent = wins;
        document.getElementById('chartbook-losses').textContent = losses;
        
        // Renderizar galería
        const container = document.getElementById('chartbook-container');
        if (!container) return;
        
        if (operations.length === 0) {
            container.innerHTML = `
                <div class="metric-card p-8 text-center">
                    <p class="text-gray-400">No hay trades para mostrar</p>
                    <p class="text-sm text-gray-500 mt-2">Agrega screenshots a tus trades en la sección de Operaciones</p>
                </div>
            `;
            return;
        }
        
        container.innerHTML = operations.map(op => {
            const hasImages = op.imageDatas && op.imageDatas.length > 0;
            
            // Debug: Log image data for each operation
            if (hasImages) {
                console.log('[Chartbook] Op', op.id, 'tiene', op.imageDatas.length, 'imágenes');
                console.log('[Chartbook] Primera imagen:', op.imageDatas[0]);
            }
            
            const plColor = op.pl >= 0 ? 'text-positive' : 'text-negative';
            const resultBadge = op.result === 'win' 
                ? '<span class="px-2 py-1 bg-green-900 text-green-300 rounded text-xs">WIN</span>'
                : '<span class="px-2 py-1 bg-red-900 text-red-300 rounded text-xs">LOSS</span>';
            
            return `
                <div class="metric-card p-4 hover:bg-surface-hover transition-colors">
                    <div class="flex justify-between items-start mb-3">
                        <div class="flex-1">
                            <div class="flex items-center gap-2 mb-2">
                                <h3 class="text-lg font-semibold">${op.instrument || 'N/A'}</h3>
                                ${resultBadge}
                                <span class="px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs">${op.type === 'buy' ? 'LONG' : 'SHORT'}</span>
                            </div>
                            <p class="text-sm text-gray-400">
                                <i class="fas fa-calendar mr-1"></i>${op.date} ${op.entryTime || ''}
                            </p>
                            ${op.setup ? `<p class="text-xs text-primary mt-1"><i class="fas fa-tag mr-1"></i>${op.setup}</p>` : ''}
                        </div>
                        <div class="text-right">
                            <p class="text-2xl font-bold ${plColor}">
                                ${op.pl >= 0 ? '+' : ''}${op.pl?.toFixed(2) || '0.00'} ${op.currency || 'USD'}
                            </p>
                            <p class="text-xs text-gray-400">ID: ${op.id.substring(0, 8)}</p>
                        </div>
                    </div>

                    <!-- Prices destacados -->
                    <div class="grid grid-cols-3 gap-3 mb-3 p-3 bg-surface rounded-lg border border-border">
                        <div class="text-center">
                            <p class="text-xs text-gray-400 mb-1"><i class="fas fa-sign-in-alt mr-1"></i>Entry</p>
                            <p class="font-bold text-green-400 text-lg">${op.entry ? parseFloat(op.entry).toFixed(2) : (op.entryPrice ? parseFloat(op.entryPrice).toFixed(2) : '-')}</p>
                        </div>
                        <div class="text-center">
                            <p class="text-xs text-gray-400 mb-1"><i class="fas fa-sign-out-alt mr-1"></i>Exit</p>
                            <p class="font-bold text-red-400 text-lg">${op.exit ? parseFloat(op.exit).toFixed(2) : (op.exitPrice ? parseFloat(op.exitPrice).toFixed(2) : '-')}</p>
                        </div>
                        <div class="text-center">
                            <p class="text-xs text-gray-400 mb-1"><i class="fas fa-chart-bar mr-1"></i>Volume</p>
                            <p class="font-semibold text-white">${op.volume || '-'}</p>
                        </div>
                    </div>
                    
                    ${hasImages ? `
                        <div class="grid grid-cols-${op.imageDatas.length >= 3 ? '3' : op.imageDatas.length} gap-2 mb-3">
                            ${op.imageDatas.map((imgData, idx) => {
                                let imgSrc = '';
                                if (typeof imgData === 'string') {
                                    imgSrc = imgData;
                                } else if (imgData && typeof imgData === 'object') {
                                    imgSrc = imgData.data || imgData.url || imgData.src || '';
                                }
                                
                                // Debug logging
                                console.log('[Chartbook Render] Imagen', idx, ':', {
                                    type: typeof imgData,
                                    isObject: imgData && typeof imgData === 'object',
                                    hasData: imgData && imgData.data ? 'yes' : 'no',
                                    srcLength: imgSrc ? imgSrc.length : 0,
                                    srcPreview: imgSrc ? imgSrc.substring(0, 50) : 'EMPTY'
                                });
                                
                                // Solo mostrar imagen si tiene src válido
                                if (!imgSrc || imgSrc.trim() === '') {
                                    return `
                                        <div class="w-full h-48 bg-gray-800 rounded cursor-pointer border-2 border-gray-600 flex items-center justify-center">
                                            <div class="text-gray-400 text-center">
                                                <i class="fas fa-image-slash text-2xl mb-2"></i>
                                                <p class="text-xs">Imagen no disponible</p>
                                            </div>
                                        </div>
                                    `;
                                }
                                
                                return `
                                    <img src="${imgSrc}" 
                                         class="w-full h-48 object-cover rounded cursor-pointer hover:opacity-80 transition-opacity border-2 border-transparent hover:border-primary"
                                         data-op-id="${op.id}"
                                         data-img-index="${idx}"
                                         alt="Trade screenshot ${idx + 1}"
                                         onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';"
                                         onload="this.style.display='block'; if(this.nextElementSibling) this.nextElementSibling.style.display='none';">
                                    <div class="w-full h-48 bg-gray-800 rounded cursor-pointer border-2 border-gray-600 flex items-center justify-center" style="display: none;">
                                        <div class="text-gray-400 text-center">
                                            <i class="fas fa-exclamation-triangle text-2xl mb-2"></i>
                                            <p class="text-xs">Error al cargar imagen</p>
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    ` : `
                        <div class="bg-gray-900 h-48 rounded flex items-center justify-center mb-3">
                            <p class="text-gray-600"><i class="fas fa-image mr-2"></i>Sin imágenes</p>
                        </div>
                    `}
                    
                    ${op.notes ? `
                        <div class="bg-gray-900 p-3 rounded text-sm text-gray-300 mb-3">
                            <i class="fas fa-sticky-note mr-2"></i>${op.notes}
                        </div>
                    ` : ''}
                    
                    <div class="flex justify-end gap-2">
                        <button class="text-xs px-3 py-1 bg-blue-900 text-blue-300 rounded hover:bg-blue-800" 
                                onclick="viewTradeDetails('${op.id}')">
                            <i class="fas fa-info-circle mr-1"></i>Ver Detalles
                        </button>
                    </div>
                </div>
            `;
        }).join('');
        
        // Agregar event listeners a las imágenes después de renderizar
        setTimeout(() => {
            container.querySelectorAll('img[data-op-id]').forEach(img => {
                img.addEventListener('click', function() {
                    const opId = this.dataset.opId;
                    const imgIndex = parseInt(this.dataset.imgIndex);
                    const operation = DB.operations.find(op => op.id === opId);
                    
                    if (operation && operation.imageDatas) {
                        const imageUrls = operation.imageDatas.map(imgData => {
                            if (typeof imgData === 'string') {
                                try {
                                    const parsed = JSON.parse(imgData);
                                    return parsed.data || imgData;
                                } catch (e) {
                                    return imgData;
                                }
                            } else if (imgData && typeof imgData === 'object') {
                                return imgData.data || imgData.url || imgData.src || '';
                            }
                            return '';
                        }).filter(url => url && url.length > 0);
                        
                        console.log('🖼️ [Chartbook] Abriendo modal con', imageUrls.length, 'imágenes, índice', imgIndex);
                        console.log('🖼️ [Chartbook] Primera URL (limpia):', imageUrls[0] ? imageUrls[0].substring(0, 50) + '...' : 'N/A');
                        platformOpenImageModal(imageUrls, imgIndex);
                    }
                });
            });
        }, 100);
    }
    
    // Event listeners
    document.getElementById('chartbook-account-select')?.addEventListener('change', (e) => {
        const selectedAccount = e.target.value;
        syncAccountSelection(selectedAccount);
        refreshChartbook();
    });
    document.getElementById('chartbook-filter')?.addEventListener('change', refreshChartbook);
    
    // Inicializar selector de cuentas
    console.log('📊 Inicializando selector de cuentas Chartbook...');
    if (typeof updateAccountSelect === 'function') {
        updateAccountSelect('chartbook-account-select');
        console.log('✅ Selector de cuentas Chartbook inicializado');
    } else {
        console.error('❌ updateAccountSelect no está definida');
    }
    
    // Función para abrir modal de imagen (NO USAR - usar la global openImageModal en su lugar)
    // window.openImageModal ya está definida globalmente con mejor funcionalidad
    
    // Funciones auxiliares para editar y ver detalles
    window.editTrade = function(opId) {
        const op = DB.operations.find(o => o.id === opId);
        if (!op) return;
        
        // Navegar a Operaciones y abrir editor
        const operationsNav = document.querySelector('[data-target="operations"]');
        if (operationsNav) {
            operationsNav.click();
            setTimeout(() => {
                if (typeof toggleAddOperationForm === 'function') {
                    toggleAddOperationForm(op);
                }
            }, 200);
        }
    };
    
    window.viewTradeDetails = function(opId) {
        const op = DB.operations.find(o => o.id === opId);
        if (!op) return;
        
        // Mostrar directamente la página de detalles de la operación
        if (typeof showOperationDetailPage === 'function') {
            showOperationDetailPage(opId);
        }
    };
    
    // Inicializar al cargar la sección
    const chartbookNav = document.querySelector('[data-target="chartbook"]');
    if (chartbookNav) {
        chartbookNav.addEventListener('click', () => {
            setTimeout(() => {
                if (typeof updateAccountSelect === 'function') {
                    updateAccountSelect('chartbook-account-select');
                }
                refreshChartbook();
            }, 100);
        });
    }
    
    // Inicialización inicial
    console.log('🔄 Inicializando Chartbook...');
    setTimeout(() => {
        if (typeof updateAccountSelect === 'function') {
            updateAccountSelect('chartbook-account-select');
            console.log('✅ Selector de cuentas poblado');
        }
        if (typeof updateSelectorLogo === 'function') {
            updateSelectorLogo('chartbook-account-select');
        }
        refreshChartbook();
        console.log('✅ Chartbook inicializado');
    }, 500);
    
    window.refreshChartbook = refreshChartbook;
})();

// =============================================
// EQUITY GRAPH - GRÁFICO DE EQUITY
// =============================================
(function() {
    console.log('📈 INICIANDO EQUITY GRAPH...');
    let equityChart = null;

    // Función para aplicar filtros a las operaciones
    function applyEquityFilters(operations) {
        let filtered = [...operations];

        // Filtro de Período
        const periodFilter = document.getElementById('equity-period-filter')?.value || 'all';
        if (periodFilter !== 'all') {
            const now = new Date();
            let cutoffDate = null;

            switch (periodFilter) {
                case '1w':
                    cutoffDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                    break;
                case '1m':
                    cutoffDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
                    break;
                case '3m':
                    cutoffDate = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);
                    break;
                case '6m':
                    cutoffDate = new Date(now.getTime() - 180 * 24 * 60 * 60 * 1000);
                    break;
                case '1y':
                    cutoffDate = new Date(now.getTime() - 365 * 24 * 60 * 60 * 1000);
                    break;
                case 'custom':
                    const dateFrom = document.getElementById('equity-date-from')?.value;
                    const dateTo = document.getElementById('equity-date-to')?.value;
                    if (dateFrom) {
                        const fromDate = new Date(dateFrom);
                        filtered = filtered.filter(op => new Date(op.date) >= fromDate);
                    }
                    if (dateTo) {
                        const toDate = new Date(dateTo);
                        toDate.setHours(23, 59, 59, 999);
                        filtered = filtered.filter(op => new Date(op.date) <= toDate);
                    }
                    return filtered; // Retornar temprano para rango personalizado
            }

            if (cutoffDate) {
                filtered = filtered.filter(op => new Date(op.date) >= cutoffDate);
            }
        }

        // Filtro de Instrumento
        const instrumentFilter = document.getElementById('equity-instrument-filter')?.value;
        if (instrumentFilter && instrumentFilter !== 'all') {
            filtered = filtered.filter(op => op.instrument === instrumentFilter);
        }

        // Filtro de Resultado
        const outcomeFilter = document.getElementById('equity-outcome-filter')?.value || 'all';
        if (outcomeFilter !== 'all') {
            filtered = filtered.filter(op => op.result === outcomeFilter);
        }

        // Filtro de Dirección
        const directionFilter = document.getElementById('equity-direction-filter')?.value || 'all';
        if (directionFilter !== 'all') {
            filtered = filtered.filter(op => op.direction?.toLowerCase() === directionFilter);
        }

        // Filtro de Setup
        const setupFilter = document.getElementById('equity-setup-filter')?.value;
        if (setupFilter && setupFilter !== 'all') {
            filtered = filtered.filter(op => op.setup === setupFilter);
        }

        // Filtro de RRR
        const rrrFilter = parseFloat(document.getElementById('equity-rrr-filter')?.value || 0);
        if (rrrFilter > 0) {
            filtered = filtered.filter(op => (op.rrr || 0) >= rrrFilter);
        }

        // Filtro de Marcadas
        const starredFilter = document.getElementById('equity-starred-filter')?.value || 'all';
        if (starredFilter === 'starred') {
            filtered = filtered.filter(op => op.isStarred === true);
        } else if (starredFilter === 'not-starred') {
            filtered = filtered.filter(op => !op.isStarred);
        }

        // Filtro de Últimas N Operaciones
        const lastTradesFilter = document.getElementById('equity-last-trades-filter')?.value;
        if (lastTradesFilter && lastTradesFilter !== 'all') {
            const limit = parseInt(lastTradesFilter);
            filtered = filtered.slice(-limit);
        }

        return filtered;
    }

    // Función para popular selectores de filtros
    function populateEquityFilters() {
        // Verificar que DB esté disponible
        if (typeof DB === 'undefined' || !DB.operations) {
            console.error('❌ DB no está disponible en populateEquityFilters');
            return;
        }
        
        // Popular Instrumentos (filtros originales)
        const instrumentFilter = document.getElementById('equity-instrument-filter');
        if (instrumentFilter) {
            const instruments = [...new Set(DB.operations.map(op => op.instrument))].filter(Boolean).sort();
            instrumentFilter.innerHTML = '<option value="all">Todos</option>';
            instruments.forEach(inst => {
                const option = document.createElement('option');
                option.value = inst;
                option.textContent = inst;
                instrumentFilter.appendChild(option);
            });
        }

        // Popular Setups (filtros originales)
        const setupFilter = document.getElementById('equity-setup-filter');
        if (setupFilter) {
            const setups = [...new Set(DB.operations.map(op => op.setup))].filter(Boolean).sort();
            setupFilter.innerHTML = '<option value="all">Todos</option>';
            setups.forEach(setup => {
                const option = document.createElement('option');
                option.value = setup;
                option.textContent = setup;
                setupFilter.appendChild(option);
            });
        }
        
        // Popular Instrumentos (sidebar)
        const instrumentSidebar = document.getElementById('equity-sidebar-instrument');
        if (instrumentSidebar) {
            const instruments = [...new Set(DB.operations.map(op => op.instrument))].filter(Boolean).sort();
            instrumentSidebar.innerHTML = '<option value="all">Todos</option>';
            instruments.forEach(inst => {
                const option = document.createElement('option');
                option.value = inst;
                option.textContent = inst;
                instrumentSidebar.appendChild(option);
            });
        }

        // Popular Setups (sidebar)
        const setupSidebar = document.getElementById('equity-sidebar-setup');
        if (setupSidebar) {
            const setups = [...new Set(DB.operations.map(op => op.setup))].filter(Boolean).sort();
            setupSidebar.innerHTML = '<option value="all">Todos</option>';
            setups.forEach(setup => {
                const option = document.createElement('option');
                option.value = setup;
                option.textContent = setup;
                setupSidebar.appendChild(option);
            });
        }
    }

    // Variables globales para el nuevo sistema de Equity Graph
    let currentEquityView = 'performance'; // 'evaluator', 'edge-finder', 'performance'
    let equityCharts = {}; // Almacenar todas las instancias de gráficos
    let selectedEquityAccounts = ['all']; // Cuentas seleccionadas en Equity Graph
    let equityEvaluatorMode = false; // Modo evaluador activado/desactivado

    // Función para inicializar el multi-select de Equity Graph
    function initEquityMultiSelect() {
        console.log('🎯 Iniciando Multi-Select de Equity Graph');

        const trigger = document.getElementById('equity-account-trigger');
        const dropdown = document.getElementById('equity-account-dropdown');
        const display = document.getElementById('equity-account-display');
        const logo = document.getElementById('equity-account-logo');
        const logoImg = document.getElementById('equity-account-logo-img');

        console.log('Elementos encontrados:', {
            trigger: !!trigger,
            dropdown: !!dropdown,
            display: !!display,
            logo: !!logo,
            logoImg: !!logoImg
        });

        if (!trigger || !dropdown || !display) {
            console.error('❌ No se encontraron elementos multi-select de Equity');
            console.error('Faltantes:', {
                trigger: !trigger,
                dropdown: !dropdown,
                display: !display
            });
            return;
        }

        console.log('✅ Todos los elementos encontrados, poblando dropdown...');

        // Poblar dropdown con opciones
        populateEquityMultiSelectDropdown();

        console.log('✅ Dropdown poblado, agregando event listeners...');

        // Toggle dropdown
        trigger.addEventListener('click', (e) => {
            console.log('🖱️ Click en trigger');
            e.stopPropagation();
            const isOpen = dropdown.classList.toggle('open');
            trigger.classList.toggle('open');
            console.log('Dropdown ahora está:', isOpen ? 'ABIERTO' : 'CERRADO');
        });

        // Cerrar dropdown al hacer clic fuera
        document.addEventListener('click', (e) => {
            if (!trigger.contains(e.target) && !dropdown.contains(e.target)) {
                const wasOpen = dropdown.classList.contains('open');
                dropdown.classList.remove('open');
                trigger.classList.remove('open');
                if (wasOpen) console.log('🖱️ Dropdown cerrado (click fuera)');
            }
        });

        console.log('✅ Multi-Select de Equity Graph inicializado correctamente');
    }

    function populateEquityMultiSelectDropdown() {
        console.log('📋 Poblando dropdown de Equity Multi-Select...');
        const dropdown = document.getElementById('equity-account-dropdown');

        if (!dropdown) {
            console.error('❌ Dropdown no encontrado');
            return;
        }
        if (!DB || !DB.accounts) {
            console.error('❌ DB o DB.accounts no disponible');
            return;
        }

        console.log(`📊 Encontradas ${DB.accounts.length} cuentas`);
        console.log('🎯 selectedEquityAccounts actual:', selectedEquityAccounts);

        dropdown.innerHTML = '';

        // Opción "Todas las cuentas"
        const allOption = document.createElement('div');
        allOption.className = 'multi-select-option all';
        allOption.innerHTML = `
            <input type="checkbox" id="equity-account-all" value="all" ${selectedEquityAccounts.includes('all') ? 'checked' : ''}>
            <label for="equity-account-all" style="cursor: pointer; user-select: none;">Todas las cuentas</label>
        `;
        dropdown.appendChild(allOption);

        const allCheckbox = allOption.querySelector('input');
        allCheckbox.addEventListener('change', (e) => {
            console.log('🔄 Checkbox "Todas" cambiado:', e.target.checked);
            if (e.target.checked) {
                selectedEquityAccounts = ['all'];
                // Desmarcar todas las demás cuentas
                dropdown.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                    if (cb.value !== 'all') cb.checked = false;
                });
            } else {
                selectedEquityAccounts = [];
            }
            console.log('📝 selectedEquityAccounts ahora:', selectedEquityAccounts);
            updateEquityMultiSelectDisplay();
            refreshEquityGraph();
        });

        // Opciones individuales de cuentas
        DB.accounts.forEach(account => {
            const option = document.createElement('div');
            option.className = 'multi-select-option';
            option.setAttribute('data-platform', account.platform);
            option.innerHTML = `
                <input type="checkbox" id="equity-account-${account.id}" value="${account.id}" ${selectedEquityAccounts.includes(account.id) ? 'checked' : ''}>
                <label for="equity-account-${account.id}" style="cursor: pointer; user-select: none;">${account.name}</label>
            `;
            dropdown.appendChild(option);

            const checkbox = option.querySelector('input');
            checkbox.addEventListener('change', (e) => {
                const accountId = e.target.value;
                console.log(`🔄 Checkbox cuenta "${accountId}" cambiado:`, e.target.checked);

                if (e.target.checked) {
                    // Desmarcar "todas las cuentas" si se selecciona una cuenta específica
                    allCheckbox.checked = false;
                    if (selectedEquityAccounts.includes('all')) {
                        selectedEquityAccounts = [];
                    }

                    if (!selectedEquityAccounts.includes(accountId)) {
                        selectedEquityAccounts.push(accountId);
                    }
                } else {
                    selectedEquityAccounts = selectedEquityAccounts.filter(id => id !== accountId);
                }

                // Si todas las cuentas están seleccionadas, marcar "Todas"
                const allAccountsSelected = DB.accounts.every(acc =>
                    selectedEquityAccounts.includes(acc.id)
                );
                if (allAccountsSelected && DB.accounts.length > 0) {
                    allCheckbox.checked = true;
                    selectedEquityAccounts = ['all'];
                    dropdown.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                        if (cb.value !== 'all') cb.checked = false;
                    });
                }

                // Si no hay ninguna cuenta seleccionada, marcar "Todas"
                if (selectedEquityAccounts.length === 0) {
                    allCheckbox.checked = true;
                    selectedEquityAccounts = ['all'];
                }

                console.log('📝 selectedEquityAccounts ahora:', selectedEquityAccounts);
                updateEquityMultiSelectDisplay();
                refreshEquityGraph();
            });
        });

        console.log('✅ Dropdown poblado con', dropdown.querySelectorAll('.multi-select-option').length, 'opciones');
    }

    function updateEquityMultiSelectDisplay() {
        const display = document.getElementById('equity-account-display');
        const logo = document.getElementById('equity-account-logo');
        const logoImg = document.getElementById('equity-account-logo-img');

        if (!display) return;

        if (selectedEquityAccounts.includes('all')) {
            display.textContent = 'Todas las cuentas';
            if (logo) logo.style.display = 'none';
        } else if (selectedEquityAccounts.length === 1) {
            const account = DB.accounts.find(a => a.id === selectedEquityAccounts[0]);
            if (account) {
                display.textContent = account.name;
                // Mostrar logo si existe
                if (logo && logoImg && account.logo) {
                    logoImg.src = account.logo;
                    logo.style.display = 'flex';
                } else if (logo) {
                    logo.style.display = 'none';
                }
            }
        } else if (selectedEquityAccounts.length > 1) {
            display.textContent = `${selectedEquityAccounts.length} cuentas seleccionadas`;
            if (logo) logo.style.display = 'none';
        } else {
            display.textContent = 'Seleccionar cuenta';
            if (logo) logo.style.display = 'none';
        }
    }

    // Función principal de refresh con gestión de subsecciones
    function refreshEquityGraph() {
        console.log('--- Refreshing Equity Graph (New System) ---');
        console.log('Current view:', currentEquityView);
        console.log('DB operations count:', DB ? DB.operations.length : 'DB not available');
        console.log('DB accounts count:', DB ? DB.accounts.length : 'DB not available');

        if (!DB || !DB.operations || !DB.accounts) {
            console.error('DB or DB data not available yet');
            return;
        }

        console.log('All checks passed, rendering view:', currentEquityView);

        // Renderizar la vista activa
        switch (currentEquityView) {
            case 'evaluator':
                renderEvaluator();
                break;
            case 'edge-finder':
                renderEdgeFinder();
                break;
            case 'performance':
                renderPerformanceAnalytics();
                break;
            default:
                console.warn('Unknown equity view:', currentEquityView);
                renderEvaluator(); // Fallback to evaluator
        }
    }
    
    // ==========================================
    // SUBSECCIÓN 1: EVALUADOR DE CUENTAS
    // ==========================================
    function renderEvaluator() {
        console.log('Rendering Evaluador de Cuentas...');

        // Usar el selector principal de Equity Graph (selectedEquityAccounts)
        // Ya no necesitamos poblar un selector separado
        renderEvaluatorCharts();
    }

    function renderEvaluatorCharts() {
        // Obtener cuentas seleccionadas desde el selector principal
        let selected = [];

        if (selectedEquityAccounts.includes('all')) {
            // Si está en "Todas las cuentas", usar todas
            selected = DB.accounts.map(a => a.id);
        } else {
            // Si hay cuentas específicas seleccionadas
            selected = [...selectedEquityAccounts];
        }

        if (selected.length === 0) {
            console.log('No accounts selected for comparison - hiding charts');
            // Limpiar los canvas
            const mainCanvas = document.getElementById('evaluator-main-chart');
            if (mainCanvas && equityCharts.evaluatorMain) {
                equityCharts.evaluatorMain.destroy();
                equityCharts.evaluatorMain = null;
            }
            return;
        }

        console.log('Rendering charts for', selected.length, 'accounts');
        
        // Preparar datos para cada cuenta
        const accountsData = selected.map(accountId => {
            const account = DB.accounts.find(a => a.id === accountId);
            const accountOps = DB.operations.filter(op => op.accountId === accountId).sort((a, b) => new Date(a.date) - new Date(b.date));
            
            let cumulativePL = 0;
            const equityLine = [{x: new Date(accountOps[0]?.date || new Date()).getTime(), y: 0}]; // Punto inicial con fecha
            
            accountOps.forEach((op, idx) => {
                const pl = convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency);
                cumulativePL += pl;
                equityLine.push({x: new Date(op.date).getTime(), y: cumulativePL});
            });
            
            const metrics = calculateMetrics(accountOps);
            const initialBalance = convertCurrency(account.initialBalance, account.currency, DB.settings.defaultCurrency);
            const finalBalance = initialBalance + cumulativePL;
            
            return {
                account,
                equityLine,
                metrics,
                initialBalance,
                finalBalance,
                totalPL: cumulativePL,
                returnPct: initialBalance > 0 ? (cumulativePL / initialBalance) * 100 : 0
            };
        });
        
        // Renderizar gráfico principal de comparación
        renderEvaluatorMainChart(accountsData);
        
        // Renderizar tabla de comparación
        renderEvaluatorTable(accountsData);
        
        // Renderizar gráficos adicionales
        renderEvaluatorVolumeChart(accountsData);
        renderEvaluatorWinrateChart(accountsData);
        renderEvaluatorMonthlyChart(accountsData);
    }
    
    function renderEvaluatorMainChart(accountsData) {
        const canvas = document.getElementById('evaluator-main-chart');
        if (!canvas) {
            console.error('Canvas evaluator-main-chart not found!');
            return;
        }
        
        console.log('Rendering main chart with', accountsData.length, 'accounts');
        
        // Destruir gráfico anterior
        if (equityCharts.evaluatorMain) {
            equityCharts.evaluatorMain.destroy();
        }
        
        const colors = ['#39FF14', '#0066FF', '#666666', '#006400'];
        
        // Obtener el modo de visualización seleccionado
        const displayMode = document.getElementById('evaluator-display-mode')?.value || 'return';
        const chartType = document.getElementById('evaluator-chart-type')?.value || 'area';
        
        // Preparar datasets según el modo seleccionado
        const datasets = accountsData.map((data, idx) => {
            let chartData = [];
            
            if (displayMode === 'return') {
                // Return ($) - P/L acumulado
                chartData = data.equityLine;
            } else if (displayMode === 'balance') {
                // Balance de Cuenta ($)
                chartData = data.equityLine.map(point => ({
                    x: point.x,
                    y: data.initialBalance + point.y
                }));
            } else if (displayMode === 'return-pct') {
                // Return (%)
                chartData = data.equityLine.map(point => ({
                    x: point.x,
                    y: data.initialBalance > 0 ? (point.y / data.initialBalance) * 100 : 0
                }));
            } else if (displayMode === 'roi') {
                // ROI (%)
                chartData = data.equityLine.map(point => ({
                    x: point.x,
                    y: data.initialBalance > 0 ? (point.y / data.initialBalance) * 100 : 0
                }));
            } else if (displayMode === 'r-multiple') {
                // R-Multiple (requiere riesgo inicial)
                const avgRisk = data.metrics.avgPL ? Math.abs(data.metrics.avgPL / 2) : 1;
                chartData = data.equityLine.map(point => ({
                    x: point.x,
                    y: avgRisk > 0 ? point.y / avgRisk : 0
                }));
            }
            
            return {
                label: data.account.name,
                data: chartData,
                borderColor: colors[idx % colors.length],
                backgroundColor: `${colors[idx % colors.length]}${chartType === 'area' ? '40' : '00'}`,
                borderWidth: 3,
                fill: chartType === 'area',
                tension: chartType === 'stepped' ? 0 : 0.4,
                stepped: chartType === 'stepped',
                pointRadius: 0,
                pointHoverRadius: 6
            };
        });
        
        // Determinar el label del eje Y según el modo
        let yAxisLabel = 'P/L Acumulado ($)';
        let yAxisCallback = value => '$' + value.toFixed(0);
        
        if (displayMode === 'balance') {
            yAxisLabel = 'Balance de Cuenta ($)';
        } else if (displayMode === 'return-pct' || displayMode === 'roi') {
            yAxisLabel = 'Return (%)';
            yAxisCallback = value => value.toFixed(1) + '%';
        } else if (displayMode === 'r-multiple') {
            yAxisLabel = 'R-Multiple';
            yAxisCallback = value => value.toFixed(2) + 'R';
        }
        
        equityCharts.evaluatorMain = new Chart(canvas.getContext('2d'), {
            type: 'line',
            data: { datasets },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'index',
                    intersect: false
                },
                plugins: {
                    legend: {
                        display: true,
                        position: 'top',
                        labels: {
                            color: '#FFFFFF',
                            usePointStyle: true,
                            padding: 15
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: (item) => {
                                if (displayMode === 'return-pct' || displayMode === 'roi') {
                                    return `${item.dataset.label}: ${item.parsed.y.toFixed(2)}%`;
                                } else if (displayMode === 'r-multiple') {
                                    return `${item.dataset.label}: ${item.parsed.y.toFixed(2)}R`;
                                } else {
                                    return `${item.dataset.label}: $${item.parsed.y.toFixed(2)}`;
                                }
                            },
                            title: (items) => {
                                if (items[0]?.parsed?.x) {
                                    const date = new Date(items[0].parsed.x);
                                    return date.toLocaleDateString('es-ES', { 
                                        year: 'numeric', 
                                        month: 'short', 
                                        day: 'numeric' 
                                    });
                                }
                                return '';
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            unit: 'day',
                            displayFormats: {
                                day: 'MMM dd',
                                week: 'MMM dd',
                                month: 'MMM yyyy'
                            }
                        },
                        title: { display: true, text: 'Fecha', color: '#FFF' },
                        grid: { color: '#2a2a2a' },
                        ticks: { 
                            color: '#FFF',
                            maxRotation: 45,
                            minRotation: 0
                        }
                    },
                    y: {
                        title: { display: true, text: yAxisLabel, color: '#FFF' },
                        grid: { color: '#2a2a2a' },
                        ticks: { color: '#FFF', callback: yAxisCallback }
                    }
                }
            }
        });
    }
    
    function renderEvaluatorTable(accountsData) {
        const tbody = document.getElementById('evaluator-comparison-tbody');
        if (!tbody) return;
        
        tbody.innerHTML = '';
        
        // Ordenar por Sharpe Ratio (calculado simple)
        accountsData.sort((a, b) => {
            const sharpeA = a.metrics.avgPL / (a.metrics.stdDev || 1);
            const sharpeB = b.metrics.avgPL / (b.metrics.stdDev || 1);
            return sharpeB - sharpeA;
        });
        
        accountsData.forEach((data, idx) => {
            const sharpe = (data.metrics.avgPL / (data.metrics.stdDev || 1)).toFixed(2);
            const maxDD = calculateMaxDrawdown(DB.operations.filter(op => op.accountId === data.account.id));
            
            const row = document.createElement('tr');
            row.className = 'border-b border-gray-700/50';
            row.innerHTML = `
                <td class="p-3 text-left" style="position: sticky; left: 0; background: var(--surface); z-index: 5;">
                    <strong>${data.account.name}</strong>
                </td>
                <td class="p-3 text-right">$${data.initialBalance.toFixed(2)}</td>
                <td class="p-3 text-right ${data.finalBalance >= data.initialBalance ? 'text-primary' : 'text-red-400'} font-bold">$${data.finalBalance.toFixed(2)}</td>
                <td class="p-3 text-right ${data.totalPL >= 0 ? 'text-primary' : 'text-red-400'} font-bold">$${data.totalPL.toFixed(2)}</td>
                <td class="p-3 text-right ${data.returnPct >= 0 ? 'text-primary' : 'text-red-400'} font-bold">${data.returnPct.toFixed(2)}%</td>
                <td class="p-3 text-center">${data.metrics.totalTrades}</td>
                <td class="p-3 text-right ${data.metrics.winRate >= 50 ? 'text-primary' : 'text-red-400'}">${data.metrics.winRate.toFixed(1)}%</td>
                <td class="p-3 text-right ${data.metrics.profitFactor >= 1 ? 'text-primary' : 'text-red-400'}">${data.metrics.profitFactor.toFixed(2)}</td>
                <td class="p-3 text-right text-red-400">-${maxDD.toFixed(2)}%</td>
                <td class="p-3 text-right ${parseFloat(sharpe) > 0 ? 'text-primary' : 'text-gray-400'}">${sharpe}</td>
                <td class="p-3 text-center">${idx + 1}</td>
            `;
            tbody.appendChild(row);
        });
    }
    
    function renderEvaluatorVolumeChart(accountsData) {
        const canvas = document.getElementById('evaluator-volume-chart');
        if (!canvas) return;
        
        if (equityCharts.evaluatorVolume) {
            equityCharts.evaluatorVolume.destroy();
        }
        
        const colors = ['#39FF14', '#0066FF', '#666666', '#006400'];
        
        equityCharts.evaluatorVolume = new Chart(canvas.getContext('2d'), {
            type: 'bar',
            data: {
                labels: accountsData.map(d => d.account.name),
                datasets: [{
                    label: 'Operaciones',
                    data: accountsData.map(d => d.metrics.totalTrades),
                    backgroundColor: colors.map(c => c + 'CC'),
                    borderColor: colors,
                    borderWidth: 2
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            label: (item) => `Operaciones: ${item.parsed.y}`
                        }
                    }
                },
                scales: {
                    x: { grid: { color: '#2a2a2a' }, ticks: { color: '#FFF' } },
                    y: { grid: { color: '#2a2a2a' }, ticks: { color: '#FFF' } }
                }
            }
        });
    }
    
    function renderEvaluatorWinrateChart(accountsData) {
        const canvas = document.getElementById('evaluator-winrate-chart');
        if (!canvas) return;
        
        if (equityCharts.evaluatorWinrate) {
            equityCharts.evaluatorWinrate.destroy();
        }
        
        const winrateColors = ['#39FF14', '#0066FF', '#666666', '#006400'];
        
        equityCharts.evaluatorWinrate = new Chart(canvas.getContext('2d'), {
            type: 'bar',
            data: {
                labels: accountsData.map(d => d.account.name),
                datasets: [{
                    label: 'Winrate %',
                    data: accountsData.map(d => d.metrics.winRate),
                    backgroundColor: accountsData.map((d, idx) => winrateColors[idx % winrateColors.length] + 'CC'),
                    borderColor: accountsData.map((d, idx) => winrateColors[idx % winrateColors.length]),
                    borderWidth: 2
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { display: false }
                },
                scales: {
                    x: { grid: { color: '#2a2a2a' }, ticks: { color: '#FFF' } },
                    y: { 
                        grid: { color: '#2a2a2a' }, 
                        ticks: { color: '#FFF', callback: v => v + '%' },
                        max: 100
                    }
                }
            }
        });
    }
    
    function renderEvaluatorMonthlyChart(accountsData) {
        const canvas = document.getElementById('evaluator-monthly-chart');
        if (!canvas) return;
        
        if (equityCharts.evaluatorMonthly) {
            equityCharts.evaluatorMonthly.destroy();
        }
        
        // Calcular P/L mensual por cuenta (simplificado - últimos 6 meses)
        const monthsLabels = ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'];
        const now = new Date();
        const last6Months = [];
        for (let i = 5; i >= 0; i--) {
            const d = new Date(now.getFullYear(), now.getMonth() - i, 1);
            last6Months.push({ month: d.getMonth(), year: d.getFullYear(), label: monthsLabels[d.getMonth()] });
        }
        
        const colors = ['#39FF14', '#0066FF', '#666666', '#006400'];
        const datasets = accountsData.map((data, idx) => {
            const monthlyPL = last6Months.map(m => {
                return DB.operations
                    .filter(op => op.accountId === data.account.id)
                    .filter(op => {
                        const opDate = new Date(op.date);
                        return opDate.getMonth() === m.month && opDate.getFullYear() === m.year;
                    })
                    .reduce((sum, op) => sum + convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency), 0);
            });
            
            return {
                label: data.account.name,
                data: monthlyPL,
                borderColor: colors[idx % colors.length],
                backgroundColor: `${colors[idx % colors.length]}40`,
                borderWidth: 2,
                fill: true,
                tension: 0.4
            };
        });
        
        equityCharts.evaluatorMonthly = new Chart(canvas.getContext('2d'), {
            type: 'line',
            data: {
                labels: last6Months.map(m => m.label),
                datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: true,
                        position: 'top',
                        labels: { color: '#FFF', usePointStyle: true, padding: 10 }
                    }
                },
                scales: {
                    x: { grid: { color: '#2a2a2a' }, ticks: { color: '#FFF' } },
                    y: { 
                        grid: { color: '#2a2a2a' }, 
                        ticks: { color: '#FFF', callback: v => '$' + v.toFixed(0) }
                    }
                }
            }
        });
    }
    
    // ==========================================
    // SUBSECCIÓN 2: EDGE FINDER
    // ==========================================
    function renderEdgeFinder() {
        console.log('Rendering Edge Finder...');

        // Filtrar operaciones por cuentas seleccionadas
        let operations = DB.operations.filter(op => op.result);
        if (!selectedEquityAccounts.includes('all')) {
            operations = operations.filter(op => selectedEquityAccounts.includes(op.accountId));
        }
        operations = operations.sort((a, b) => new Date(a.date) - new Date(b.date));

        if (operations.length === 0) {
            console.log('No operations with results found for Edge Finder');
            return;
        }

        console.log('Edge Finder: Processing', operations.length, 'operations');
        
        // AI Insights Cards
        renderEdgeInsights(operations);
        
        // Winning Patterns
        renderWinningPatterns(operations);
        
        // What-If Analysis
        renderWhatIfAnalysis(operations);
        
        // Exit Analysis Charts
        renderExitAnalysis(operations);
        
        // Risk-Adjusted Metrics
        renderRiskAdjustedMetrics(operations);
    }
    
    function renderEdgeInsights(operations) {
        // Best Setup
        const setupPL = {};
        operations.forEach(op => {
            const setupId = op.setupId || 'Sin setup';
            if (!setupPL[setupId]) setupPL[setupId] = { pl: 0, count: 0 };
            setupPL[setupId].pl += convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency);
            setupPL[setupId].count++;
        });
        
        let bestSetup = { id: 'N/A', pl: 0, winrate: 0 };
        Object.keys(setupPL).forEach(setupId => {
            if (setupPL[setupId].pl > bestSetup.pl) {
                const setupOps = operations.filter(op => (op.setupId || 'Sin setup') === setupId);
                const wins = setupOps.filter(op => op.result === 'win').length;
                const winrate = setupOps.length > 0 ? (wins / setupOps.length * 100) : 0;
                
                const setupName = setupId === 'Sin setup' ? 'Sin setup' : (DB.setups.find(s => s.id === setupId)?.name || setupId);
                bestSetup = { id: setupName, pl: setupPL[setupId].pl, winrate };
            }
        });
        
        const nameEl = document.getElementById('edge-best-setup-name');
        const winrateEl = document.getElementById('edge-best-setup-winrate');
        const profitEl = document.getElementById('edge-best-setup-profit');
        if (nameEl) nameEl.textContent = bestSetup.id;
        if (winrateEl) winrateEl.textContent = `${bestSetup.winrate.toFixed(1)}% WR`;
        if (profitEl) profitEl.textContent = `+$${bestSetup.pl.toFixed(2)}`;
        
        // Best Time
        const hourPL = {};
        operations.forEach(op => {
            const hour = new Date(op.date).getHours();
            if (!hourPL[hour]) hourPL[hour] = 0;
            hourPL[hour] += convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency);
        });
        
        let bestHour = { hour: 'N/A', pl: -Infinity };
        Object.keys(hourPL).forEach(h => {
            if (hourPL[h] > bestHour.pl) {
                bestHour = { hour: h, pl: hourPL[h] };
            }
        });
        
        const hourOps = operations.filter(op => new Date(op.date).getHours() == bestHour.hour);
        const hourWinrate = hourOps.length > 0 ? (hourOps.filter(op => op.result === 'win').length / hourOps.length * 100) : 0;
        
        const hourEl = document.getElementById('edge-best-time-hour');
        const tradesEl = document.getElementById('edge-best-time-trades');
        const timeWinrateEl = document.getElementById('edge-best-time-winrate');
        if (hourEl) hourEl.textContent = bestHour.hour !== 'N/A' ? `${bestHour.hour}:00` : 'N/A';
        if (tradesEl) tradesEl.textContent = `${hourOps.length} trades`;
        if (timeWinrateEl) timeWinrateEl.textContent = `${hourWinrate.toFixed(1)}% WR`;
        
        // Opportunity Lost
        const totalProfit = operations.filter(op => op.result === 'win').reduce((s, op) => s + convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency), 0);
        const totalLoss = Math.abs(operations.filter(op => op.result === 'loss').reduce((s, op) => s + convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency), 0));
        const avgWin = operations.filter(op => op.result === 'win').length > 0 ? totalProfit / operations.filter(op => op.result === 'win').length : 0;
        const lossCount = operations.filter(op => op.result === 'loss').length;
        const potentialGain = avgWin * lossCount - totalLoss;
        
        const oppAmountEl = document.getElementById('edge-opp-lost-amount');
        const oppTradesEl = document.getElementById('edge-opp-lost-trades');
        if (oppAmountEl) oppAmountEl.textContent = potentialGain > 0 ? `+$${potentialGain.toFixed(2)}` : '$0.00';
        if (oppTradesEl) oppTradesEl.textContent = `${lossCount} trades mejorados`;
    }
    
    function renderWinningPatterns(operations) {
        // NOTA: Esta función está deshabilitada temporalmente porque el elemento HTML
        // "edge-patterns-grid" no existe. Los patrones ganadores se muestran en las
        // tarjetas de insights superiores (Mejor Setup, Mejor Horario, etc.)
        console.log('📊 renderWinningPatterns: Saltando (elemento HTML no implementado)');
        return;

        /* CÓDIGO ORIGINAL COMENTADO
        const patterns = [
            { name: 'Días consecutivos ganadores',
              value: calculateMaxStreak(operations, 'win'),
              color: 'bg-gradient-to-br from-green-900/20 to-surface border border-primary/30'
            },
            { name: 'Mejor instrumento',
              value: findBestInstrument(operations),
              color: 'bg-gradient-to-br from-green-900/20 to-surface border border-primary/30'
            },
            { name: 'Mejor sesión',
              value: findBestSession(operations),
              color: 'bg-gradient-to-br from-green-900/20 to-surface border border-primary/30'
            }
        ];

        const container = document.getElementById('edge-patterns-grid');
        if (!container) {
            console.log('edge-patterns-grid not found, skipping pattern rendering');
            return;
        }
        container.innerHTML = patterns.map(p => `
            <div class="card ${p.color} p-4">
                <div class="flex items-center gap-3 mb-2">
                    <h4 class="text-sm text-primary font-semibold">${p.name}</h4>
                </div>
                <p class="text-2xl font-bold text-white">${p.value}</p>
            </div>
        `).join('');
        */
    }

    function renderWhatIfAnalysis(operations) {
        const scenarios = [
            { 
                condition: 'Solo trading en mejores horas (10-14)', 
                filter: op => {
                    const hour = new Date(op.date).getHours();
                    return hour >= 10 && hour <= 14;
                }
            },
            { 
                condition: 'Solo mejor setup', 
                filter: op => {
                    // Encontrar mejor setup
                    const setupPL = {};
                    operations.forEach(o => {
                        const sid = o.setupId || 'none';
                        if (!setupPL[sid]) setupPL[sid] = 0;
                        setupPL[sid] += convertCurrency(o.pl || 0, o.currency, DB.settings.defaultCurrency);
                    });
                    const best = Object.keys(setupPL).reduce((a, b) => setupPL[a] > setupPL[b] ? a : b);
                    return (op.setupId || 'none') === best;
                }
            },
            { 
                condition: 'Sin pérdidas mayores a $100', 
                filter: op => {
                    const pl = convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency);
                    return pl >= -100;
                }
            }
        ];
        
        const tbody = document.getElementById('edge-whatif-tbody');
        if (!tbody) {
            console.log('edge-whatif-tbody not found');
            return;
        }
        tbody.innerHTML = scenarios.map(scenario => {
            const filteredOps = operations.filter(scenario.filter);
            const profit = filteredOps.reduce((s, op) => s + convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency), 0);
            const currentProfit = operations.reduce((s, op) => s + convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency), 0);
            const diff = profit - currentProfit;
            const diffPct = currentProfit !== 0 ? (diff / Math.abs(currentProfit) * 100) : 0;
            
            return `
                <tr class="border-b border-gray-700/50">
                    <td class="text-sm">${scenario.condition}</td>
                    <td class="${profit >= 0 ? 'text-primary' : 'text-red-400'} font-bold">$${profit.toFixed(2)}</td>
                    <td class="${diff >= 0 ? 'text-primary' : 'text-red-400'}">${diff >= 0 ? '+' : ''}$${diff.toFixed(2)}</td>
                    <td class="${diffPct >= 0 ? 'text-primary' : 'text-red-400'}">${diffPct >= 0 ? '+' : ''}${diffPct.toFixed(1)}%</td>
                </tr>
            `;
        }).join('');
    }
    
    function renderExitAnalysis(operations) {
        // Winners Cut Early Chart
        const canvas1 = document.getElementById('edge-winners-cut-chart');
        if (canvas1) {
            if (equityCharts.edgeWinnersCut) equityCharts.edgeWinnersCut.destroy();
            
            const winningOps = operations.filter(op => op.result === 'win');
            const avgWin = winningOps.length > 0 ? winningOps.reduce((s, op) => s + convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency), 0) / winningOps.length : 0;
            
            const cutEarly = winningOps.filter(op => {
                const pl = convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency);
                return pl < avgWin * 0.8; // Menos del 80% del promedio
            }).length;
            
            const heldFull = winningOps.length - cutEarly;
            
            equityCharts.edgeWinnersCut = new Chart(canvas1.getContext('2d'), {
                type: 'doughnut',
                data: {
                    labels: ['Held to Target', 'Cut Early'],
                    datasets: [{
                        data: [heldFull, cutEarly],
                        backgroundColor: ['#39FF14', '#FF3131'],
                        borderWidth: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { color: '#FFF' }
                        }
                    }
                }
            });
        }
        
        // Losers Held Long Chart
        const canvas2 = document.getElementById('edge-losers-held-chart');
        if (canvas2) {
            if (equityCharts.edgeLosersHeld) equityCharts.edgeLosersHeld.destroy();
            
            const losingOps = operations.filter(op => op.result === 'loss');
            const avgLoss = losingOps.length > 0 ? Math.abs(losingOps.reduce((s, op) => s + convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency), 0) / losingOps.length) : 0;
            
            const heldLong = losingOps.filter(op => {
                const pl = Math.abs(convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency));
                return pl > avgLoss * 1.2; // Más del 120% del promedio
            }).length;
            
            const cutQuick = losingOps.length - heldLong;
            
            equityCharts.edgeLosersHeld = new Chart(canvas2.getContext('2d'), {
                type: 'doughnut',
                data: {
                    labels: ['Cut at Stop', 'Held Too Long'],
                    datasets: [{
                        data: [cutQuick, heldLong],
                        backgroundColor: ['#39ff14', '#FF3131'],
                        borderWidth: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { color: '#FFF' }
                        }
                    }
                }
            });
        }
    }
    
    function renderRiskAdjustedMetrics(operations) {
        const plArray = operations.map(op => convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency));
        const avgPL = plArray.reduce((a, b) => a + b, 0) / plArray.length || 0;
        const stdDev = Math.sqrt(plArray.reduce((sum, pl) => sum + Math.pow(pl - avgPL, 2), 0) / plArray.length) || 1;
        
        // Sharpe Ratio (simplified: avgPL / stdDev)
        const sharpe = (avgPL / stdDev).toFixed(2);
        
        // Sortino Ratio (only downside deviation)
        const downsidePL = plArray.filter(pl => pl < 0);
        const downsideStdDev = downsidePL.length > 0 ? Math.sqrt(downsidePL.reduce((sum, pl) => sum + Math.pow(pl, 2), 0) / downsidePL.length) : 1;
        const sortino = (avgPL / downsideStdDev).toFixed(2);
        
        // Calmar Ratio (return / max drawdown)
        const maxDD = calculateMaxDrawdown(operations) || 1;
        const totalReturn = plArray.reduce((a, b) => a + b, 0);
        const calmar = (totalReturn / maxDD).toFixed(2);
        
        // Expectancy
        const wins = operations.filter(op => op.result === 'win');
        const losses = operations.filter(op => op.result === 'loss');
        const winRate = operations.length > 0 ? wins.length / operations.length : 0;
        const avgWin = wins.length > 0 ? wins.reduce((s, op) => s + convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency), 0) / wins.length : 0;
        const avgLoss = losses.length > 0 ? Math.abs(losses.reduce((s, op) => s + convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency), 0) / losses.length) : 0;
        const expectancy = ((winRate * avgWin) - ((1 - winRate) * avgLoss)).toFixed(2);
        
        const sharpeEl = document.getElementById('edge-sharpe');
        const sortinoEl = document.getElementById('edge-sortino');
        const calmarEl = document.getElementById('edge-calmar');
        const expectancyEl = document.getElementById('edge-expectancy');
        
        if (sharpeEl) {
            sharpeEl.textContent = sharpe;
            sharpeEl.className = parseFloat(sharpe) > 1 ? 'text-primary text-3xl font-bold' : 'text-gray-400 text-3xl font-bold';
        }
        if (sortinoEl) {
            sortinoEl.textContent = sortino;
            sortinoEl.className = parseFloat(sortino) > 1 ? 'text-primary text-3xl font-bold' : 'text-gray-400 text-3xl font-bold';
        }
        if (calmarEl) {
            calmarEl.textContent = calmar;
            calmarEl.className = parseFloat(calmar) > 1 ? 'text-primary text-3xl font-bold' : 'text-gray-400 text-3xl font-bold';
        }
        if (expectancyEl) {
            expectancyEl.textContent = `$${expectancy}`;
            expectancyEl.className = parseFloat(expectancy) > 0 ? 'text-primary text-3xl font-bold' : 'text-red-400 text-3xl font-bold';
        }
    }
    
    // Helper functions for Edge Finder
    function calculateMaxStreak(operations, type) {
        let maxStreak = 0;
        let currentStreak = 0;
        
        operations.sort((a, b) => new Date(a.date) - new Date(b.date)).forEach(op => {
            if (op.result === type) {
                currentStreak++;
                maxStreak = Math.max(maxStreak, currentStreak);
            } else {
                currentStreak = 0;
            }
        });
        
        return maxStreak;
    }
    
    function findBestInstrument(operations) {
        const instrPL = {};
        operations.forEach(op => {
            const instr = op.instrument || 'N/A';
            if (!instrPL[instr]) instrPL[instr] = 0;
            instrPL[instr] += convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency);
        });
        
        let best = { name: 'N/A', pl: -Infinity };
        Object.keys(instrPL).forEach(i => {
            if (instrPL[i] > best.pl) {
                best = { name: i, pl: instrPL[i] };
            }
        });
        
        return best.name;
    }
    
    function findBestSession(operations) {
        const sessions = {
            'Asia (0-8h)': ops => ops.filter(op => {
                const h = new Date(op.date).getHours();
                return h >= 0 && h < 8;
            }),
            'Londres (8-12h)': ops => ops.filter(op => {
                const h = new Date(op.date).getHours();
                return h >= 8 && h < 12;
            }),
            'NY (12-16h)': ops => ops.filter(op => {
                const h = new Date(op.date).getHours();
                return h >= 12 && h < 16;
            }),
            'PM (16-24h)': ops => ops.filter(op => {
                const h = new Date(op.date).getHours();
                return h >= 16;
            })
        };
        
        let best = { name: 'N/A', pl: -Infinity };
        Object.keys(sessions).forEach(session => {
            const sessionOps = sessions[session](operations);
            const pl = sessionOps.reduce((s, op) => s + convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency), 0);
            if (pl > best.pl) {
                best = { name: session, pl };
            }
        });
        
        return best.name;
    }
    
    function calculateMaxDrawdown(operations) {
        if (operations.length === 0) return 0;
        
        let peak = 0;
        let maxDD = 0;
        let cumulative = 0;
        
        operations.sort((a, b) => new Date(a.date) - new Date(b.date)).forEach(op => {
            cumulative += convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency);
            if (cumulative > peak) peak = cumulative;
            const dd = peak - cumulative;
            if (dd > maxDD) maxDD = dd;
        });
        
        return maxDD;
    }
    
    // ==========================================
    // SUBSECCIÓN 3: PERFORMANCE ANALYTICS
    // ==========================================
    function renderPerformanceAnalytics() {
        console.log('Rendering Performance Analytics...');

        // Filtrar operaciones por cuentas seleccionadas
        let operations = DB.operations.filter(op => op.result);
        if (!selectedEquityAccounts.includes('all')) {
            operations = operations.filter(op => selectedEquityAccounts.includes(op.accountId));
        }
        operations = operations.sort((a, b) => new Date(a.date) - new Date(b.date));

        if (operations.length === 0) {
            console.log('No operations with results found for Performance Analytics');
            return;
        }

        console.log('Performance Analytics: Processing', operations.length, 'operations');
        
        // Top KPIs Row
        renderPerformanceKPIs(operations);
        
        // Main Chart (default: cumulative equity)
        renderPerformanceMainChart(operations);
        
        // Distribution Charts
        renderPLDistribution(operations);
        renderDurationDistribution(operations);
        
        // Time Analysis
        renderTimeAnalysis(operations);
        
        // MAE/MFE Analysis
        renderMAEMFE(operations);
        
        // Drawdown Timeline
        renderDrawdownTimeline(operations);
        
        // Rolling Statistics
        renderRollingStats(operations);
        
        // Additional KPIs
        renderAdditionalKPIs(operations);
    }
    
    function renderPerformanceKPIs(operations) {
        const totalTrades = operations.length;
        const wins = operations.filter(op => op.result === 'win').length;
        const winRate = totalTrades > 0 ? (wins / totalTrades * 100) : 0;

        const totalPL = operations.reduce((s, op) => s + convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency), 0);
        const avgPL = totalTrades > 0 ? totalPL / totalTrades : 0;

        const profitFactor = calculateProfitFactor(operations);
        const maxDD = calculateMaxDrawdown(operations);

        // Calcular balance de cuenta
        let accountBalance = 0;
        if (selectedEquityAccounts.includes('all')) {
            // Sumar todos los balances
            DB.accounts.forEach(account => {
                accountBalance += convertCurrency(account.balance || account.initialBalance || 0, account.currency, DB.settings.defaultCurrency);
            });
        } else if (selectedEquityAccounts.length > 0) {
            // Sumar balances de cuentas seleccionadas
            selectedEquityAccounts.forEach(accountId => {
                const account = DB.accounts.find(a => a.id === accountId);
                if (account) {
                    accountBalance += convertCurrency(account.balance || account.initialBalance || 0, account.currency, DB.settings.defaultCurrency);
                }
            });
        }

        const totalTradesEl = document.getElementById('perf-total-trades');
        const winrateEl = document.getElementById('perf-winrate');
        const returnPercentEl = document.getElementById('perf-return-percent');
        const profitFactorEl = document.getElementById('perf-profit-factor');
        const maxDDEl = document.getElementById('perf-max-drawdown');
        const accountBalanceEl = document.getElementById('perf-account-balance');

        if (totalTradesEl) totalTradesEl.textContent = totalTrades;
        if (winrateEl) {
            winrateEl.textContent = `${winRate.toFixed(1)}%`;
            winrateEl.className = `text-xl font-bold ${winRate >= 50 ? 'text-primary' : 'text-red-400'}`;
        }
        if (returnPercentEl) {
            const returnPct = accountBalance > 0 ? (totalPL / accountBalance * 100) : 0;
            returnPercentEl.textContent = `${returnPct.toFixed(1)}%`;
            returnPercentEl.className = `text-xl font-bold ${returnPct >= 0 ? 'text-primary' : 'text-red-400'}`;
        }
        if (profitFactorEl) {
            profitFactorEl.textContent = profitFactor.toFixed(2);
            profitFactorEl.className = `text-xl font-bold ${profitFactor >= 1 ? 'text-primary' : 'text-red-400'}`;
        }
        if (maxDDEl) maxDDEl.textContent = `-$${maxDD.toFixed(2)}`;
        if (accountBalanceEl) accountBalanceEl.textContent = `$${accountBalance.toFixed(2)}`;
    }

    function renderPerformanceMainChart(operations) {
        const canvas = document.getElementById('performance-main-chart');
        if (!canvas) {
            console.error('❌ Canvas performance-main-chart no encontrado');
            return;
        }

        console.log('📊 Renderizando gráfico principal con', operations.length, 'operaciones');

        // Destruir gráfico existente de forma segura
        if (equityCharts.perfMain) {
            try {
                equityCharts.perfMain.destroy();
                equityCharts.perfMain = null;
            } catch (e) {
                console.warn('Error destruyendo gráfico:', e);
            }
        }

        // Get chart type and metric from selectors
        const chartTypeSelect = document.getElementById('perf-chart-type');
        const metricSelect = document.getElementById('perf-metric');
        const chartType = chartTypeSelect ? chartTypeSelect.value : 'area';
        const metric = metricSelect ? metricSelect.value : 'return';

        // Calcular balance inicial
        let initialBalance = 0;
        if (selectedEquityAccounts.includes('all')) {
            initialBalance = DB.accounts.reduce((sum, acc) => {
                return sum + convertCurrency(acc.initialBalance, acc.currency, DB.settings.defaultCurrency);
            }, 0);
        } else if (selectedEquityAccounts.length > 0) {
            selectedEquityAccounts.forEach(accountId => {
                const account = DB.accounts.find(a => a.id === accountId);
                if (account) {
                    initialBalance += convertCurrency(account.initialBalance, account.currency, DB.settings.defaultCurrency);
                }
            });
        }

        // Preparar datos según la métrica seleccionada
        let cumulativePL = 0;
        let peak = initialBalance;
        const chartData = operations.map((op, idx) => {
            const pl = convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency);
            cumulativePL += pl;
            
            let yValue;
            if (metric === 'balance') {
                yValue = initialBalance + cumulativePL;
                peak = Math.max(peak, yValue);
            } else if (metric === 'return') {
                yValue = cumulativePL;
            } else if (metric === 'return-pct') {
                yValue = initialBalance > 0 ? (cumulativePL / initialBalance) * 100 : 0;
            } else if (metric === 'drawdown') {
                const currentBalance = initialBalance + cumulativePL;
                yValue = peak > 0 ? ((currentBalance - peak) / peak) * 100 : 0;
                peak = Math.max(peak, currentBalance);
            }
            
            return {
                x: new Date(op.date).getTime(),
                y: yValue
            };
        });

        // Agregar punto inicial
        chartData.unshift({
            x: chartData.length > 0 ? chartData[0].x - 86400000 : new Date().getTime(),
            y: metric === 'balance' ? initialBalance : 0
        });

        // Validar tipo de gráfico
        const validChartType = (chartType === 'area' || chartType === 'line') ? 'line' : 'bar';

        // Configurar label y callback del eje Y según la métrica
        let yAxisLabel = 'P/L ($)';
        let yAxisCallback = v => '$' + v.toFixed(0);
        let tooltipCallback = (item) => `P/L: $${item.parsed.y.toFixed(2)}`;
        let borderColor = '#39FF14';
        let backgroundColor = '#39FF14';

        if (metric === 'balance') {
            yAxisLabel = 'Balance ($)';
            tooltipCallback = (item) => `Balance: $${item.parsed.y.toFixed(2)}`;
        } else if (metric === 'return-pct') {
            yAxisLabel = 'Return (%)';
            yAxisCallback = v => v.toFixed(1) + '%';
            tooltipCallback = (item) => `Return: ${item.parsed.y.toFixed(2)}%`;
        } else if (metric === 'drawdown') {
            yAxisLabel = 'Drawdown (%)';
            yAxisCallback = v => v.toFixed(1) + '%';
            tooltipCallback = (item) => `Drawdown: ${item.parsed.y.toFixed(2)}%`;
            borderColor = '#FF3131';
            backgroundColor = '#FF3131';
        }

        const config = {
            type: validChartType,
            data: {
                datasets: [{
                    label: yAxisLabel,
                    data: chartData,
                    borderColor: borderColor,
                    backgroundColor: chartType === 'area' ? (backgroundColor + '40') : backgroundColor,
                    borderWidth: chartType === 'bar' ? 0 : 2,
                    fill: chartType === 'area',
                    tension: 0.4,
                    pointRadius: 0,
                    pointHoverRadius: 6,
                    pointHoverBackgroundColor: borderColor,
                    pointHoverBorderColor: '#fff',
                    pointHoverBorderWidth: 2
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'index',
                    intersect: false
                },
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        backgroundColor: 'rgba(0, 0, 0, 0.8)',
                        titleColor: '#fff',
                        bodyColor: '#fff',
                        borderColor: borderColor,
                        borderWidth: 1,
                        callbacks: {
                            label: tooltipCallback,
                            title: (items) => {
                                if (items[0]?.parsed?.x) {
                                    const date = new Date(items[0].parsed.x);
                                    return date.toLocaleDateString('es-ES', { 
                                        year: 'numeric', 
                                        month: 'short', 
                                        day: 'numeric' 
                                    });
                                }
                                return '';
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            unit: 'day',
                            displayFormats: {
                                day: 'MMM dd',
                                week: 'MMM dd',
                                month: 'MMM yyyy'
                            }
                        },
                        title: { display: true, text: 'Fecha', color: '#FFF' },
                        grid: { color: '#2a2a2a' },
                        ticks: { 
                            color: '#FFF',
                            maxRotation: 45,
                            minRotation: 0
                        }
                    },
                    y: {
                        title: { display: true, text: yAxisLabel, color: '#FFF' },
                        grid: { color: '#2a2a2a' },
                        ticks: { color: '#FFF', callback: yAxisCallback }
                    }
                }
            }
        };

        try {
            equityCharts.perfMain = new Chart(canvas.getContext('2d'), config);
            console.log('✅ Gráfico principal creado exitosamente');
        } catch (error) {
            console.error('❌ Error creando gráfico principal:', error);
        }
    }

    function renderPLDistribution(operations) {
        const canvas = document.getElementById('perf-pl-distribution');
        if (!canvas) {
            console.error('❌ Canvas perf-pl-distribution no encontrado');
            return;
        }

        console.log('📊 Renderizando distribución P/L con', operations.length, 'operaciones');
        if (equityCharts.perfPLDist) equityCharts.perfPLDist.destroy();
        
        // Create bins
        const plValues = operations.map(op => convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency));
        const bins = createHistogramBins(plValues, 20);
        
        equityCharts.perfPLDist = new Chart(canvas.getContext('2d'), {
            type: 'bar',
            data: {
                labels: bins.labels,
                datasets: [{
                    label: 'Frecuencia',
                    data: bins.counts,
                    backgroundColor: bins.labels.map(l => parseFloat(l) >= 0 ? '#00FF00' : '#FF0000'),
                    borderWidth: 0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: { legend: { display: false } },
                scales: {
                    x: {
                        title: { display: true, text: 'P/L ($)', color: '#FFF' },
                        grid: { color: '#2a2a2a' },
                        ticks: { color: '#FFF' }
                    },
                    y: {
                        title: { display: true, text: 'Frecuencia', color: '#FFF' },
                        grid: { color: '#2a2a2a' },
                        ticks: { color: '#FFF' }
                    }
                }
            }
        });
    }
    
    function renderDurationDistribution(operations) {
        const canvas = document.getElementById('perf-duration-distribution');
        if (!canvas) return;
        
        if (equityCharts.perfDurationDist) equityCharts.perfDurationDist.destroy();
        
        // Get durations in minutes
        const durations = operations.map(op => {
            if (!op.entryTime || !op.exitTime) return 0;
            const entry = new Date(op.date + ' ' + op.entryTime);
            const exit = new Date(op.date + ' ' + op.exitTime);
            return (exit - entry) / (1000 * 60); // minutes
        }).filter(d => d > 0);
        
        const bins = createHistogramBins(durations, 15);
        
        equityCharts.perfDurationDist = new Chart(canvas.getContext('2d'), {
            type: 'bar',
            data: {
                labels: bins.labels,
                datasets: [{
                    label: 'Frecuencia',
                    data: bins.counts,
                    backgroundColor: '#00FF00',
                    borderWidth: 0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: { legend: { display: false } },
                scales: {
                    x: {
                        title: { display: true, text: 'Duración (min)', color: '#FFF' },
                        grid: { color: '#2a2a2a' },
                        ticks: { color: '#FFF' }
                    },
                    y: {
                        title: { display: true, text: 'Frecuencia', color: '#FFF' },
                        grid: { color: '#2a2a2a' },
                        ticks: { color: '#FFF' }
                    }
                }
            }
        });
    }
    
    function renderTimeAnalysis(operations) {
        const canvas = document.getElementById('perf-time-analysis');
        if (!canvas) return;
        
        if (equityCharts.perfTimeAnalysis) equityCharts.perfTimeAnalysis.destroy();
        
        const analysisType = document.getElementById('perf-time-analysis-type')?.value || 'hour';
        
        let labels = [];
        let data = [];
        let xAxisLabel = '';
        
        if (analysisType === 'hour') {
            // P/L by hour
            const hourlyPL = {};
            for (let h = 0; h < 24; h++) hourlyPL[h] = 0;
            
            operations.forEach(op => {
                const hour = new Date(op.date).getHours();
                hourlyPL[hour] += convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency);
            });
            
            labels = Object.keys(hourlyPL).map(h => `${h}:00`);
            data = Object.values(hourlyPL);
            xAxisLabel = 'Hora del día';
            
        } else if (analysisType === 'day') {
            // P/L by day of week
            const daysOfWeek = ['Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sábado', 'Domingo'];
            const dailyPL = {0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0};
            
            operations.forEach(op => {
                const date = new Date(op.date);
                const dayOfWeek = date.getDay(); // 0 = Sunday, 1 = Monday, etc.
                // Convertir a formato lunes=0
                const adjustedDay = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
                dailyPL[adjustedDay] += convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency);
            });
            
            labels = daysOfWeek;
            data = Object.values(dailyPL);
            xAxisLabel = 'Día de la Semana';
            
        } else if (analysisType === 'month') {
            // P/L by month
            const monthNames = ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'];
            const monthlyPL = {};
            for (let m = 0; m < 12; m++) monthlyPL[m] = 0;
            
            operations.forEach(op => {
                const month = new Date(op.date).getMonth();
                monthlyPL[month] += convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency);
            });
            
            labels = monthNames;
            data = Object.values(monthlyPL);
            xAxisLabel = 'Mes';
        }
        
        equityCharts.perfTimeAnalysis = new Chart(canvas.getContext('2d'), {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [{
                    label: 'P/L',
                    data: data,
                    backgroundColor: data.map(v => v >= 0 ? '#39FF14' : '#FF0000'),
                    borderWidth: 0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: { 
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            label: (item) => `P/L: $${item.parsed.y.toFixed(2)}`
                        }
                    }
                },
                scales: {
                    x: {
                        title: { display: true, text: xAxisLabel, color: '#FFF' },
                        grid: { color: '#2a2a2a' },
                        ticks: { color: '#FFF' }
                    },
                    y: {
                        title: { display: true, text: 'P/L ($)', color: '#FFF' },
                        grid: { color: '#2a2a2a' },
                        ticks: { color: '#FFF', callback: v => '$' + v.toFixed(0) }
                    }
                }
            }
        });
    }
    
    function renderMAEMFE(operations) {
        console.log('📊 Renderizando MAE/MFE con', operations.length, 'operaciones');
        const canvas1 = document.getElementById('perf-mae-chart');
        const canvas2 = document.getElementById('perf-mfe-chart');

        // MAE (Maximum Adverse Excursion)
        if (canvas1) {
            if (equityCharts.perfMAE) equityCharts.perfMAE.destroy();

            const maeData = operations.map(op => ({
                x: convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency),
                y: Math.abs(convertCurrency(op.mae || 0, op.currency, DB.settings.defaultCurrency))
            })).filter(d => d.y > 0);

            console.log('📉 MAE Datos:', maeData.length, 'puntos válidos de', operations.length, 'operaciones');

            if (maeData.length === 0) {
                console.warn('⚠️ No hay datos MAE (las operaciones no tienen campo "mae")');
                // Mostrar mensaje en lugar de gráfico negro
                const container = canvas1.parentElement;
                container.innerHTML = `
                    <h4 class="text-base font-semibold mb-4">MAE Analysis (Maximum Adverse Excursion)</h4>
                    <div style="width: 100%; height: calc(100% - 40px); display: flex; align-items: center; justify-content: center; flex-direction: column;">
                        <i class="fas fa-chart-area text-6xl text-gray-700 mb-4"></i>
                        <p class="text-text-secondary text-center">No hay datos MAE disponibles</p>
                        <p class="text-xs text-text-secondary text-center mt-2">Las operaciones necesitan incluir el campo "mae"<br>para mostrar el análisis de excursión adversa máxima</p>
                    </div>
                `;
            } else {
                equityCharts.perfMAE = new Chart(canvas1.getContext('2d'), {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'MAE',
                        data: maeData,
                        backgroundColor: maeData.map(d => d.x >= 0 ? '#00FF00' : '#FF0000'),
                        pointRadius: 6,
                        pointHoverRadius: 8,
                        borderWidth: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        x: {
                            title: { display: true, text: 'Final P/L ($)', color: '#FFF' },
                            grid: { color: '#2a2a2a' },
                            ticks: { color: '#FFF' }
                        },
                        y: {
                            title: { display: true, text: 'MAE ($)', color: '#FFF' },
                            grid: { color: '#2a2a2a' },
                            ticks: { color: '#FFF' }
                        }
                    }
                }
            });
            }
        }

        // MFE (Maximum Favorable Excursion)
        if (canvas2) {
            if (equityCharts.perfMFE) equityCharts.perfMFE.destroy();

            const mfeData = operations.map(op => ({
                x: convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency),
                y: convertCurrency(op.mfe || 0, op.currency, DB.settings.defaultCurrency)
            })).filter(d => d.y > 0);

            console.log('📈 MFE Datos:', mfeData.length, 'puntos válidos de', operations.length, 'operaciones');

            if (mfeData.length === 0) {
                console.warn('⚠️ No hay datos MFE (las operaciones no tienen campo "mfe")');
                // Mostrar mensaje en lugar de gráfico negro
                const container = canvas2.parentElement;
                container.innerHTML = `
                    <h4 class="text-base font-semibold mb-4">MFE Analysis (Maximum Favorable Excursion)</h4>
                    <div style="width: 100%; height: calc(100% - 40px); display: flex; align-items: center; justify-content: center; flex-direction: column;">
                        <i class="fas fa-chart-line text-6xl text-gray-700 mb-4"></i>
                        <p class="text-text-secondary text-center">No hay datos MFE disponibles</p>
                        <p class="text-xs text-text-secondary text-center mt-2">Las operaciones necesitan incluir el campo "mfe"<br>para mostrar el análisis de excursión favorable máxima</p>
                    </div>
                `;
            } else {
                equityCharts.perfMFE = new Chart(canvas2.getContext('2d'), {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'MFE',
                        data: mfeData,
                        backgroundColor: mfeData.map(d => d.x >= 0 ? '#00FF00' : '#FF0000'),
                        pointRadius: 6,
                        pointHoverRadius: 8,
                        borderWidth: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        x: {
                            title: { display: true, text: 'Final P/L ($)', color: '#FFF' },
                            grid: { color: '#2a2a2a' },
                            ticks: { color: '#FFF' }
                        },
                        y: {
                            title: { display: true, text: 'MFE ($)', color: '#FFF' },
                            grid: { color: '#2a2a2a' },
                            ticks: { color: '#FFF' }
                        }
                    }
                }
            });
            }
        }
    }

    function renderDrawdownTimeline(operations) {
        console.log('📊 Renderizando Drawdown Timeline con', operations.length, 'operaciones');
        const canvas = document.getElementById('perf-drawdown-timeline');
        if (!canvas) {
            console.error('❌ Canvas perf-drawdown-timeline no encontrado');
            return;
        }

        // Log canvas dimensions
        const rect = canvas.getBoundingClientRect();
        console.log(`📐 Drawdown Canvas dimensions: ${rect.width}x${rect.height}`);

        if (rect.width === 0 || rect.height === 0) {
            console.error('❌ Canvas Drawdown tiene dimensiones 0, esperando...');
            setTimeout(() => renderDrawdownTimeline(operations), 100);
            return;
        }

        if (equityCharts.perfDD) equityCharts.perfDD.destroy();

        if (operations.length === 0) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#666';
            ctx.font = '14px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('No hay datos de drawdown disponibles', canvas.width / 2, canvas.height / 2);
            console.log('⚠️ Drawdown Timeline: No hay operaciones para mostrar');
            return;
        }

        // Ordenar operaciones cronológicamente
        const sortedOps = [...operations].sort((a, b) => {
            const dateA = new Date(a.date + (a.entryTime ? ' ' + a.entryTime : ''));
            const dateB = new Date(b.date + (b.entryTime ? ' ' + b.entryTime : ''));
            return dateA - dateB;
        });

        let peak = 0;
        let cumulative = 0;
        const ddData = sortedOps.map((op, idx) => {
            cumulative += convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency);
            if (cumulative > peak) peak = cumulative;
            const dd = peak - cumulative;
            return { x: idx + 1, y: -dd };
        });

        console.log(`📊 Drawdown Timeline: ${ddData.length} puntos, Max DD: $${Math.min(...ddData.map(d => d.y)).toFixed(2)}`);

        equityCharts.perfDD = new Chart(canvas.getContext('2d'), {
            type: 'line',
            data: {
                datasets: [{
                    label: 'Drawdown',
                    data: ddData,
                    borderColor: '#FF0000',
                    backgroundColor: '#FF0000',
                    borderWidth: 0,
                    fill: true,
                    tension: 0.4,
                    pointRadius: 0,
                    pointHoverRadius: 6,
                    pointHoverBackgroundColor: '#FF0000',
                    pointHoverBorderColor: '#FF0000',
                    pointHoverBorderWidth: 0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            label: (context) => `Drawdown: $${context.parsed.y.toFixed(2)}`
                        }
                    }
                },
                scales: {
                    x: {
                        type: 'linear',
                        title: { display: true, text: 'Operaciones', color: '#FFF' },
                        grid: { color: '#2a2a2a' },
                        ticks: { color: '#FFF' }
                    },
                    y: {
                        title: { display: true, text: 'Drawdown ($)', color: '#FFF' },
                        grid: { color: '#2a2a2a' },
                        ticks: { color: '#FFF', callback: v => '$' + v.toFixed(0) }
                    }
                }
            }
        });

        console.log('✅ Drawdown Timeline chart creado:', equityCharts.perfDD.id);
    }
    
    function renderRollingStats(operations) {
        console.log('📊 Renderizando Rolling Stats con', operations.length, 'operaciones');
        const canvas = document.getElementById('perf-rolling-stats');
        if (!canvas) {
            console.error('❌ Canvas perf-rolling-stats no encontrado');
            return;
        }

        // Log canvas dimensions
        const rect = canvas.getBoundingClientRect();
        console.log(`📐 Rolling Stats Canvas dimensions: ${rect.width}x${rect.height}`);

        if (rect.width === 0 || rect.height === 0) {
            console.error('❌ Canvas Rolling Stats tiene dimensiones 0, esperando...');
            setTimeout(() => renderRollingStats(operations), 100);
            return;
        }

        if (equityCharts.perfRolling) equityCharts.perfRolling.destroy();

        const windowSize = 20; // 20-trade rolling window

        if (operations.length < windowSize) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#666';
            ctx.font = '14px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(`Se necesitan al menos ${windowSize} operaciones para estadísticas móviles`, canvas.width / 2, canvas.height / 2);
            ctx.fillText(`(Tienes ${operations.length} operaciones)`, canvas.width / 2, canvas.height / 2 + 20);
            console.log(`⚠️ Rolling Stats: Se necesitan ${windowSize} operaciones, solo hay ${operations.length}`);
            return;
        }

        // Ordenar operaciones cronológicamente
        const sortedOps = [...operations].sort((a, b) => {
            const dateA = new Date(a.date + (a.entryTime ? ' ' + a.entryTime : ''));
            const dateB = new Date(b.date + (b.entryTime ? ' ' + b.entryTime : ''));
            return dateA - dateB;
        });

        const rollingWinRate = [];

        for (let i = windowSize; i <= sortedOps.length; i++) {
            const window = sortedOps.slice(i - windowSize, i);
            const wins = window.filter(op => op.result === 'win').length;
            const wr = (wins / windowSize) * 100;
            rollingWinRate.push({ x: i, y: wr });
        }

        console.log(`📊 Rolling Stats: ${rollingWinRate.length} puntos calculados`);

        equityCharts.perfRolling = new Chart(canvas.getContext('2d'), {
            type: 'line',
            data: {
                datasets: [{
                    label: 'Rolling Winrate (20 trades)',
                    data: rollingWinRate,
                    borderColor: '#00FF00',
                    backgroundColor: '#00FF00',
                    borderWidth: 0,
                    fill: true,
                    tension: 0.4,
                    pointRadius: 0,
                    pointHoverRadius: 6,
                    pointHoverBackgroundColor: '#00FF00',
                    pointHoverBorderColor: '#00FF00',
                    pointHoverBorderWidth: 0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            label: (context) => `Winrate: ${context.parsed.y.toFixed(1)}%`
                        }
                    }
                },
                scales: {
                    x: {
                        type: 'linear',
                        title: { display: true, text: 'Operaciones', color: '#FFF' },
                        grid: { color: '#2a2a2a' },
                        ticks: { color: '#FFF' }
                    },
                    y: {
                        title: { display: true, text: 'Winrate (%)', color: '#FFF' },
                        grid: { color: '#2a2a2a' },
                        ticks: { color: '#FFF', callback: v => v.toFixed(0) + '%' },
                        min: 0,
                        max: 100
                    }
                }
            }
        });

        console.log('✅ Rolling Stats chart creado:', equityCharts.perfRolling.id);
    }
    
    function renderAdditionalKPIs(operations) {
        console.log('📊 Renderizando KPIs Adicionales con', operations.length, 'operaciones');
        const wins = operations.filter(op => op.result === 'win');
        const losses = operations.filter(op => op.result === 'loss');

        const avgWin = wins.length > 0 ? wins.reduce((s, op) => s + convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency), 0) / wins.length : 0;
        const avgLoss = losses.length > 0 ? Math.abs(losses.reduce((s, op) => s + convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency), 0) / losses.length) : 0;
        const winLossRatio = avgLoss > 0 ? avgWin / avgLoss : 0;

        const largestWin = wins.length > 0 ? Math.max(...wins.map(op => convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency))) : 0;
        const largestLoss = losses.length > 0 ? Math.abs(Math.min(...losses.map(op => convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency)))) : 0;

        // Expectancy = (Win% × Avg Win) - (Loss% × Avg Loss)
        const winRate = operations.length > 0 ? wins.length / operations.length : 0;
        const lossRate = operations.length > 0 ? losses.length / operations.length : 0;
        const expectancy = (winRate * avgWin) - (lossRate * avgLoss);

        // Recovery Factor = Net Profit / Max Drawdown
        const netProfit = operations.reduce((sum, op) => sum + convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency), 0);
        const maxDrawdown = Math.abs(calculateMaxDrawdown(operations));
        const recoveryFactor = maxDrawdown > 0 ? netProfit / maxDrawdown : 0;

        // Best/Worst Day
        const dailyPL = new Map();
        operations.forEach(op => {
            const pl = convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency);
            dailyPL.set(op.date, (dailyPL.get(op.date) || 0) + pl);
        });
        const bestDay = dailyPL.size > 0 ? Math.max(...dailyPL.values()) : 0;
        const worstDay = dailyPL.size > 0 ? Math.min(...dailyPL.values()) : 0;

        const avgDuration = operations.filter(op => op.entryTime && op.exitTime).length > 0 ?
            operations.filter(op => op.entryTime && op.exitTime).reduce((sum, op) => {
                const entry = new Date(op.date + ' ' + op.entryTime);
                const exit = new Date(op.date + ' ' + op.exitTime);
                return sum + (exit - entry) / (1000 * 60);
            }, 0) / operations.filter(op => op.entryTime && op.exitTime).length : 0;

        const consecutiveWins = calculateMaxStreak(operations, 'win');
        const consecutiveLosses = calculateMaxStreak(operations, 'loss');

        // Update elements with correct IDs matching HTML
        const els = {
            avgWinner: document.getElementById('perf-avg-winner'),
            avgLoser: document.getElementById('perf-avg-loser'),
            winLossRatio: document.getElementById('perf-win-loss-ratio'),
            expectancy: document.getElementById('perf-expectancy'),
            largestWinner: document.getElementById('perf-largest-winner'),
            largestLoser: document.getElementById('perf-largest-loser'),
            recoveryFactor: document.getElementById('perf-recovery-factor'),
            avgDuration: document.getElementById('perf-avg-duration'),
            bestDay: document.getElementById('perf-best-day'),
            worstDay: document.getElementById('perf-worst-day'),
            consecutiveWins: document.getElementById('perf-consecutive-wins'),
            consecutiveLosses: document.getElementById('perf-consecutive-losses')
        };

        if (els.avgWinner) els.avgWinner.textContent = `$${avgWin.toFixed(2)}`;
        if (els.avgLoser) els.avgLoser.textContent = `$${avgLoss.toFixed(2)}`;
        if (els.winLossRatio) els.winLossRatio.textContent = winLossRatio.toFixed(2);
        if (els.expectancy) els.expectancy.textContent = `$${expectancy.toFixed(2)}`;
        if (els.largestWinner) els.largestWinner.textContent = `$${largestWin.toFixed(2)}`;
        if (els.largestLoser) els.largestLoser.textContent = `$${largestLoss.toFixed(2)}`;
        if (els.recoveryFactor) els.recoveryFactor.textContent = recoveryFactor.toFixed(2);
        if (els.avgDuration) els.avgDuration.textContent = avgDuration > 0 ? `${avgDuration.toFixed(0)}m` : '0m';
        if (els.bestDay) els.bestDay.textContent = `$${bestDay.toFixed(2)}`;
        if (els.worstDay) els.worstDay.textContent = `$${worstDay.toFixed(2)}`;
        if (els.consecutiveWins) els.consecutiveWins.textContent = consecutiveWins;
        if (els.consecutiveLosses) els.consecutiveLosses.textContent = consecutiveLosses;
    }
    
    // Helper functions
    function createHistogramBins(data, binCount) {
        if (data.length === 0) return { labels: [], counts: [] };
        
        const min = Math.min(...data);
        const max = Math.max(...data);
        const binSize = (max - min) / binCount;
        
        const bins = Array(binCount).fill(0);
        const labels = [];
        
        for (let i = 0; i < binCount; i++) {
            labels.push((min + i * binSize).toFixed(0));
        }
        
        data.forEach(value => {
            const binIndex = Math.min(Math.floor((value - min) / binSize), binCount - 1);
            bins[binIndex]++;
        });
        
        return { labels, counts: bins };
    }
    
    function calculateProfitFactor(operations) {
        const totalProfit = operations.filter(op => op.result === 'win').reduce((s, op) => s + convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency), 0);
        const totalLoss = Math.abs(operations.filter(op => op.result === 'loss').reduce((s, op) => s + convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency), 0));
        
        return totalLoss > 0 ? totalProfit / totalLoss : (totalProfit > 0 ? 999 : 0);
    }
    
    // ==========================================
    // TAB NAVIGATION
    // ==========================================
    function initEquityTabNavigation() {
        const tabs = document.querySelectorAll('.equity-view-tab');
        console.log('Initializing Equity Tab Navigation, found', tabs.length, 'tabs');
        
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                const view = tab.dataset.view;
                console.log('Tab clicked:', view);
                
                // Update active tab
                document.querySelectorAll('.equity-view-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                
                // Update active content
                document.querySelectorAll('.equity-view-content').forEach(c => c.classList.remove('active'));
                const targetSection = document.getElementById(`equity-view-${view}`);
                if (targetSection) {
                    targetSection.classList.add('active');
                    targetSection.style.display = 'block';
                    console.log('Showing section:', `equity-view-${view}`);
                } else {
                    console.error('Section not found:', `equity-view-${view}`);
                }
                
                // Hide non-active sections
                document.querySelectorAll('.equity-view-content').forEach(c => {
                    if (!c.classList.contains('active')) {
                        c.style.display = 'none';
                    }
                });
                
                // Update current view
                currentEquityView = view;
                
                // Render the selected view
                console.log('About to call refreshEquityGraph for view:', view);
                refreshEquityGraph();
            });
        });
        
        console.log('Equity Tab Navigation initialized');
    }
    
    function updateEquityComparisonMetrics(allOperations) {
        const tbody = document.getElementById('equity-comparison-tbody');
        if (!tbody) return;
        
        tbody.innerHTML = '';
        
        selectedEquityAccounts.forEach(accountId => {
            const account = DB.accounts.find(a => a.id === accountId);
            if (!account) return;
            
            const accountOps = allOperations.filter(op => op.accountId === accountId);
            if (accountOps.length === 0) return;
            
            const metrics = calculateMetrics(accountOps);
            const initialBalance = convertCurrency(account.initialBalance, account.currency, DB.settings.defaultCurrency);
            const plNeto = metrics.plNeto;
            const finalBalance = initialBalance + plNeto;
            const returnPct = initialBalance > 0 ? ((plNeto / initialBalance) * 100) : 0;
            
            // Calcular Max Drawdown
            let maxDD = 0;
            let peak = initialBalance;
            let cumulativePL = 0;
            accountOps.forEach(op => {
                const pl = convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency);
                cumulativePL += pl;
                const currentBalance = initialBalance + cumulativePL;
                if (currentBalance > peak) peak = currentBalance;
                const dd = peak > 0 ? ((peak - currentBalance) / peak * 100) : 0;
                if (dd > maxDD) maxDD = dd;
            });
            
            const row = document.createElement('tr');
            const isPositive = plNeto >= 0;
            const plColor = isPositive ? 'var(--primary)' : 'var(--danger)';
            
            row.innerHTML = `
                <td><strong>${account.name}</strong></td>
                <td>${formatCurrency(initialBalance)}</td>
                <td>${formatCurrency(finalBalance)}</td>
                <td style="color: ${plColor}; font-weight: bold;">${formatCurrency(plNeto)}</td>
                <td style="color: ${returnPct >= 0 ? 'var(--primary)' : 'var(--danger)'}; font-weight: bold;">${returnPct.toFixed(2)}%</td>
                <td>${metrics.totalTrades}</td>
                <td style="color: ${metrics.winRate >= 50 ? 'var(--primary)' : 'var(--danger)'}">${metrics.winRate.toFixed(1)}%</td>
                <td style="color: ${metrics.profitFactor >= 1 ? 'var(--primary)' : 'var(--danger)'}">${metrics.profitFactor.toFixed(2)}</td>
                <td style="color: var(--danger)">-${maxDD.toFixed(2)}%</td>
            `;
            tbody.appendChild(row);
        });
    }
    
    // Actualizar gráfico de volumen comparativo
    function updateEquityVolumeChart(allOperations) {
        const canvas = document.getElementById('equity-volume-chart');
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        
        if (equityVolumeChart) {
            equityVolumeChart.destroy();
        }
        
        const labels = [];
        const tradesData = [];
        const volumeData = [];
        const colors = [];
        
        selectedEquityAccounts.forEach(accountId => {
            const account = DB.accounts.find(a => a.id === accountId);
            if (!account) return;
            
            const accountOps = allOperations.filter(op => op.accountId === accountId);
            const metrics = calculateMetrics(accountOps);
            
            labels.push(account.name);
            tradesData.push(metrics.totalTrades);
            
            // Calcular volumen total operado (suma del tamaño de lotes)
            const totalVolume = accountOps.reduce((sum, op) => {
                const lots = parseFloat(op.lots || op.quantity || 0);
                return sum + lots;
            }, 0);
            volumeData.push(totalVolume);
            
            // Color basado en rendimiento
            const isPositive = metrics.plNeto >= 0;
            colors.push(isPositive ? '#39FF14' : '#FF3131');
        });
        
        equityVolumeChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [
                    {
                        label: 'Número de Trades',
                        data: tradesData,
                        backgroundColor: colors.map(c => c + '80'),
                        borderColor: colors,
                        borderWidth: 2,
                        yAxisID: 'y'
                    },
                    {
                        label: 'Volumen Operado ($)',
                        data: volumeData,
                        backgroundColor: colors.map(c => c + '40'),
                        borderColor: colors,
                        borderWidth: 2,
                        yAxisID: 'y1'
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'index',
                    intersect: false
                },
                plugins: {
                    legend: {
                        display: true,
                        position: 'top',
                        labels: {
                            color: '#FFFFFF',
                            usePointStyle: true,
                            padding: 15
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: (item) => {
                                const label = item.dataset.label;
                                const value = item.parsed.y;
                                return label.includes('Volumen') 
                                    ? `${label}: ${formatCurrency(value)}`
                                    : `${label}: ${value}`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        grid: { color: '#2a2a2a' },
                        ticks: { color: '#FFFFFF' }
                    },
                    y: {
                        type: 'linear',
                        display: true,
                        position: 'left',
                        title: {
                            display: true,
                            text: 'Trades',
                            color: '#FFFFFF'
                        },
                        grid: { color: '#2a2a2a' },
                        ticks: { color: '#FFFFFF' }
                    },
                    y1: {
                        type: 'linear',
                        display: true,
                        position: 'right',
                        title: {
                            display: true,
                            text: 'Volumen ($)',
                            color: '#FFFFFF'
                        },
                        grid: { drawOnChartArea: false },
                        ticks: {
                            color: '#FFFFFF',
                            callback: (value) => formatCurrency(value)
                        }
                    }
                }
            }
        });
    }
    
    // Función auxiliar para calcular datos de equity por cuenta
    function calculateEquityData(operations, displayMode, groupBy, initialBalance) {
        let cumulativePL = 0;
        const labels = ['Inicio'];
        const data = [displayMode === 'balance' ? initialBalance : 0];
        
        operations.forEach((op, index) => {
            const pl = convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency);
            cumulativePL += pl;
            
            labels.push(formatDate(op.date));
            
            let dataValue = 0;
            switch (displayMode) {
                case 'balance':
                    dataValue = initialBalance + cumulativePL;
                    break;
                case 'return-pct':
                    dataValue = initialBalance > 0 ? (cumulativePL / initialBalance) * 100 : 0;
                    break;
                case 'roi':
                    dataValue = initialBalance > 0 ? (cumulativePL / initialBalance) * 100 : 0;
                    break;
                case 'r-multiple':
                    dataValue = op.rrr || 0;
                    break;
                default: // return
                    dataValue = cumulativePL;
            }
            
            data.push(dataValue);
        });

        return { labels, data };
    }

    // Inicialización de Event Listeners para Filtros
    // NOTA: selectedEquityAccounts ya está declarado arriba en línea 67205
    // let selectedEquityAccounts = ['all']; // ELIMINADO - Duplicado
    // let selectedEquityLineType = 'normal'; // ELIMINADO - No se usa
    // let equityEvaluatorMode = false; // ELIMINADO - No se usa
    let equityVolumeChart = null; // Referencia al gráfico de volumen

    function initEquityFiltersListeners() {
        // Toggle sidebar de filtros
        const toggleFiltersBtn = document.getElementById('equity-toggle-filters-btn');
        const filtersSidebar = document.getElementById('equity-filters-sidebar');
        const filtersOverlay = document.getElementById('filters-overlay');
        const closeFiltersBtn = document.getElementById('close-equity-filters-btn');
        
        if (toggleFiltersBtn) {
            toggleFiltersBtn.addEventListener('click', () => {
                filtersSidebar.classList.add('active');
                filtersOverlay.classList.add('active');
            });
        }
        
        if (closeFiltersBtn) {
            closeFiltersBtn.addEventListener('click', () => {
                filtersSidebar.classList.remove('active');
                filtersOverlay.classList.remove('active');
            });
        }

        // Mostrar/ocultar rango de fechas personalizado
        const periodFilter = document.getElementById('equity-sidebar-period');
        const customDateRange = document.getElementById('equity-sidebar-custom-range');
        
        if (periodFilter && customDateRange) {
            periodFilter.addEventListener('change', () => {
                customDateRange.style.display = periodFilter.value === 'custom' ? 'block' : 'none';
            });
        }

        // Aplicar filtros desde sidebar
        const applyFiltersBtn = document.getElementById('equity-sidebar-apply-btn');
        if (applyFiltersBtn) {
            applyFiltersBtn.addEventListener('click', () => {
                // Copiar valores del sidebar a los filtros originales
                const periodValue = document.getElementById('equity-sidebar-period').value;
                const instrumentValue = document.getElementById('equity-sidebar-instrument').value;
                const outcomeValue = document.getElementById('equity-sidebar-outcome').value;
                const directionValue = document.getElementById('equity-sidebar-direction').value;
                const setupValue = document.getElementById('equity-sidebar-setup').value;
                const rrrValue = document.getElementById('equity-sidebar-rrr').value;
                const starredValue = document.getElementById('equity-sidebar-starred').value;
                const displayValue = document.getElementById('equity-sidebar-display').value;
                const groupbyValue = document.getElementById('equity-sidebar-groupby').value;
                const lasttradesValue = document.getElementById('equity-sidebar-lasttrades').value;
                
                // Actualizar filtros originales
                const periodFilterEl = document.getElementById('equity-period-filter');
                const instrumentFilterEl = document.getElementById('equity-instrument-filter');
                const outcomeFilterEl = document.getElementById('equity-outcome-filter');
                const directionFilterEl = document.getElementById('equity-direction-filter');
                const setupFilterEl = document.getElementById('equity-setup-filter');
                const rrrFilterEl = document.getElementById('equity-rrr-filter');
                const starredFilterEl = document.getElementById('equity-starred-filter');
                const displayModeEl = document.getElementById('equity-display-mode');
                const groupByEl = document.getElementById('equity-group-by');
                const lastTradesFilterEl = document.getElementById('equity-last-trades-filter');
                
                if (periodFilterEl) periodFilterEl.value = periodValue;
                if (instrumentFilterEl) instrumentFilterEl.value = instrumentValue;
                if (outcomeFilterEl) outcomeFilterEl.value = outcomeValue;
                if (directionFilterEl) directionFilterEl.value = directionValue;
                if (setupFilterEl) setupFilterEl.value = setupValue;
                if (rrrFilterEl) rrrFilterEl.value = rrrValue;
                if (starredFilterEl) starredFilterEl.value = starredValue;
                if (displayModeEl) displayModeEl.value = displayValue;
                if (groupByEl) groupByEl.value = groupbyValue;
                if (lastTradesFilterEl) lastTradesFilterEl.value = lasttradesValue;
                
                // Cerrar sidebar
                filtersSidebar.classList.remove('active');
                filtersOverlay.classList.remove('active');
                
                populateEquityFilters();
                refreshEquityGraph();
            });
        }

        // Limpiar filtros desde sidebar
        const clearFiltersBtn = document.getElementById('equity-sidebar-clear-btn');
        if (clearFiltersBtn) {
            clearFiltersBtn.addEventListener('click', () => {
                document.getElementById('equity-sidebar-period').value = 'all';
                document.getElementById('equity-sidebar-instrument').value = 'all';
                document.getElementById('equity-sidebar-outcome').value = 'all';
                document.getElementById('equity-sidebar-direction').value = 'all';
                document.getElementById('equity-sidebar-setup').value = 'all';
                document.getElementById('equity-sidebar-rrr').value = '0';
                document.getElementById('equity-sidebar-starred').value = 'all';
                document.getElementById('equity-sidebar-display').value = 'return';
                document.getElementById('equity-sidebar-groupby').value = 'trades';
                document.getElementById('equity-sidebar-lasttrades').value = 'all';
                document.getElementById('equity-sidebar-date-from').value = '';
                document.getElementById('equity-sidebar-date-to').value = '';
                document.getElementById('equity-sidebar-custom-range').style.display = 'none';
                
                // Limpiar filtros originales también
                const periodFilterEl = document.getElementById('equity-period-filter');
                const instrumentFilterEl = document.getElementById('equity-instrument-filter');
                const outcomeFilterEl = document.getElementById('equity-outcome-filter');
                const directionFilterEl = document.getElementById('equity-direction-filter');
                const setupFilterEl = document.getElementById('equity-setup-filter');
                const rrrFilterEl = document.getElementById('equity-rrr-filter');
                const starredFilterEl = document.getElementById('equity-starred-filter');
                const displayModeEl = document.getElementById('equity-display-mode');
                const groupByEl = document.getElementById('equity-group-by');
                const lastTradesFilterEl = document.getElementById('equity-last-trades-filter');
                
                if (periodFilterEl) periodFilterEl.value = 'all';
                if (instrumentFilterEl) instrumentFilterEl.value = 'all';
                if (outcomeFilterEl) outcomeFilterEl.value = 'all';
                if (directionFilterEl) directionFilterEl.value = 'all';
                if (setupFilterEl) setupFilterEl.value = 'all';
                if (rrrFilterEl) rrrFilterEl.value = '0';
                if (starredFilterEl) starredFilterEl.value = 'all';
                if (displayModeEl) displayModeEl.value = 'return';
                if (groupByEl) groupByEl.value = 'trades';
                if (lastTradesFilterEl) lastTradesFilterEl.value = 'all';
                
                // Cerrar sidebar
                filtersSidebar.classList.remove('active');
                filtersOverlay.classList.remove('active');
                
                refreshEquityGraph();
            });
        }
    }

    /* FUNCIONES OBSOLETAS - ELIMINADAS PARA EVITAR CONFLICTOS
    // Función para poblar el multi-select de Equity Graph
    function populateEquityMultiSelect() {
        ...
    }

    // Inicializar event listeners del multi-select una sola vez
    function initEquityMultiSelectListeners() {
        ...
    }
    */

    // Inicializar event listeners del selector de tipo de línea
    function initEquityLineTypeListeners() {
        const dropdown = document.getElementById('equity-line-type-dropdown');
        const trigger = document.getElementById('equity-line-type-trigger');
        const display = document.getElementById('equity-line-type-display');
        
        if (!dropdown || !trigger || !display) return;
        
        // Toggle dropdown
        trigger.addEventListener('click', (e) => {
            e.stopPropagation();
            dropdown.classList.toggle('open');
            trigger.classList.toggle('open');
        });
        
        // Cerrar al hacer clic fuera
        document.addEventListener('click', (e) => {
            if (!dropdown.contains(e.target) && !trigger.contains(e.target)) {
                dropdown.classList.remove('open');
                trigger.classList.remove('open');
            }
        });
        
        // Manejar selección de opciones
        dropdown.querySelectorAll('.multi-select-option').forEach(option => {
            option.addEventListener('click', () => {
                const value = option.getAttribute('data-value');
                const text = option.querySelector('span').textContent;
                const icon = option.querySelector('i').className;
                
                selectedEquityLineType = value;
                display.textContent = text;
                
                // Actualizar ícono del trigger
                const triggerIcon = trigger.querySelector('i:first-child');
                if (triggerIcon) {
                    triggerIcon.className = icon;
                }
                
                // Cerrar dropdown
                dropdown.classList.remove('open');
                trigger.classList.remove('open');
                
                // Refrescar gráfico
                refreshEquityGraph();
            });
        });
        
        console.log('✅ Event listeners del selector de tipo de línea inicializados');
    }
    
    // Inicializar toggle de modo evaluador
    function initEquityEvaluatorToggle() {
        const toggle = document.getElementById('equity-evaluator-toggle');
        const panel = document.getElementById('equity-evaluator-panel');
        
        if (!toggle || !panel) return;
        
        toggle.addEventListener('change', (e) => {
            equityEvaluatorMode = e.target.checked;
            
            // Mostrar/ocultar panel de evaluador
            panel.style.display = equityEvaluatorMode ? 'block' : 'none';

            // Si se activa el evaluador y está en "todas las cuentas", cambiar a multi-select
            if (equityEvaluatorMode && selectedEquityAccounts.includes('all')) {
                // Deseleccionar "todas" y seleccionar las primeras 3 cuentas para comparar
                selectedEquityAccounts = DB.accounts.slice(0, Math.min(3, DB.accounts.length)).map(a => a.id);
                populateEquityMultiSelectDropdown();
                updateEquityMultiSelectDisplay();
            }

            console.log('📊 Modo Evaluador:', equityEvaluatorMode ? 'ACTIVADO' : 'DESACTIVADO');
            refreshEquityGraph();
        });
        
        console.log('✅ Toggle de modo evaluador inicializado');
    }

    /* FUNCIÓN OBSOLETA - ELIMINADA (usar updateEquityMultiSelectDisplay en su lugar)
    function updateEquityAccountDisplay() {
        ...
    }
    */

    // Función para inicializar event listeners de Performance Analytics (solo una vez)
    let perfAnalyticsListenersInitialized = false;
    function initPerformanceAnalyticsListeners() {
        if (perfAnalyticsListenersInitialized) {
            console.log('⚠️ Performance Analytics listeners ya inicializados, saltando...');
            return;
        }

        console.log('🎧 Inicializando listeners de Performance Analytics...');

        const perfChartTypeSelect = document.getElementById('perf-chart-type');
        if (perfChartTypeSelect) {
            perfChartTypeSelect.addEventListener('change', () => {
                console.log('📊 Cambio en tipo de gráfico Performance');
                if (currentEquityView === 'performance') {
                    refreshEquityGraph(); // Usar refresh en lugar de render directo
                }
            });
        }

        const perfMetricSelect = document.getElementById('perf-metric');
        if (perfMetricSelect) {
            perfMetricSelect.addEventListener('change', () => {
                console.log('📊 Cambio en métrica Performance');
                if (currentEquityView === 'performance') {
                    refreshEquityGraph(); // Usar refresh en lugar de render directo
                }
            });
        }

        const perfTimeAnalysisType = document.getElementById('perf-time-analysis-type');
        if (perfTimeAnalysisType) {
            perfTimeAnalysisType.addEventListener('change', () => {
                console.log('📊 Cambio en tipo de análisis de tiempo');
                if (currentEquityView === 'performance') {
                    refreshEquityGraph(); // Usar refresh en lugar de render directo
                }
            });
        }

        perfAnalyticsListenersInitialized = true;
        console.log('✅ Listeners de Performance Analytics inicializados');
    }

    // Función para inicializar event listeners del Evaluador de Cuentas (solo una vez)
    let evaluatorListenersInitialized = false;
    function initEvaluatorListeners() {
        if (evaluatorListenersInitialized) {
            console.log('⚠️ Evaluator listeners ya inicializados, saltando...');
            return;
        }

        console.log('🎧 Inicializando listeners del Evaluador de Cuentas...');

        const evaluatorDisplayMode = document.getElementById('evaluator-display-mode');
        if (evaluatorDisplayMode) {
            evaluatorDisplayMode.addEventListener('change', () => {
                console.log('📊 Cambio en modo de visualización Evaluador');
                if (currentEquityView === 'evaluator') {
                    refreshEquityGraph();
                }
            });
        }

        const evaluatorChartType = document.getElementById('evaluator-chart-type');
        if (evaluatorChartType) {
            evaluatorChartType.addEventListener('change', () => {
                console.log('📊 Cambio en tipo de gráfico Evaluador');
                if (currentEquityView === 'evaluator') {
                    refreshEquityGraph();
                }
            });
        }

        evaluatorListenersInitialized = true;
        console.log('✅ Listeners del Evaluador inicializados');
    }

    // Inicialización con delay - movida a initializeApp para ejecutarse DESPUÉS de loadData
    // Se ejecutará desde initializeApp() cuando DB este listo
    console.log('Equity Graph: Configuración cargada, esperando inicialización desde initializeApp...');

    // Inicializar navegación de tabs cuando el DOM esté listo
    setTimeout(() => {
        initEquityTabNavigation();
        initPerformanceAnalyticsListeners(); // Inicializar listeners de Performance Analytics
        initEvaluatorListeners(); // Inicializar listeners del Evaluador
        console.log('Tabs initialized successfully');
        // NOTA: No renderizamos aquí porque la sección no está activa aún
        // Se renderizará cuando el usuario haga clic en el tab Equity Graph
    }, 100);

    // Exportar funciones al scope global para que puedan ser llamadas desde initializeApp()
    window.refreshEquityGraph = refreshEquityGraph;
    window.populateEquityFilters = populateEquityFilters;
    window.initEquityMultiSelect = initEquityMultiSelect;
    window.initEquityFiltersListeners = initEquityFiltersListeners;
    window.initPerformanceAnalyticsListeners = initPerformanceAnalyticsListeners;
    window.initEvaluatorListeners = initEvaluatorListeners;
    window.selectedEquityAccounts = selectedEquityAccounts;
})();

// =============================================
// DAILY JOURNAL - DIARIO DE TRADING DIARIO
// =============================================
(async function() {
    console.log('📔 INICIANDO DAILY JOURNAL...');
    
    let currentMonth = new Date().getMonth();
    let currentYear = new Date().getFullYear();
    let dayCharts = {}; // Almacenar instancias de gráficos por día
    
    // Almacenamiento de notas diarias (verificar que DB exista)
    if (typeof DB !== 'undefined' && !DB.dailyNotes) {
        DB.dailyNotes = {};
    }

    // CARGAR dayAnalysisData desde IndexedDB al iniciar
    try {
        const stored = await dexieDB.generalData.get('dayAnalysisData');
        if (stored && stored.data) {
            DB.dayAnalysisData = stored.data;
            console.log('✅ dayAnalysisData cargado desde IndexedDB:', DB.dayAnalysisData);
        } else {
            DB.dayAnalysisData = {};
            console.log('📝 Iniciando dayAnalysisData vacío');
        }
    } catch (error) {
        console.error('❌ Error cargando dayAnalysisData:', error);
        DB.dayAnalysisData = {};
    }
    
    function refreshDailyJournal() {
        console.log('--- Refreshing Daily Journal ---');
        
        if (!document.getElementById('daily-journal').classList.contains('active')) {
            console.log('Daily Journal tab not active, skipping refresh.');
            return;
        }
        
        const accountSelect = document.getElementById('daily-journal-account-select');
        if (!accountSelect) return;
        
        const selectedAccount = accountSelect.value;
        let operations = [...DB.operations];
        
        // Filtrar por cuenta
        if (selectedAccount !== 'all') {
            operations = operations.filter(op => op.accountId === selectedAccount);
        }

        // Aplicar filtros personalizados
        operations = applyDailyJournalFilters(operations);
        
        // Agrupar operaciones por día
        const dayGroups = {};
        operations.forEach(op => {
            const date = op.date;
            if (!dayGroups[date]) {
                dayGroups[date] = [];
            }
            dayGroups[date].push(op);
        });
        
        // Ordenar días por fecha descendente (más reciente primero)
        const sortedDates = Object.keys(dayGroups).sort((a, b) => new Date(b) - new Date(a));
        
        // Renderizar lista de días
        const listContainer = document.getElementById('daily-journal-list');
        if (!listContainer) return;
        
        if (sortedDates.length === 0) {
            listContainer.innerHTML = `
                <div class="metric-card text-center py-12">
                    <i class="fas fa-book text-6xl text-text-secondary mb-4"></i>
                    <p class="text-text-secondary">No hay operaciones registradas</p>
                </div>
            `;
        } else {
            listContainer.innerHTML = sortedDates.map(date => {
                const dayOps = dayGroups[date];
                return renderDayCard(date, dayOps);
            }).join('');
            
            // Inicializar gráficos para cada día
            setTimeout(() => {
                sortedDates.forEach(date => {
                    createDayChart(date, dayGroups[date]);
                });
            }, 100);
        }
        
        // Renderizar calendario mini
        renderMiniCalendar(dayGroups);
    }
    
    function renderDayCard(date, operations) {
        // Calcular métricas del día
        const totalTrades = operations.length;
        const winners = operations.filter(op => op.result === 'win').length;
        const losers = operations.filter(op => op.result === 'loss').length;
        const winrate = totalTrades > 0 ? (winners / totalTrades) * 100 : 0;
        
        const grossPL = operations.reduce((sum, op) => {
            return sum + convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency);
        }, 0);
        
        const commissions = operations.reduce((sum, op) => {
            return sum + convertCurrency(op.fee || op.fees || 0, op.currency, DB.settings.defaultCurrency);
        }, 0);
        
        const netPL = grossPL - commissions;
        
        const volume = operations.reduce((sum, op) => sum + (op.volume || 0), 0);
        
        const totalWinPL = operations.filter(op => op.result === 'win').reduce((sum, op) => {
            return sum + convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency);
        }, 0);
        
        const totalLossPL = Math.abs(operations.filter(op => op.result === 'loss').reduce((sum, op) => {
            return sum + convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency);
        }, 0));
        
        const profitFactor = totalLossPL > 0 ? totalWinPL / totalLossPL : (totalWinPL > 0 ? 999 : 0);
        
        // Formatear fecha al estilo "Wed, Jun 26, 2024"
        const dateObj = new Date(date + 'T12:00:00');
        const formattedDate = dateObj.toLocaleDateString('es-ES', { 
            weekday: 'short', 
            year: 'numeric', 
            month: 'short', 
            day: 'numeric' 
        });
        
        // Formatear fecha completa para el modal de análisis
        const dayFullName = dateObj.toLocaleDateString('es-ES', { 
            weekday: 'long', 
            day: 'numeric', 
            month: 'long' 
        });
        
        const plClass = netPL >= 0 ? 'positive' : 'negative';
        const hasNote = DB.dailyNotes && DB.dailyNotes[date];
        
        return `
            <div class="daily-journal-day-card" data-date="${date}" data-journal-date="${date}">
                <div class="daily-journal-header" onclick="toggleDayExpansion('${date}')">
                    <div>
                        <div class="daily-journal-date">${formattedDate}</div>
                    </div>
                    <div class="flex items-center gap-4">
                        <div class="daily-journal-pl ${plClass}">
                            Net P&L $${netPL.toFixed(2)}
                        </div>
                        <i class="fas fa-chevron-down transition-transform" id="chevron-${date}"></i>
                    </div>
                </div>
                
                <div id="day-content-${date}" class="day-content" style="display: block;">
                    <!-- Gráfico de área del día -->
                    <div class="daily-journal-chart-container">
                        <canvas id="day-chart-${date}"></canvas>
                    </div>
                    
                    <!-- Métricas del día -->
                    <div class="daily-journal-metrics">
                        <div class="daily-journal-metric">
                            <div class="daily-journal-metric-label">Total Trades</div>
                            <div class="daily-journal-metric-value">${totalTrades}</div>
                        </div>
                        <div class="daily-journal-metric">
                            <div class="daily-journal-metric-label">Winners</div>
                            <div class="daily-journal-metric-value" style="color: var(--success);">${winners}</div>
                        </div>
                        <div class="daily-journal-metric">
                            <div class="daily-journal-metric-label">Losers</div>
                            <div class="daily-journal-metric-value" style="color: var(--danger);">${losers}</div>
                        </div>
                        <div class="daily-journal-metric">
                            <div class="daily-journal-metric-label">Winrate</div>
                            <div class="daily-journal-metric-value">${winrate.toFixed(1)}%</div>
                        </div>
                        <div class="daily-journal-metric">
                            <div class="daily-journal-metric-label">Gross P&L</div>
                            <div class="daily-journal-metric-value">$${grossPL.toFixed(2)}</div>
                        </div>
                        <div class="daily-journal-metric">
                            <div class="daily-journal-metric-label">Volumen</div>
                            <div class="daily-journal-metric-value">${volume.toFixed(2)}</div>
                        </div>
                        <div class="daily-journal-metric">
                            <div class="daily-journal-metric-label">Comisiones</div>
                            <div class="daily-journal-metric-value">$${commissions.toFixed(2)}</div>
                        </div>
                        <div class="daily-journal-metric">
                            <div class="daily-journal-metric-label">Profit Factor</div>
                            <div class="daily-journal-metric-value">${profitFactor.toFixed(2)}</div>
                        </div>
                    </div>
                    
                    <!-- Botones de acción -->
                    <div class="mt-4 flex justify-end gap-2">
                        <button class="daily-journal-note-btn" onclick="openDayAnalysis('${date}')">
                            <i class="fas fa-book-open"></i>
                            <span>Notebook</span>
                        </button>
                        <button class="daily-journal-note-btn has-note" onclick="openAnalyticsDetailModal('date', '${date}', 'Día: ${dayFullName}')">
                            <i class="fas fa-external-link-alt"></i>
                            <span>Abrir</span>
                        </button>
                    </div>
                </div>
            </div>
        `;
    }
    
    function createDayChart(date, operations) {
        const canvas = document.getElementById(`day-chart-${date}`);
        if (!canvas) return;
        
        // Destruir gráfico existente si lo hay
        if (dayCharts[date]) {
            dayCharts[date].destroy();
        }
        
        // Ordenar operaciones por hora
        const sortedOps = [...operations].sort((a, b) => {
            const timeA = a.entryTime || '00:00';
            const timeB = b.entryTime || '00:00';
            return timeA.localeCompare(timeB);
        });
        
        // Calcular P&L acumulado
        let cumulative = 0;
        const labels = [];
        const data = [];
        const positiveData = [];
        const negativeData = [];
        
        sortedOps.forEach((op, index) => {
            const pl = convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency);
            cumulative += pl;
            
            labels.push(`#${index + 1}`);
            data.push(cumulative);
            
            if (cumulative >= 0) {
                positiveData.push(cumulative);
                negativeData.push(null);
            } else {
                positiveData.push(null);
                negativeData.push(cumulative);
            }
        });
        
        const ctx = canvas.getContext('2d');
        
        dayCharts[date] = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [
                    {
                        label: 'Profit',
                        data: positiveData,
                        borderColor: '#39ff14',
                        backgroundColor: 'rgba(57, 255, 20, 0.3)',
                        fill: 'origin',
                        borderWidth: 2,
                        tension: 0.4,
                        pointRadius: 3,
                        pointHoverRadius: 5
                    },
                    {
                        label: 'Loss',
                        data: negativeData,
                        borderColor: '#ff4136',
                        backgroundColor: 'rgba(255, 65, 54, 0.3)',
                        fill: 'origin',
                        borderWidth: 2,
                        tension: 0.4,
                        pointRadius: 3,
                        pointHoverRadius: 5
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'index',
                    intersect: false
                },
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        backgroundColor: 'rgba(26, 26, 26, 0.95)',
                        titleColor: '#ffffff',
                        bodyColor: '#ffffff',
                        borderColor: '#39ff14',
                        borderWidth: 1,
                        callbacks: {
                            label: (item) => {
                                if (item.parsed.y === null) return '';
                                return `P&L Acumulado: $${item.parsed.y.toFixed(2)}`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        display: true,
                        grid: {
                            color: 'rgba(255, 255, 255, 0.05)'
                        },
                        ticks: {
                            color: '#a0a0a0',
                            font: { size: 10 }
                        }
                    },
                    y: {
                        display: true,
                        grid: {
                            color: 'rgba(255, 255, 255, 0.05)'
                        },
                        ticks: {
                            color: '#a0a0a0',
                            font: { size: 10 },
                            callback: (value) => '$' + value.toFixed(0)
                        }
                    }
                }
            }
        });
    }
    
    function renderMiniCalendar(dayGroups) {
        const calendarContainer = document.getElementById('daily-journal-calendar-mini');
        if (!calendarContainer) return;
        
        const monthNames = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 
                           'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'];
        
        const firstDay = new Date(currentYear, currentMonth, 1);
        const lastDay = new Date(currentYear, currentMonth + 1, 0);
        const daysInMonth = lastDay.getDate();
        const startingDayOfWeek = firstDay.getDay();
        
        let calendarHTML = `
            <div class="daily-journal-calendar-header">
                <button class="daily-journal-calendar-nav" onclick="changeCalendarMonth(-1)">
                    <i class="fas fa-chevron-left"></i>
                </button>
                <div class="daily-journal-calendar-month">${monthNames[currentMonth]} ${currentYear}</div>
                <button class="daily-journal-calendar-nav" onclick="changeCalendarMonth(1)">
                    <i class="fas fa-chevron-right"></i>
                </button>
            </div>
            <div class="daily-journal-calendar-grid">
                <div class="daily-journal-calendar-day-header">D</div>
                <div class="daily-journal-calendar-day-header">L</div>
                <div class="daily-journal-calendar-day-header">M</div>
                <div class="daily-journal-calendar-day-header">X</div>
                <div class="daily-journal-calendar-day-header">J</div>
                <div class="daily-journal-calendar-day-header">V</div>
                <div class="daily-journal-calendar-day-header">S</div>
        `;
        
        // Días vacíos al inicio
        for (let i = 0; i < startingDayOfWeek; i++) {
            calendarHTML += '<div class="daily-journal-calendar-day empty"></div>';
        }
        
        // Días del mes
        const today = new Date();
        for (let day = 1; day <= daysInMonth; day++) {
            const dateStr = `${currentYear}-${String(currentMonth + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
            const isToday = today.getDate() === day && today.getMonth() === currentMonth && today.getFullYear() === currentYear;
            
            let dayClass = 'daily-journal-calendar-day';
            if (isToday) dayClass += ' today';
            
            if (dayGroups[dateStr]) {
                const dayOps = dayGroups[dateStr];
                const netPL = dayOps.reduce((sum, op) => {
                    return sum + convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency);
                }, 0);
                
                dayClass += netPL >= 0 ? ' has-data positive' : ' has-data negative';
            }
            
            calendarHTML += `<div class="${dayClass}" onclick="scrollToDay('${dateStr}')">${day}</div>`;
        }
        
        calendarHTML += '</div>';
        calendarContainer.innerHTML = calendarHTML;
    }
    
    // Funciones globales
    window.toggleDayExpansion = function(date) {
        const content = document.getElementById(`day-content-${date}`);
        const chevron = document.getElementById(`chevron-${date}`);
        
        if (content.style.display === 'none') {
            content.style.display = 'block';
            chevron.style.transform = 'rotate(0deg)';
        } else {
            content.style.display = 'none';
            chevron.style.transform = 'rotate(-90deg)';
        }
    };
    
    window.scrollToDay = function(date) {
        const card = document.querySelector(`[data-date="${date}"]`);
        if (card) {
            card.scrollIntoView({ behavior: 'smooth', block: 'center' });
            card.style.borderColor = 'var(--primary)';
            setTimeout(() => {
                card.style.borderColor = '';
            }, 2000);
        }
    };
    
    window.changeCalendarMonth = function(delta) {
        currentMonth += delta;
        if (currentMonth > 11) {
            currentMonth = 0;
            currentYear++;
        } else if (currentMonth < 0) {
            currentMonth = 11;
            currentYear--;
        }
        refreshDailyJournal();
    };
    
    // Nueva función para abrir el análisis del día
    window.openDayAnalysis = function(date, openImagesTab = false) {
        const modal = document.getElementById('day-analysis-modal');
        if (!modal) return;
        
        // Obtener operaciones del día
        const accountSelect = document.getElementById('daily-journal-account-select');
        const selectedAccount = accountSelect ? accountSelect.value : 'all';
        
        let dayOps = DB.operations.filter(op => op.date === date);
        if (selectedAccount !== 'all') {
            dayOps = dayOps.filter(op => op.accountId === selectedAccount);
        }
        
        // Calcular métricas
        const totalTrades = dayOps.length;
        const winners = dayOps.filter(op => op.result === 'win').length;
        const losers = dayOps.filter(op => op.result === 'loss').length;
        const winrate = totalTrades > 0 ? (winners / totalTrades) * 100 : 0;
        
        const grossPL = dayOps.reduce((sum, op) => {
            return sum + convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency);
        }, 0);
        
        const commissions = dayOps.reduce((sum, op) => {
            return sum + convertCurrency(op.fee || op.fees || 0, op.currency, DB.settings.defaultCurrency);
        }, 0);
        
        const netPL = grossPL - commissions;
        
        const totalWinPL = dayOps.filter(op => op.result === 'win').reduce((sum, op) => {
            return sum + convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency);
        }, 0);
        
        const totalLossPL = Math.abs(dayOps.filter(op => op.result === 'loss').reduce((sum, op) => {
            return sum + convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency);
        }, 0));
        
        const profitFactor = totalLossPL > 0 ? totalWinPL / totalLossPL : (totalWinPL > 0 ? 999 : 0);
        
        // Formatear fecha
        const dateObj = new Date(date + 'T12:00:00');
        const formattedDate = dateObj.toLocaleDateString('es-ES', { 
            weekday: 'long', 
            year: 'numeric', 
            month: 'long', 
            day: 'numeric' 
        });
        
        // Actualizar modal
        document.getElementById('day-analysis-date').textContent = formattedDate;
        document.getElementById('day-analysis-net-pl').textContent = `$${netPL.toFixed(2)}`;
        document.getElementById('day-analysis-net-pl').className = netPL >= 0 ? 'text-xl font-bold text-green' : 'text-xl font-bold text-red';
        document.getElementById('day-analysis-trades').textContent = totalTrades;
        document.getElementById('day-analysis-winners').textContent = winners;
        document.getElementById('day-analysis-losers').textContent = losers;
        document.getElementById('day-analysis-winrate').textContent = `${winrate.toFixed(1)}%`;
        document.getElementById('day-analysis-gross-pl').textContent = `$${grossPL.toFixed(2)}`;
        document.getElementById('day-analysis-commissions').textContent = `$${commissions.toFixed(2)}`;
        document.getElementById('day-analysis-pf').textContent = profitFactor.toFixed(2);
        
        // Cargar notas e imágenes del día
        loadDayAnalysisData(date);
        
        // Abrir pestaña correspondiente (imágenes si openImagesTab es true, sino notas)
        if (openImagesTab) {
            switchDayAnalysisTab('images');
        } else {
            switchDayAnalysisTab('notes');
        }
        
        // Mostrar modal
        modal.style.display = 'flex';
        modal.dataset.currentDate = date;
    };
    
    function loadDayAnalysisData(date) {
        // Cargar notas
        const notes = (DB.dayAnalysisData && DB.dayAnalysisData[date] && DB.dayAnalysisData[date].notes) || '';
        const notesView = document.getElementById('day-analysis-notes-view');
        if (notes) {
            notesView.innerHTML = notes;
        } else {
            notesView.innerHTML = '<p class="text-text-secondary italic">Sin notas agregadas para este día.</p>';
        }
        
        // Cargar imágenes
        const images = (DB.dayAnalysisData && DB.dayAnalysisData[date] && DB.dayAnalysisData[date].images) || [];
        renderDayAnalysisImages(images);
    }
    
    function renderDayAnalysisImages(images) {
        const imagesView = document.getElementById('day-analysis-images-view');
        if (!images || images.length === 0) {
            imagesView.innerHTML = '<p class="col-span-full text-center text-text-secondary italic py-8">Sin imágenes agregadas para este día.</p>';
        } else {
            imagesView.innerHTML = images.map((img, index) => `
                <div class="relative group">
                    <img src="${img}" alt="Imagen ${index + 1}" class="w-full h-48 object-cover rounded border border-border cursor-pointer hover:opacity-80 transition" onclick="viewImageFullscreen('${img}')">
                    <button class="absolute top-2 right-2 bg-red text-white p-2 rounded-full opacity-0 group-hover:opacity-100 transition" onclick="deleteDayAnalysisImage(${index})" title="Eliminar">
                        <i class="fas fa-trash text-xs"></i>
                    </button>
                </div>
            `).join('');
        }
    }
    
    window.viewImageFullscreen = function(src) {
        const viewer = document.createElement('div');
        viewer.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);z-index:10000;display:flex;align-items:center;justify-content:center;cursor:zoom-out;';
        viewer.innerHTML = `<img src="${src}" style="max-width:90%;max-height:90%;object-fit:contain;">`;
        viewer.onclick = () => viewer.remove();
        document.body.appendChild(viewer);
    };
    
    window.deleteDayAnalysisImage = function(index) {
        if (!confirm('¿Eliminar esta imagen?')) return;
        
        const modal = document.getElementById('day-analysis-modal');
        const date = modal.dataset.currentDate;
        
        if (!DB.dayAnalysisData) DB.dayAnalysisData = {};
        if (!DB.dayAnalysisData[date]) DB.dayAnalysisData[date] = {};
        if (!DB.dayAnalysisData[date].images) DB.dayAnalysisData[date].images = [];
        
        DB.dayAnalysisData[date].images.splice(index, 1);
        
        // Guardar en Dexie
        dexieDB.generalData.put({ key: 'dayAnalysisData', data: DB.dayAnalysisData });
        
        renderDayAnalysisImages(DB.dayAnalysisData[date].images);
    };
    
    function switchDayAnalysisTab(tab) {
        // Actualizar botones
        document.querySelectorAll('.day-analysis-tab-btn').forEach(btn => {
            btn.classList.remove('active', 'bg-primary', 'text-black');
            if (btn.dataset.tab === tab) {
                btn.classList.add('active', 'bg-primary', 'text-black');
            }
        });
        
        // Mostrar/ocultar contenido
        document.querySelectorAll('.day-analysis-tab-content').forEach(content => {
            content.classList.add('hidden');
            content.classList.remove('active');
        });
        
        if (tab === 'notes') {
            document.getElementById('day-analysis-notes-content').classList.remove('hidden');
            document.getElementById('day-analysis-notes-content').classList.add('active');
        } else if (tab === 'images') {
            document.getElementById('day-analysis-images-content').classList.remove('hidden');
            document.getElementById('day-analysis-images-content').classList.add('active');
        }
    }
    
    // Event listeners
    const accountSelect = document.getElementById('daily-journal-account-select');
    if (accountSelect) {
        accountSelect.addEventListener('change', () => {
            updateSelectorLogo('daily-journal-account-select');
            refreshDailyJournal();
        });
    }
    
    // Inicialización
    console.log('🔄 Inicializando Daily Journal...');
    setTimeout(async () => {
        if (typeof updateAccountSelect === 'function') {
            updateAccountSelect('daily-journal-account-select');
            console.log('✅ Selector de cuentas Daily Journal poblado');
        }
        if (typeof updateSelectorLogo === 'function') {
            updateSelectorLogo('daily-journal-account-select');
        }
        
        // Cargar datos de análisis diario desde Dexie (local)
        if (typeof dexieDB !== 'undefined' && dexieDB) {
            try {
                const localData = await dexieDB.generalData.get('dayAnalysisData');
                if (localData && localData.data) {
                    DB.dayAnalysisData = localData.data;
                } else {
                    DB.dayAnalysisData = {};
                }
            } catch (error) {
                console.warn('⚠️ Error cargando datos de Dexie:', error);
                DB.dayAnalysisData = {};
            }
        } else {
            console.warn('⚠️ dexieDB no está disponible');
            if (typeof DB !== 'undefined' && DB) {
                DB.dayAnalysisData = {};
            }
        }
        
        // Cargar datos desde Supabase y fusionar con datos locales
        if (currentUser && typeof loadJournalEntriesFromSupabase === 'function') {
            try {
                const supabaseEntries = await loadJournalEntriesFromSupabase();
                console.log('📥 Cargadas', supabaseEntries.length, 'entradas del journal desde Supabase');
                
                // Fusionar con datos locales (Supabase tiene prioridad)
                supabaseEntries.forEach(entry => {
                    if (!DB.dayAnalysisData[entry.date]) {
                        DB.dayAnalysisData[entry.date] = {};
                    }
                    
                    DB.dayAnalysisData[entry.date].notes = entry.pre_trading_note || '';
                    DB.dayAnalysisData[entry.date].post_notes = entry.post_trading_note || '';
                    DB.dayAnalysisData[entry.date].lessons = entry.lessons_learned || '';
                    
                    if (entry.image_data) {
                        if (!DB.dayAnalysisData[entry.date].images) {
                            DB.dayAnalysisData[entry.date].images = [];
                        }
                        if (!DB.dayAnalysisData[entry.date].images.includes(entry.image_data)) {
                            DB.dayAnalysisData[entry.date].images.push(entry.image_data);
                        }
                    }
                });
                
                // Guardar datos fusionados localmente
                await dexieDB.generalData.put({ key: 'dayAnalysisData', data: DB.dayAnalysisData });
                console.log('✅ Datos del journal fusionados y guardados localmente');
            } catch (error) {
                console.error('❌ Error cargando entradas del journal desde Supabase:', error);
            }
        }
        
        // Inicializar event listeners del modal de análisis del día
        initializeDayAnalysisModal();
        
        if (document.getElementById('daily-journal').classList.contains('active')) {
            refreshDailyJournal();
        }
        console.log('✅ Daily Journal inicializado');
    }, 500);
    
    // Función para inicializar el modal de análisis del día
    function initializeDayAnalysisModal() {
        let dayAnalysisRichEditor = null;
        
        // Cerrar modal
        document.getElementById('close-day-analysis-modal')?.addEventListener('click', () => {
            document.getElementById('day-analysis-modal').style.display = 'none';
        });
        
        // Tabs
        document.querySelectorAll('.day-analysis-tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                switchDayAnalysisTab(btn.dataset.tab);
            });
        });
        
        // Editar notas
        document.getElementById('day-analysis-edit-notes-btn')?.addEventListener('click', () => {
            document.getElementById('day-analysis-notes-view').classList.add('hidden');
            document.getElementById('day-analysis-notes-edit').classList.remove('hidden');
            
            // Inicializar Rich Text Editor si no existe
            if (!dayAnalysisRichEditor) {
                const container = document.getElementById('day-analysis-rich-editor-container');
                if (container) {
                    dayAnalysisRichEditor = new RichTextEditor(container, {
                        placeholder: 'Escribe las notas del día...',
                        minHeight: '300px',
                        maxHeight: '500px',
                        showVoiceRecorder: true,
                        showDownload: true,
                        showCharCount: true
                    });
                }
            }
            
            // Cargar contenido actual
            const modal = document.getElementById('day-analysis-modal');
            const date = modal.dataset.currentDate;
            const notes = (DB.dayAnalysisData && DB.dayAnalysisData[date] && DB.dayAnalysisData[date].notes) || '';
            
            if (dayAnalysisRichEditor) {
                dayAnalysisRichEditor.setContent(notes, 'html');
            }
        });
        
        // Guardar notas
        document.getElementById('day-analysis-save-notes-btn')?.addEventListener('click', async () => {
            const modal = document.getElementById('day-analysis-modal');
            const date = modal.dataset.currentDate;
            const notes = dayAnalysisRichEditor ? dayAnalysisRichEditor.getContent('html') : '';
            
            if (!DB.dayAnalysisData) DB.dayAnalysisData = {};
            if (!DB.dayAnalysisData[date]) DB.dayAnalysisData[date] = {};
            
            DB.dayAnalysisData[date].notes = notes;
            
            // Guardar en Dexie (local) - usar 'key' en lugar de 'id'
            try {
                await dexieDB.generalData.put({ key: 'dayAnalysisData', data: DB.dayAnalysisData });
            } catch (error) {
                console.error('Error guardando en Dexie:', error);
            }
            
            // --- SINCRONIZACIÓN AUTOMÁTICA CON NOTEBOOK ---
            try {
                // Asegurar que userId esté definido
                if (!window.userId && window.currentUser) {
                    window.userId = window.currentUser.id;
                }
                
                if (!window.userId) {
                    console.warn('⚠️ No hay userId disponible, saltando sincronización con Notebook');
                    return;
                }

                // Buscar carpeta "Daily Journal" en IndexedDB (NO en memoria)
                const allFolders = await dexieDB.notebookFolders.toArray();
                let dailyJournalFolder = allFolders.find(f => f.name === 'Daily Journal' && f.user_id === window.userId);
                
                if (!dailyJournalFolder) {
                    console.log('📁 Creando carpeta "Daily Journal" en Notebook...');
                    dailyJournalFolder = {
                        id: 'folder_dailyjournal_' + window.userId + '_' + Date.now(),
                        user_id: window.userId,
                        name: 'Daily Journal',
                        icon: '📁',
                        created_at: new Date().toISOString()
                    };
                    
                    await dexieDB.notebookFolders.add(dailyJournalFolder);
                    console.log('💾 Carpeta guardada en IndexedDB');
                    
                    if (window.supabase) {
                        const { error } = await supabase.from('notebook_folders').insert([dailyJournalFolder]);
                        if (error) {
                            console.error('❌ Error guardando carpeta en Supabase:', error);
                        } else {
                            console.log('☁️ Carpeta guardada en Supabase');
                        }
                    }
                    
                    // Actualizar memoria
                    if (!DB.notebookFolders) DB.notebookFolders = [];
                    DB.notebookFolders.push(dailyJournalFolder);
                    console.log('✅ Carpeta Daily Journal creada');
                } else {
                    console.log('✅ Carpeta Daily Journal encontrada:', dailyJournalFolder.id);
                }
                
                // Crear título descriptivo para la nota
                const noteTitle = `Análisis del Día - ${new Date(date).toLocaleDateString('es-ES', { weekday: 'long', day: 'numeric', month: 'long' })}`;
                
                // Buscar si ya existe una nota para este día (DESDE DEXIE, NO MEMORIA)
                const allNotes = await dexieDB.notebookNotes
                    .where('folder_id')
                    .equals(dailyJournalFolder.id)
                    .toArray();
                    
                let existingNote = allNotes.find(n => 
                    n.metadata && 
                    n.metadata.date === date &&
                    n.metadata.source === 'day_analysis'
                );
                
                console.log('🔍 Búsqueda de nota existente para fecha', date, ':', existingNote ? 'ENCONTRADA' : 'NO ENCONTRADA');
                
                if (existingNote) {
                    // Actualizar nota existente
                    console.log('📝 Actualizando nota existente:', existingNote.id);
                    existingNote.title = noteTitle;
                    existingNote.content = notes;
                    existingNote.updated_at = new Date().toISOString();
                    
                    await dexieDB.notebookNotes.put(existingNote);
                    console.log('💾 Nota actualizada en IndexedDB');
                    
                    if (window.supabase) {
                        const { error } = await supabase
                            .from('notebook_notes')
                            .update({
                                title: existingNote.title,
                                content: existingNote.content,
                                updated_at: existingNote.updated_at
                            })
                            .eq('id', existingNote.id);
                            
                        if (error) {
                            console.error('❌ Error actualizando nota en Supabase:', error);
                        } else {
                            console.log('☁️ Nota actualizada en Supabase');
                        }
                    }
                    
                    // Actualizar en memoria
                    if (!DB.notebookNotes) DB.notebookNotes = [];
                    const memIndex = DB.notebookNotes.findIndex(n => n.id === existingNote.id);
                    if (memIndex >= 0) {
                        DB.notebookNotes[memIndex] = existingNote;
                    } else {
                        DB.notebookNotes.push(existingNote);
                    }
                } else {
                    // Crear nueva nota
                    console.log('📝 Creando nueva nota en Notebook...');
                    const newNote = {
                        id: 'note_da_' + date.replace(/\//g, '-') + '_' + Date.now(),
                        user_id: window.userId,
                        folder_id: dailyJournalFolder.id,
                        title: noteTitle,
                        content: notes,
                        created_at: new Date().toISOString(),
                        updated_at: new Date().toISOString(),
                        is_pinned: false,
                        metadata: {
                            date: date,
                            source: 'day_analysis'
                        }
                    };
                    
                    await dexieDB.notebookNotes.add(newNote);
                    console.log('💾 Nueva nota guardada en IndexedDB con ID:', newNote.id);
                    
                    if (window.supabase) {
                        const { error } = await supabase.from('notebook_notes').insert([newNote]);
                        if (error) {
                            console.error('❌ Error guardando nota en Supabase:', error);
                        } else {
                            console.log('☁️ Nota guardada en Supabase');
                        }
                    }
                    
                    // Actualizar memoria
                    if (!DB.notebookNotes) DB.notebookNotes = [];
                    DB.notebookNotes.unshift(newNote);
                }
                
                console.log('✅ Notas sincronizadas con Notebook → Carpeta "Daily Journal"');
                
                // Mostrar notificación de éxito
                if (typeof showNotification === 'function') {
                    showNotification('✅ Nota guardada en Daily Journal', 'success');
                }
                
                // Notificar a Notebook para que actualice
                if (typeof window.notebookNotesUpdated === 'function') {
                    await window.notebookNotesUpdated();
                    console.log('📢 Notebook notificado para actualizar contadores');
                }
                
                // Si estamos en la sección Notebook, recargar la carpeta Daily Journal
                if (document.getElementById('notebook')?.classList.contains('active')) {
                    console.log('📂 Sección Notebook activa, refrescando vista...');
                    if (typeof window.notifyNotebookNewNote === 'function') {
                        await window.notifyNotebookNewNote(dailyJournalFolder.id);
                    }
                }
            } catch (notebookError) {
                console.error('❌ Error al sincronizar con Notebook:', notebookError);
                console.error('Stack trace:', notebookError.stack);
            }
            
            // Guardar en Supabase
            if (currentUser && typeof saveJournalEntryToSupabase === 'function') {
                const accountSelect = document.getElementById('daily-journal-account-select');
                const accountId = accountSelect ? accountSelect.value : 'all';
                
                // Obtener métricas del día
                let dayOps = DB.operations.filter(op => op.date === date);
                if (accountId !== 'all') {
                    dayOps = dayOps.filter(op => op.accountId === accountId);
                }
                
                const totalTrades = dayOps.length;
                const winners = dayOps.filter(op => op.result === 'win').length;
                const winrate = totalTrades > 0 ? (winners / totalTrades) * 100 : 0;
                const dailyPnl = dayOps.reduce((sum, op) => sum + (op.pl || 0), 0);
                
                const entryData = {
                    date: date,
                    account_id: accountId !== 'all' ? accountId : null,
                    pre_trading_note: notes,
                    post_trading_note: DB.dayAnalysisData[date].post_notes || '',
                    lessons_learned: DB.dayAnalysisData[date].lessons || '',
                    image_data: (DB.dayAnalysisData[date].images && DB.dayAnalysisData[date].images[0]) || null,
                    daily_pnl: dailyPnl,
                    trades_count: totalTrades,
                    win_rate: winrate
                };
                
                saveJournalEntryToSupabase(entryData).catch(err => {
                    console.error('Error guardando entrada en Supabase:', err);
                });
            }
            
            // Actualizar vista
            document.getElementById('day-analysis-notes-view').innerHTML = notes || '<p class="text-text-secondary italic">Sin notas agregadas para este día.</p>';
            document.getElementById('day-analysis-notes-view').classList.remove('hidden');
            document.getElementById('day-analysis-notes-edit').classList.add('hidden');
        });
        
        // Cancelar edición de notas
        document.getElementById('day-analysis-cancel-notes-btn')?.addEventListener('click', () => {
            document.getElementById('day-analysis-notes-view').classList.remove('hidden');
            document.getElementById('day-analysis-notes-edit').classList.add('hidden');
        });
        
        // Ir a Notebook - Daily Journal
        document.getElementById('day-analysis-goto-notebook-btn')?.addEventListener('click', async () => {
            try {
                console.log('📂 Abriendo carpeta Daily Journal en Notebook...');
                
                // Asegurar que la carpeta existe
                const allFolders = await dexieDB.notebookFolders.toArray();
                const dailyJournalFolder = allFolders.find(f => f.name === 'Daily Journal');
                
                if (!dailyJournalFolder) {
                    alert('No se encontró la carpeta Daily Journal. Guarda las notas primero.');
                    return;
                }
                
                // Cerrar modal
                document.getElementById('day-analysis-modal').style.display = 'none';
                
                // Cambiar a la sección Notebook
                if (typeof switchSection === 'function') {
                    switchSection('notebook');
                } else {
                    document.getElementById('notebook')?.click();
                }
                
                // Esperar a que Notebook se cargue
                setTimeout(async () => {
                    // Seleccionar la carpeta Daily Journal
                    if (typeof window.notebookSelectFolder === 'function') {
                        await window.notebookSelectFolder(dailyJournalFolder.id);
                    } else {
                        // Simular click en la carpeta
                        const folderElement = document.querySelector(`[data-folder-id="${dailyJournalFolder.id}"]`);
                        if (folderElement) {
                            folderElement.click();
                        }
                    }
                }, 300);
                
            } catch (error) {
                console.error('❌ Error abriendo Notebook:', error);
                alert('Error abriendo Notebook: ' + error.message);
            }
        });
        
        // Agregar imágenes
        document.getElementById('day-analysis-add-images-btn')?.addEventListener('click', () => {
            document.getElementById('day-analysis-images-view').classList.add('hidden');
            document.getElementById('day-analysis-images-upload').classList.remove('hidden');
        });
        
        // Preview de imágenes
        document.getElementById('day-analysis-image-input')?.addEventListener('change', (e) => {
            const files = Array.from(e.target.files);
            const previewContainer = document.getElementById('day-analysis-image-preview');
            previewContainer.innerHTML = '';
            
            files.forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const div = document.createElement('div');
                    div.className = 'relative';
                    div.innerHTML = `
                        <img src="${e.target.result}" class="w-full h-32 object-cover rounded border border-border">
                        <button type="button" class="absolute top-1 right-1 bg-red text-white p-1 rounded-full text-xs" onclick="this.parentElement.remove()">
                            <i class="fas fa-times"></i>
                        </button>
                    `;
                    previewContainer.appendChild(div);
                };
                reader.readAsDataURL(file);
            });
        });
        
        // Subir imágenes
        document.getElementById('day-analysis-upload-images-btn')?.addEventListener('click', async () => {
            const modal = document.getElementById('day-analysis-modal');
            const date = modal.dataset.currentDate;
            const input = document.getElementById('day-analysis-image-input');
            const files = Array.from(input.files);
            
            if (files.length === 0) {
                alert('Por favor selecciona al menos una imagen');
                return;
            }
            
            if (!DB.dayAnalysisData) DB.dayAnalysisData = {};
            if (!DB.dayAnalysisData[date]) DB.dayAnalysisData[date] = {};
            if (!DB.dayAnalysisData[date].images) DB.dayAnalysisData[date].images = [];
            
            try {
                // Procesar todos los archivos con Promise.all
                const imagePromises = files.map(file => {
                    return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = (e) => resolve(e.target.result);
                        reader.onerror = reject;
                        reader.readAsDataURL(file);
                    });
                });
                
                const images = await Promise.all(imagePromises);
                DB.dayAnalysisData[date].images.push(...images);
                
                console.log(`📸 ${images.length} imágenes agregadas para ${date}`);
                
                // Guardar en Dexie (local)
                await dexieDB.generalData.put({ key: 'dayAnalysisData', data: DB.dayAnalysisData });
                console.log('✅ Imágenes guardadas en IndexedDB');
                
                // Guardar en Supabase
                if (currentUser && typeof saveJournalEntryToSupabase === 'function') {
                    const accountSelect = document.getElementById('daily-journal-account-select');
                    const accountId = accountSelect ? accountSelect.value : 'all';
                    
                    // Obtener métricas del día
                    let dayOps = DB.operations.filter(op => op.date === date);
                    if (accountId !== 'all') {
                        dayOps = dayOps.filter(op => op.accountId === accountId);
                    }
                    
                    const totalTrades = dayOps.length;
                    const winners = dayOps.filter(op => op.result === 'win').length;
                    const winrate = totalTrades > 0 ? (winners / totalTrades) * 100 : 0;
                    const dailyPnl = dayOps.reduce((sum, op) => sum + (op.pl || 0), 0);
                    
                    const entryData = {
                        date: date,
                        account_id: accountId !== 'all' ? accountId : null,
                        pre_trading_note: DB.dayAnalysisData[date].notes || '',
                        post_trading_note: DB.dayAnalysisData[date].post_notes || '',
                        lessons_learned: DB.dayAnalysisData[date].lessons || '',
                        image_data: DB.dayAnalysisData[date].images[0] || null,
                        daily_pnl: dailyPnl,
                        trades_count: totalTrades,
                        win_rate: winrate
                    };
                    
                    await saveJournalEntryToSupabase(entryData);
                    console.log('✅ Imágenes guardadas en Supabase');
                }
                
                // Actualizar vista
                renderDayAnalysisImages(DB.dayAnalysisData[date].images);
                document.getElementById('day-analysis-images-view').classList.remove('hidden');
                document.getElementById('day-analysis-images-upload').classList.add('hidden');
                document.getElementById('day-analysis-image-input').value = '';
                document.getElementById('day-analysis-image-preview').innerHTML = '';
            } catch (error) {
                console.error('❌ Error subiendo imágenes:', error);
                alert('Error subiendo imágenes: ' + error.message);
            }
        });
        
        // Cancelar subida de imágenes
        document.getElementById('day-analysis-cancel-images-btn')?.addEventListener('click', () => {
            const modal = document.getElementById('day-analysis-modal');
            const date = modal.dataset.currentDate;
            const images = (DB.dayAnalysisData && DB.dayAnalysisData[date] && DB.dayAnalysisData[date].images) || [];
            
            renderDayAnalysisImages(images);
            document.getElementById('day-analysis-images-view').classList.remove('hidden');
            document.getElementById('day-analysis-images-upload').classList.add('hidden');
            document.getElementById('day-analysis-image-input').value = '';
            document.getElementById('day-analysis-image-preview').innerHTML = '';
        });
    }
    
    window.refreshDailyJournal = refreshDailyJournal;
})(); // Llamada inmediata del IIFE async

// =============================================
// RICH TEXT EDITOR - EDITOR DE TEXTO ENRIQUECIDO
// =============================================
class RichTextEditor {
    constructor(container, options = {}) {
        this.container = container;
        this.options = {
            placeholder: options.placeholder || 'Escribe aquí...',
            minHeight: options.minHeight || '150px',
            maxHeight: options.maxHeight || '400px',
            showVoiceRecorder: options.showVoiceRecorder !== false,
            showDownload: options.showDownload !== false,
            showCharCount: options.showCharCount !== false,
            onChange: options.onChange || null,
            ...options
        };
        
        this.editor = null;
        this.mediaRecorder = null;
        this.audioChunks = [];
        this.isRecording = false;
        
        this.init();
    }
    
    init() {
        const editorHTML = `
            <div class="rich-text-editor">
                <!-- Toolbar -->
                <div class="rte-toolbar">
                    <!-- Formato de texto -->
                    <div class="rte-toolbar-group">
                        <button type="button" class="rte-btn" data-command="bold" title="Negrita (Ctrl+B)">
                            <i class="fas fa-bold"></i>
                        </button>
                        <button type="button" class="rte-btn" data-command="italic" title="Cursiva (Ctrl+I)">
                            <i class="fas fa-italic"></i>
                        </button>
                        <button type="button" class="rte-btn" data-command="underline" title="Subrayado (Ctrl+U)">
                            <i class="fas fa-underline"></i>
                        </button>
                        <button type="button" class="rte-btn" data-command="strikeThrough" title="Tachado">
                            <i class="fas fa-strikethrough"></i>
                        </button>
                    </div>
                    
                    <!-- Alineación -->
                    <div class="rte-toolbar-group">
                        <button type="button" class="rte-btn" data-command="justifyLeft" title="Alinear izquierda">
                            <i class="fas fa-align-left"></i>
                        </button>
                        <button type="button" class="rte-btn" data-command="justifyCenter" title="Alinear centro">
                            <i class="fas fa-align-center"></i>
                        </button>
                        <button type="button" class="rte-btn" data-command="justifyRight" title="Alinear derecha">
                            <i class="fas fa-align-right"></i>
                        </button>
                        <button type="button" class="rte-btn" data-command="justifyFull" title="Justificar">
                            <i class="fas fa-align-justify"></i>
                        </button>
                    </div>
                    
                    <!-- Listas -->
                    <div class="rte-toolbar-group">
                        <button type="button" class="rte-btn" data-command="insertUnorderedList" title="Lista con viñetas">
                            <i class="fas fa-list-ul"></i>
                        </button>
                        <button type="button" class="rte-btn" data-command="insertOrderedList" title="Lista numerada">
                            <i class="fas fa-list-ol"></i>
                        </button>
                        <button type="button" class="rte-btn" data-command="indent" title="Aumentar sangría">
                            <i class="fas fa-indent"></i>
                        </button>
                        <button type="button" class="rte-btn" data-command="outdent" title="Reducir sangría">
                            <i class="fas fa-outdent"></i>
                        </button>
                    </div>
                    
                    <!-- Tamaño de fuente -->
                    <div class="rte-toolbar-group">
                        <select class="rte-select" data-command="fontSize" title="Tamaño de fuente">
                            <option value="1">Muy pequeño</option>
                            <option value="2">Pequeño</option>
                            <option value="3" selected>Normal</option>
                            <option value="4">Mediano</option>
                            <option value="5">Grande</option>
                            <option value="6">Muy grande</option>
                            <option value="7">Enorme</option>
                        </select>
                    </div>
                    
                    <!-- Color de texto -->
                    <div class="rte-toolbar-group">
                        <input type="color" class="rte-btn" data-command="foreColor" value="#ffffff" title="Color de texto" style="padding: 2px; width: 40px;">
                        <input type="color" class="rte-btn" data-command="hiliteColor" value="#ffff00" title="Color de resaltado" style="padding: 2px; width: 40px;">
                    </div>
                    
                    <!-- Otros -->
                    <div class="rte-toolbar-group">
                        <button type="button" class="rte-btn" data-command="insertImage" title="Insertar imagen">
                            <i class="fas fa-image"></i>
                        </button>
                        <button type="button" class="rte-btn" data-command="createLink" title="Insertar enlace">
                            <i class="fas fa-link"></i>
                        </button>
                        <button type="button" class="rte-btn" data-command="insertHorizontalRule" title="Insertar línea horizontal">
                            <i class="fas fa-minus"></i>
                        </button>
                        <button type="button" class="rte-btn" data-command="removeFormat" title="Limpiar formato">
                            <i class="fas fa-remove-format"></i>
                        </button>
                    </div>
                </div>
                
                <!-- Input oculto para selección de imágenes -->
                <input type="file" class="rte-image-input" accept="image/*" style="display: none;">
                
                <!-- Área de contenido editable -->
                <div class="rte-content" 
                     contenteditable="true" 
                     data-placeholder="${this.options.placeholder}"
                     style="min-height: ${this.options.minHeight}; max-height: ${this.options.maxHeight};">
                </div>
                
                <!-- Footer con acciones -->
                <div class="rte-footer">
                    <div class="rte-actions">
                        ${this.options.showVoiceRecorder ? `
                        <button type="button" class="rte-voice-btn" data-action="voice">
                            <i class="fas fa-microphone"></i>
                            <span class="voice-btn-text">Nota de Voz</span>
                        </button>
                        <div class="rte-voice-indicator" style="display: none;">
                            <span>Grabando...</span>
                            <div class="rte-voice-wave"></div>
                            <div class="rte-voice-wave"></div>
                            <div class="rte-voice-wave"></div>
                            <div class="rte-voice-wave"></div>
                        </div>
                        ` : ''}
                        ${this.options.showDownload ? `
                        <button type="button" class="rte-download-btn" data-action="download">
                            <i class="fas fa-download"></i>
                            <span>Descargar Nota</span>
                        </button>
                        ` : ''}
                    </div>
                    ${this.options.showCharCount ? `
                    <div class="rte-char-count">
                        <span class="char-count">0</span> caracteres
                    </div>
                    ` : ''}
                </div>
            </div>
        `;
        
        this.container.innerHTML = editorHTML;
        this.editor = this.container.querySelector('.rte-content');
        
        this.attachEvents();
    }
    
    attachEvents() {
        // Botones de formato
        this.container.querySelectorAll('.rte-btn[data-command]').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.preventDefault();
                const command = btn.dataset.command;
                
                if (command === 'createLink') {
                    const url = prompt('Ingresa la URL:');
                    if (url) {
                        document.execCommand(command, false, url);
                    }
                } else if (command === 'insertImage') {
                    // Activar selector de archivo para imagen
                    const imageInput = this.container.querySelector('.rte-image-input');
                    if (imageInput) {
                        imageInput.click();
                    }
                } else {
                    document.execCommand(command, false, null);
                }
                
                this.editor.focus();
            });
        });
        
        // Manejo de selección de imagen
        const imageInput = this.container.querySelector('.rte-image-input');
        if (imageInput) {
            imageInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file && file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const img = `<img src="${event.target.result}" style="max-width: 100%; height: auto; margin: 10px 0; border-radius: 8px;" />`;
                        this.insertHTML(img);
                    };
                    reader.readAsDataURL(file);
                }
                // Resetear input
                e.target.value = '';
            });
        }
        
        // Select de tamaño de fuente
        const fontSizeSelect = this.container.querySelector('select[data-command="fontSize"]');
        if (fontSizeSelect) {
            fontSizeSelect.addEventListener('change', (e) => {
                document.execCommand('fontSize', false, e.target.value);
                this.editor.focus();
            });
        }
        
        // Color pickers
        this.container.querySelectorAll('input[type="color"]').forEach(input => {
            input.addEventListener('change', (e) => {
                const command = input.dataset.command;
                document.execCommand(command, false, e.target.value);
                this.editor.focus();
            });
        });
        
        // Contador de caracteres
        if (this.options.showCharCount) {
            this.editor.addEventListener('input', () => {
                const charCount = this.container.querySelector('.char-count');
                if (charCount) {
                    charCount.textContent = this.editor.textContent.length;
                }
                
                if (this.options.onChange) {
                    this.options.onChange(this.getContent());
                }
            });
        }
        
        // Grabación de voz
        const voiceBtn = this.container.querySelector('[data-action="voice"]');
        if (voiceBtn) {
            voiceBtn.addEventListener('click', () => this.toggleVoiceRecording());
        }
        
        // Descarga de nota
        const downloadBtn = this.container.querySelector('[data-action="download"]');
        if (downloadBtn) {
            downloadBtn.addEventListener('click', () => this.downloadNote());
        }
    }
    
    async toggleVoiceRecording() {
        if (!this.isRecording) {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                this.mediaRecorder = new MediaRecorder(stream);
                this.audioChunks = [];
                
                this.mediaRecorder.addEventListener('dataavailable', (event) => {
                    this.audioChunks.push(event.data);
                });
                
                this.mediaRecorder.addEventListener('stop', () => {
                    const audioBlob = new Blob(this.audioChunks, { type: 'audio/webm' });
                    const audioUrl = URL.createObjectURL(audioBlob);
                    
                    // Insertar reproductor de audio en el editor
                    const audioHTML = `<div style="margin: 10px 0;"><audio controls src="${audioUrl}" style="max-width: 100%;"></audio></div>`;
                    this.insertHTML(audioHTML);
                    
                    // Opcional: guardar el audio como base64
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        const base64Audio = reader.result;
                        console.log('Audio grabado (base64):', base64Audio.substring(0, 100) + '...');
                    };
                    reader.readAsDataURL(audioBlob);
                    
                    stream.getTracks().forEach(track => track.stop());
                });
                
                this.mediaRecorder.start();
                this.isRecording = true;
                
                // Actualizar UI
                const voiceBtn = this.container.querySelector('[data-action="voice"]');
                const voiceIndicator = this.container.querySelector('.rte-voice-indicator');
                
                if (voiceBtn) {
                    voiceBtn.classList.add('recording');
                    voiceBtn.querySelector('.voice-btn-text').textContent = 'Detener';
                }
                if (voiceIndicator) {
                    voiceIndicator.style.display = 'flex';
                }
                
            } catch (error) {
                console.error('Error al acceder al micrófono:', error);
                alert('No se pudo acceder al micrófono. Verifica los permisos del navegador.');
            }
        } else {
            // Detener grabación
            if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {
                this.mediaRecorder.stop();
            }
            this.isRecording = false;
            
            // Actualizar UI
            const voiceBtn = this.container.querySelector('[data-action="voice"]');
            const voiceIndicator = this.container.querySelector('.rte-voice-indicator');
            
            if (voiceBtn) {
                voiceBtn.classList.remove('recording');
                voiceBtn.querySelector('.voice-btn-text').textContent = 'Nota de Voz';
            }
            if (voiceIndicator) {
                voiceIndicator.style.display = 'none';
            }
        }
    }
    
    downloadNote() {
        const content = this.getContent('html');
        const plainText = this.getContent('text');
        
        // Crear archivo de texto
        const blob = new Blob([plainText], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `nota_${new Date().toISOString().split('T')[0]}.txt`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }
    
    getContent(format = 'html') {
        if (format === 'text') {
            return this.editor.textContent || '';
        }
        return this.editor.innerHTML || '';
    }
    
    setContent(content, format = 'html') {
        if (format === 'text') {
            this.editor.textContent = content;
        } else {
            this.editor.innerHTML = content;
        }
        
        // Actualizar contador
        const charCount = this.container.querySelector('.char-count');
        if (charCount) {
            charCount.textContent = this.editor.textContent.length;
        }
    }
    
    insertHTML(html) {
        this.editor.focus();
        document.execCommand('insertHTML', false, html);
    }
    
    clear() {
        this.editor.innerHTML = '';
        const charCount = this.container.querySelector('.char-count');
        if (charCount) {
            charCount.textContent = '0';
        }
    }
}

// Hacer disponible globalmente
window.RichTextEditor = RichTextEditor;

// =============================================
// PLAYBOOK - GESTIÓN DE SETUPS DE TRADING
// =============================================
(function() {
    console.log('📖 INICIANDO PLAYBOOK...');
    let editingSetupId = null;

    function refreshPlaybook() {
        console.log('--- Refreshing Playbook ---');
        
        const categoryFilter = document.getElementById('playbook-category-filter')?.value || 'all';
        const ratingFilter = parseInt(document.getElementById('playbook-rating-filter')?.value || 'all');
        const sort = document.getElementById('playbook-sort')?.value || 'rating-desc';

        let setups = DB.setups || [];
        
        // Calcular estadísticas por setup
        const setupStats = calculateSetupStatistics();
        
        // Actualizar métricas generales
        updatePlaybookMetrics(setups, setupStats);
        
        // Filtrar
        setups = setups.filter(setup => {
            if (categoryFilter !== 'all' && setup.category !== categoryFilter) return false;
            if (!isNaN(ratingFilter) && setup.rating < ratingFilter) return false;
            return true;
        });

        // Ordenar
        setups.sort((a, b) => {
            switch (sort) {
                case 'rating-desc': return (b.rating || 0) - (a.rating || 0);
                case 'rating-asc': return (a.rating || 0) - (b.rating || 0);
                case 'recent': return new Date(b.createdAt || 0) - new Date(a.createdAt || 0);
                case 'oldest': return new Date(a.createdAt || 0) - new Date(b.createdAt || 0);
                case 'name': return (a.name || '').localeCompare(b.name || '');
                case 'winrate': return (setupStats[b.id]?.winrate || 0) - (setupStats[a.id]?.winrate || 0);
                case 'trades': return (setupStats[b.id]?.totalTrades || 0) - (setupStats[a.id]?.totalTrades || 0);
                default: return 0;
            }
        });

        const container = document.getElementById('playbook-container');
        if (!container) {
            console.error('❌ playbook-container no encontrado');
            return;
        }

        if (setups.length === 0) {
            container.innerHTML = `
                <div class="col-span-full text-center py-12">
                    <i class="fas fa-book text-6xl text-text-secondary mb-4"></i>
                    <p class="text-text-secondary">No hay setups creados todavía</p>
                    <button id="add-setup-empty-btn" class="primary mt-4">
                        <i class="fas fa-plus mr-2"></i>Crear Primer Setup
                    </button>
                </div>
            `;
            // Re-attach event listener para el botón del empty state
            document.getElementById('add-setup-empty-btn')?.addEventListener('click', () => {
                console.log('✅ Botón "Crear Primer Setup" clickeado');
                showSetupForm();
            });
            return;
        }

        container.innerHTML = setups.map(setup => {
            const stars = '⭐'.repeat(setup.rating || 0);
            const stats = setupStats[setup.id] || {};
            const hasStats = stats.totalTrades > 0;
            
            // Asegurar que tags siempre sea un array
            const tags = Array.isArray(setup.tags) ? setup.tags : [];
            
            const gradeIcons = {
                'P': '🏆',
                'A+': '💎',
                'A': '✨',
                'B+': '⭐',
                'B': '👍'
            };
            const gradeIcon = setup.grade ? gradeIcons[setup.grade] : '';
            
            return `
                <div class="metric-card p-6 hover:shadow-xl transition-shadow">
                    <div class="flex justify-between items-start mb-3">
                        <div class="flex-1">
                            <div class="flex items-center gap-2 mb-2">
                                <h3 class="text-lg font-bold">${setup.name}</h3>
                                ${setup.grade ? `<span class="text-xl" title="Grado ${setup.grade}">${gradeIcon}</span>` : ''}
                            </div>
                            <div class="flex flex-wrap gap-2">
                                ${setup.category ? `<span class="px-2 py-1 rounded text-xs bg-primary bg-opacity-20 text-primary">${setup.category}</span>` : ''}
                                ${setup.grade ? `<span class="px-2 py-1 rounded text-xs bg-yellow-500 bg-opacity-20 text-yellow-500">${setup.grade}</span>` : ''}
                            </div>
                        </div>
                        <div class="text-right">
                            <p class="text-2xl">${stars}</p>
                            <p class="text-xs text-text-secondary">${setup.rating}/5</p>
                        </div>
                    </div>

                    ${tags && tags.length > 0 ? `
                        <div class="flex flex-wrap gap-1 mb-3">
                            ${tags.map(tag => `
                                <span class="px-2 py-0.5 bg-surface rounded-full text-xs text-text-secondary border border-border">
                                    ${tag}
                                </span>
                            `).join('')}
                        </div>
                    ` : ''}

                    ${hasStats ? `
                        <div class="bg-surface rounded-lg p-3 mb-4 border border-border">
                            <p class="text-xs text-text-secondary mb-2">📊 Estadísticas de Trading</p>
                            <div class="grid grid-cols-2 gap-2 text-sm">
                                <div>
                                    <p class="text-text-secondary text-xs">Trades</p>
                                    <p class="font-bold">${stats.totalTrades}</p>
                                </div>
                                <div>
                                    <p class="text-text-secondary text-xs">Winrate</p>
                                    <p class="font-bold ${stats.winrate >= 50 ? 'text-success' : 'text-danger'}">${stats.winrate.toFixed(1)}%</p>
                                </div>
                                <div>
                                    <p class="text-text-secondary text-xs">Profit Factor</p>
                                    <p class="font-bold ${stats.profitFactor >= 1.5 ? 'text-success' : stats.profitFactor >= 1 ? 'text-yellow' : 'text-danger'}">${stats.profitFactor.toFixed(2)}</p>
                                </div>
                                <div>
                                    <p class="text-text-secondary text-xs">P/L Total</p>
                                    <p class="font-bold ${stats.totalPL >= 0 ? 'text-success' : 'text-danger'}">${formatCurrency(stats.totalPL)}</p>
                                </div>
                            </div>
                            <p class="text-xs text-text-secondary mt-2">Última vez: ${stats.lastUsed || 'Nunca'}</p>
                        </div>
                    ` : `
                        <div class="bg-surface rounded-lg p-3 mb-4 border border-border text-center">
                            <p class="text-xs text-text-secondary">📊 Sin datos de trading</p>
                            <p class="text-xs text-text-secondary mt-1">Vincula operaciones a este setup</p>
                        </div>
                    `}

                    ${setup.description ? `<p class="text-sm text-text-secondary mb-4 line-clamp-3">${setup.description.substring(0, 150)}${setup.description.length > 150 ? '...' : ''}</p>` : ''}

                    ${setup.images && setup.images.length > 0 ? `
                        <div class="grid ${setup.images.length === 1 ? 'grid-cols-1' : 'grid-cols-2'} gap-3 mb-4" id="setup-images-${setup.id}">
                            ${setup.images.slice(0, 4).map((img, idx) => `
                                <img src="${img}" alt="Setup example" class="w-full h-48 object-cover rounded-lg border-2 border-border cursor-pointer hover:border-primary hover:shadow-lg transition-all setup-image" data-setup-id="${setup.id}" data-img-index="${idx}">
                            `).join('')}
                        </div>
                    ` : ''}

                    <div class="flex gap-2 mt-4">
                        <button onclick="openSetupDetails('${setup.id}')" class="flex-1 py-2 bg-primary text-background rounded hover:bg-primary-dark transition-colors">
                            <i class="fas fa-eye mr-2"></i>Ver Detalles
                        </button>
                        <button onclick="editSetup('${setup.id}')" class="px-4 py-2 bg-surface border border-border rounded hover:bg-surface-light transition-colors">
                            <i class="fas fa-edit"></i>
                        </button>
                        <button onclick="deleteSetup('${setup.id}')" class="px-4 py-2 bg-danger bg-opacity-20 text-danger rounded hover:bg-opacity-30 transition-colors">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </div>
            `;
        }).join('');
        
        // Renderizar tabla de performance
        renderSetupPerformanceTable(setupStats);
        
        // Agregar event listeners a las imágenes después de renderizar
        setTimeout(() => {
            document.querySelectorAll('.setup-image').forEach(img => {
                img.addEventListener('click', function() {
                    const setupId = this.dataset.setupId;
                    const imgIndex = parseInt(this.dataset.imgIndex);
                    const setup = DB.setups.find(s => s.id === setupId);
                    
                    if (setup && setup.images) {
                        console.log('🖼️ [Playbook] Abriendo modal con', setup.images.length, 'imágenes, índice', imgIndex);
                        platformOpenImageModal(setup.images, imgIndex);
                    }
                });
            });
        }, 100);
    }

    // Calcular estadísticas por setup basado en operaciones
    function calculateSetupStatistics() {
        const stats = {};
        const operations = DB.operations || [];
        
        operations.forEach(op => {
            const setupId = op.setupId || op.setupUsed; // Compatibilidad
            if (!setupId) return;
            
            if (!stats[setupId]) {
                stats[setupId] = {
                    totalTrades: 0,
                    wins: 0,
                    losses: 0,
                    breakeven: 0,
                    totalPL: 0,
                    totalWinPL: 0,
                    totalLossPL: 0,
                    winrate: 0,
                    profitFactor: 0,
                    avgWin: 0,
                    avgLoss: 0,
                    lastUsed: null
                };
            }
            
            const s = stats[setupId];
            s.totalTrades++;
            
            const pl = convertCurrency(op.pl || 0, op.currency, DB.settings.defaultCurrency);
            s.totalPL += pl;
            
            if (op.result === 'win') {
                s.wins++;
                s.totalWinPL += pl;
            } else if (op.result === 'loss') {
                s.losses++;
                s.totalLossPL += Math.abs(pl);
            } else {
                s.breakeven++;
            }
            
            // Última vez usado
            if (!s.lastUsed || new Date(op.date) > new Date(s.lastUsed)) {
                s.lastUsed = op.date;
            }
        });
        
        // Calcular métricas finales
        Object.keys(stats).forEach(setupId => {
            const s = stats[setupId];
            s.winrate = s.totalTrades > 0 ? (s.wins / s.totalTrades) * 100 : 0;
            s.profitFactor = s.totalLossPL > 0 ? s.totalWinPL / s.totalLossPL : (s.totalWinPL > 0 ? 999 : 0);
            s.avgWin = s.wins > 0 ? s.totalWinPL / s.wins : 0;
            s.avgLoss = s.losses > 0 ? s.totalLossPL / s.losses : 0;
            
            // Formatear última vez
            if (s.lastUsed) {
                const lastDate = new Date(s.lastUsed);
                const today = new Date();
                const diffDays = Math.floor((today - lastDate) / (1000 * 60 * 60 * 24));
                
                if (diffDays === 0) s.lastUsed = 'Hoy';
                else if (diffDays === 1) s.lastUsed = 'Ayer';
                else if (diffDays < 7) s.lastUsed = `Hace ${diffDays} días`;
                else if (diffDays < 30) s.lastUsed = `Hace ${Math.floor(diffDays / 7)} semanas`;
                else s.lastUsed = lastDate.toLocaleDateString();
            }
        });
        
        return stats;
    }

    // Actualizar métricas del playbook
    function updatePlaybookMetrics(setups, setupStats) {
        // Total setups
        const totalEl = document.getElementById('playbook-total-setups');
        if (totalEl) totalEl.textContent = setups.length;
        
        // Distribución por categoría
        const byCatEl = document.getElementById('playbook-by-category');
        if (byCatEl && setups.length > 0) {
            const categories = {};
            setups.forEach(s => {
                categories[s.category] = (categories[s.category] || 0) + 1;
            });
            const catText = Object.entries(categories).slice(0, 2).map(([cat, count]) => `${cat}: ${count}`).join(', ');
            byCatEl.textContent = catText;
        }
        
        // Rating promedio
        const avgRating = setups.length > 0 ? setups.reduce((sum, s) => sum + (s.rating || 0), 0) / setups.length : 0;
        const avgRatingEl = document.getElementById('playbook-avg-rating');
        if (avgRatingEl) avgRatingEl.textContent = avgRating.toFixed(1);
        
        const starsEl = document.getElementById('playbook-rating-stars');
        if (starsEl) {
            const fullStars = Math.floor(avgRating);
            const halfStar = avgRating % 1 >= 0.5 ? 1 : 0;
            const emptyStars = 5 - fullStars - halfStar;
            starsEl.textContent = '★'.repeat(fullStars) + (halfStar ? '½' : '') + '☆'.repeat(emptyStars);
        }
        
        // Setup más usado
        let mostUsed = null;
        let maxTrades = 0;
        Object.entries(setupStats).forEach(([id, stats]) => {
            if (stats.totalTrades > maxTrades) {
                maxTrades = stats.totalTrades;
                mostUsed = setups.find(s => s.id === id);
            }
        });
        
        const mostUsedNameEl = document.getElementById('playbook-most-used-name');
        const mostUsedCountEl = document.getElementById('playbook-most-used-count');
        if (mostUsedNameEl) mostUsedNameEl.textContent = mostUsed?.name || '-';
        if (mostUsedCountEl) mostUsedCountEl.textContent = maxTrades > 0 ? `${maxTrades} veces` : '0 veces';
        
        // Mejor winrate
        let bestWR = null;
        let maxWR = 0;
        Object.entries(setupStats).forEach(([id, stats]) => {
            if (stats.totalTrades >= 5 && stats.winrate > maxWR) { // Mínimo 5 trades
                maxWR = stats.winrate;
                bestWR = setups.find(s => s.id === id);
            }
        });
        
        const bestWRNameEl = document.getElementById('playbook-best-wr-name');
        const bestWRValueEl = document.getElementById('playbook-best-wr-value');
        if (bestWRNameEl) bestWRNameEl.textContent = bestWR?.name || '-';
        if (bestWRValueEl) bestWRValueEl.textContent = maxWR > 0 ? `${maxWR.toFixed(1)}%` : '0%';
        
        // Mostrar/ocultar sección de performance
        const perfSection = document.getElementById('playbook-performance-section');
        if (perfSection) {
            perfSection.style.display = Object.keys(setupStats).length > 0 ? 'block' : 'none';
        }
    }

    // Renderizar tabla de performance
    function renderSetupPerformanceTable(setupStats) {
        const tbody = document.getElementById('playbook-performance-tbody');
        if (!tbody) return;
        
        const setups = DB.setups || [];
        const rows = [];
        
        setups.forEach(setup => {
            const stats = setupStats[setup.id];
            if (!stats || stats.totalTrades === 0) return;
            
            rows.push({
                name: setup.name,
                trades: stats.totalTrades,
                winrate: stats.winrate,
                avgWin: stats.avgWin,
                avgLoss: stats.avgLoss,
                totalPL: stats.totalPL,
                profitFactor: stats.profitFactor,
                lastUsed: stats.lastUsed
            });
        });
        
        // Ordenar por winrate descendente
        rows.sort((a, b) => b.winrate - a.winrate);
        
        if (rows.length === 0) {
            tbody.innerHTML = '<tr><td colspan="8" class="text-center p-4 text-text-secondary">No hay datos de trading</td></tr>';
            return;
        }
        
        tbody.innerHTML = rows.map(row => `
            <tr class="border-b border-border hover:bg-surface transition-colors">
                <td class="p-2 font-medium">${row.name}</td>
                <td class="text-center p-2">${row.trades}</td>
                <td class="text-center p-2">
                    <span class="${row.winrate >= 60 ? 'text-success' : row.winrate >= 50 ? 'text-yellow' : 'text-danger'} font-bold">
                        ${row.winrate.toFixed(1)}%
                    </span>
                </td>
                <td class="text-center p-2 text-success">${formatCurrency(row.avgWin)}</td>
                <td class="text-center p-2 text-danger">${formatCurrency(row.avgLoss)}</td>
                <td class="text-center p-2 ${row.totalPL >= 0 ? 'text-success' : 'text-danger'} font-bold">${formatCurrency(row.totalPL)}</td>
                <td class="text-center p-2">
                    <span class="${row.profitFactor >= 2 ? 'text-success' : row.profitFactor >= 1 ? 'text-yellow' : 'text-danger'}">
                        ${row.profitFactor.toFixed(2)}
                    </span>
                </td>
                <td class="text-center p-2 text-sm text-text-secondary">${row.lastUsed}</td>
            </tr>
        `).join('');
    }

    // Toggle tabla de performance
    document.getElementById('toggle-performance-table')?.addEventListener('click', function() {
        const table = document.getElementById('playbook-performance-table-container');
        if (table) {
            const isHidden = table.style.display === 'none';
            table.style.display = isHidden ? 'block' : 'none';
            this.innerHTML = isHidden 
                ? '<i class="fas fa-chart-bar mr-1"></i>Ocultar Estadísticas' 
                : '<i class="fas fa-chart-bar mr-1"></i>Ver Estadísticas';
        }
    });

    // Inicializar base de datos de setups
    if (typeof DB !== 'undefined' && DB) {
        if (!DB.setups) {
            DB.setups = [];
            if (typeof saveDB === 'function') saveDB();
        }
    }

    // Función para actualizar todos los dropdowns de setup
    function updateAllSetupDropdowns() {
        console.log('🔄 Actualizando todos los dropdowns de setup...');
        console.log('📋 DB.setups disponibles:', DB.setups ? DB.setups.length : 0, DB.setups);
        
        // Actualizar dropdown del formulario de operaciones
        const setupSelect = document.getElementById('op-setup');
        if (setupSelect) {
            const currentValue = setupSelect.value;
            setupSelect.innerHTML = '<option value="">Ninguno</option>';
            
            if (DB.setups && DB.setups.length > 0) {
                DB.setups.forEach(setup => {
                    const option = document.createElement('option');
                    option.value = setup.id;
                    option.textContent = setup.name;
                    setupSelect.appendChild(option);
                });
                
                // Restaurar valor seleccionado si existe
                if (currentValue && DB.setups.find(s => s.id === currentValue)) {
                    setupSelect.value = currentValue;
                }
            }
            
            console.log(`✅ Dropdown actualizado con ${DB.setups.length} setups`);
        } else {
            console.warn('⚠️ Dropdown op-setup no encontrado');
        }
    }
    
    // Hacer la función global para uso en otras partes
    window.updateAllSetupDropdowns = updateAllSetupDropdowns;

    // Inicializar Rich Text Editor para setup
    let setupRichEditor = null;
    const setupEditorContainer = document.getElementById('setup-rich-editor-container');
    if (setupEditorContainer) {
        setupRichEditor = new RichTextEditor(setupEditorContainer, {
            placeholder: 'Describe las condiciones de entrada, stop loss, take profit, contexto de mercado, etc.',
            minHeight: '200px',
            maxHeight: '400px',
            showVoiceRecorder: true,
            showDownload: true,
            showCharCount: true
        });
    }

    // Event listeners para formulario
    const setupModal = document.getElementById('setup-modal');
    const addSetupBtn = document.getElementById('add-setup-btn');
    const closeModalBtn = document.getElementById('close-setup-modal');
    const saveSetupBtn = document.getElementById('save-setup-btn');
    const cancelSetupBtn = document.getElementById('cancel-setup-btn');

    function showSetupForm() {
        console.log('🔹 showSetupForm() llamada');
        console.log('🔹 setupModal:', setupModal);
        if (setupModal) {
            setupModal.style.display = 'flex';
            console.log('✅ Modal mostrado con display flex');
        } else {
            console.error('❌ setupModal no encontrado');
        }
    }

    function hideSetupForm() {
        if (setupModal) {
            setupModal.style.display = 'none';
        }
        // Limpiar formulario
        document.getElementById('setup-name').value = '';
        document.getElementById('setup-category').value = '';
        document.getElementById('setup-grade').value = '';
        document.getElementById('setup-description').value = '';
        document.getElementById('setup-rating').value = '0';
        document.getElementById('setup-tag-input').value = '';
        currentTags = [];
        renderTags();
        
        document.querySelectorAll('#setup-rating-selector .star').forEach(star => {
            star.style.opacity = '0.3';
        });
        
        const previewEl = document.getElementById('setup-images-preview');
        if (previewEl) previewEl.innerHTML = '';
        
        // Limpiar input de archivos
        const imagesInput = document.getElementById('setup-images');
        if (imagesInput) imagesInput.value = '';
        
        editingSetupId = null;
        const titleEl = document.getElementById('setup-modal-title') || document.getElementById('setup-form-title');
        if (titleEl) titleEl.textContent = 'Nuevo Setup';
    }

    addSetupBtn?.addEventListener('click', () => {
        console.log('✅ Botón "Nuevo Setup" clickeado');
        showSetupForm();
    });
    
    closeModalBtn?.addEventListener('click', () => {
        console.log('✅ Botón cerrar modal clickeado');
        hideSetupForm();
    });
    
    cancelSetupBtn?.addEventListener('click', () => {
        console.log('✅ Botón cancelar clickeado');
        hideSetupForm();
    });
    
    // Cerrar modal al click fuera
    setupModal?.addEventListener('click', function(e) {
        if (e.target === setupModal) {
            hideSetupForm();
        }
    });

    // Sistema de estrellas
    document.querySelectorAll('#setup-rating-selector .star').forEach((star, idx) => {
        star.addEventListener('click', function() {
            const rating = idx + 1;
            document.getElementById('setup-rating').value = rating;
            const valueEl = document.getElementById('setup-rating-value');
            if (valueEl) valueEl.textContent = `${rating} estrella${rating !== 1 ? 's' : ''}`;
            
            document.querySelectorAll('#setup-rating-selector .star').forEach((s, i) => {
                s.style.opacity = i < rating ? '1' : '0.3';
            });
        });
    });

    // Preview de imágenes (máximo 4)
    document.getElementById('setup-images')?.addEventListener('change', function(e) {
        const files = Array.from(e.target.files).slice(0, 4);
        const container = document.getElementById('setup-images-preview');
        if (!container) return;
        container.innerHTML = '';

        if (files.length > 4) {
            alert('Solo puedes subir hasta 4 imágenes');
        }

        files.forEach((file, idx) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                const div = document.createElement('div');
                div.className = 'relative';
                div.innerHTML = `
                    <img src="${e.target.result}" class="w-full h-40 object-cover rounded-lg border-2 border-border">
                    <button type="button" onclick="this.parentElement.remove()" class="absolute top-2 right-2 bg-danger text-white rounded-full w-8 h-8 flex items-center justify-center hover:bg-opacity-80 shadow-lg">
                        <i class="fas fa-times"></i>
                    </button>
                `;
                container.appendChild(div);
            };
            reader.readAsDataURL(file);
        });
    });

    // Guardar setup
    saveSetupBtn?.addEventListener('click', async function() {
        console.log('💾 Botón Guardar Setup clickeado');
        
        const name = document.getElementById('setup-name').value.trim();
        const category = document.getElementById('setup-category').value;
        const grade = document.getElementById('setup-grade').value;
        const rating = parseInt(document.getElementById('setup-rating').value);
        const description = document.getElementById('setup-description').value.trim();

        console.log('📝 Datos del formulario:', { name, category, grade, rating, description, tags: currentTags });

        if (!name) {
            alert('Por favor ingresa un nombre para el setup');
            return;
        }

        if (!category) {
            alert('Por favor selecciona una categoría');
            return;
        }

        if (!grade) {
            alert('Por favor selecciona un grado de calidad');
            return;
        }

        if (rating === 0 || isNaN(rating)) {
            alert('Por favor califica el setup (1-5 estrellas)');
            return;
        }

        // Convertir imágenes a base64
        const imageFiles = document.getElementById('setup-images').files;
        const images = [];
        for (let file of imageFiles) {
            const base64 = await fileToBase64(file);
            images.push(base64);
        }

        console.log(`📸 ${images.length} imágenes procesadas`);

        const setup = {
            id: editingSetupId || Date.now().toString(),
            name,
            category,
            grade,
            rating,
            description,
            tags: [...currentTags],
            images,
            createdAt: editingSetupId ? (DB.setups.find(s => s.id === editingSetupId)?.createdAt || new Date().toISOString()) : new Date().toISOString(),
            updatedAt: new Date().toISOString()
        };

        console.log('📦 Setup creado:', setup);

        if (editingSetupId) {
            const idx = DB.setups.findIndex(s => s.id === editingSetupId);
            DB.setups[idx] = setup;
            console.log('✏️ Setup actualizado en índice:', idx);
            await dexieDB.setups.put(setup);
            await saveSetupToSupabase(setup);
        } else {
            DB.setups.push(setup);
            console.log('➕ Setup agregado. Total setups:', DB.setups.length);
            await dexieDB.setups.add(setup);
            await saveSetupToSupabase(setup);
        }

        console.log('💾 Setup guardado en BD');
        
        // ACTUALIZAR TODOS LOS DROPDOWNS DE SETUP
        updateAllSetupDropdowns();
        
        hideSetupForm();
        refreshPlaybook();
        showNotification(editingSetupId ? 'Setup actualizado' : 'Setup creado exitosamente', 'success');
    });

    function fileToBase64(file) {
        return new Promise((resolve) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.readAsDataURL(file);
        });
    }

    window.editSetup = function(id) {
        const setup = DB.setups.find(s => s.id === id);
        if (!setup) return;

        editingSetupId = id;
        document.getElementById('setup-modal-title').textContent = 'Editar Setup';
        document.getElementById('setup-name').value = setup.name || '';
        document.getElementById('setup-category').value = setup.category || '';
        document.getElementById('setup-grade').value = setup.grade || '';
        document.getElementById('setup-description').value = setup.description || '';
        
        // Cargar tags - asegurar que sea un array
        currentTags = Array.isArray(setup.tags) ? setup.tags : [];
        renderTags();

        // Set rating
        const rating = setup.rating || 0;
        document.getElementById('setup-rating').value = rating;
        
        document.querySelectorAll('#setup-rating-selector .star').forEach((s, idx) => {
            s.style.opacity = idx < rating ? '1' : '0.3';
        });

        // Show images
        const container = document.getElementById('setup-images-preview');
        if (container) {
            container.innerHTML = setup.images?.slice(0, 4).map(img => `
                <div class="relative">
                    <img src="${img}" class="w-full h-40 object-cover rounded-lg border-2 border-border">
                </div>
            `).join('') || '';
        }

        showSetupForm();
    };

    window.deleteSetup = async function(id) {
        if (!confirm('¿Estás seguro de eliminar este setup? Esta acción no se puede deshacer.')) return;
        
        try {
            DB.setups = DB.setups.filter(s => s.id !== id);
            await dexieDB.setups.delete(id);
            await deleteSetupFromSupabase(id);
            refreshPlaybook();
            showNotification('Setup eliminado', 'info');
        } catch (error) {
            console.error('Error eliminando setup:', error);
            showNotification('Error al eliminar setup', 'error');
        }
    };
    
    // ========================================
    // MODAL DE DETALLES DEL SETUP (PANTALLA COMPLETA)
    // ========================================
    let setupDetailsRichEditor = null;
    let currentSetupDetails = null;
    
    window.openSetupDetails = async function(setupId) {
        console.log('📖 Abriendo detalles del setup:', setupId);
        
        const setup = DB.setups.find(s => s.id === setupId);
        if (!setup) {
            showNotification('Setup no encontrado', 'error');
            return;
        }
        
        currentSetupDetails = setup;
        
        // Mostrar modal
        const modal = document.getElementById('setup-details-modal');
        modal.style.display = 'block';
        document.body.style.overflow = 'hidden';
        
        // Cargar información básica
        document.getElementById('setup-details-title').textContent = setup.name;
        document.getElementById('setup-details-subtitle').textContent = setup.category || 'Sin categoría';
        document.getElementById('setup-details-rating').textContent = '⭐'.repeat(setup.rating || 0);
        
        const gradeIcons = {
            'P': '🏆',
            'A+': '💎',
            'A': '✨',
            'B+': '⭐',
            'B': '👍'
        };
        document.getElementById('setup-details-grade').textContent = setup.grade ? gradeIcons[setup.grade] : '';
        document.getElementById('setup-details-description').textContent = setup.description || 'Sin descripción';
        
        // Calcular estadísticas
        const ops = DB.operations.filter(op => op.setupId === setupId || op.setup_id === setupId);
        const wins = ops.filter(op => op.result === 'win');
        const losses = ops.filter(op => op.result === 'loss');
        const totalPL = ops.reduce((sum, op) => sum + (parseFloat(op.pl) || 0), 0);
        const totalWins = wins.reduce((sum, op) => sum + (parseFloat(op.pl) || 0), 0);
        const totalLosses = Math.abs(losses.reduce((sum, op) => sum + (parseFloat(op.pl) || 0), 0));
        const winrate = ops.length > 0 ? (wins.length / ops.length) * 100 : 0;
        const profitFactor = totalLosses > 0 ? totalWins / totalLosses : totalWins > 0 ? Infinity : 0;
        const avgWin = wins.length > 0 ? totalWins / wins.length : 0;
        const avgLoss = losses.length > 0 ? totalLosses / losses.length : 0;
        const expectancy = ops.length > 0 ? (winrate / 100 * avgWin) - ((100 - winrate) / 100 * avgLoss) : 0;
        
        // Actualizar KPIs
        document.getElementById('detail-total-trades').textContent = ops.length;
        document.getElementById('detail-win-rate').textContent = winrate.toFixed(1) + '%';
        document.getElementById('detail-profit-factor').textContent = profitFactor === Infinity ? '∞' : profitFactor.toFixed(2);
        document.getElementById('detail-total-pl').textContent = formatCurrency(totalPL);
        document.getElementById('detail-avg-win').textContent = formatCurrency(avgWin);
        document.getElementById('detail-avg-loss').textContent = formatCurrency(avgLoss);
        document.getElementById('detail-expectancy').textContent = formatCurrency(expectancy);
        document.getElementById('detail-last-used').textContent = ops.length > 0 ? ops[ops.length - 1].date : 'Nunca';
        document.getElementById('detail-category').textContent = setup.category || '-';
        
        // Tags
        const tagsContainer = document.getElementById('detail-tags');
        tagsContainer.innerHTML = setup.tags && setup.tags.length > 0 
            ? setup.tags.map(tag => `<span class="px-2 py-1 bg-surface rounded text-xs">${tag}</span>`).join('')
            : '<span class="text-xs text-text-secondary">Sin tags</span>';
        
        // Galería de imágenes
        const imagesGrid = document.getElementById('setup-details-images-grid');
        if (setup.images && setup.images.length > 0) {
            imagesGrid.innerHTML = setup.images.map((img, idx) => `
                <div class="relative group">
                    <img src="${img}" alt="Setup image ${idx + 1}" 
                         class="w-full h-48 object-cover rounded-lg border-2 border-border cursor-pointer hover:border-primary transition-all">
                    <button onclick="removeSetupImage(${idx})" 
                            class="absolute top-2 right-2 bg-danger text-white p-2 rounded-full opacity-0 group-hover:opacity-100 transition-opacity">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            `).join('');
        } else {
            imagesGrid.innerHTML = '<p class="col-span-2 text-center text-text-secondary italic">No hay imágenes agregadas</p>';
        }
        
        // Cargar notas desde Notebook
        await loadSetupNotesFromNotebook(setupId);
        
        // Renderizar gráficas
        renderSetupDetailCharts(ops, wins, losses, totalPL, winrate, profitFactor);
    };
    
    async function loadSetupNotesFromNotebook(setupId) {
        try {
            // Buscar carpeta Playbook
            const allFolders = await dexieDB.notebookFolders.toArray();
            const playbookFolder = allFolders.find(f => f.name === 'Playbook');
            
            if (!playbookFolder) {
                console.log('📁 Carpeta Playbook no encontrada');
                return;
            }
            
            // Buscar nota del setup
            const allNotes = await dexieDB.notebookNotes
                .where('folder_id')
                .equals(playbookFolder.id)
                .toArray();
            
            const setupNote = allNotes.find(n => 
                n.metadata && 
                n.metadata.setupId === setupId &&
                n.metadata.source === 'playbook_setup'
            );
            
            const notesContent = document.getElementById('setup-notes-content');
            if (setupNote && setupNote.content) {
                notesContent.innerHTML = setupNote.content;
            } else {
                notesContent.innerHTML = '<p class="text-text-secondary italic">No hay notas escritas aún. Haz clic en "Editar Notas" para comenzar.</p>';
            }
        } catch (error) {
            console.error('❌ Error cargando notas:', error);
        }
    }
    
    function renderSetupDetailCharts(ops, wins, losses, totalPL, winrate, profitFactor) {
        // Destruir charts existentes
        const charts = ['setup-detail-performance-chart', 'setup-detail-expectancy-chart', 'setup-detail-daily-pl-chart'];
        charts.forEach(id => {
            const canvas = document.getElementById(id);
            if (canvas && canvas.chart) {
                canvas.chart.destroy();
            }
        });
        
        // 1. Performance Score (Radar)
        const perfCtx = document.getElementById('setup-detail-performance-chart').getContext('2d');
        const perfChart = new Chart(perfCtx, {
            type: 'radar',
            data: {
                labels: ['Win Rate', 'Profit Factor', 'Avg Win/Loss', 'Consistencia', 'Total Trades'],
                datasets: [{
                    label: 'Performance',
                    data: [
                        winrate,
                        Math.min(profitFactor * 20, 100),
                        Math.min((wins.length > 0 && losses.length > 0 ? (wins.reduce((s, o) => s + parseFloat(o.pl), 0) / wins.length) / (Math.abs(losses.reduce((s, o) => s + parseFloat(o.pl), 0)) / losses.length) * 20 : 0), 100),
                        Math.min(ops.length * 2, 100),
                        Math.min(ops.length * 5, 100)
                    ],
                    backgroundColor: 'rgba(0, 255, 0, 0.2)',
                    borderColor: 'rgb(0, 255, 0)',
                    pointBackgroundColor: 'rgb(0, 255, 0)',
                    pointBorderColor: '#fff',
                    pointHoverBackgroundColor: '#fff',
                    pointHoverBorderColor: 'rgb(0, 255, 0)'
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    r: {
                        beginAtZero: true,
                        max: 100,
                        ticks: { color: 'rgba(255, 255, 255, 0.7)' },
                        grid: { color: 'rgba(255, 255, 255, 0.1)' },
                        pointLabels: { color: 'rgba(255, 255, 255, 0.9)' }
                    }
                },
                plugins: {
                    legend: { display: false }
                }
            }
        });
        document.getElementById('setup-detail-performance-chart').chart = perfChart;
        
        // 2. Expectancy Breakdown (Bar)
        const expectCtx = document.getElementById('setup-detail-expectancy-chart').getContext('2d');
        const avgWin = wins.length > 0 ? wins.reduce((s, o) => s + parseFloat(o.pl), 0) / wins.length : 0;
        const avgLoss = losses.length > 0 ? Math.abs(losses.reduce((s, o) => s + parseFloat(o.pl), 0)) / losses.length : 0;
        
        const expectChart = new Chart(expectCtx, {
            type: 'bar',
            data: {
                labels: ['Avg Win', 'Avg Loss', 'Expectancy'],
                datasets: [{
                    label: 'USD',
                    data: [avgWin, -avgLoss, (winrate / 100 * avgWin) - ((100 - winrate) / 100 * avgLoss)],
                    backgroundColor: [
                        'rgba(0, 255, 0, 0.8)',
                        'rgba(0, 255, 100, 0.8)',
                        'rgba(50, 255, 50, 0.8)'
                    ],
                    borderColor: [
                        'rgb(0, 255, 0)',
                        'rgb(0, 255, 100)',
                        'rgb(50, 255, 50)'
                    ],
                    borderWidth: 2
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            label: (context) => `$${context.parsed.y.toFixed(2)}`
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: {
                            color: 'rgba(255, 255, 255, 0.7)',
                            callback: (value) => '$' + value.toFixed(0)
                        },
                        grid: { color: 'rgba(255, 255, 255, 0.1)' }
                    },
                    x: {
                        ticks: { color: 'rgba(255, 255, 255, 0.9)' },
                        grid: { display: false }
                    }
                }
            }
        });
        document.getElementById('setup-detail-expectancy-chart').chart = expectChart;
        
        // 3. Daily P/L (Line)
        const dailyPL = {};
        ops.forEach(op => {
            const date = op.date;
            dailyPL[date] = (dailyPL[date] || 0) + parseFloat(op.pl);
        });
        
        const sortedDates = Object.keys(dailyPL).sort();
        let cumulative = 0;
        const cumulativeData = sortedDates.map(date => {
            cumulative += dailyPL[date];
            return cumulative;
        });
        
        const dailyCtx = document.getElementById('setup-detail-daily-pl-chart').getContext('2d');
        const dailyChart = new Chart(dailyCtx, {
            type: 'line',
            data: {
                labels: sortedDates,
                datasets: [{
                    label: 'P/L Acumulado',
                    data: cumulativeData,
                    borderColor: 'rgb(0, 255, 0)',
                    backgroundColor: 'rgba(0, 255, 0, 0.1)',
                    fill: true,
                    tension: 0.4
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            label: (context) => `$${context.parsed.y.toFixed(2)}`
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: false,
                        ticks: {
                            color: 'rgba(255, 255, 255, 0.7)',
                            callback: (value) => '$' + value.toFixed(0)
                        },
                        grid: { color: 'rgba(255, 255, 255, 0.1)' }
                    },
                    x: {
                        ticks: { 
                            color: 'rgba(255, 255, 255, 0.9)',
                            maxTicksLimit: 10
                        },
                        grid: { display: false }
                    }
                }
            }
        });
        document.getElementById('setup-detail-daily-pl-chart').chart = dailyChart;
    }
    
    // Cerrar modal
    document.getElementById('close-setup-details-modal')?.addEventListener('click', () => {
        document.getElementById('setup-details-modal').style.display = 'none';
        document.body.style.overflow = '';
        currentSetupDetails = null;
        
        // Destruir editor si existe
        if (setupDetailsRichEditor) {
            setupDetailsRichEditor = null;
        }
    });
    
    // Editar notas
    document.getElementById('setup-notes-edit-btn')?.addEventListener('click', () => {
        document.getElementById('setup-notes-view').classList.add('hidden');
        document.getElementById('setup-notes-edit').classList.remove('hidden');
        
        // Inicializar Rich Text Editor si no existe
        if (!setupDetailsRichEditor) {
            const container = document.getElementById('setup-notes-rich-editor-container');
            if (container && typeof RichTextEditor !== 'undefined') {
                try {
                    setupDetailsRichEditor = new RichTextEditor(container, {
                        placeholder: 'Escribe las notas estratégicas del setup...',
                        minHeight: '500px',
                        maxHeight: '700px',
                        showVoiceRecorder: true,
                        showDownload: true,
                        showCharCount: true
                    });
                    console.log('✅ RichTextEditor inicializado correctamente');
                } catch (error) {
                    console.error('❌ Error inicializando RichTextEditor:', error);
                    showNotification('Error al inicializar editor', 'error');
                    return;
                }
            } else {
                console.error('❌ Container o RichTextEditor no disponible');
                showNotification('Editor no disponible', 'error');
                return;
            }
        }
        
        // Cargar contenido actual
        const currentContent = document.getElementById('setup-notes-content').innerHTML;
        if (setupDetailsRichEditor && !currentContent.includes('No hay notas')) {
            try {
                setupDetailsRichEditor.setContent(currentContent, 'html');
                console.log('✅ Contenido cargado en editor');
            } catch (error) {
                console.error('❌ Error cargando contenido:', error);
            }
        }
    });
    
    // Cancelar edición
    document.getElementById('setup-notes-cancel-btn')?.addEventListener('click', () => {
        document.getElementById('setup-notes-view').classList.remove('hidden');
        document.getElementById('setup-notes-edit').classList.add('hidden');
    });
    
    // Guardar notas
    document.getElementById('setup-notes-save-btn')?.addEventListener('click', async () => {
        if (!currentSetupDetails) {
            showNotification('No hay setup seleccionado', 'error');
            return;
        }
        
        if (!setupDetailsRichEditor) {
            showNotification('Editor no inicializado', 'error');
            return;
        }
        
        const content = setupDetailsRichEditor.getContent('html');
        
        try {
            // Asegurar que userId esté definido - múltiples fuentes
            let userId = window.userId;
            
            if (!userId && window.currentUser) {
                userId = window.currentUser.id;
                window.userId = userId;
            }
            
            if (!userId && window.supabase) {
                const { data: { user } } = await supabase.auth.getUser();
                if (user) {
                    userId = user.id;
                    window.userId = userId;
                }
            }
            
            if (!userId) {
                console.error('❌ No se encontró userId en:', {
                    'window.userId': window.userId,
                    'window.currentUser': window.currentUser,
                    'supabase': window.supabase ? 'disponible' : 'no disponible'
                });
                showNotification('No hay usuario autenticado', 'error');
                return;
            }
            
            console.log('✅ Usuario identificado:', userId);
            
            console.log('✅ Usuario identificado:', userId);
            
            // Buscar o crear carpeta Playbook
            const allFolders = await dexieDB.notebookFolders.toArray();
            let playbookFolder = allFolders.find(f => f.name === 'Playbook' && f.user_id == userId);
            
            if (!playbookFolder) {
                playbookFolder = {
                    id: 'folder_playbook_' + userId + '_' + Date.now(),
                    user_id: userId,
                    name: 'Playbook',
                    icon: '📁',
                    created_at: new Date().toISOString()
                };
                
                console.log('📁 Creando carpeta Playbook:', playbookFolder);
                
                await dexieDB.notebookFolders.add(playbookFolder);
                
                if (window.supabase) {
                    await supabase.from('notebook_folders').insert([playbookFolder]);
                }
                
                if (!DB.notebookFolders) DB.notebookFolders = [];
                DB.notebookFolders.push(playbookFolder);
            } else {
                console.log('✅ Carpeta Playbook encontrada:', playbookFolder.id);
            }
            
            // Buscar nota existente del setup
            const allNotes = await dexieDB.notebookNotes
                .where('folder_id')
                .equals(playbookFolder.id)
                .toArray();
            
            let existingNote = allNotes.find(n => 
                n.metadata && 
                n.metadata.setupId === currentSetupDetails.id &&
                n.metadata.source === 'playbook_setup'
            );
            
            const noteTitle = `📋 ${currentSetupDetails.name} - Notas Estratégicas`;
            
            console.log('🔍 Buscando nota existente. Total notas en carpeta:', allNotes.length);
            
            if (existingNote) {
                // Actualizar nota existente
                console.log('✏️ Actualizando nota existente:', existingNote.id);
                existingNote.title = noteTitle;
                existingNote.content = content;
                existingNote.updated_at = new Date().toISOString();
                
                await dexieDB.notebookNotes.put(existingNote);
                console.log('✅ Nota actualizada en IndexedDB');
                
                if (window.supabase) {
                    await supabase
                        .from('notebook_notes')
                        .update({
                            title: existingNote.title,
                            content: existingNote.content,
                            updated_at: existingNote.updated_at
                        })
                        .eq('id', existingNote.id);
                    console.log('✅ Nota actualizada en Supabase');
                }
                
                // Actualizar en memoria
                if (!DB.notebookNotes) DB.notebookNotes = [];
                const memIndex = DB.notebookNotes.findIndex(n => n.id === existingNote.id);
                if (memIndex >= 0) {
                    DB.notebookNotes[memIndex] = existingNote;
                } else {
                    DB.notebookNotes.push(existingNote);
                }
            } else {
                // Crear nueva nota
                console.log('📝 Creando nueva nota para setup:', currentSetupDetails.id);
                const newNote = {
                    id: 'note_setup_' + currentSetupDetails.id + '_' + Date.now(),
                    user_id: userId,
                    folder_id: playbookFolder.id,
                    title: noteTitle,
                    content: content,
                    created_at: new Date().toISOString(),
                    updated_at: new Date().toISOString(),
                    is_pinned: false,
                    metadata: {
                        setupId: currentSetupDetails.id,
                        source: 'playbook_setup'
                    }
                };
                
                console.log('📋 Datos de la nueva nota:', newNote);
                
                await dexieDB.notebookNotes.add(newNote);
                console.log('✅ Nota creada en IndexedDB');
                
                if (window.supabase) {
                    await supabase.from('notebook_notes').insert([newNote]);
                    console.log('✅ Nota creada en Supabase');
                }
                
                if (!DB.notebookNotes) DB.notebookNotes = [];
                DB.notebookNotes.unshift(newNote);
            }
            
            // Actualizar vista
            console.log('🔄 Actualizando vista de notas');
            document.getElementById('setup-notes-content').innerHTML = content;
            document.getElementById('setup-notes-view').classList.remove('hidden');
            document.getElementById('setup-notes-edit').classList.add('hidden');
            
            // Notificar a Notebook
            if (typeof window.notebookNotesUpdated === 'function') {
                await window.notebookNotesUpdated();
                console.log('✅ Notebook notificado');
            }
            
            showNotification('Notas guardadas correctamente', 'success');
            console.log('✅ Proceso de guardado completado');
            
        } catch (error) {
            console.error('❌ Error guardando notas:', error);
            console.error('Stack trace:', error.stack);
            showNotification('Error al guardar notas: ' + error.message, 'error');
        }
    });
    
    // Ir a Notebook
    document.getElementById('setup-notes-goto-notebook')?.addEventListener('click', async () => {
        try {
            const allFolders = await dexieDB.notebookFolders.toArray();
            const playbookFolder = allFolders.find(f => f.name === 'Playbook');
            
            if (!playbookFolder) {
                showNotification('Guarda las notas primero', 'error');
                return;
            }
            
            // Cerrar modal
            document.getElementById('setup-details-modal').style.display = 'none';
            document.body.style.overflow = '';
            
            // Cambiar a sección Notebook
            if (typeof switchSection === 'function') {
                switchSection('notebook');
            } else {
                document.getElementById('notebook')?.click();
            }
            
            // Seleccionar carpeta Playbook
            setTimeout(async () => {
                if (typeof window.notebookSelectFolder === 'function') {
                    await window.notebookSelectFolder(playbookFolder.id);
                } else {
                    const folderElement = document.querySelector(`[data-folder-id="${playbookFolder.id}"]`);
                    if (folderElement) {
                        folderElement.click();
                    }
                }
            }, 300);
            
        } catch (error) {
            console.error('❌ Error abriendo Notebook:', error);
            showNotification('Error abriendo Notebook', 'error');
        }
    });
    
    // Agregar imágenes
    document.getElementById('setup-add-images-btn')?.addEventListener('click', () => {
        document.getElementById('setup-details-image-input').click();
    });
    
    document.getElementById('setup-details-image-input')?.addEventListener('change', async (e) => {
        const files = Array.from(e.target.files);
        if (files.length === 0 || !currentSetupDetails) return;
        
        try {
            const imagePromises = files.map(file => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });
            });
            
            const newImages = await Promise.all(imagePromises);
            
            if (!currentSetupDetails.images) currentSetupDetails.images = [];
            currentSetupDetails.images.push(...newImages);
            
            // Actualizar en DB
            const setupIndex = DB.setups.findIndex(s => s.id === currentSetupDetails.id);
            if (setupIndex >= 0) {
                DB.setups[setupIndex] = currentSetupDetails;
                await dexieDB.setups.put(currentSetupDetails);
                
                if (window.supabase && window.currentUser) {
                    await supabase
                        .from('setups')
                        .update({ images: currentSetupDetails.images })
                        .eq('id', currentSetupDetails.id)
                        .eq('user_id', window.currentUser.id);
                }
            }
            
            // Actualizar galería
            const imagesGrid = document.getElementById('setup-details-images-grid');
            imagesGrid.innerHTML = currentSetupDetails.images.map((img, idx) => `
                <div class="relative group">
                    <img src="${img}" alt="Setup image ${idx + 1}" 
                         class="w-full h-48 object-cover rounded-lg border-2 border-border cursor-pointer hover:border-primary transition-all">
                    <button onclick="removeSetupImage(${idx})" 
                            class="absolute top-2 right-2 bg-danger text-white p-2 rounded-full opacity-0 group-hover:opacity-100 transition-opacity">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            `).join('');
            
            showNotification(`${newImages.length} imagen(es) agregada(s)`, 'success');
            e.target.value = '';
            
        } catch (error) {
            console.error('❌ Error agregando imágenes:', error);
            showNotification('Error al agregar imágenes', 'error');
        }
    });
    
    // Remover imagen
    window.removeSetupImage = async function(index) {
        if (!currentSetupDetails || !confirm('¿Eliminar esta imagen?')) return;
        
        currentSetupDetails.images.splice(index, 1);
        
        // Actualizar en DB
        const setupIndex = DB.setups.findIndex(s => s.id === currentSetupDetails.id);
        if (setupIndex >= 0) {
            DB.setups[setupIndex] = currentSetupDetails;
            await dexieDB.setups.put(currentSetupDetails);
            
            if (window.supabase && window.currentUser) {
                await supabase
                    .from('setups')
                    .update({ images: currentSetupDetails.images })
                    .eq('id', currentSetupDetails.id)
                    .eq('user_id', window.currentUser.id);
            }
        }
        
        // Actualizar galería
        const imagesGrid = document.getElementById('setup-details-images-grid');
        if (currentSetupDetails.images.length > 0) {
            imagesGrid.innerHTML = currentSetupDetails.images.map((img, idx) => `
                <div class="relative group">
                    <img src="${img}" alt="Setup image ${idx + 1}" 
                         class="w-full h-48 object-cover rounded-lg border-2 border-border cursor-pointer hover:border-primary transition-all">
                    <button onclick="removeSetupImage(${idx})" 
                            class="absolute top-2 right-2 bg-danger text-white p-2 rounded-full opacity-0 group-hover:opacity-100 transition-opacity">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            `).join('');
        } else {
            imagesGrid.innerHTML = '<p class="col-span-2 text-center text-text-secondary italic">No hay imágenes agregadas</p>';
        }
        
        showNotification('Imagen eliminada', 'info');
    };

    // Event listeners
    document.getElementById('playbook-category-filter')?.addEventListener('change', refreshPlaybook);
    document.getElementById('playbook-rating-filter')?.addEventListener('change', refreshPlaybook);
    document.getElementById('playbook-sort')?.addEventListener('change', refreshPlaybook);

    window.refreshPlaybook = refreshPlaybook;

    // Función de notificación simple
    window.showNotification = function(message, type = 'success') {
        const notification = document.createElement('div');
        notification.className = `toast-notification ${type === 'success' ? 'bg-green-900' : 'bg-red-900'} text-white px-4 py-3 rounded shadow-lg`;
        notification.style.cssText = 'position: fixed; bottom: 20px; right: 20px; z-index: 9999; min-width: 250px;';
        notification.innerHTML = `
            <div class="flex items-center gap-2">
                <i class="fas fa-${type === 'success' ? 'check-circle' : 'exclamation-circle'}"></i>
                <span>${message}</span>
            </div>
        `;
        document.body.appendChild(notification);
        setTimeout(() => notification.remove(), 3000);
    };

    // Inicializar vista
    console.log('🔄 Inicializando Playbook...');
    refreshPlaybook();

    // ========================================
    // CATEGORÍAS PERSONALIZADAS
    // ========================================
    const CUSTOM_CATEGORIES_KEY = 'playbook_custom_categories';
    
    function loadCustomCategories() {
        try {
            const saved = localStorage.getItem(CUSTOM_CATEGORIES_KEY);
            return saved ? JSON.parse(saved) : [];
        } catch {
            return [];
        }
    }
    
    function saveCustomCategories(categories) {
        localStorage.setItem(CUSTOM_CATEGORIES_KEY, JSON.stringify(categories));
    }
    
    function populateCategoryDropdown() {
        const dropdown = document.getElementById('setup-category');
        if (!dropdown) return;
        
        const defaultCategories = ['Breakout', 'Reversal', 'Trend Following', 'Scalping', 'News Trading'];
        const customCategories = loadCustomCategories();
        const allCategories = [...defaultCategories, ...customCategories];
        
        dropdown.innerHTML = '<option value="">Seleccionar categoría...</option>';
        allCategories.forEach(cat => {
            dropdown.innerHTML += `<option value="${cat}">${cat}</option>`;
        });
    }
    
    document.getElementById('new-category-btn')?.addEventListener('click', () => {
        const newCategory = prompt('Nombre de la nueva categoría:');
        if (!newCategory || newCategory.trim() === '') return;
        
        const customCategories = loadCustomCategories();
        if (customCategories.includes(newCategory.trim())) {
            alert('Esta categoría ya existe');
            return;
        }
        
        customCategories.push(newCategory.trim());
        saveCustomCategories(customCategories);
        populateCategoryDropdown();
        
        document.getElementById('setup-category').value = newCategory.trim();
        showNotification('Categoría creada exitosamente', 'success');
    });
    
    populateCategoryDropdown();
    
    // ========================================
    // SISTEMA DE TAGS
    // ========================================
    let currentTags = [];
    
    function renderTags() {
        const container = document.getElementById('setup-tags-container');
        if (!container) return;
        
        container.innerHTML = currentTags.map(tag => `
            <span class="px-3 py-1 bg-primary text-background rounded-full text-sm flex items-center gap-2">
                ${tag}
                <button type="button" onclick="removeTag('${tag}')" class="hover:text-danger">
                    <i class="fas fa-times"></i>
                </button>
            </span>
        `).join('') || '<span class="text-text-secondary text-sm">No hay tags agregados</span>';
    }
    
    window.removeTag = function(tag) {
        currentTags = currentTags.filter(t => t !== tag);
        renderTags();
    };
    
    document.getElementById('add-tag-btn')?.addEventListener('click', () => {
        const input = document.getElementById('setup-tag-input');
        const tag = input.value.trim();
        
        if (!tag) return;
        
        if (currentTags.includes(tag)) {
            alert('Este tag ya ha sido agregado');
            return;
        }
        
        currentTags.push(tag);
        renderTags();
        input.value = '';
    });
    
    document.getElementById('setup-tag-input')?.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            document.getElementById('add-tag-btn').click();
        }
    });
    
    // ========================================
    // NAVEGACIÓN DE TABS
    // ========================================
    document.querySelectorAll('.playbook-tab').forEach(tab => {
        tab.addEventListener('click', () => {
            const target = tab.getAttribute('data-target');
            
            // Actualizar tabs activos
            document.querySelectorAll('.playbook-tab').forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
            
            // Mostrar vista correspondiente
            document.querySelectorAll('.playbook-view').forEach(view => {
                view.style.display = 'none';
            });
            document.getElementById(target).style.display = 'block';
            
            // Inicializar vista si es necesario
            if (target === 'playbook-analysis-view') {
                initializeIndividualAnalysisView();
            } else if (target === 'playbook-comparative-view') {
                initializeComparativeView();
            } else if (target === 'playbook-backtest-view') {
                initializeBacktestView();
            } else if (target === 'playbook-management-view') {
                initializeManagementView();
            }
        });
    });
    
    // ========================================
    // VISTA: ANÁLISIS INDIVIDUAL
    // ========================================
    let selectedSetupForAnalysis = null;
    
    // Variables para las 6 gráficas profesionales
    let expectancyBreakdownChart = null;
    let magnitudeDistributionChart = null;
    let consecutiveSequencesChart = null;
    let drawdownRecoveryChart = null;
    let indPerformanceScoreChart = null;
    let indHourlyDistributionChart = null;
    
    function initializeIndividualAnalysisView() {
        console.log('📊 Inicializando vista de Análisis Individual...');
        
        // Poblar selector de setups
        const select = document.getElementById('individual-setup-select');
        if (!select) {
            console.error('❌ Selector individual-setup-select no encontrado');
            return;
        }
        
        // Guardar el valor actual antes de repoblar
        const currentValue = select.value;
        
        select.innerHTML = '<option value="">Seleccionar setup para analizar...</option>';
        
        if (!DB.setups || DB.setups.length === 0) {
            console.warn('⚠️ No hay setups disponibles');
            return;
        }
        
        console.log(`📋 Poblando selector con ${DB.setups.length} setups`);
        DB.setups.forEach(setup => {
            const option = document.createElement('option');
            option.value = setup.id;
            option.textContent = setup.name;
            select.appendChild(option);
        });
        
        // Restaurar valor si existía
        if (currentValue) {
            select.value = currentValue;
        }
        
        // Remover event listeners anteriores
        const newSelect = select.cloneNode(true);
        select.parentNode.replaceChild(newSelect, select);
        
        // Event listener para cambio de setup
        newSelect.addEventListener('change', (e) => {
            console.log('🔄 Evento change detectado');
            const setupId = e.target.value;
            console.log(`📌 Setup ID seleccionado: "${setupId}"`);
            
            if (!setupId) {
                document.getElementById('individual-analysis-results').style.display = 'none';
                return;
            }
            
            analyzeIndividualSetup(setupId);
        });
        
        console.log('✅ Análisis Individual inicializado');
        
        // Si hay un valor, analizar automáticamente
        if (newSelect.value) {
            console.log('🔄 Analizando setup automáticamente:', newSelect.value);
            analyzeIndividualSetup(newSelect.value);
        }
    }
    
    function analyzeIndividualSetup(setupId) {
        console.log(`🔍 Analizando setup: ${setupId}`);
        console.log('📦 DB.operations total:', DB.operations.length);
        console.log('📦 DB.setups:', DB.setups);
        
        const setup = DB.setups.find(s => s.id == setupId);
        if (!setup) {
            console.error('❌ Setup no encontrado');
            return;
        }
        
        console.log('✅ Setup encontrado:', setup);
        selectedSetupForAnalysis = setup;
        
        // Filtrar operaciones de este setup
        const setupOps = DB.operations.filter(op => {
            const match = op.setupId == setupId || op.setupUsed == setupId;
            if (match) {
                console.log('✅ Match encontrado:', op);
            }
            return match;
        });
        
        console.log(`📊 ${setupOps.length} operaciones encontradas para "${setup.name}"`);
        console.log('🔍 Muestra de todas las operaciones (primeras 5):');
        DB.operations.slice(0, 5).forEach(op => {
            console.log(`  - ID: ${op.id}, setupId: ${op.setupId}, setupUsed: ${op.setupUsed}, pnl: ${op.pnl}`);
        });
        
        if (setupOps.length === 0) {
            document.getElementById('individual-analysis-results').style.display = 'none';
            showNotification('Este setup no tiene operaciones ejecutadas', 'warning');
            return;
        }
        
        // Calcular estadísticas
        const stats = calculateSetupStats();
        const setupData = stats[setupId];
        
        console.log('📊 Stats calculados:', stats);
        console.log('📊 SetupData específico:', setupData);
        
        if (!setupData) {
            console.error('❌ No se pudieron calcular estadísticas');
            return;
        }
        
        // Mostrar contenedor de resultados
        document.getElementById('individual-analysis-results').style.display = 'block';
        
        // Actualizar KPIs
        document.getElementById('ind-total-trades').textContent = setupData.totalTrades;
        document.getElementById('ind-win-rate').textContent = `${setupData.winRate.toFixed(1)}%`;
        document.getElementById('ind-profit-factor').textContent = setupData.profitFactor.toFixed(2);
        document.getElementById('ind-expectancy').textContent = `$${setupData.expectancy.toFixed(2)}`;
        
        // Métricas detalladas
        document.getElementById('ind-avg-win').textContent = `$${setupData.avgWin.toFixed(2)}`;
        document.getElementById('ind-avg-loss').textContent = `$${setupData.avgLoss.toFixed(2)}`;
        document.getElementById('ind-perf-score').textContent = `${setupData.performanceScore.toFixed(0)}/100`;
        document.getElementById('ind-consistency').textContent = `${setupData.consistency.toFixed(1)}%`;
        
        console.log(`📊 Consistencia mostrada: ${setupData.consistency.toFixed(1)}%`);
        
        const totalPL = setupOps.reduce((sum, op) => sum + (op.pl || 0), 0);
        document.getElementById('ind-total-pl').textContent = `$${totalPL.toFixed(2)}`;
        document.getElementById('ind-total-pl').className = `text-lg font-bold ${totalPL >= 0 ? 'text-success' : 'text-danger'}`;
        
        document.getElementById('ind-category').textContent = setup.category || '-';
        
        // Crear gráficas profesionales de barras
        createExpectancyBreakdown(setupOps, setupData);
        createMagnitudeDistribution(setupOps);
        createConsecutiveSequences(setupOps);
        createDrawdownRecovery(setupOps);
        createPerformanceScore(setupData);
        createHourlyDistribution(setupOps);
        createIndWeekdayBarChart(setupOps);
        createIndNetDailyPL(setupOps);
        
        console.log('✅ Análisis individual completado');
    }
    
    // ========================================
    // GRÁFICAS PROFESIONALES DE BARRAS
    // ========================================
    
    // 1. EXPECTANCY BREAKDOWN
    function createExpectancyBreakdown(operations, stats) {
        const canvas = document.getElementById('expectancy-breakdown-chart');
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        if (expectancyBreakdownChart) {
            expectancyBreakdownChart.destroy();
        }
        
        const winContribution = (stats.winRate / 100) * stats.avgWin;
        const lossContribution = ((100 - stats.winRate) / 100) * stats.avgLoss;
        const netExpectancy = stats.expectancy;
        const expectancyPerDollar = stats.expectancy;
        
        const dataValues = [winContribution, lossContribution, netExpectancy, expectancyPerDollar];
        const colors = [
            '#39FF14',
            '#ff0000',
            netExpectancy >= 0 ? '#39FF14' : '#ff0000',
            expectancyPerDollar >= 0 ? '#39FF14' : '#ff0000'
        ];
        
        expectancyBreakdownChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: ['Win Contrib', 'Loss Contrib', 'Net Exp', 'Per $1'],
                datasets: [{
                    data: dataValues,
                    backgroundColor: colors,
                    borderWidth: 0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        backgroundColor: '#1a1a1a',
                        titleColor: '#39FF14',
                        bodyColor: '#ccc',
                        borderColor: '#39FF14',
                        borderWidth: 1,
                        callbacks: {
                            label: (context) => `$${context.parsed.y.toFixed(2)}`
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        grid: { color: '#333' },
                        ticks: { 
                            color: '#888',
                            callback: (value) => '$' + value.toFixed(0)
                        }
                    },
                    x: {
                        grid: { display: false },
                        ticks: { color: '#ccc' }
                    }
                }
            }
        });
    }
    
    // 2. WIN/LOSS MAGNITUDE DISTRIBUTION
    function createMagnitudeDistribution(operations) {
        const canvas = document.getElementById('magnitude-distribution-chart');
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        if (magnitudeDistributionChart) {
            magnitudeDistributionChart.destroy();
        }
        
        const wins = operations.filter(op => op.pl > 0);
        const losses = operations.filter(op => op.pl < 0);
        
        const avgWin = wins.length > 0 ? wins.reduce((sum, op) => sum + op.pl, 0) / wins.length : 0;
        const avgLoss = losses.length > 0 ? Math.abs(losses.reduce((sum, op) => sum + op.pl, 0) / losses.length) : 0;
        
        const bigWins = wins.filter(op => op.pl > avgWin * 2).length;
        const mediumWins = wins.filter(op => op.pl >= avgWin * 0.5 && op.pl <= avgWin * 2).length;
        const smallWins = wins.filter(op => op.pl < avgWin * 0.5).length;
        const smallLosses = losses.filter(op => Math.abs(op.pl) < avgLoss * 0.5).length;
        const bigLosses = losses.filter(op => Math.abs(op.pl) >= avgLoss * 0.5).length;
        
        magnitudeDistributionChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: ['Big Wins', 'Med Wins', 'Small Wins', 'Small Loss', 'Big Loss'],
                datasets: [{
                    data: [bigWins, mediumWins, smallWins, smallLosses, bigLosses],
                    backgroundColor: ['#39FF14', '#7CFC00', '#ADFF2F', '#FFA500', '#ff0000'],
                    borderWidth: 0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        backgroundColor: '#1a1a1a',
                        titleColor: '#39FF14',
                        bodyColor: '#ccc',
                        borderColor: '#39FF14',
                        borderWidth: 1,
                        callbacks: {
                            title: (context) => {
                                return `Rango: ${context[0].label}`;
                            },
                            label: (context) => {
                                const total = operations.length;
                                const pct = total > 0 ? ((context.parsed.y / total) * 100).toFixed(1) : 0;
                                const isWin = context.dataIndex < 4;
                                return [
                                    `${context.parsed.y} trades (${pct}%)`,
                                    isWin ? '✅ Ganancias en este rango' : '❌ Pérdidas en este rango',
                                    'Idealmente: Wins grandes y Losses pequeñas'
                                ];
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        grid: { color: '#333' },
                        ticks: { 
                            color: '#888',
                            stepSize: 1
                        }
                    },
                    x: {
                        grid: { display: false },
                        ticks: { color: '#ccc' }
                    }
                }
            }
        });
    }
    
    // 3. CONSECUTIVE TRADE SEQUENCES
    function createConsecutiveSequences(operations) {
        const canvas = document.getElementById('consecutive-sequences-chart');
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        if (consecutiveSequencesChart) {
            consecutiveSequencesChart.destroy();
        }
        
        // Ordenar operaciones por fecha
        const sortedOps = [...operations].sort((a, b) => {
            const dateA = new Date(a.entry_time || a.open_time);
            const dateB = new Date(b.entry_time || b.open_time);
            return dateA - dateB;
        });
        
        const sequences = {
            'after1Win': [],
            'after2Wins': [],
            'after1Loss': [],
            'after2Losses': [],
            'after3Losses': []
        };
        
        for (let i = 1; i < sortedOps.length; i++) {
            const current = sortedOps[i];
            const prev1 = sortedOps[i - 1];
            const prev2 = i >= 2 ? sortedOps[i - 2] : null;
            const prev3 = i >= 3 ? sortedOps[i - 3] : null;
            
            // After 1 Win
            if (prev1.pl > 0) {
                sequences.after1Win.push(current.pl);
            }
            
            // After 2 Wins
            if (prev1.pl > 0 && prev2 && prev2.pl > 0) {
                sequences.after2Wins.push(current.pl);
            }
            
            // After 1 Loss
            if (prev1.pl < 0) {
                sequences.after1Loss.push(current.pl);
            }
            
            // After 2 Losses
            if (prev1.pl < 0 && prev2 && prev2.pl < 0) {
                sequences.after2Losses.push(current.pl);
            }
            
            // After 3+ Losses
            if (prev1.pl < 0 && prev2 && prev2.pl < 0 && prev3 && prev3.pl < 0) {
                sequences.after3Losses.push(current.pl);
            }
        }
        
        const calcAvg = (arr) => arr.length > 0 ? arr.reduce((sum, v) => sum + v, 0) / arr.length : 0;
        
        const avgValues = [
            calcAvg(sequences.after1Win),
            calcAvg(sequences.after2Wins),
            calcAvg(sequences.after1Loss),
            calcAvg(sequences.after2Losses),
            calcAvg(sequences.after3Losses)
        ];
        
        const colors = avgValues.map(v => v >= 0 ? '#39FF14' : '#ff0000');
        const counts = [
            sequences.after1Win.length,
            sequences.after2Wins.length,
            sequences.after1Loss.length,
            sequences.after2Losses.length,
            sequences.after3Losses.length
        ];
        
        consecutiveSequencesChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: ['After 1W', 'After 2W', 'After 1L', 'After 2L', 'After 3+L'],
                datasets: [{
                    data: avgValues,
                    backgroundColor: colors,
                    borderWidth: 0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        backgroundColor: '#1a1a1a',
                        titleColor: '#39FF14',
                        bodyColor: '#ccc',
                        borderColor: '#39FF14',
                        borderWidth: 1,
                        callbacks: {
                            title: (context) => {
                                const sequences = ['Después de 1 Win', 'Después de 2 Wins', 'Después de 1 Loss', 'Después de 2 Losses', 'Después de 3+ Losses'];
                                return sequences[context[0].dataIndex];
                            },
                            label: (context) => {
                                const idx = context.dataIndex;
                                const isPositive = context.parsed.y >= 0;
                                return [
                                    `P/L Promedio: $${context.parsed.y.toFixed(2)}`,
                                    `Trades analizados: ${counts[idx]}`,
                                    isPositive ? '✅ Rendimiento positivo tras esta racha' : '⚠️ Rendimiento negativo - posible revenge trading',
                                    'Idealmente: Valores verdes indican disciplina tras rachas'
                                ];
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        grid: { color: '#333' },
                        ticks: { 
                            color: '#888',
                            callback: (value) => '$' + value.toFixed(0)
                        }
                    },
                    x: {
                        grid: { display: false },
                        ticks: { color: '#ccc' }
                    }
                }
            }
        });
    }
    
    // 4. DRAWDOWN RECOVERY RATE
    function createDrawdownRecovery(operations) {
        const canvas = document.getElementById('drawdown-recovery-chart');
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        if (drawdownRecoveryChart) {
            drawdownRecoveryChart.destroy();
        }
        
        // Ordenar operaciones por fecha
        const sortedOps = [...operations].sort((a, b) => {
            const dateA = new Date(a.entry_time || a.open_time);
            const dateB = new Date(b.entry_time || b.open_time);
            return dateA - dateB;
        });
        
        const recovery = {
            'after1Loss': { trades: [], winRate: [] },
            'after2Losses': { trades: [], winRate: [] },
            'after3Losses': { trades: [], winRate: [] },
            'after4Losses': { trades: [], winRate: [] }
        };
        
        for (let i = 0; i < sortedOps.length; i++) {
            let lossStreak = 0;
            
            // Contar racha de pérdidas
            for (let j = i - 1; j >= 0 && sortedOps[j].pl < 0; j--) {
                lossStreak++;
            }
            
            if (lossStreak === 0) continue;
            
            // Buscar trades para recuperar
            let tradesCount = 0;
            let wins = 0;
            let total = 0;
            
            for (let k = i; k < sortedOps.length; k++) {
                tradesCount++;
                total++;
                if (sortedOps[k].pl > 0) wins++;
                
                // Verificar si recuperó (simplificado)
                if (tradesCount >= 3) break;
            }
            
            const winRate = total > 0 ? (wins / total) * 100 : 0;
            
            if (lossStreak === 1 && recovery.after1Loss.trades.length < 50) {
                recovery.after1Loss.trades.push(tradesCount);
                recovery.after1Loss.winRate.push(winRate);
            } else if (lossStreak === 2 && recovery.after2Losses.trades.length < 50) {
                recovery.after2Losses.trades.push(tradesCount);
                recovery.after2Losses.winRate.push(winRate);
            } else if (lossStreak === 3 && recovery.after3Losses.trades.length < 50) {
                recovery.after3Losses.trades.push(tradesCount);
                recovery.after3Losses.winRate.push(winRate);
            } else if (lossStreak >= 4 && recovery.after4Losses.trades.length < 50) {
                recovery.after4Losses.trades.push(tradesCount);
                recovery.after4Losses.winRate.push(winRate);
            }
        }
        
        const calcAvg = (arr) => arr.length > 0 ? arr.reduce((sum, v) => sum + v, 0) / arr.length : 0;
        
        const avgTrades = [
            calcAvg(recovery.after1Loss.trades),
            calcAvg(recovery.after2Losses.trades),
            calcAvg(recovery.after3Losses.trades),
            calcAvg(recovery.after4Losses.trades)
        ];
        
        const avgWinRates = [
            calcAvg(recovery.after1Loss.winRate),
            calcAvg(recovery.after2Losses.winRate),
            calcAvg(recovery.after3Losses.winRate),
            calcAvg(recovery.after4Losses.winRate)
        ];
        
        const colors = avgWinRates.map(wr => wr >= 50 ? '#39FF14' : '#ff0000');
        
        drawdownRecoveryChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: ['After 1L', 'After 2L', 'After 3L', 'After 4+L'],
                datasets: [{
                    data: avgTrades,
                    backgroundColor: colors,
                    borderWidth: 0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        backgroundColor: '#1a1a1a',
                        titleColor: '#39FF14',
                        bodyColor: '#ccc',
                        borderColor: '#39FF14',
                        borderWidth: 1,
                        callbacks: {
                            title: (context) => {
                                const labels = ['Después de 1 Pérdida', 'Después de 2 Pérdidas', 'Después de 3 Pérdidas', 'Después de 4+ Pérdidas'];
                                return labels[context[0].dataIndex];
                            },
                            label: (context) => {
                                const idx = context.dataIndex;
                                const goodRecovery = avgWinRates[idx] >= 50;
                                return [
                                    `Trades para recuperar: ${context.parsed.y.toFixed(1)}`,
                                    `Win rate durante recuperación: ${avgWinRates[idx].toFixed(1)}%`,
                                    goodRecovery ? '✅ Buena capacidad de recuperación' : '⚠️ Dificultad para recuperar después de pérdidas',
                                    'Menor número de trades = Recuperación más rápida y eficiente'
                                ];
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        grid: { color: '#333' },
                        ticks: { 
                            color: '#888',
                            stepSize: 1
                        }
                    },
                    x: {
                        grid: { display: false },
                        ticks: { color: '#ccc' }
                    }
                }
            }
        });
    }
    
    // 5. PERFORMANCE SCORE
    function createPerformanceScore(stats) {
        console.log('🎯 createPerformanceScore llamada con stats:', stats);
        
        const canvas = document.getElementById('ind-performance-score-chart');
        if (!canvas) {
            console.error('❌ Canvas ind-performance-score-chart no encontrado');
            return;
        }
        
        const ctx = canvas.getContext('2d');
        if (indPerformanceScoreChart) {
            indPerformanceScoreChart.destroy();
        }
        
        // Componentes del score para radar (5 dimensiones)
        const winRateScore = stats.winRate || 0; // 0-100
        const profitFactorScore = Math.min((stats.profitFactor || 0) * 10, 100); // 0-100 (PF de 10 = 100%)
        const avgWinLossRatio = stats.avgWin > 0 && stats.avgLoss > 0 ? Math.min((stats.avgWin / stats.avgLoss) * 20, 100) : 0; // 0-100
        const drawdownControl = 50; // Por ahora fijo, necesitaríamos calcular maxDrawdown
        const consistencyScore = stats.consistency || 0; // 0-100
        
        console.log('📊 Radar values:', {
            winRateScore,
            profitFactorScore,
            avgWinLossRatio,
            drawdownControl,
            consistencyScore
        });
        
        indPerformanceScoreChart = new Chart(ctx, {
            type: 'radar',
            data: {
                labels: ['Win %', 'Profit Factor', 'Avg Win/Loss', 'Drawdown Ctrl', 'Consistencia'],
                datasets: [{
                    label: 'Rendimiento del Setup',
                    data: [winRateScore, profitFactorScore, avgWinLossRatio, drawdownControl, consistencyScore],
                    backgroundColor: 'rgba(57, 255, 20, 0.2)',
                    borderColor: '#39FF14',
                    borderWidth: 2,
                    pointBackgroundColor: '#39FF14',
                    pointBorderColor: '#fff',
                    pointHoverBackgroundColor: '#fff',
                    pointHoverBorderColor: '#39FF14',
                    pointRadius: 4,
                    pointHoverRadius: 6
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { 
                        display: false
                    },
                    tooltip: {
                        backgroundColor: '#1a1a1a',
                        titleColor: '#39FF14',
                        bodyColor: '#ccc',
                        borderColor: '#39FF14',
                        borderWidth: 1,
                        callbacks: {
                            title: (context) => {
                                const labels = ['Win %', 'Profit Factor', 'Avg Win/Loss', 'Drawdown Ctrl', 'Consistencia'];
                                return labels[context[0].dataIndex];
                            },
                            label: (context) => {
                                const idx = context.dataIndex;
                                const explanations = [
                                    `Porcentaje de aciertos: ${stats.winRate.toFixed(1)}%`,
                                    `Profit Factor: ${stats.profitFactor.toFixed(2)} (Ganancias/Pérdidas)`,
                                    `Avg Win: $${stats.avgWin.toFixed(2)} | Avg Loss: $${stats.avgLoss.toFixed(2)}`,
                                    `Control de drawdown y gestión de riesgo`,
                                    `Consistencia: ${stats.consistency.toFixed(1)}% - Estabilidad de resultados`
                                ];
                                return [
                                    `Score: ${context.parsed.r.toFixed(1)}/100`,
                                    explanations[idx]
                                ];
                            }
                        }
                    }
                },
                scales: {
                    r: {
                        beginAtZero: true,
                        max: 100,
                        min: 0,
                        ticks: { 
                            color: '#888',
                            stepSize: 20,
                            callback: (value) => value + '%',
                            backdropColor: 'transparent'
                        },
                        grid: { 
                            color: '#333',
                            circular: true
                        },
                        angleLines: { 
                            color: '#333'
                        },
                        pointLabels: { 
                            color: '#ccc',
                            font: {
                                size: 12,
                                weight: 'bold'
                            }
                        }
                    }
                }
            }
        });
    }
    
    // 6. DISTRIBUCIÓN POR HORARIO
    function createHourlyDistribution(operations) {
        console.log('📊 createHourlyDistribution llamada con', operations.length, 'operaciones');
        
        const canvas = document.getElementById('ind-hourly-distribution-chart');
        if (!canvas) {
            console.error('❌ Canvas ind-hourly-distribution-chart no encontrado');
            return;
        }
        
        const ctx = canvas.getContext('2d');
        if (indHourlyDistributionChart) {
            indHourlyDistributionChart.destroy();
        }
        
        // Agrupar por hora (0-23)
        const hourlyData = Array(24).fill(0).map(() => ({ wins: 0, losses: 0, total: 0, pnl: 0 }));
        
        operations.forEach(op => {
            // Usar entryTime que está en las operaciones
            const time = op.entryTime;
            if (!time) return;
            
            try {
                const hour = parseInt(time.split(':')[0], 10);
                if (isNaN(hour) || hour < 0 || hour > 23) return;
                
                hourlyData[hour].total++;
                hourlyData[hour].pnl += (op.pl || 0);
                
                if (op.pl > 0) hourlyData[hour].wins++;
                else if (op.pl < 0) hourlyData[hour].losses++;
            } catch(e) { /* ignore invalid time */ }
        });
        
        console.log('📈 Datos horarios:', hourlyData.filter(d => d.total > 0));
        
        // Filtrar solo horas con datos
        const labels = hourlyData
            .map((data, hour) => ({ hour, ...data }))
            .filter(d => d.total > 0)
            .map(d => `${d.hour}:00`);
        
        const volumes = hourlyData.filter(d => d.total > 0).map(d => d.total);
        const pnls = hourlyData.filter(d => d.total > 0).map(d => d.pnl);
        
        const colors = pnls.map(pnl => pnl >= 0 ? '#39FF14' : '#ff0000');
        
        indHourlyDistributionChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [{
                    label: 'P&L por Hora',
                    data: pnls,
                    backgroundColor: colors,
                    borderWidth: 0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        backgroundColor: '#1a1a1a',
                        titleColor: '#39FF14',
                        bodyColor: '#ccc',
                        borderColor: '#39FF14',
                        borderWidth: 1,
                        callbacks: {
                            title: (context) => {
                                return `Franja Horaria: ${context[0].label}`;
                            },
                            label: (context) => {
                                const idx = context.dataIndex;
                                const filteredData = hourlyData.filter(d => d.total > 0);
                                
                                if (!filteredData[idx]) {
                                    return `P&L: $${context.parsed.y.toFixed(2)}`;
                                }
                                
                                const data = filteredData[idx];
                                const winRate = data.total > 0 ? ((data.wins / data.total) * 100).toFixed(1) : 0;
                                const isGoodHour = data.pnl > 0 && parseFloat(winRate) >= 50;
                                
                                return [
                                    `P&L Total: $${context.parsed.y.toFixed(2)}`,
                                    `Trades: ${data.total} (${data.wins}W / ${data.losses}L)`,
                                    `Win Rate: ${winRate}%`,
                                    isGoodHour ? '✅ Franja rentable - considera priorizar' : '⚠️ Franja menos rentable - analiza condiciones',
                                    'Verde = P&L positivo | Rojo = P&L negativo'
                                ];
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        grid: { color: '#333' },
                        ticks: { 
                            color: '#888',
                            callback: (value) => '$' + value
                        }
                    },
                    x: {
                        grid: { display: false },
                        ticks: { color: '#ccc' }
                    }
                }
            }
        });
    }
    
    // 7. RENDIMIENTO POR DÍA DE SEMANA (Individual Analysis)
    let indWeekdayBarChart = null;
    function createIndWeekdayBarChart(operations) {
        console.log('📊 createIndWeekdayBarChart llamada con', operations.length, 'operaciones');
        
        const canvas = document.getElementById('ind-weekday-bar-chart');
        if (!canvas) {
            console.error('❌ Canvas ind-weekday-bar-chart no encontrado');
            return;
        }
        
        const ctx = canvas.getContext('2d');
        if (indWeekdayBarChart) {
            indWeekdayBarChart.destroy();
        }
        
        const weekdayPL = Array(7).fill(0);
        
        operations.forEach(op => {
            const time = op.date;
            if (!time) return;
            
            const date = new Date(time);
            const dayIndex = date.getDay();
            weekdayPL[dayIndex] += (op.pl || 0);
        });
        
        // Reordenar: Lunes primero
        const reorderedDays = ['Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sábado', 'Domingo'];
        const reorderedData = [
            weekdayPL[1], // Lunes
            weekdayPL[2], // Martes
            weekdayPL[3], // Miércoles
            weekdayPL[4], // Jueves
            weekdayPL[5], // Viernes
            weekdayPL[6], // Sábado
            weekdayPL[0]  // Domingo
        ];
        
        console.log('📊 Weekday P&L (Individual):', reorderedData);
        
        indWeekdayBarChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: reorderedDays,
                datasets: [{
                    label: 'P&L por Día',
                    data: reorderedData,
                    backgroundColor: reorderedData.map(val => val >= 0 ? 'rgba(57, 255, 20, 0.8)' : 'rgba(255, 65, 54, 0.8)'),
                    borderColor: reorderedData.map(val => val >= 0 ? '#39ff14' : '#ff4136'),
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: true,
                        labels: { color: '#ccc' }
                    }
                },
                scales: {
                    x: { 
                        ticks: { color: '#aaa' },
                        grid: { display: false }
                    },
                    y: { 
                        ticks: { color: '#888' },
                        grid: { color: '#333' }
                    }
                }
            }
        });
        
        console.log('✅ Gráfica semanal individual creada');
    }
    
    // 8. NET DAILY P&L (Individual Analysis)
    let indNetDailyPLChart = null;
    function createIndNetDailyPL(operations) {
        console.log('📊 createIndNetDailyPL llamada con', operations.length, 'operaciones');
        
        const canvas = document.getElementById('ind-net-daily-pl-chart');
        if (!canvas) {
            console.error('❌ Canvas ind-net-daily-pl-chart no encontrado');
            return;
        }
        
        const ctx = canvas.getContext('2d');
        if (indNetDailyPLChart) {
            indNetDailyPLChart.destroy();
        }
        
        // Agrupar por fecha
        const dailyPL = {};
        operations.forEach(op => {
            const date = op.date;
            if (!date) return;
            
            if (!dailyPL[date]) dailyPL[date] = 0;
            dailyPL[date] += (op.pl || 0);
        });
        
        const sorted = Object.keys(dailyPL).sort();
        const labels = sorted;
        const data = sorted.map(date => dailyPL[date]);
        
        console.log('📊 Daily P&L (Individual):', data);
        
        indNetDailyPLChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels,
                datasets: [{
                    label: 'P&L Diario',
                    data,
                    backgroundColor: data.map(val => val >= 0 ? 'rgba(57, 255, 20, 0.8)' : 'rgba(255, 65, 54, 0.8)'),
                    borderColor: data.map(val => val >= 0 ? '#39ff14' : '#ff4136'),
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: true,
                        labels: { color: '#ccc' }
                    }
                },
                scales: {
                    x: { 
                        ticks: { color: '#aaa' },
                        grid: { display: false }
                    },
                    y: { 
                        ticks: { color: '#888' },
                        grid: { color: '#333' }
                    }
                }
            }
        });
        
        console.log('✅ Gráfica Net Daily P&L individual creada');
    }
    
    // ========================================
    // VISTA: COMPARATIVA (ANTERIOR ANÁLISIS)
    // ========================================
    let expectancyChart = null;
    let performanceScoreChart = null;
    let assetSetupPieChart = null;
    let consistencyLineChart = null;
    
    function initializeComparativeView() {
        console.log('📊 Inicializando vista Comparativa...');
        console.log('📊 DB.setups:', DB.setups);
        console.log('📊 DB.operations:', DB.operations);
        
        // Validar que existan setups
        if (!DB.setups || DB.setups.length === 0) {
            console.warn('⚠️ No hay setups disponibles para comparar');
            const view = document.getElementById('playbook-comparative-view');
            if (view) {
                view.innerHTML = `
                    <div class="metric-card text-center p-12">
                        <div class="text-6xl mb-4">📝</div>
                        <h3 class="text-xl font-semibold mb-2" style="color: #39FF14">No hay setups para comparar</h3>
                        <p class="text-text-secondary mb-4">Crea al menos dos setups para ver comparativas</p>
                        <button onclick="document.querySelector('[data-target=playbook-management-view]').click()" class="primary">
                            <i class="fas fa-plus mr-2"></i>Ir a Gestión
                        </button>
                    </div>
                `;
            }
            return;
        }
        
        console.log(`✅ Comparando ${DB.setups.length} setups con ${DB.operations.length} operaciones`);
        
        try {
            console.log('1️⃣ Actualizando KPIs comparativos...');
            updateComparativeKPIs();
            
            console.log('2️⃣ Creando gráfico Expectancy...');
            createExpectancyChart();
            
            console.log('3️⃣ Creando gráfico Performance Score...');
            createPerformanceScoreChart();
            
            console.log('4️⃣ Creando gráfico Asset vs Setup...');
            createAssetSetupChart();
            
            console.log('5️⃣ Creando gráfica de barras por día de semana...');
            createWeekdayBarChart();
            
            console.log('6️⃣ Creando heatmap semanal...');
            createWeekdayHeatmap();
            
            console.log('7️⃣ Creando gráfico de consistencia...');
            createConsistencyChart();
            
            console.log('✅ Vista comparativa inicializada correctamente');
        } catch (error) {
            console.error('❌ Error inicializando comparativa:', error);
            console.error('Stack:', error.stack);
        }
    }
    
    function updateComparativeKPIs() {
        const setupStats = calculateSetupStats();
        const setupIds = Object.keys(setupStats);
        
        // Total setups
        document.getElementById('comp-total-setups').textContent = setupIds.length;
        
        // Total trades
        const totalTrades = setupIds.reduce((sum, id) => sum + setupStats[id].totalTrades, 0);
        document.getElementById('comp-total-trades').textContent = totalTrades;
        
        // Avg expectancy
        const avgExpectancy = setupIds.reduce((sum, id) => sum + setupStats[id].expectancy, 0) / setupIds.length;
        document.getElementById('comp-avg-expectancy').textContent = `$${avgExpectancy.toFixed(2)}`;
        document.getElementById('comp-avg-expectancy').className = `text-2xl font-bold ${avgExpectancy >= 0 ? 'text-primary' : 'text-danger'}`;
        
        // Mejor setup
        const best = setupIds.reduce((best, id) => {
            return setupStats[id].performanceScore > (setupStats[best]?.performanceScore || 0) ? id : best;
        }, setupIds[0]);
        
        document.getElementById('comp-best-setup').textContent = setupStats[best]?.name || '-';
    }
    
    function initializeAnalysisView() {
        // Función legacy - redirige a la nueva vista comparativa
        console.warn('⚠️ initializeAnalysisView() es legacy. Usa initializeComparativeView() o initializeIndividualAnalysisView()');
        initializeComparativeView();
    }
    
    // KPIs Principales - ACTUALIZAR NOMBRE
    function updateAnalysisKPIs() {
        // Función legacy - llama a updateComparativeKPIs()
        updateComparativeKPIs();
    }
    
    // Calcular estadísticas por setup
    function calculateSetupStats() {
        const operations = DB.operations || [];
        const setups = DB.setups || [];
        const setupStats = {};
        
        console.log(`📊 Calculando estadísticas para ${setups.length} setups y ${operations.length} operaciones`);
        
        setups.forEach(setup => {
            const setupOps = operations.filter(op => op.setupId == setup.id || op.setupUsed == setup.id);
            
            console.log(`  Setup "${setup.name}": ${setupOps.length} operaciones`);
            
            if (setupOps.length === 0) {
                setupStats[setup.id] = {
                    name: setup.name,
                    totalTrades: 0,
                    wins: 0,
                    losses: 0,
                    winRate: 0,
                    profitFactor: 0,
                    expectancy: 0,
                    avgWin: 0,
                    avgLoss: 0,
                    consistency: 0,
                    performanceScore: 0
                };
                return;
            }
            
            const wins = setupOps.filter(op => op.pl > 0);
            const losses = setupOps.filter(op => op.pl < 0);
            const totalWins = wins.reduce((sum, op) => sum + op.pl, 0);
            const totalLosses = Math.abs(losses.reduce((sum, op) => sum + op.pl, 0));
            
            const winRate = (wins.length / setupOps.length) * 100;
            const avgWin = wins.length > 0 ? totalWins / wins.length : 0;
            const avgLoss = losses.length > 0 ? totalLosses / losses.length : 0;
            const profitFactor = totalLosses > 0 ? totalWins / totalLosses : (totalWins > 0 ? 999 : 0);
            
            // EXPECTANCY: (Win% × AvgWin) - (Loss% × AvgLoss)
            const expectancy = (winRate / 100 * avgWin) - ((1 - winRate / 100) * avgLoss);
            
            // CONSISTENCY: Desviación estándar de resultados (menor = más consistente)
            // CORREGIDO: No usar || 0 para no perder operaciones con pl = 0
            const pnls = setupOps.map(op => {
                const plValue = op.pl ?? op.pnl ?? 0;
                return typeof plValue === 'number' && !isNaN(plValue) ? plValue : 0;
            });
            
            const avgPnl = pnls.reduce((sum, pnl) => sum + pnl, 0) / pnls.length;
            const variance = pnls.reduce((sum, pnl) => sum + Math.pow(pnl - avgPnl, 2), 0) / pnls.length;
            const stdDev = Math.sqrt(variance);
            
            // Consistencia mejorada: Basada en coeficiente de variación
            let consistencyScore = 0;
            
            if (pnls.length < 2) {
                // Si hay menos de 2 operaciones, la consistencia no es confiable
                consistencyScore = 0;
            } else if (Math.abs(avgPnl) > 0.01) {
                // Coeficiente de variación (CV)
                const coefficientOfVariation = stdDev / Math.abs(avgPnl);
                
                // Escala adaptada al trading real
                if (coefficientOfVariation < 0.3) {
                    consistencyScore = 95 + (0.3 - coefficientOfVariation) * 16.67;
                } else if (coefficientOfVariation < 0.8) {
                    consistencyScore = 80 + (0.8 - coefficientOfVariation) * 30;
                } else if (coefficientOfVariation < 1.5) {
                    consistencyScore = 60 + (1.5 - coefficientOfVariation) * 28.57;
                } else if (coefficientOfVariation < 2.5) {
                    consistencyScore = 35 + (2.5 - coefficientOfVariation) * 25;
                } else if (coefficientOfVariation < 4.0) {
                    consistencyScore = 10 + (4.0 - coefficientOfVariation) * 16.67;
                } else {
                    consistencyScore = Math.max(0, 10 - (coefficientOfVariation - 4.0) * 2.5);
                }
                
                consistencyScore = Math.max(0, Math.min(100, consistencyScore));
            } else {
                // Si avgPnl es ~0, usar win rate como proxy de consistencia
                consistencyScore = winRate;
            }
            
            // PERFORMANCE SCORE: 0-100
            const winRateScore = winRate; // 0-100
            const pfScore = Math.min(100, profitFactor * 33.33); // PF de 3.0 = 100
            const expectancyScore = Math.min(100, Math.max(0, expectancy * 10 + 50)); // Normalizado
            
            const performanceScore = (
                winRateScore * 0.30 +
                pfScore * 0.30 +
                expectancyScore * 0.20 +
                consistencyScore * 0.20
            );
            
            console.log(`  📊 ${setup.name}:`);
            console.log(`     - Total Trades: ${setupOps.length}`);
            console.log(`     - Win Rate: ${winRate.toFixed(1)}%`);
            console.log(`     - Avg P&L: ${avgPnl.toFixed(2)}`);
            console.log(`     - StdDev: ${stdDev.toFixed(2)}`);
            console.log(`     - Consistency: ${consistencyScore.toFixed(1)}%`);
            console.log(`     - Performance Score: ${performanceScore.toFixed(1)}/100`);
            
            setupStats[setup.id] = {
                name: setup.name,
                totalTrades: setupOps.length,
                wins: wins.length,
                losses: losses.length,
                winRate,
                profitFactor,
                expectancy,
                avgWin,
                avgLoss,
                consistency: consistencyScore,
                performanceScore
            };
            
            console.log(`  ✅ SetupStats[${setup.id}].consistency = ${consistencyScore.toFixed(1)}%`);
        });
        
        console.log('✅ Estadísticas calculadas:', setupStats);
        return setupStats;
    }
    
    // 1. Expectancy Chart
    function createExpectancyChart() {
        console.log('💰 Creando gráfico de Expectancy...');
        const setupStats = calculateSetupStats();
        const data = Object.entries(setupStats)
            .filter(([_, stat]) => stat.totalTrades > 0)
            .sort((a, b) => b[1].expectancy - a[1].expectancy);
        
        console.log(`  Setups con datos: ${data.length}`);
        
        if (data.length === 0) {
            console.warn('⚠️ No hay datos para gráfico de Expectancy');
            const ctx = document.getElementById('expectancy-bar-chart');
            if (ctx) {
                const parent = ctx.parentElement;
                parent.innerHTML = '<div class="text-center p-8 text-text-secondary">No hay datos suficientes. Asigna setups a tus operaciones.</div>';
            }
            return;
        }
        
        const labels = data.map(([_, stat]) => stat.name);
        const expectancies = data.map(([_, stat]) => stat.expectancy);
        
        const ctx = document.getElementById('expectancy-bar-chart');
        if (ctx) {
            if (expectancyChart) expectancyChart.destroy();
            expectancyChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Expectancy ($/Trade)',
                        data: expectancies,
                        backgroundColor: expectancies.map(e => e > 0 ? '#00FF00' : 'rgba(255, 0, 0, 0.7)'),
                        borderColor: expectancies.map(e => e > 0 ? '#39FF14' : '#ff0000'),
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    scales: {
                        y: { 
                            beginAtZero: true,
                            ticks: { 
                                color: '#888',
                                callback: function(value) {
                                    return '$' + value.toFixed(2);
                                }
                            },
                            grid: { color: '#333' }
                        },
                        x: { 
                            ticks: { color: '#aaa' },
                            grid: { display: false }
                        }
                    },
                    plugins: {
                        legend: { labels: { color: '#ccc' } },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return 'Expectancy: $' + context.parsed.y.toFixed(2);
                                }
                            }
                        }
                    }
                }
            });
            console.log('✅ Gráfico de Expectancy creado');
        }
        
        // Detalles de expectancy
        const detailsContainer = document.getElementById('expectancy-details');
        if (detailsContainer) {
            detailsContainer.innerHTML = data.slice(0, 6).map(([_, stat]) => {
                const color = stat.expectancy > 0 ? '#39FF14' : '#ff0000';
                return `
                    <div class="p-3 bg-background rounded">
                        <div class="flex justify-between items-center mb-2">
                            <span class="font-semibold">${stat.name}</span>
                            <span class="text-lg font-bold" style="color: ${color}">$${stat.expectancy.toFixed(2)}</span>
                        </div>
                        <div class="text-xs text-text-secondary grid grid-cols-2 gap-1">
                            <div>WR: ${stat.winRate.toFixed(1)}%</div>
                            <div>Avg Win: $${stat.avgWin.toFixed(2)}</div>
                            <div>PF: ${stat.profitFactor.toFixed(2)}</div>
                            <div>Avg Loss: $${stat.avgLoss.toFixed(2)}</div>
                        </div>
                    </div>
                `;
            }).join('');
        }
    }
    
    // 2. Performance Score Chart
    function createPerformanceScoreChart() {
        const setupStats = calculateSetupStats();
        const data = Object.entries(setupStats)
            .filter(([_, stat]) => stat.totalTrades > 0)
            .sort((a, b) => b[1].performanceScore - a[1].performanceScore);
        
        const labels = data.map(([_, stat]) => stat.name);
        const scores = data.map(([_, stat]) => stat.performanceScore);
        
        const ctx = document.getElementById('performance-score-chart');
        if (ctx) {
            if (performanceScoreChart) performanceScoreChart.destroy();
            performanceScoreChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Performance Score (0-100)',
                        data: scores,
                        backgroundColor: data.map(([_, stat]) => {
                            const score = stat.performanceScore;
                            const totalPnl = stat.netPL || 0;
                            // Rojo brillante si está en drawdown (P&L negativo)
                            if (totalPnl < 0) return 'rgba(255, 0, 0, 0.9)';
                            // Verde fluorescente para scores altos
                            if (score >= 70) return 'rgba(57, 255, 20, 0.9)';
                            // Azul para scores medios
                            if (score >= 50) return 'rgba(0, 150, 255, 0.8)';
                            // Gris para scores bajos
                            return 'rgba(128, 128, 128, 0.7)';
                        }),
                        borderColor: data.map(([_, stat]) => {
                            const score = stat.performanceScore;
                            const totalPnl = stat.netPL || 0;
                            if (totalPnl < 0) return '#FF0000';
                            if (score >= 70) return '#39FF14';
                            if (score >= 50) return '#0096FF';
                            return '#808080';
                        }),
                        borderWidth: 2
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: true,
                    scales: {
                        x: { 
                            beginAtZero: true,
                            max: 100,
                            ticks: { color: '#888' },
                            grid: { color: '#333' }
                        },
                        y: { 
                            ticks: { color: '#aaa' },
                            grid: { display: false }
                        }
                    },
                    plugins: {
                        legend: { labels: { color: '#ccc' } }
                    }
                }
            });
        }
        
        // Tabla de scores
        const tableBody = document.getElementById('performance-score-table');
        if (tableBody) {
            tableBody.innerHTML = data.map(([_, stat]) => {
                const score = stat.performanceScore;
                const totalPnl = stat.netPL || 0;
                // Rojo brillante si está en drawdown
                let scoreColor = '#FF0000';
                if (totalPnl >= 0) {
                    scoreColor = score >= 70 ? '#39FF14' : (score >= 50 ? '#0096FF' : '#808080');
                }
                return `
                    <tr class="border-b border-border">
                        <td class="p-2">${stat.name}</td>
                        <td class="text-center p-2 font-bold" style="color: ${scoreColor}">${stat.performanceScore.toFixed(1)}</td>
                        <td class="text-center p-2">${stat.winRate.toFixed(1)}%</td>
                        <td class="text-center p-2">${stat.profitFactor.toFixed(2)}</td>
                        <td class="text-center p-2">$${stat.expectancy.toFixed(2)}</td>
                        <td class="text-center p-2">${stat.consistency.toFixed(1)}%</td>
                    </tr>
                `;
            }).join('');
        }
    }
    
    // 3. Asset vs Setup (Pie Chart)
    function createAssetSetupChart() {
        const operations = DB.operations || [];
        const setups = DB.setups || [];
        
        // Función para normalizar símbolos (BTC-USDT = BTCUSDT, MNQMAR26 = MNQ)
        function normalizeSymbol(symbol) {
            if (!symbol) return 'Desconocido';
            // Remover guiones, underscores, espacios, convertir a mayúsculas
            let normalized = symbol.replace(/-/g, '').replace(/_/g, '').replace(/\s+/g, '').toUpperCase();
            
            // Consolidar futuros: MNQMAR26, MNQH6, MNQDEC25, NQDEC25 → MNQ
            if (normalized.match(/^MNQ.*/) || normalized.match(/^NQ(DEC|MAR|JUN|SEP|H|M|U|Z)\d+$/)) {
                return 'MNQ';
            }
            
            return normalized;
        }
        
        // Agrupar por activo NORMALIZADO
        const assetGroups = {};
        operations.forEach(op => {
            const rawSymbol = op.symbol || op.instrument || 'Desconocido';
            const asset = normalizeSymbol(rawSymbol);
            if (!assetGroups[asset]) assetGroups[asset] = [];
            assetGroups[asset].push(op);
        });
        
        const labels = Object.keys(assetGroups);
        const data = labels.map(asset => assetGroups[asset].length);
        
        const ctx = document.getElementById('asset-setup-pie-chart');
        if (ctx) {
            if (assetSetupPieChart) assetSetupPieChart.destroy();
            assetSetupPieChart = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: [
                            'rgba(57, 255, 20, 0.8)',    // Verde neón
                            'rgba(0, 191, 255, 0.8)',    // Cyan
                            'rgba(128, 128, 128, 0.8)',  // Gris
                            'rgba(233, 30, 99, 0.8)',    // Rosa/Magenta
                            'rgba(0, 51, 102, 0.8)',     // Azul marino
                            'rgba(0, 100, 0, 0.8)'       // Verde oscuro
                        ],
                        borderColor: '#1a1a1a',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: { 
                            labels: { color: '#ccc' },
                            position: 'bottom'
                        }
                    }
                }
            });
        }
        
        // Detalles por activo - MOSTRAR TODOS LOS ACTIVOS
        const detailsContainer = document.getElementById('asset-setup-details');
        if (detailsContainer) {
            detailsContainer.innerHTML = labels.map(asset => {
                const ops = assetGroups[asset];
                const wins = ops.filter(op => (op.pl || 0) > 0).length;
                const winRate = ((wins / ops.length) * 100).toFixed(1);
                const totalPnl = ops.reduce((sum, op) => sum + (op.pl || 0), 0);
                const color = totalPnl > 0 ? '#39FF14' : '#ff0000';
                
                return `
                    <div class="p-3 bg-background rounded">
                        <div class="font-semibold mb-2">${asset}</div>
                        <div class="text-sm space-y-1">
                            <div>Trades: ${ops.length}</div>
                            <div>Winrate: ${winRate}%</div>
                            <div style="color: ${color}">P&L: $${totalPnl.toFixed(2)}</div>
                        </div>
                    </div>
                `;
            }).join('');
        }
    }
    
    // 4. Session Analysis (Radar + Bar)
    function createSessionAnalysis() {
        const operations = DB.operations || [];
        
        // Agrupar por sesión
        const sessions = {
            'Tokyo': { trades: 0, wins: 0 },
            'London': { trades: 0, wins: 0 },
            'NY Open': { trades: 0, wins: 0 },
            'NY Mid': { trades: 0, wins: 0 },
            'NY Close': { trades: 0, wins: 0 }
        };
        
        operations.forEach(op => {
            const session = op.session || 'NY Mid';
            if (sessions[session]) {
                sessions[session].trades++;
                if (op.pnl > 0) sessions[session].wins++;
            }
        });
        
        const sessionLabels = Object.keys(sessions);
        const winrates = sessionLabels.map(s => sessions[s].trades > 0 ? (sessions[s].wins / sessions[s].trades * 100) : 0);
        const volumes = sessionLabels.map(s => sessions[s].trades);
        
        // Radar: Winrate por sesión
        const radarCtx = document.getElementById('session-winrate-radar');
        if (radarCtx) {
            if (sessionWinrateRadarChart) sessionWinrateRadarChart.destroy();
            sessionWinrateRadarChart = new Chart(radarCtx, {
                type: 'radar',
                data: {
                    labels: sessionLabels,
                    datasets: [{
                        label: 'Winrate %',
                        data: winrates,
                        backgroundColor: 'rgba(57, 255, 20, 0.2)',
                        borderColor: '#39FF14',
                        borderWidth: 3,
                        pointBackgroundColor: '#39FF14',
                        pointBorderColor: '#fff',
                        pointHoverBackgroundColor: '#fff',
                        pointHoverBorderColor: '#39FF14'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    scales: {
                        r: {
                            beginAtZero: true,
                            max: 100,
                            ticks: { color: '#888' },
                            grid: { color: '#333' },
                            pointLabels: { color: '#aaa' }
                        }
                    },
                    plugins: {
                        legend: { labels: { color: '#ccc' } }
                    }
                }
            });
        }
        
        // Bar: Volumen por sesión
        const barCtx = document.getElementById('hourly-volume-chart');
        if (barCtx) {
            if (hourlyVolumeChart) hourlyVolumeChart.destroy();
            hourlyVolumeChart = new Chart(barCtx, {
                type: 'bar',
                data: {
                    labels: sessionLabels,
                    datasets: [{
                        label: 'Trades',
                        data: volumes,
                        backgroundColor: 'rgba(0, 191, 255, 0.7)',
                        borderColor: '#00BFFF',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    scales: {
                        y: { 
                            beginAtZero: true,
                            ticks: { color: '#888' },
                            grid: { color: '#333' }
                        },
                        x: { 
                            ticks: { color: '#aaa' },
                            grid: { display: false }
                        }
                    },
                    plugins: {
                        legend: { labels: { color: '#ccc' } }
                    }
                }
            });
        }
        
        // Detalles por sesión
        const detailsContainer = document.getElementById('session-details');
        if (detailsContainer) {
            detailsContainer.innerHTML = sessionLabels.map(session => {
                const stat = sessions[session];
                const winRate = stat.trades > 0 ? ((stat.wins / stat.trades) * 100).toFixed(1) : '0.0';
                const color = parseFloat(winRate) >= 50 ? '#39FF14' : '#ff5722';
                
                return `
                    <div class="p-3 bg-background rounded text-center">
                        <div class="font-semibold mb-1">${session}</div>
                        <div class="text-2xl font-bold mb-1" style="color: ${color}">${winRate}%</div>
                        <div class="text-xs text-text-secondary">${stat.trades} trades</div>
                    </div>
                `;
            }).join('');
        }
    }
    
    // 4.5 Weekday Bar Chart (NEW)
    let playbookWeekdayBarChart = null;
    function createWeekdayBarChart() {
        console.log('📊 createWeekdayBarChart llamada');
        const operations = DB.operations || [];
        
        console.log(`📊 ${operations.length} operaciones`);
        
        const weekdays = ['Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sábado', 'Domingo'];
        const weekdayPL = Array(7).fill(0);
        
        console.log('📊 Procesando operaciones...');
        operations.forEach(op => {
            const time = op.date;
            if (!time) return;
            
            const date = new Date(time);
            const dayIndex = date.getDay(); // 0=Dom, 1=Lun, 2=Mar, 3=Mié, 4=Jue, 5=Vie, 6=Sáb
            weekdayPL[dayIndex] += (op.pl || 0);
        });
        
        console.log('📊 weekdayPL original:', weekdayPL);
        
        // Reordenar: Lunes primero
        const reorderedDays = ['Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sábado', 'Domingo'];
        const reorderedData = [
            weekdayPL[1], // Lunes
            weekdayPL[2], // Martes
            weekdayPL[3], // Miércoles
            weekdayPL[4], // Jueves
            weekdayPL[5], // Viernes
            weekdayPL[6], // Sábado
            weekdayPL[0]  // Domingo
        ];
        
        console.log('📊 Weekday P&L:', reorderedData);
        
        const ctx = document.getElementById('playbook-weekday-bar-chart');
        console.log('📊 Canvas encontrado:', !!ctx);
        
        if (ctx) {
            if (playbookWeekdayBarChart) {
                console.log('📊 Destruyendo gráfica anterior...');
                playbookWeekdayBarChart.destroy();
            }
            
            console.log('📊 Creando nueva gráfica...');
            playbookWeekdayBarChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: reorderedDays,
                    datasets: [{
                        label: 'P&L por Día',
                        data: reorderedData,
                        backgroundColor: reorderedData.map(val => val >= 0 ? 'rgba(57, 255, 20, 0.8)' : 'rgba(255, 65, 54, 0.8)'),
                        borderColor: reorderedData.map(val => val >= 0 ? '#39ff14' : '#ff4136'),
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            labels: { color: '#ccc' }
                        }
                    },
                    scales: {
                        x: { 
                            ticks: { color: '#aaa' },
                            grid: { display: false }
                        },
                        y: { 
                            ticks: { color: '#888' },
                            grid: { color: '#333' }
                        }
                    }
                }
            });
            console.log('✅ Gráfica creada exitosamente');
        } else {
            console.error('❌ Canvas no encontrado!');
        }
    }
    
    // 5. Weekday Heatmap
    function createWeekdayHeatmap() {
        console.log('🔥 createWeekdayHeatmap llamada');
        const operations = DB.operations || [];
        const setups = DB.setups || [];
        
        console.log(`📊 ${operations.length} operaciones, ${setups.length} setups`);
        
        const weekdays = ['Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes'];
        const heatmapData = {};
        
        setups.forEach(setup => {
            heatmapData[setup.name] = { Mon: 0, Tue: 0, Wed: 0, Thu: 0, Fri: 0 };
        });
        
        let processedCount = 0;
        let skippedNoSetup = 0;
        let skippedNoDate = 0;
        let skippedWeekend = 0;
        
        operations.forEach(op => {
            const setup = setups.find(s => s.id == op.setupId || s.id == op.setupUsed);
            if (!setup) {
                skippedNoSetup++;
                return;
            }
            
            // CORREGIDO: Usar op.date en lugar de entry_time/open_time
            const time = op.date;
            if (!time) {
                skippedNoDate++;
                return;
            }
            
            const date = new Date(time);
            const dayIndex = date.getDay(); // 0=Dom, 1=Lun, 2=Mar, 3=Mié, 4=Jue, 5=Vie, 6=Sáb
            const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            const dayKey = days[dayIndex];
            
            // Ignorar fines de semana
            if (dayKey === 'Sun' || dayKey === 'Sat') {
                skippedWeekend++;
                return;
            }
            
            if (heatmapData[setup.name] && heatmapData[setup.name][dayKey] !== undefined) {
                heatmapData[setup.name][dayKey] += (op.pl || 0);
                processedCount++;
            }
        });
        
        console.log('📊 HeatmapData:', heatmapData);
        console.log(`✅ Procesadas: ${processedCount}, ❌ Sin setup: ${skippedNoSetup}, ❌ Sin fecha: ${skippedNoDate}, ⏭️ Fin de semana: ${skippedWeekend}`);
        
        const container = document.getElementById('weekday-heatmap');
        if (container) {
            let html = '<table class="w-full text-sm border-collapse"><thead><tr class="border-b border-border"><th class="p-2 text-left">Setup</th>';
            weekdays.forEach(day => {
                html += `<th class="p-2 text-center">${day}</th>`;
            });
            html += '</tr></thead><tbody>';
            
            Object.entries(heatmapData).forEach(([setupName, days]) => {
                html += `<tr class="border-b border-border"><td class="p-2 font-semibold">${setupName}</td>`;
                const dayKeys = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri'];
                dayKeys.forEach(key => {
                    const value = days[key];
                    const isPositive = value > 0;
                    const isNegative = value < 0;
                    const absValue = Math.abs(value);
                    const intensity = Math.min(absValue / 100, 1); // Normalizar a 100
                    const bgColor = isPositive 
                        ? `rgba(57, 255, 20, ${intensity * 0.7})` 
                        : isNegative 
                        ? `rgba(255, 0, 0, ${intensity * 0.7})` 
                        : 'transparent';
                    html += `<td class="p-2 text-center" style="background-color: ${bgColor}">$${value.toFixed(0)}</td>`;
                });
                html += '</tr>';
            });
            
            html += '</tbody></table>';
            container.innerHTML = html;
        }
    }
    
    // 6. Consistency Chart (Line)
    function createConsistencyChart() {
        console.log('📈 createConsistencyChart llamada');
        const operations = DB.operations || [];
        const setups = DB.setups || [];
        
        console.log(`📊 ${operations.length} operaciones, ${setups.length} setups`);
        
        // Ordenar operaciones por fecha
        const sorted = [...operations].sort((a, b) => {
            const dateA = new Date(a.entry_time || a.open_time || 0);
            const dateB = new Date(b.entry_time || b.open_time || 0);
            return dateA - dateB;
        });
        
        // Crear datasets por setup (top 5)
        const setupStats = calculateSetupStats();
        const topSetups = Object.entries(setupStats)
            .filter(([_, stat]) => stat.totalTrades > 0)
            .sort((a, b) => b[1].performanceScore - a[1].performanceScore)
            .slice(0, 5);
        
        console.log(`📊 Top 5 setups:`, topSetups.map(([id, s]) => s.name));
        
        const datasets = topSetups.map(([setupId, stat], index) => {
            const setupOps = sorted.filter(op => op.setupId == setupId || op.setupUsed == setupId);
            console.log(`  ${stat.name}: ${setupOps.length} operaciones`);
            
            let cumulative = 0;
            const data = setupOps.map((op, i) => {
                cumulative += (op.pl || 0); // CORREGIDO: op.pl en lugar de op.pnl
                return { x: i + 1, y: cumulative };
            });
            
            const colors = ['#39FF14', '#00BFFF', '#FFC107', '#FF5722', '#E91E63'];
            return {
                label: stat.name,
                data: data,
                borderColor: colors[index],
                backgroundColor: colors[index] + '20',
                borderWidth: 2,
                fill: false,
                tension: 0.1
            };
        });
        
        const ctx = document.getElementById('consistency-line-chart');
        if (ctx) {
            if (consistencyLineChart) consistencyLineChart.destroy();
            consistencyLineChart = new Chart(ctx, {
                type: 'line',
                data: { datasets: datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    scales: {
                        x: { 
                            type: 'linear',
                            title: { display: true, text: 'Trade #', color: '#aaa' },
                            ticks: { color: '#888' },
                            grid: { color: '#333' }
                        },
                        y: { 
                            title: { display: true, text: 'P&L Acumulado ($)', color: '#aaa' },
                            ticks: { color: '#888' },
                            grid: { color: '#333' }
                        }
                    },
                    plugins: {
                        legend: { labels: { color: '#ccc' } }
                    }
                }
            });
        }
    }
    
    // ========================================
    // VISTA: BACKTESTING
    // ========================================
    let equityCurveChart = null;
    
    function initializeBacktestView() {
        console.log('🔬 Inicializando vista de Backtesting...');
        const select = document.getElementById('backtest-setup-select');
        if (!select) return;
        
        select.innerHTML = '<option value="">Seleccionar setup para analizar...</option>';
        (DB.setups || []).forEach(setup => {
            select.innerHTML += `<option value="${setup.id}">${setup.name}</option>`;
        });
        
        document.getElementById('backtest-analyze-btn')?.addEventListener('click', runBacktest);
        
        select.addEventListener('change', () => {
            const btn = document.getElementById('backtest-analyze-btn');
            btn.disabled = !select.value;
        });
    }
    
    function runBacktest() {
        const setupId = document.getElementById('backtest-setup-select')?.value;
        if (!setupId) return;
        
        // Obtener operaciones que usan este setup
        const operations = DB.operations.filter(op => 
            op.setupId == setupId || op.setupUsed == setupId
        );
        
        if (operations.length === 0) {
            alert('No hay operaciones registradas con este setup');
            return;
        }
        
        // Calcular métricas - USAR op.pl no op.pnl
        const wins = operations.filter(op => (op.pl || 0) > 0).length;
        const losses = operations.filter(op => (op.pl || 0) < 0).length;
        const totalPnL = operations.reduce((sum, op) => sum + (op.pl || 0), 0);
        const totalWins = operations.filter(op => (op.pl || 0) > 0).reduce((sum, op) => sum + (op.pl || 0), 0);
        const totalLosses = Math.abs(operations.filter(op => (op.pl || 0) < 0).reduce((sum, op) => sum + (op.pl || 0), 0));
        
        const winRate = ((wins / operations.length) * 100).toFixed(1);
        const profitFactor = totalLosses > 0 ? (totalWins / totalLosses).toFixed(2) : totalWins.toFixed(2);
        const avgRR = operations.filter(op => op.rMultiple).length > 0 ?
            (operations.reduce((sum, op) => sum + (op.rMultiple || 0), 0) / operations.filter(op => op.rMultiple).length).toFixed(2) : 'N/A';
        
        // Mostrar métricas
        document.getElementById('bt-total-trades').textContent = operations.length;
        document.getElementById('bt-win-rate').textContent = winRate + '%';
        document.getElementById('bt-profit-factor').textContent = profitFactor;
        document.getElementById('bt-avg-rr').textContent = avgRR + 'R';
        
        // Crear curva de equity
        createEquityCurve(operations);
        
        // Crear heatmap
        createPerformanceHeatmap(operations);
        
        // Llenar tabla de operaciones
        fillBacktestTable(operations);
        
        document.getElementById('backtest-results').style.display = 'block';
    }
    
    function createEquityCurve(operations) {
        const sorted = [...operations].sort((a, b) => new Date(a.date) - new Date(b.date));
        
        let cumulative = 0;
        const labels = [];
        const data = [];
        
        sorted.forEach((op, idx) => {
            cumulative += (op.pl || 0);
            labels.push(`#${idx + 1}`);
            data.push(cumulative);
        });
        
        const ctx = document.getElementById('equity-curve-chart');
        if (!ctx) return;
        
        if (equityCurveChart) equityCurveChart.destroy();
        equityCurveChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [{
                    label: 'Equity Curve',
                    data: data,
                    borderColor: '#39FF14',
                    backgroundColor: 'rgba(57, 255, 20, 0.1)',
                    borderWidth: 3,
                    fill: true,
                    tension: 0.4
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                scales: {
                    y: {
                        ticks: { color: '#888' },
                        grid: { color: '#333' }
                    },
                    x: {
                        ticks: { color: '#aaa' },
                        grid: { display: false }
                    }
                },
                plugins: {
                    legend: { labels: { color: '#ccc' } }
                }
            }
        });
    }
    
    function createPerformanceHeatmap(operations) {
        const container = document.getElementById('performance-heatmap');
        if (!container) return;
        
        const heatmap = {};
        const days = ['Lun', 'Mar', 'Mié', 'Jue', 'Vie'];
        const hours = Array.from({length: 24}, (_, i) => i);
        
        operations.forEach(op => {
            const date = new Date(op.date);
            const day = (date.getDay() + 6) % 7; // Lunes = 0
            
            // Usar entryTime si existe
            let hour = 12; // Default
            if (op.entryTime) {
                try {
                    hour = parseInt(op.entryTime.split(':')[0], 10);
                } catch(e) {}
            }
            
            const key = `${day}-${hour}`;
            if (!heatmap[key]) heatmap[key] = { count: 0, pnl: 0 };
            heatmap[key].count++;
            heatmap[key].pnl += (op.pl || 0);
        });
        
        let html = '<table class="min-w-full text-xs"><thead><tr><th></th>';
        hours.forEach(h => html += `<th class="p-1">${h}</th>`);
        html += '</tr></thead><tbody>';
        
        days.forEach((day, d) => {
            html += `<tr><td class="font-semibold p-2">${day}</td>`;
            hours.forEach(h => {
                const key = `${d}-${h}`;
                const cell = heatmap[key];
                let bgColor = 'transparent';
                let text = '-';
                
                if (cell) {
                    const intensity = Math.min(100, (cell.count / operations.length) * 500);
                    bgColor = cell.pnl >= 0 ? 
                        `rgba(57, 255, 20, ${intensity / 100})` :
                        `rgba(255, 57, 57, ${intensity / 100})`;
                    text = cell.count;
                }
                
                html += `<td class="p-2 text-center border border-border" style="background: ${bgColor};">${text}</td>`;
            });
            html += '</tr>';
        });
        
        html += '</tbody></table>';
        container.innerHTML = html;
    }
    
    function fillBacktestTable(operations) {
        const tbody = document.querySelector('#backtest-trades-table tbody');
        if (!tbody) return;
        
        const sorted = [...operations].sort((a, b) => new Date(b.date) - new Date(a.date));
        
        tbody.innerHTML = sorted.map(op => {
            const date = new Date(op.date);
            const dateStr = date.toString() !== 'Invalid Date' ? date.toLocaleDateString() : 'Sin fecha';
            const symbol = op.symbol || op.instrument || '-';
            const plValue = op.pl || 0;
            const plClass = plValue >= 0 ? 'text-success' : 'text-danger';
            
            return `
                <tr>
                    <td class="p-2">${dateStr}</td>
                    <td class="p-2">${symbol}</td>
                    <td class="p-2">${op.type || '-'}</td>
                    <td class="p-2 ${plClass}">$${plValue.toFixed(2)}</td>
                    <td class="p-2">${op.rMultiple ? op.rMultiple.toFixed(2) + 'R' : '-'}</td>
                    <td class="p-2 text-xs">${op.tags?.join(', ') || '-'}</td>
                </tr>
            `;
        }).join('');
    }
    
    // ========================================
    // VISTA: GESTIÓN
    // ========================================
    function initializeManagementView() {
        console.log('⚙️ Inicializando vista de Gestión...');
        updateManagementStats();
        validateSetups();
    }
    
    function updateManagementStats() {
        const setups = DB.setups || [];
        document.getElementById('stats-total-setups').textContent = setups.length;
        document.getElementById('stats-premium').textContent = setups.filter(s => s.grade === 'P').length;
        document.getElementById('stats-categories').textContent = new Set(setups.map(s => s.category)).size;
        
        const allTags = setups.flatMap(s => s.tags || []);
        document.getElementById('stats-tags').textContent = new Set(allTags).length;
        
        const avgRating = setups.length > 0 ?
            (setups.reduce((sum, s) => sum + (s.rating || 0), 0) / setups.length).toFixed(1) : '0.0';
        document.getElementById('stats-avg-rating').textContent = avgRating;
    }
    
    function validateSetups() {
        const setups = DB.setups || [];
        document.getElementById('check-all-categorized').checked = setups.every(s => s.category);
        document.getElementById('check-all-graded').checked = setups.every(s => s.grade);
        document.getElementById('check-all-rated').checked = setups.every(s => s.rating > 0);
        document.getElementById('check-all-described').checked = setups.every(s => s.description);
    }
    
    // Export
    document.getElementById('export-all-setups')?.addEventListener('click', () => {
        const data = JSON.stringify(DB.setups || [], null, 2);
        const blob = new Blob([data], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `playbook-setups-${new Date().toISOString().split('T')[0]}.json`;
        a.click();
        showNotification('Setups exportados exitosamente', 'success');
    });
    
    // Import
    document.getElementById('import-setups-trigger')?.addEventListener('click', () => {
        document.getElementById('import-setups-file').click();
    });
    
    document.getElementById('import-setups-file')?.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = async (event) => {
            try {
                const imported = JSON.parse(event.target.result);
                if (!Array.isArray(imported)) throw new Error('Formato inválido');
                
                for (const setup of imported) {
                    setup.id = Date.now() + Math.random();
                    DB.setups.push(setup);
                    await dexieDB.setups.add(setup);
                }
                
                refreshPlaybook();
                showNotification(`${imported.length} setups importados`, 'success');
            } catch (err) {
                alert('Error al importar: ' + err.message);
            }
        };
        reader.readAsText(file);
    });
    
    document.getElementById('validate-all-setups')?.addEventListener('click', () => {
        validateSetups();
        showNotification('Validación completada', 'success');
    });
    
    document.getElementById('save-alerts-config')?.addEventListener('click', () => {
        const config = {
            winrate: document.getElementById('alert-winrate')?.value,
            pf: document.getElementById('alert-pf')?.value,
            unusedDays: document.getElementById('alert-unused-days')?.value
        };
        localStorage.setItem('playbook_alerts_config', JSON.stringify(config));
        showNotification('Configuración de alertas guardada', 'success');
    });

})();

// =============================================
// NOTEBOOK - SISTEMA DE NOTAS Y CARPETAS
// =============================================

// Hacer initializeNotebook global
let initializeNotebook;

document.addEventListener('DOMContentLoaded', function() {
    // Esperar a que DB esté disponible
    const initNotebookWhenReady = setInterval(() => {
        if (window.DB && window.dexieDB) {
            clearInterval(initNotebookWhenReady);
            initializeNotebook();
        }
    }, 100);

    initializeNotebook = function() {
        console.log('📓 Inicializando Notebook...');

        let currentFolder = null;
        let currentNote = null;
        let autoSaveTimeout = null;
        let mediaRecorder = null;
        let audioChunks = [];
        let recordingStartTime = null;
        let recordingInterval = null;

        // Cargar carpetas y notas al iniciar
        async function initNotebook() {
            await cleanupAndRecreateSystemFolders(); // LIMPIAR TODO Y RECREAR CARPETAS DEL SISTEMA
            await loadFolders();
            await createDefaultFolders(); // Crear carpetas faltantes
            await loadAllNotes(); // Cargar TODAS las notas en memoria
            await updateFolderCounts(); // Actualizar conteos al iniciar
        }

        // LIMPIAR Y RECREAR CARPETAS DEL SISTEMA
        async function cleanupAndRecreateSystemFolders() {
            try {
                console.log('🧹 LIMPIEZA COMPLETA: Eliminando duplicados y recreando carpetas del sistema...');
                
                const systemFolderNames = ['Daily Journal', 'Análisis del Mes', 'Análisis de la Semana', 'Operaciones', 'Playbook', 'Ideas', 'Notas Generales', 'Contexto general'];
                const allFolders = await dexieDB.notebookFolders.toArray();
                
                // Agrupar carpetas por nombre
                const foldersByName = {};
                allFolders.forEach(folder => {
                    if (!foldersByName[folder.name]) {
                        foldersByName[folder.name] = [];
                    }
                    foldersByName[folder.name].push(folder);
                });
                
                // Para cada carpeta del sistema
                for (const folderName of systemFolderNames) {
                    const folders = foldersByName[folderName] || [];
                    
                    if (folders.length > 1) {
                        console.log(`🗑️ ${folders.length} duplicados de "${folderName}" - eliminando...`);
                        
                        // Ordenar por fecha (más antigua primero)
                        folders.sort((a, b) => new Date(a.created_at) - new Date(b.created_at));
                        
                        // Mantener la primera, eliminar las demás
                        const toKeep = folders[0];
                        const toDelete = folders.slice(1);
                        
                        // Mover todas las notas a la carpeta que vamos a mantener
                        for (const folder of toDelete) {
                            const notes = await dexieDB.notebookNotes.where('folder_id').equals(folder.id).toArray();
                            console.log(`  📝 Moviendo ${notes.length} notas de carpeta duplicada ${folder.id}`);
                            for (const note of notes) {
                                note.folder_id = toKeep.id;
                                await dexieDB.notebookNotes.put(note);
                            }
                            
                            // Eliminar duplicado
                            await dexieDB.notebookFolders.delete(folder.id);
                            if (window.supabase) {
                                await supabase.from('notebook_folders').delete().eq('id', folder.id);
                            }
                        }
                        
                        // Actualizar icono de la carpeta que mantenemos a 📁
                        toKeep.icon = '📁';
                        await dexieDB.notebookFolders.put(toKeep);
                        if (window.supabase) {
                            await supabase.from('notebook_folders').update({ icon: '📁' }).eq('id', toKeep.id);
                        }
                        console.log(`  ✅ Carpeta "${folderName}" limpiada y actualizada con icono 📁`);
                        
                    } else if (folders.length === 1) {
                        // Solo hay una, actualizar su icono
                        const folder = folders[0];
                        folder.icon = '📁';
                        await dexieDB.notebookFolders.put(folder);
                        if (window.supabase) {
                            await supabase.from('notebook_folders').update({ icon: '📁' }).eq('id', folder.id);
                        }
                        console.log(`  ✅ Carpeta "${folderName}" actualizada con icono 📁`);
                    }
                    // Si no existe, createDefaultFolders la creará después
                }
                
                console.log('✅ Limpieza completa terminada');
            } catch (error) {
                console.error('❌ Error en limpieza:', error);
            }
        }

        // Cargar TODAS las notas en memoria (una sola vez al inicio)
        async function loadAllNotes() {
            try {
                console.log('📋 Cargando TODAS las notas en memoria...');
                const allNotes = await dexieDB.notebookNotes.toArray();
                DB.notebookNotes = allNotes;
                console.log(`✅ ${allNotes.length} notas cargadas en DB.notebookNotes`);
                console.log('📊 Muestra de IDs cargados:', allNotes.slice(0, 5).map(n => `${n.id} (${typeof n.id}) - ${n.title}`));
            } catch (error) {
                console.error('❌ Error cargando todas las notas:', error);
                DB.notebookNotes = [];
            }
        }

        // Crear carpetas predeterminadas si no existen
        async function createDefaultFolders() {
            // IMPORTANTE: Consultar dexieDB directamente, NO usar DB.notebookFolders de memoria
            const folders = await dexieDB.notebookFolders.toArray();
            const defaultFolders = [
                { name: 'Operaciones', icon: '📁' },
                { name: 'Playbook', icon: '📁' },
                { name: 'Daily Journal', icon: '📁' },
                { name: 'Análisis del Mes', icon: '📁' },
                { name: 'Análisis de la Semana', icon: '📁' },
                { name: 'Análisis de Trimestre', icon: '📁' },
                { name: 'Ideas', icon: '📁' },
                { name: 'Notas Generales', icon: '📁' },
                { name: 'Contexto general', icon: '📁' }
            ];

            // Solo crear las carpetas que NO existen
            for (const defFolder of defaultFolders) {
                const exists = folders.some(f => f.name === defFolder.name);
                if (!exists) {
                    console.log(`📂 Creando carpeta faltante: ${defFolder.name}`);
                    await createFolder(defFolder.name, defFolder.icon);
                }
            }
        }

        // Cargar carpetas desde la base de datos
        async function loadFolders() {
        try {
            // Desde IndexedDB
            const folders = await dexieDB.notebookFolders.toArray();
            DB.notebookFolders = folders;

            // Desde Supabase
            if (window.supabase && window.userId) {
                const { data, error } = await supabase
                    .from('notebook_folders')
                    .select('*')
                    .eq('user_id', userId)
                    .order('created_at', { ascending: true });

                if (!error && data) {
                    // Sincronizar
                    for (const folder of data) {
                        await dexieDB.notebookFolders.put(folder);
                    }
                    DB.notebookFolders = data;
                }
            }

            renderFolders();
            await updateFolderCounts(); // Actualizar conteos después de renderizar carpetas
        } catch (error) {
            console.error('Error cargando carpetas:', error);
        }
    }

    // Renderizar lista de carpetas
    function renderFolders() {
        const container = document.getElementById('folders-list');
        if (!container) return;

        const folders = DB.notebookFolders || [];
        const systemFolders = ['Daily Journal', 'Operaciones', 'Playbook', 'Ideas de Trading'];
        
        container.innerHTML = folders.map(folder => {
            const isSystemFolder = systemFolders.includes(folder.name);
            return `
            <div class="folder-item px-4 py-2 rounded-lg cursor-pointer hover:bg-surface-light transition-colors flex items-center gap-2 whitespace-nowrap ${currentFolder && currentFolder.id === folder.id ? 'bg-primary text-white' : 'bg-surface-light'}" 
                 data-folder-id="${folder.id}">
                <span class="text-xl">${folder.icon || '📁'}</span>
                <span class="font-medium">${folder.name}</span>
                <span class="text-xs px-2 py-0.5 rounded-full bg-surface" id="folder-count-${folder.id}">0</span>
                ${!isSystemFolder ? `<button class="delete-folder-btn hover:text-danger ml-2" data-folder-id="${folder.id}" onclick="event.stopPropagation()">
                    <i class="fas fa-times text-sm"></i>
                </button>` : ''}
            </div>
            `;
        }).join('');

        // Event listeners
        document.querySelectorAll('.folder-item').forEach(item => {
            item.addEventListener('click', function(e) {
                if (e.target.closest('.delete-folder-btn')) return;
                const folderId = this.dataset.folderId; // NO convertir a int, mantener como string
                console.log('🖱️ Click en carpeta:', folderId);
                selectFolder(folderId);
            });
        });

        document.querySelectorAll('.delete-folder-btn').forEach(btn => {
            btn.addEventListener('click', async function(e) {
                e.stopPropagation();
                const folderId = this.dataset.folderId; // NO convertir a int
                if (confirm('¿Eliminar esta carpeta y todas sus notas?')) {
                    await deleteFolder(folderId);
                }
            });
        });

        // Actualizar contadores
        (async () => await updateFolderCounts())();
    }

    // Actualizar contador de notas por carpeta
    async function updateFolderCounts() {
        // IMPORTANTE: Consultar dexieDB directamente para obtener datos persistentes
        const notes = await dexieDB.notebookNotes.toArray();
        const folders = await dexieDB.notebookFolders.toArray();

        folders.forEach(folder => {
            const count = notes.filter(n => n.folder_id === folder.id).length;
            const countEl = document.getElementById(`folder-count-${folder.id}`);
            if (countEl) countEl.textContent = count;
        });
    }

    // FUNCIÓN GLOBAL: Notificar a Notebook cuando se crea una nota desde Daily Journal
    window.notifyNotebookNewNote = async function(folderId) {
        console.log('📢 [Notebook] Notificada creación de nota en carpeta:', folderId);
        
        // Recargar notas si la carpeta actual es la afectada
        if (currentFolder && currentFolder.id === folderId) {
            console.log('📂 Recargando notas de carpeta actual...');
            await loadNotes(folderId);
        }
        
        // Actualizar conteos
        await updateFolderCounts();
    };

    // FUNCIÓN GLOBAL: Actualizar contadores de notas en todas las carpetas
    window.notebookNotesUpdated = async function() {
        console.log('📢 [Notebook] Actualizando contadores de carpetas...');
        await updateFolderCounts();
    };

    // Seleccionar carpeta
    async function selectFolder(folderId) {
        console.log('📂 [selectFolder] Buscando carpeta con ID:', folderId, '(tipo:', typeof folderId, ')');
        console.log('📂 [selectFolder] Carpetas disponibles:', DB.notebookFolders?.map(f => `${f.id} (${typeof f.id}) - ${f.name}`));
        
        const folder = (DB.notebookFolders || []).find(f => f.id === folderId || f.id == folderId); // Comparación flexible
        
        if (!folder) {
            console.error('❌ [selectFolder] Carpeta no encontrada:', folderId);
            return;
        }

        console.log('✅ [selectFolder] Carpeta seleccionada:', folder.name, folder.id);
        currentFolder = folder;
        renderFolders();
        await loadNotes(folderId);
    }
    
    // Exponer función globalmente para acceso desde otras secciones
    window.notebookSelectFolder = selectFolder;

    // Cargar notas de una carpeta
    async function loadNotes(folderId) {
        try {
            console.log('📂 [loadNotes] Cargando notas de carpeta:', folderId);
            
            // Primero sincronizar con Supabase si es necesario
            if (window.supabase && window.userId) {
                const { data, error } = await supabase
                    .from('notebook_notes')
                    .select('*')
                    .eq('user_id', userId)
                    .eq('folder_id', folderId)
                    .order('updated_at', { ascending: false });

                if (!error && data) {
                    console.log('☁️ [loadNotes] Notas desde Supabase:', data.length);
                    for (const note of data) {
                        await dexieDB.notebookNotes.put(note);
                        // Actualizar en memoria también
                        const existingIndex = DB.notebookNotes.findIndex(n => n.id === note.id);
                        if (existingIndex >= 0) {
                            DB.notebookNotes[existingIndex] = note;
                        } else {
                            DB.notebookNotes.push(note);
                        }
                    }
                } else if (error) {
                    console.error('❌ [loadNotes] Error Supabase:', error);
                }
            }
            
            // Ahora cargar desde IndexedDB (que ya está sincronizado)
            const notesInDB = await dexieDB.notebookNotes
                .where('folder_id')
                .equals(folderId)
                .toArray();
            
            console.log('💾 [loadNotes] Notas desde IndexedDB:', notesInDB.length);
            
            // Actualizar DB.notebookNotes en memoria con las notas de esta carpeta
            // Eliminar las notas viejas de esta carpeta
            DB.notebookNotes = DB.notebookNotes.filter(n => n.folder_id !== folderId);
            // Agregar las notas actualizadas
            DB.notebookNotes.push(...notesInDB);
            
            console.log('📂 [loadNotes] Total de notas en carpeta', folderId, ':', notesInDB.length);
            
            if (notesInDB.length > 0) {
                console.log('📋 [loadNotes] Primera nota:', {
                    id: notesInDB[0].id,
                    title: notesInDB[0].title,
                    preview: notesInDB[0].content?.substring(0, 50)
                });
            }

            renderNotes();
        } catch (error) {
            console.error('❌ [loadNotes] Error cargando notas:', error);
            console.error('Stack trace:', error.stack);
        }
    }

    // Renderizar lista de notas
    function renderNotes() {
        const container = document.getElementById('notes-list');
        if (!container) return;

        // Filtrar solo las notas de la carpeta actual
        const notes = (DB.notebookNotes || []).filter(n => n.folder_id === currentFolder?.id);

        if (notes.length === 0) {
            container.innerHTML = `
                <div class="text-center p-8 text-text-secondary">
                    <i class="fas fa-sticky-note text-4xl mb-3 opacity-20"></i>
                    <p class="text-sm">No hay notas en esta carpeta</p>
                </div>
            `;
            return;
        }

        container.innerHTML = notes.map(note => {
            const preview = note.content ? stripHtml(note.content).substring(0, 100) : 'Sin contenido';
            const date = new Date(note.updated_at).toLocaleDateString('es-ES', { month: 'short', day: 'numeric' });

            console.log('📋 [renderNotes] Renderizando nota:', note.id, 'Título:', note.title);

            return `
                <div class="note-item p-3 rounded cursor-pointer hover:bg-surface-light transition-colors mb-2 ${currentNote && currentNote.id === note.id ? 'bg-primary bg-opacity-10 border-l-2 border-primary' : ''}" 
                     data-note-id="${note.id}">
                    <div class="flex items-start justify-between mb-1">
                        <h4 class="font-semibold text-sm">${note.title || 'Sin título'}</h4>
                        ${note.is_pinned ? '<i class="fas fa-thumbtack text-primary text-xs"></i>' : ''}
                    </div>
                    <p class="text-xs text-text-secondary line-clamp-2">${preview}</p>
                    <p class="text-xs text-text-secondary mt-1">${date}</p>
                </div>
            `;
        }).join('');

        // Event listeners
        document.querySelectorAll('.note-item').forEach(item => {
            item.addEventListener('click', function() {
                console.log('🖱️ [renderNotes] Click en nota. dataset:', this.dataset);
                console.log('🖱️ [renderNotes] noteId raw:', this.dataset.noteId);
                // NO usar parseInt - los IDs pueden ser strings como "note_op_25005_1769862667931"
                const noteId = this.dataset.noteId;
                console.log('🖱️ [renderNotes] noteId (sin parse):', noteId);
                selectNote(noteId);
            });
        });
    }

    // Seleccionar y mostrar nota
    async function selectNote(noteId) {
        console.log('📝 [selectNote] Seleccionando nota:', noteId, 'Tipo:', typeof noteId);
        
        // FORZAR RECARGA desde IndexedDB si no está en memoria
        if (!(DB.notebookNotes || []).find(n => String(n.id) === String(noteId))) {
            console.log('⚠️ Nota no en memoria, recargando desde IndexedDB...');
            const noteFromDB = await dexieDB.notebookNotes.get(Number(noteId) || noteId);
            if (noteFromDB) {
                console.log('✅ Nota encontrada en IndexedDB, añadiendo a memoria');
                DB.notebookNotes = DB.notebookNotes || [];
                DB.notebookNotes.push(noteFromDB);
            }
        }
        
        // Convertir ambos IDs a String para comparación consistente (número vs string)
        const note = (DB.notebookNotes || []).find(n => String(n.id) === String(noteId));
        
        if (!note) {
            console.log('⚠️ [selectNote] Nota no encontrada:', noteId);
            console.log('📊 [selectNote] Total notas en memoria:', DB.notebookNotes?.length);
            console.log('📊 [selectNote] Todos los IDs:', DB.notebookNotes?.map(n => `${n.id}`).join(', '));
            return;
        }

        console.log('📝 [selectNote] Nota encontrada:', note);
        currentNote = note;
        
        // ACTUALIZAR ESTADO VISUAL DE LAS NOTAS (sin regenerar HTML completo)
        document.querySelectorAll('.note-item').forEach(item => {
            // NO usar parseInt - comparar directamente para soportar string IDs
            const itemId = item.dataset.noteId;
            if (itemId === noteId) {
                item.classList.add('selected');
            } else {
                item.classList.remove('selected');
            }
        });

        // Mostrar editor
        document.getElementById('note-editor-empty').style.display = 'none';
        document.getElementById('note-editor-container').style.display = 'flex';

        // Cargar contenido
        console.log('📝 [selectNote] Cargando contenido:', note.content);
        const titleEl = document.getElementById('note-title');
        const contentEl = document.getElementById('note-content');
        
        if (titleEl) {
            titleEl.value = note.title || '';
            console.log('✅ [selectNote] Título cargado:', titleEl.value);
        }
        
        if (contentEl) {
            // Asegurar que el contenido se cargue correctamente
            contentEl.innerHTML = note.content || '';
            console.log('✅ [selectNote] Contenido cargado - Length:', contentEl.innerHTML.length);
        }
        
        document.getElementById('note-date').textContent = `Creada: ${new Date(note.created_at).toLocaleString('es-ES')}`;
        document.getElementById('note-folder').textContent = `Carpeta: ${currentFolder?.name || '-'}`;
        
        updateWordCount();
    }

    // Crear nueva nota
    async function createNote() {
        if (!currentFolder) {
            alert('Selecciona una carpeta primero');
            return;
        }

        const note = {
            id: Date.now(),
            user_id: window.userId,
            folder_id: currentFolder.id,
            title: 'Nueva nota',
            content: '',
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString(),
            is_pinned: false
        };

        // Guardar en IndexedDB
        await dexieDB.notebookNotes.add(note);
        
        // Guardar en Supabase
        if (window.supabase && window.userId) {
            await supabase.from('notebook_notes').insert([note]);
        }

        // Agregar a memoria
        DB.notebookNotes = DB.notebookNotes || [];
        DB.notebookNotes.unshift(note);

        renderNotes();
        await updateFolderCounts();
        selectNote(note.id);

        // Focus en título
        document.getElementById('note-title').focus();
        document.getElementById('note-title').select();
    }

    // Guardar nota (autosave)
    async function saveNote() {
        if (!currentNote) return;

        const title = document.getElementById('note-title').value;
        const content = document.getElementById('note-content').innerHTML;

        currentNote.title = title || 'Sin título';
        currentNote.content = content;
        currentNote.updated_at = new Date().toISOString();

        try {
            // Guardar en IndexedDB
            await dexieDB.notebookNotes.put(currentNote);
            console.log('💾 [saveNote] Guardando nota:', currentNote.id, currentNote.title);

            // Guardar en Supabase usando UPSERT para manejar insert/update automáticamente
            if (window.supabase && window.userId) {
                const { error } = await supabase
                    .from('notebook_notes')
                    .upsert({
                        id: currentNote.id,
                        user_id: currentNote.user_id,
                        folder_id: currentNote.folder_id,
                        title: currentNote.title,
                        content: currentNote.content,
                        created_at: currentNote.created_at,
                        updated_at: currentNote.updated_at,
                        is_pinned: currentNote.is_pinned || false
                    }, {
                        onConflict: 'id'
                    });
                
                if (error) {
                    console.error('❌ [saveNote] Error guardando en Supabase:', error);
                    document.getElementById('note-updated').textContent = '⚠️ Error guardando';
                    document.getElementById('note-updated').style.color = '#ef4444';
                } else {
                    console.log('✅ [saveNote] Guardado en Supabase correctamente');
                    document.getElementById('note-updated').textContent = '✅ Guardado ' + new Date().toLocaleTimeString('es-ES');
                    document.getElementById('note-updated').style.color = '#10b981';
                }
            } else {
                document.getElementById('note-updated').textContent = '💾 Guardado local ' + new Date().toLocaleTimeString('es-ES');
                document.getElementById('note-updated').style.color = '#3b82f6';
            }

            // Actualizar en DB.notebookNotes
            const noteIndex = (DB.notebookNotes || []).findIndex(n => String(n.id) === String(currentNote.id));
            if (noteIndex >= 0) {
                DB.notebookNotes[noteIndex] = currentNote;
            }

            renderNotes();
            updateFolderCounts(); // Actualizar conteo de carpetas
        } catch (error) {
            console.error('❌ [saveNote] Error guardando nota:', error);
            document.getElementById('note-updated').textContent = '❌ Error: ' + error.message;
            document.getElementById('note-updated').style.color = '#ef4444';
        }
    }

    // Auto-save al editar
    function scheduleAutoSave() {
        clearTimeout(autoSaveTimeout);
        autoSaveTimeout = setTimeout(() => {
            saveNote();
        }, 1000);
    }

    // Eliminar nota
    async function deleteNote() {
        if (!currentNote || !confirm('¿Eliminar esta nota?')) return;

        await dexieDB.notebookNotes.delete(currentNote.id);

        if (window.supabase) {
            await supabase.from('notebook_notes').delete().eq('id', currentNote.id);
        }

        DB.notebookNotes = (DB.notebookNotes || []).filter(n => n.id !== currentNote.id);
        
        currentNote = null;
        document.getElementById('note-editor-empty').style.display = 'flex';
        document.getElementById('note-editor-container').style.display = 'none';

        renderNotes();
        updateFolderCounts();
    }

    // Crear carpeta
    async function createFolder(name, icon = '📁') {
        // VERIFICAR SI YA EXISTE una carpeta con este nombre
        const existing = await dexieDB.notebookFolders.toArray();
        const duplicate = existing.find(f => f.name === name);
        
        if (duplicate) {
            console.log(`⚠️ Carpeta "${name}" ya existe (ID: ${duplicate.id}), saltando creación`);
            return duplicate; // Retornar la existente en lugar de crear duplicado
        }

        const folder = {
            id: Date.now(),
            user_id: window.userId,
            name: name,
            icon: icon,
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString()
        };

        await dexieDB.notebookFolders.add(folder);

        if (window.supabase && window.userId) {
            await supabase.from('notebook_folders').insert([folder]);
        }

        DB.notebookFolders = DB.notebookFolders || [];
        DB.notebookFolders.push(folder);

        renderFolders();
        console.log(`✅ Carpeta "${name}" creada (ID: ${folder.id})`);
        return folder;
    }

    // Eliminar carpeta
    async function deleteFolder(folderId) {
        // Prevenir eliminación de carpetas del sistema
        const folder = await dexieDB.notebookFolders.get(folderId);
        const systemFolders = ['Daily Journal', 'Operaciones', 'Playbook', 'Ideas de Trading'];
        if (folder && systemFolders.includes(folder.name)) {
            showNotification('Las carpetas del sistema no se pueden eliminar', 'warning');
            return;
        }
        
        // Eliminar notas de la carpeta
        const notes = await dexieDB.notebookNotes.where('folder_id').equals(folderId).toArray();
        for (const note of notes) {
            await dexieDB.notebookNotes.delete(note.id);
        }

        // Eliminar carpeta
        await dexieDB.notebookFolders.delete(folderId);

        if (window.supabase) {
            await supabase.from('notebook_notes').delete().eq('folder_id', folderId);
            await supabase.from('notebook_folders').delete().eq('id', folderId);
        }

        DB.notebookFolders = (DB.notebookFolders || []).filter(f => f.id !== folderId);
        DB.notebookNotes = (DB.notebookNotes || []).filter(n => n.folder_id !== folderId);

        if (currentFolder && currentFolder.id === folderId) {
            currentFolder = null;
            currentNote = null;
            document.getElementById('note-editor-empty').style.display = 'flex';
            document.getElementById('note-editor-container').style.display = 'none';
        }

        renderFolders();
        renderNotes();
    }

    // Utilidades
    function stripHtml(html) {
        const tmp = document.createElement('div');
        tmp.innerHTML = html;
        return tmp.textContent || tmp.innerText || '';
    }

    function updateWordCount() {
        const content = document.getElementById('note-content');
        if (!content) return;

        const text = stripHtml(content.innerHTML);
        const words = text.trim().split(/\s+/).length;
        document.getElementById('note-word-count').textContent = `${words} palabra${words !== 1 ? 's' : ''}`;
    }

    // Formateo de texto
    function formatText(command, value = null) {
        document.execCommand(command, false, value);
        document.getElementById('note-content').focus();
        scheduleAutoSave();
    }

    // Pantalla completa para el editor de notas
    function toggleFullscreen() {
        const editorContainer = document.getElementById('note-editor-container');
        const fullscreenBtn = document.getElementById('fullscreen-note-btn');
        const noteContent = document.getElementById('note-content');
        
        if (!editorContainer.classList.contains('fullscreen-note')) {
            // Activar pantalla completa
            editorContainer.classList.add('fullscreen-note');
            fullscreenBtn.innerHTML = '<i class="fas fa-compress"></i>';
            fullscreenBtn.title = 'Salir de pantalla completa';
            
            // Estilos para pantalla completa - completamente opaco
            editorContainer.style.cssText = `
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                right: 0 !important;
                bottom: 0 !important;
                width: 100vw !important;
                height: 100vh !important;
                z-index: 99999 !important;
                background-color: #0f0f0f !important;
                display: flex !important;
                flex-direction: column !important;
                margin: 0 !important;
                padding: 0 !important;
                overflow: hidden !important;
            `;
            
            // Ajustar el contenido para que use todo el espacio
            noteContent.style.cssText = `
                flex: 1 1 auto !important;
                overflow-y: auto !important;
                max-height: none !important;
                height: auto !important;
                padding: 2rem !important;
            `;
        } else {
            // Salir de pantalla completa
            editorContainer.classList.remove('fullscreen-note');
            fullscreenBtn.innerHTML = '<i class="fas fa-expand"></i>';
            fullscreenBtn.title = 'Pantalla completa';
            
            // Restaurar estilos originales
            editorContainer.style.cssText = '';
            noteContent.style.cssText = 'flex: 1; padding: 1.5rem; overflow-y: auto; min-height: 500px; max-height: calc(100vh - 400px);';
        }
    }

    // Insertar imagen
    async function insertImage(file) {
        const reader = new FileReader();
        reader.onload = function(e) {
            const img = document.createElement('img');
            img.src = e.target.result;
            img.style.maxWidth = '100%';
            img.style.margin = '10px 0';
            img.style.borderRadius = '8px';
            
            const content = document.getElementById('note-content');
            content.appendChild(img);
            scheduleAutoSave();
        };
        reader.readAsDataURL(file);
    }

    // Grabación de voz
    async function startRecording() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            mediaRecorder = new MediaRecorder(stream);
            audioChunks = [];

            mediaRecorder.ondataavailable = (e) => {
                audioChunks.push(e.data);
            };

            mediaRecorder.onstop = () => {
                const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                const audioUrl = URL.createObjectURL(audioBlob);
                document.getElementById('audio-playback').src = audioUrl;
                document.getElementById('audio-preview').classList.remove('hidden');
            };

            mediaRecorder.start();
            recordingStartTime = Date.now();

            document.getElementById('recording-indicator').classList.remove('hidden');
            document.getElementById('start-recording-btn').classList.add('hidden');
            document.getElementById('stop-recording-btn').classList.remove('hidden');

            // Timer
            recordingInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
                const mins = Math.floor(elapsed / 60).toString().padStart(2, '0');
                const secs = (elapsed % 60).toString().padStart(2, '0');
                document.getElementById('recording-time').textContent = `${mins}:${secs}`;
            }, 1000);

        } catch (error) {
            console.error('Error accediendo al micrófono:', error);
            alert('No se pudo acceder al micrófono');
        }
    }

    function stopRecording() {
        if (mediaRecorder && mediaRecorder.state !== 'inactive') {
            mediaRecorder.stop();
            mediaRecorder.stream.getTracks().forEach(track => track.stop());
            clearInterval(recordingInterval);

            document.getElementById('recording-indicator').classList.add('hidden');
            document.getElementById('start-recording-btn').classList.remove('hidden');
            document.getElementById('stop-recording-btn').classList.add('hidden');
        }
    }

    function saveAudio() {
        const audioEl = document.getElementById('audio-playback');
        if (!audioEl.src) return;

        const content = document.getElementById('note-content');
        const audio = document.createElement('audio');
        audio.src = audioEl.src;
        audio.controls = true;
        audio.style.width = '100%';
        audio.style.margin = '10px 0';

        content.appendChild(audio);
        
        closeModal('voice-recorder-modal');
        resetRecorder();
        scheduleAutoSave();
    }

    function resetRecorder() {
        document.getElementById('audio-preview').classList.add('hidden');
        document.getElementById('audio-playback').src = '';
        document.getElementById('recording-time').textContent = '00:00';
    }

        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }

        // Event Listeners
        document.getElementById('new-folder-btn')?.addEventListener('click', () => {
            document.getElementById('new-folder-modal').style.display = 'flex';
            document.getElementById('folder-name-input').value = '';
            document.getElementById('selected-folder-icon').value = '📁';
        });

        document.getElementById('new-note-btn')?.addEventListener('click', createNote);

        document.getElementById('save-folder-btn')?.addEventListener('click', async () => {
            const name = document.getElementById('folder-name-input').value.trim();
            const icon = document.getElementById('selected-folder-icon').value;

            if (!name) {
                alert('Ingresa un nombre para la carpeta');
                return;
            }

            await createFolder(name, icon);
            closeModal('new-folder-modal');
        });

        document.querySelectorAll('.folder-icon-option').forEach(btn => {
            btn.addEventListener('click', function() {
                document.getElementById('selected-folder-icon').value = this.dataset.icon;
                document.querySelectorAll('.folder-icon-option').forEach(b => b.classList.remove('bg-primary', 'bg-opacity-20'));
                this.classList.add('bg-primary', 'bg-opacity-20');
            });
        });

        // Editor de notas
        document.getElementById('note-title')?.addEventListener('input', scheduleAutoSave);
        document.getElementById('note-content')?.addEventListener('input', () => {
            updateWordCount();
            scheduleAutoSave();
        });

        // Toolbar
        document.getElementById('bold-btn')?.addEventListener('click', () => formatText('bold'));
        document.getElementById('italic-btn')?.addEventListener('click', () => formatText('italic'));
        document.getElementById('underline-btn')?.addEventListener('click', () => formatText('underline'));
        document.getElementById('h1-btn')?.addEventListener('click', () => formatText('formatBlock', '<h1>'));
        document.getElementById('h2-btn')?.addEventListener('click', () => formatText('formatBlock', '<h2>'));
        document.getElementById('h3-btn')?.addEventListener('click', () => formatText('formatBlock', '<h3>'));
        document.getElementById('ul-btn')?.addEventListener('click', () => formatText('insertUnorderedList'));
        document.getElementById('ol-btn')?.addEventListener('click', () => formatText('insertOrderedList'));

        document.getElementById('image-btn')?.addEventListener('click', () => {
            document.getElementById('image-upload').click();
        });

        document.getElementById('image-upload')?.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) insertImage(file);
        });

        document.getElementById('voice-btn')?.addEventListener('click', () => {
            document.getElementById('voice-recorder-modal').style.display = 'flex';
            resetRecorder();
        });

        document.getElementById('delete-note-btn')?.addEventListener('click', deleteNote);

        // Pantalla completa
        document.getElementById('fullscreen-note-btn')?.addEventListener('click', toggleFullscreen);

        // Voice recorder
        document.getElementById('start-recording-btn')?.addEventListener('click', startRecording);
        document.getElementById('stop-recording-btn')?.addEventListener('click', stopRecording);
        document.getElementById('save-audio-btn')?.addEventListener('click', saveAudio);
        document.getElementById('cancel-audio-btn')?.addEventListener('click', () => {
            closeModal('voice-recorder-modal');
            resetRecorder();
        });

        // Búsqueda
        document.getElementById('search-notes')?.addEventListener('input', function(e) {
            const query = e.target.value.toLowerCase();
            const notes = DB.notebookNotes || [];
            
            if (!query) {
                renderNotes();
                return;
            }

            const filtered = notes.filter(note => 
                note.title.toLowerCase().includes(query) ||
                stripHtml(note.content).toLowerCase().includes(query)
            );

            DB.notebookNotes = filtered;
            renderNotes();
        });

        // FUNCIÓN GLOBAL: Notificar a Notebook cuando se crea una nota desde Daily Journal
        window.notifyNotebookNewNote = async function(folderId) {
            console.log('📢 [Notebook] Notificada creación de nota en carpeta:', folderId);
            
            // Recargar carpetas por si es nueva
            await loadFolders();
            
            // Recargar notas si la carpeta actual es la afectada
            if (currentFolder && currentFolder.id === folderId) {
                console.log('📂 Recargando notas de carpeta actual...');
                await loadNotes(folderId);
            }
            
            // Actualizar conteos
            updateFolderCounts();
        };

        // Cerrar modales
        document.querySelectorAll('.close-modal').forEach(btn => {
            btn.addEventListener('click', function() {
                const modalId = this.dataset.modal;
                closeModal(modalId);
            });
        });

        // Inicializar
        initNotebook();

        console.log('✅ Notebook inicializado');
    }
});

// =============================================
// MODAL ASIGNAR SETUP A OPERACIÓN
// =============================================
(function() {
    const modal = document.getElementById('assign-setup-modal');
    const closeBtn = document.getElementById('close-assign-setup-modal');
    const cancelBtn = document.getElementById('cancel-assign-setup-btn');
    const removeBtn = document.getElementById('remove-setup-btn');
    const setupList = document.getElementById('assign-setup-list');
    const operationIdInput = document.getElementById('assign-setup-operation-id');

    // Función global para abrir el modal
    window.openAssignSetupModal = function(operationId) {
        const operation = DB.operations.find(op => op.id === operationId);
        if (!operation) {
            console.error('Operación no encontrada:', operationId);
            return;
        }

        operationIdInput.value = operationId;
        
        // Mostrar u ocultar botón de remover según si tiene setup
        const hasSetup = operation.setupId || operation.setupUsed;
        removeBtn.style.display = hasSetup ? 'block' : 'none';
        
        renderSetupList(operation);
        modal.style.display = 'flex';
    };

    function renderSetupList(operation) {
        if (!setupList) return;
        
        const currentSetupId = operation.setupId || operation.setupUsed;
        const activeSetups = DB.setups || [];
        
        if (activeSetups.length === 0) {
            setupList.innerHTML = `
                <div class="text-center py-8 text-text-secondary">
                    <i class="fas fa-book text-4xl mb-3 opacity-50"></i>
                    <p>No tienes setups en tu Playbook</p>
                    <p class="text-xs mt-2">Crea tu primer setup desde la sección Playbook</p>
                </div>
            `;
            return;
        }

        setupList.innerHTML = activeSetups.map(setup => {
            const isSelected = setup.id === currentSetupId;
            return `
                <div class="setup-option metric-card p-4 cursor-pointer hover:border-primary transition-all ${isSelected ? 'border-primary bg-surface-light' : ''}"
                     data-setup-id="${setup.id}">
                    <div class="flex items-center justify-between">
                        <div class="flex-1">
                            <div class="flex items-center gap-2">
                                ${isSelected ? '<i class="fas fa-check-circle text-primary"></i>' : '<i class="far fa-circle text-text-secondary"></i>'}
                                <h4 class="font-semibold text-white">${setup.name}</h4>
                            </div>
                            <div class="flex items-center gap-3 mt-2 text-xs text-text-secondary">
                                <span class="px-2 py-1 rounded bg-surface-light">${setup.category || 'Sin categoría'}</span>
                                <span>${'⭐'.repeat(setup.rating || 0)}</span>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }).join('');

        // Agregar event listeners a las opciones
        setupList.querySelectorAll('.setup-option').forEach(option => {
            option.addEventListener('click', async function() {
                const setupId = this.dataset.setupId;
                await assignSetupToOperation(operationIdInput.value, setupId);
            });
        });
    }

    async function assignSetupToOperation(operationId, setupId) {
        try {
            showLoading(true);
            
            const operation = DB.operations.find(op => op.id === operationId);
            if (!operation) {
                throw new Error('Operación no encontrada');
            }

            // Actualizar operación con el setup
            operation.setupId = setupId;
            operation.setupUsed = setupId;
            
            // Guardar en Dexie
            await dexieDB.operations.put(operation);
            
            // Guardar en Supabase
            if (typeof saveOperationToSupabase === 'function') {
                await saveOperationToSupabase(operation);
            }
            
            // Cerrar modal
            modal.style.display = 'none';
            
            // Refrescar vistas
            refreshOperationsTable();
            if (typeof window.refreshPlaybook === 'function') {
                window.refreshPlaybook();
            }
            
            showNotification('Setup asignado correctamente', 'success');
        } catch (error) {
            console.error('Error asignando setup:', error);
            showNotification('Error al asignar setup', 'error');
        } finally {
            showLoading(false);
        }
    }

    async function removeSetupFromOperation() {
        const operationId = operationIdInput.value;
        if (!operationId) return;

        try {
            showLoading(true);
            
            const operation = DB.operations.find(op => op.id === operationId);
            if (!operation) {
                throw new Error('Operación no encontrada');
            }

            // Remover setup
            delete operation.setupId;
            delete operation.setupUsed;
            
            // Guardar en Dexie
            await dexieDB.operations.put(operation);
            
            // Guardar en Supabase
            if (typeof saveOperationToSupabase === 'function') {
                await saveOperationToSupabase(operation);
            }
            
            // Cerrar modal
            modal.style.display = 'none';
            
            // Refrescar vistas
            refreshOperationsTable();
            if (typeof window.refreshPlaybook === 'function') {
                window.refreshPlaybook();
            }
            
            showNotification('Setup removido correctamente', 'success');
        } catch (error) {
            console.error('Error removiendo setup:', error);
            showNotification('Error al remover setup', 'error');
        } finally {
            showLoading(false);
        }
    }

    // Event listeners
    closeBtn?.addEventListener('click', () => {
        modal.style.display = 'none';
    });

    cancelBtn?.addEventListener('click', () => {
        modal.style.display = 'none';
    });

    removeBtn?.addEventListener('click', async () => {
        if (confirm('¿Estás seguro de quitar el setup de esta operación?')) {
            await removeSetupFromOperation();
        }
    });

    // Cerrar al hacer click fuera del modal
    modal?.addEventListener('click', function(e) {
        if (e.target === modal) {
            modal.style.display = 'none';
        }
    });
})();

// =============================================
// TRADINGVIEW SIMPLE IFRAME (SIEMPRE FUNCIONA)
// =============================================

window.loadTradingViewChart = function(operation) {
    console.log('📊 Cargando gráfico avanzado para:', operation.instrument);

    // Guardar operación actual para referencia global
    currentOperationForChart = operation;

    // Actualizar información del panel
    updateChartInfo(operation);

    // Obtener todas las operaciones relacionadas
    let relatedOperations = [];
    if (operation.csvId) {
        relatedOperations = DB.operations.filter(op => op.csvId === operation.csvId);
    } else {
        relatedOperations = [operation];
    }
    
    // Guardar operación y relacionadas para fallback
    window.currentOperationForChart = {
        operation: operation,
        relatedOps: relatedOperations
    };

    // Crear directamente el gráfico avanzado
    if (typeof TradingView !== 'undefined') {
        createTradingViewWidget(operation, relatedOperations);
    } else {
        createLightweightChartWithMarkers(operation, relatedOperations);
    }

    // Mostrar panel de información en esquina derecha
    displayTradeMarkers(operation, relatedOperations);
    
    console.log('✅ Gráfico avanzado cargado');
}

// Función para intentar inyectar marcadores en el iframe
function injectMarkersIntoIframe(iframe, drawingsArray) {
    try {
        // Esta función intenta comunicarse con el iframe de TradingView
        // Nota: Esto puede estar limitado por CORS, pero vale la pena intentarlo
        
        const iframeWindow = iframe.contentWindow;
        if (iframeWindow && drawingsArray.length > 0) {
            
            // Enviar mensaje al iframe con los marcadores
            const message = {
                name: 'add-markers',
                data: drawingsArray
            };
            
            iframeWindow.postMessage(message, 'https://s.tradingview.com');
            console.log('📤 Marcadores enviados al iframe');
            
        }
    } catch (error) {
        console.log('ℹ️ No se pudo inyectar marcadores en iframe (CORS esperado)');
    }
}

// Función alternativa para mostrar información de entrada/salida en esquina derecha
function displayTradeMarkers(operation, relatedOperations) {
    const chartInfo = document.querySelector('.chart-info');
    if (!chartInfo) return;
    
    // Crear o actualizar panel de marcadores en esquina derecha
    let markersPanel = document.getElementById('trade-markers-panel');
    if (!markersPanel) {
        markersPanel = document.createElement('div');
        markersPanel.id = 'trade-markers-panel';
        markersPanel.className = 'absolute top-4 right-4 bg-black bg-opacity-90 text-white text-xs p-3 rounded-lg border border-gray-600 max-w-xs z-20 shadow-lg';
        chartInfo.appendChild(markersPanel);
    }
    
    let markersHTML = '<div class="font-semibold mb-3 text-primary">📍 Puntos de Entrada/Salida</div>';
    
    // Cartel CFD eliminado por solicitud del usuario
    
    relatedOperations.forEach((op, index) => {
        const precision = getInstrumentPrecision(op.instrument);
        const entryColor = op.type === 'buy' ? '#10B981' : '#EF4444';
        const exitColor = op.pl >= 0 ? '#10B981' : '#EF4444';
        
        markersHTML += `
            <div class="mb-3 p-2 border border-gray-600 rounded bg-black bg-opacity-50">
                <div class="font-medium text-primary mb-2">${index === 0 ? 'Principal' : `Parcial ${index}`}</div>
                <div class="space-y-1">
                    <div class="flex justify-between items-center text-xs">
                        <span style="color: ${entryColor}">▲ Entrada:</span>
                        <span class="font-medium">${op.entryTime || '--'}</span>
                    </div>
                    <div class="flex justify-between items-center text-xs">
                        <span class="text-gray-400">Precio:</span>
                        <span class="font-medium">${op.entry ? op.entry.toFixed(precision) : '--'}</span>
                    </div>
                    <div class="flex justify-between items-center text-xs">
                        <span style="color: ${exitColor}">▼ Salida:</span>
                        <span class="font-medium">${op.exitTime || '--'}</span>
                    </div>
                    <div class="flex justify-between items-center text-xs">
                        <span class="text-gray-400">Precio:</span>
                        <span class="font-medium">${op.exit ? op.exit.toFixed(precision) : '--'}</span>
                    </div>
                    <div class="text-center text-xs mt-2 p-1 rounded" style="background-color: ${exitColor}20; color: ${exitColor}">
                        <strong>${formatCurrency(op.pl, op.currency, op.currency)}</strong>
                    </div>
                </div>
            </div>
        `;
    });
    
    markersPanel.innerHTML = markersHTML;
}

// ========== SISTEMA DE MÚLTIPLES FUENTES DE DATOS GRATUITAS ==========

// Mapeo de símbolos a diferentes exchanges/fuentes
const SYMBOL_MAPPINGS = {
    // Crypto pairs - formato normalizado
    'BTCUSDT': { binance: 'BTCUSDT', coingecko: 'bitcoin', yahoo: 'BTC-USD', tradingview: 'BINANCE:BTCUSDT' },
    'ETHUSDT': { binance: 'ETHUSDT', coingecko: 'ethereum', yahoo: 'ETH-USD', tradingview: 'BINANCE:ETHUSDT' },
    'BNBUSDT': { binance: 'BNBUSDT', coingecko: 'binancecoin', yahoo: 'BNB-USD', tradingview: 'BINANCE:BNBUSDT' },
    'XRPUSDT': { binance: 'XRPUSDT', coingecko: 'ripple', yahoo: 'XRP-USD', tradingview: 'BINANCE:XRPUSDT' },
    'ADAUSDT': { binance: 'ADAUSDT', coingecko: 'cardano', yahoo: 'ADA-USD', tradingview: 'BINANCE:ADAUSDT' },
    'SOLUSDT': { binance: 'SOLUSDT', coingecko: 'solana', yahoo: 'SOL-USD', tradingview: 'BINANCE:SOLUSDT' },
    'DOGEUSDT': { binance: 'DOGEUSDT', coingecko: 'dogecoin', yahoo: 'DOGE-USD', tradingview: 'BINANCE:DOGEUSDT' },
    'MATICUSDT': { binance: 'MATICUSDT', coingecko: 'matic-network', yahoo: 'MATIC-USD', tradingview: 'BINANCE:MATICUSDT' },
};

// Función para normalizar símbolo a formato estándar
function normalizeSymbol(instrument) {
    if (!instrument) return null;
    
    const clean = instrument.toUpperCase().replace(/[^A-Z0-9]/g, '');
    
    // Detectar pares crypto comunes
    if (clean.endsWith('USDT')) return clean;
    if (clean.endsWith('USD')) return clean;
    if (clean.endsWith('BTC')) return clean;
    
    // Para otros símbolos, devolver tal cual
    return clean;
}

// Función para obtener datos de Binance API (GRATUITA)
async function fetchBinanceData(symbol, interval = '5m', limit = 500) {
    try {
        const normalized = normalizeSymbol(symbol);
        console.log(`🔄 Intentando obtener datos de Binance: ${normalized}`);
        
        const url = `https://api.binance.com/api/v3/klines?symbol=${normalized}&interval=${interval}&limit=${limit}`;
        const response = await fetch(url);
        
        if (!response.ok) {
            throw new Error(`Binance API error: ${response.status}`);
        }
        
        const data = await response.json();
        
        // Convertir formato Binance a formato estándar
        const candlesticks = data.map(candle => ({
            time: candle[0] / 1000, // timestamp en segundos
            open: parseFloat(candle[1]),
            high: parseFloat(candle[2]),
            low: parseFloat(candle[3]),
            close: parseFloat(candle[4]),
            volume: parseFloat(candle[5])
        }));
        
        console.log(`✅ Datos obtenidos de Binance: ${candlesticks.length} velas`);
        return { success: true, data: candlesticks, source: 'Binance' };
        
    } catch (error) {
        console.log(`⚠️ Binance falló para ${symbol}:`, error.message);
        return { success: false, error: error.message };
    }
}

// Función para obtener datos de CoinGecko API (GRATUITA)
async function fetchCoinGeckoData(symbol) {
    try {
        const mapping = SYMBOL_MAPPINGS[normalizeSymbol(symbol)];
        if (!mapping || !mapping.coingecko) {
            return { success: false, error: 'Símbolo no mapeado en CoinGecko' };
        }
        
        console.log(`🔄 Intentando obtener datos de CoinGecko: ${mapping.coingecko}`);
        
        const url = `https://api.coingecko.com/api/v3/coins/${mapping.coingecko}/market_chart?vs_currency=usd&days=7&interval=hourly`;
        const response = await fetch(url);
        
        if (!response.ok) {
            throw new Error(`CoinGecko API error: ${response.status}`);
        }
        
        const data = await response.json();
        
        // Convertir a formato de velas (aproximado, CoinGecko solo da precios)
        const candlesticks = data.prices.map((price, i) => ({
            time: price[0] / 1000,
            open: price[1],
            high: price[1] * 1.001,
            low: price[1] * 0.999,
            close: price[1],
            volume: data.total_volumes[i]?.[1] || 0
        }));
        
        console.log(`✅ Datos obtenidos de CoinGecko: ${candlesticks.length} puntos`);
        return { success: true, data: candlesticks, source: 'CoinGecko' };
        
    } catch (error) {
        console.log(`⚠️ CoinGecko falló para ${symbol}:`, error.message);
        return { success: false, error: error.message };
    }
}

// Función para obtener datos de MEXC API (GRATUITA)
async function fetchMEXCData(symbol, interval = '5m', limit = 500) {
    try {
        const normalized = normalizeSymbol(symbol);
        console.log(`🔄 Intentando obtener datos de MEXC: ${normalized}`);
        
        const url = `https://api.mexc.com/api/v3/klines?symbol=${normalized}&interval=${interval}&limit=${limit}`;
        const response = await fetch(url);
        
        if (!response.ok) {
            throw new Error(`MEXC API error: ${response.status}`);
        }
        
        const data = await response.json();
        
        const candlesticks = data.map(candle => ({
            time: candle[0] / 1000,
            open: parseFloat(candle[1]),
            high: parseFloat(candle[2]),
            low: parseFloat(candle[3]),
            close: parseFloat(candle[4]),
            volume: parseFloat(candle[5])
        }));
        
        console.log(`✅ Datos obtenidos de MEXC: ${candlesticks.length} velas`);
        return { success: true, data: candlesticks, source: 'MEXC' };
        
    } catch (error) {
        console.log(`⚠️ MEXC falló para ${symbol}:`, error.message);
        return { success: false, error: error.message };
    }
}

// Función principal con fallback automático entre múltiples fuentes
async function fetchMultiSourceChartData(operation) {
    const instrument = operation.instrument || '';
    console.log(`🔍 Buscando datos para: ${instrument}`);
    
    // Detectar tipo de mercado
    const marketInfo = detectMarketType(operation);
    console.log(`   Tipo de mercado detectado: ${marketInfo.type}`);
    
    // Estrategia según tipo de mercado
    if (marketInfo.type === 'CRYPTO') {
        // Para CRYPTO: Intentar Binance -> MEXC -> CoinGecko
        console.log('   📊 Usando fuentes crypto: Binance, MEXC, CoinGecko');
        const sources = [
            () => fetchBinanceData(instrument),
            () => fetchMEXCData(instrument),
            () => fetchCoinGeckoData(instrument)
        ];
        
        for (const sourceFn of sources) {
            const result = await sourceFn();
            if (result.success) {
                return result;
            }
        }
    } else if (marketInfo.type === 'FUTURES' || marketInfo.type === 'FOREX' || marketInfo.type === 'STOCK') {
        // Para FUTUROS/FOREX/STOCKS: TradingView es la mejor opción
        // Intentar con APIs alternativas solo si están disponibles
        console.log(`   📊 Mercado ${marketInfo.type}: usando solo TradingView widget (sin API gratuita disponible)`);
        return { 
            success: false, 
            error: `No hay APIs gratuitas para ${marketInfo.type}. Use TradingView widget.`,
            requiresTradingView: true
        };
    } else {
        // Mercado desconocido, intentar crypto por defecto
        console.log('   ⚠️ Mercado desconocido, intentando fuentes crypto...');
        const sources = [
            () => fetchBinanceData(instrument),
            () => fetchMEXCData(instrument)
        ];
        
        for (const sourceFn of sources) {
            const result = await sourceFn();
            if (result.success) {
                return result;
            }
        }
    }
    
    console.error(`❌ Ninguna fuente pudo proporcionar datos para ${instrument}`);
    return { success: false, error: 'Todas las fuentes fallaron' };
}

// Variables globales para gráficos
let tradingViewWidget = null;
let lightweightChart = null;
let currentOperationForChart = null;

// Función para detectar el tipo de mercado basado en el instrumento y broker
function detectMarketType(operation) {
    const instrument = (operation.instrument || '').toUpperCase();
    const subaccount = (operation.subaccount_name || '').toLowerCase();
    const broker = (operation.broker || '').toLowerCase();
    
    // **PRIORIDAD 1: Detectar CFDs de ÍNDICES/COMMODITIES** (MT5, cTrader, OANDA, etc.)
    // Estos brokers usan nomenclatura como NAS100, US30, SPX500, XAUUSD, etc.
    const isCFDBroker = subaccount.includes('metatrader') || subaccount.includes('mt5') || 
                        subaccount.includes('mt4') || subaccount.includes('ctrader') ||
                        subaccount.includes('oanda') || subaccount.includes('pepperstone') ||
                        subaccount.includes('ic markets') || subaccount.includes('blackbull') ||
                        broker.includes('metatrader') || broker.includes('oanda');
    
    const isCFDIndex = instrument.includes('NAS100') || instrument.includes('US100') ||  // NASDAQ
                       instrument.includes('SPX500') || instrument.includes('US500') ||   // S&P 500
                       instrument.includes('US30') || instrument.includes('DJ30') ||      // Dow Jones
                       instrument.includes('US2000') || instrument.includes('RUS2000') || // Russell
                       instrument.includes('DAX') || instrument.includes('GER') ||        // DAX
                       instrument.includes('FTSE') || instrument.includes('UK100') ||     // FTSE
                       instrument.includes('CAC') || instrument.includes('FRA40');        // CAC
    
    const isCFDCommodity = instrument.includes('XAUUSD') || instrument.includes('GOLD') ||  // Oro
                           instrument.includes('XAGUSD') || instrument.includes('SILVER') || // Plata
                           instrument.includes('WTIUSD') || instrument.includes('BRENT') ||  // Petróleo
                           instrument.includes('NATGAS');                                    // Gas
    
    // Si es un metal precioso o commodity, SIEMPRE es CFD independiente del broker
    if (isCFDCommodity || isCFDIndex) {
        return {
            type: 'CFD',
            exchanges: ['OANDA', 'FX_IDC', 'CAPITALCOM'],
            preferredExchange: 'OANDA'
        };
    }
    
    if (isCFDBroker && (isCFDIndex || isCFDCommodity)) {
        return {
            type: 'CFD',
            exchanges: ['OANDA', 'FX_IDC', 'CAPITALCOM'],
            preferredExchange: 'OANDA'
        };
    }
    
    // **PRIORIDAD 2: Detectar FUTUROS** (NinjaTrader, TopstepX, etc.)
    // Detectar por broker/subcuenta o por símbolos conocidos de futuros
    if (subaccount.includes('ninjatrader') || subaccount.includes('tradovate') ||
        subaccount.includes('futures') || subaccount.includes('topstep') ||
        broker.includes('ninjatrader') || broker.includes('topstep') ||
        // E-mini y Micro E-mini futuros
        instrument.startsWith('NQ') || instrument.startsWith('MNQ') ||  // NASDAQ
        instrument.startsWith('ES') || instrument.startsWith('MES') ||  // S&P 500
        instrument.startsWith('YM') || instrument.startsWith('MYM') ||  // Dow Jones
        instrument.startsWith('RTY') || instrument.startsWith('M2K') || // Russell 2000
        // Commodities
        instrument.startsWith('CL') || instrument.startsWith('MCL') ||  // Crude Oil
        instrument.startsWith('GC') || instrument.startsWith('MGC') ||  // Gold
        instrument.startsWith('SI') || instrument.startsWith('SIL') ||  // Silver
        instrument.startsWith('NG') || instrument.startsWith('MNG')) {  // Natural Gas
        return {
            type: 'FUTURES',
            exchanges: ['CME', 'CBOT', 'NYMEX', 'COMEX'],
            preferredExchange: 'CME'
        };
    }
    
    // **PRIORIDAD 2: Detectar CRYPTO** (después de descartar futuros)
    if (instrument.includes('USDT') || instrument.includes('USDC') || 
        instrument.includes('BUSD') || instrument.includes('BTC') ||
        instrument.includes('ETH') || instrument.includes('BNB') ||
        subaccount.includes('binance') || subaccount.includes('mexc') ||
        subaccount.includes('bitget') || subaccount.includes('bingx') ||
        subaccount.includes('crypto')) {
        
        // Orden de exchanges: BINANCE → BYBIT → OKX → GATEIO → MEXC → BITGET → BINGX → COINBASE → KRAKEN → KUCOIN
        // SIEMPRE empezar por BINANCE sin importar la cuenta (mayor liquidez y disponibilidad)
        return {
            type: 'CRYPTO',
            exchanges: ['BINANCE', 'BYBIT', 'OKX', 'GATEIO', 'MEXC', 'BITGET', 'BINGX', 'COINBASE', 'KRAKEN', 'KUCOIN'],
            preferredExchange: 'BINANCE'  // Siempre BINANCE primero
        };
    }
    
    // Detectar FOREX/CFD por pares comunes
    if (instrument.match(/^[A-Z]{6}$/) || // EURUSD, GBPJPY formato
        instrument.includes('USD') && !instrument.includes('USDT') ||
        instrument.includes('EUR') || instrument.includes('GBP') ||
        instrument.includes('JPY') || instrument.includes('AUD') ||
        subaccount.includes('oanda') || subaccount.includes('fxcm') ||
        subaccount.includes('forex') || subaccount.includes('cfd')) {
        return {
            type: 'FOREX',
            exchanges: ['OANDA', 'FXCM', 'FX_IDC', 'FOREXCOM'],
            preferredExchange: 'OANDA'
        };
    }
    
    // Detectar ACCIONES por exchanges conocidos
    if (subaccount.includes('stock') || subaccount.includes('equity') ||
        broker.includes('etrade') || broker.includes('td') ||
        broker.includes('schwab')) {
        return {
            type: 'STOCK',
            exchanges: ['NASDAQ', 'NYSE', 'AMEX'],
            preferredExchange: 'NASDAQ'
        };
    }
    
    // Por defecto, asumir CRYPTO para símbolos desconocidos
    return {
        type: 'CRYPTO',
        exchanges: ['BINANCE', 'BYBIT', 'OKX', 'GATEIO', 'MEXC', 'BITGET', 'BINGX', 'COINBASE', 'KRAKEN', 'KUCOIN'],
        preferredExchange: 'BINANCE'
    };
}

// Función mejorada para convertir instrumento a símbolo de TradingView con exchange correcto
function convertToTradingViewSymbolWithExchange(operation) {
    const marketInfo = detectMarketType(operation);
    let cleanSymbol = (operation.instrument || '').toUpperCase();
    
    console.log(`🔍 Mercado detectado: ${marketInfo.type}`);
    console.log(`   Instrumento: ${cleanSymbol}`);
    console.log(`   Exchange preferido: ${marketInfo.preferredExchange}`);
    
    // Limpiar símbolo de espacios y caracteres especiales
    cleanSymbol = cleanSymbol.replace(/[\s\-]/g, '');
    
    // Mapeos específicos por tipo de mercado
    if (marketInfo.type === 'FUTURES') {
        // FUTUROS → Mapear a CFDs del índice/commodity subyacente
        // Limpiar símbolo de sufijos de futuros:
        // - Contratos continuos: 1!, 2!, 3!
        // - Códigos de mes: H26, M26, U26, Z26, H2026, MAR26, etc.
        // - Micro variants: M6E, MNQ, MES, etc.
        
        let baseSymbol = cleanSymbol
            .replace(/\d!$/, '')           // Elimina 1!, 2!, 3!
            .replace(/[FGHJKMNQUVXZ]\d{1,4}$/, '')  // Elimina H26, M2026, MAR26, etc.
            .replace(/\d{4}$/, '');        // Elimina años 2026, 2025, etc.
        
        // Mapeo de futuros a sus CFDs equivalentes en OANDA
        const futuresCFDMap = {
            // ========== ÍNDICES ==========
            // NASDAQ 100
            'NQ': 'OANDA:NAS100USD',
            'NQ1': 'OANDA:NAS100USD',
            'MNQ': 'OANDA:NAS100USD',
            'MNQ1': 'OANDA:NAS100USD',
            
            // S&P 500
            'ES': 'OANDA:SPX500USD',
            'ES1': 'OANDA:SPX500USD',
            'MES': 'OANDA:SPX500USD',
            'MES1': 'OANDA:SPX500USD',
            'MESH': 'OANDA:SPX500USD',
            
            // Dow Jones
            'YM': 'OANDA:US30USD',
            'YM1': 'OANDA:US30USD',
            'MYM': 'OANDA:US30USD',
            'MYM1': 'OANDA:US30USD',
            
            // Russell 2000
            'RTY': 'OANDA:US2000USD',
            'RTY1': 'OANDA:US2000USD',
            'M2K': 'OANDA:US2000USD',
            'MRTY': 'OANDA:US2000USD',
            
            // ========== METALES ==========
            // Oro
            'GC': 'OANDA:XAUUSD',
            'GC1': 'OANDA:XAUUSD',
            'MGC': 'OANDA:XAUUSD',
            'MGC1': 'OANDA:XAUUSD',
            
            // Plata
            'SI': 'OANDA:XAGUSD',
            'SI1': 'OANDA:XAGUSD',
            'SIL': 'OANDA:XAGUSD',
            'MSI': 'OANDA:XAGUSD',
            
            // Cobre
            'HG': 'OANDA:XCUUSD',
            'HG1': 'OANDA:XCUUSD',
            
            // ========== ENERGÍA ==========
            // Petróleo WTI
            'CL': 'OANDA:WTICOUSD',
            'CL1': 'OANDA:WTICOUSD',
            'MCL': 'OANDA:WTICOUSD',
            'QM': 'OANDA:WTICOUSD',
            
            // Gas Natural
            'NG': 'OANDA:NATGASUSD',
            'NG1': 'OANDA:NATGASUSD',
            'MNG': 'OANDA:NATGASUSD',
            'QG': 'OANDA:NATGASUSD',
            
            // ========== DIVISAS ==========
            // Euro
            '6E': 'OANDA:EURUSD',
            '6E1': 'OANDA:EURUSD',
            'M6E': 'OANDA:EURUSD',
            'M6E1': 'OANDA:EURUSD',
            'E7': 'OANDA:EURUSD',
            
            // Yen Japonés
            '6J': 'OANDA:USDJPY',
            '6J1': 'OANDA:USDJPY',
            'M6J': 'OANDA:USDJPY',
            'J7': 'OANDA:USDJPY',
            
            // Libra Esterlina
            '6B': 'OANDA:GBPUSD',
            '6B1': 'OANDA:GBPUSD',
            'M6B': 'OANDA:GBPUSD',
            
            // Dólar Australiano
            '6A': 'OANDA:AUDUSD',
            '6A1': 'OANDA:AUDUSD',
            'M6A': 'OANDA:AUDUSD',
            
            // Dólar Canadiense
            '6C': 'OANDA:USDCAD',
            '6C1': 'OANDA:USDCAD',
            'M6C': 'OANDA:USDCAD',
            
            // Franco Suizo
            '6S': 'OANDA:USDCHF',
            '6S1': 'OANDA:USDCHF',
            'M6S': 'OANDA:USDCHF',
            
            // Dólar Neozelandés
            '6N': 'OANDA:NZDUSD',
            '6N1': 'OANDA:NZDUSD',
            
            // Dollar Index
            'DX': 'OANDA:USDDXY',
            'DX1': 'OANDA:USDDXY',
            'DXY': 'OANDA:USDDXY',
            
            // ========== CRYPTO ==========
            'BTC': 'BINANCE:BTCUSDT',
            'BTC1': 'BINANCE:BTCUSDT',
            'MBT': 'BINANCE:BTCUSDT',
            'ETH': 'BINANCE:ETHUSDT',
            'ETH1': 'BINANCE:ETHUSDT',
            'MET': 'BINANCE:ETHUSDT',
            
            // ========== BONOS ==========
            // T-Notes 10 años
            'ZN': 'OANDA:USB10YUSD',
            'ZN1': 'OANDA:USB10YUSD',
            
            // T-Bonds 30 años
            'ZB': 'OANDA:USB30YUSD',
            'ZB1': 'OANDA:USB30YUSD',
            
            // ========== AGRICULTURA ==========
            // Maíz
            'ZC': 'OANDA:CORNUSD',
            'ZC1': 'OANDA:CORNUSD',
            
            // Soja
            'ZS': 'OANDA:SOYBNUSD',
            'ZS1': 'OANDA:SOYBNUSD',
            
            // Trigo
            'ZW': 'OANDA:WHEATUSD',
            'ZW1': 'OANDA:WHEATUSD'
        };
        
        // Buscar en mapa usando símbolo base
        const cfdSymbol = futuresCFDMap[baseSymbol] || futuresCFDMap[cleanSymbol];
        
        if (cfdSymbol) {
            console.log(`✅ Futuro → CFD: ${cleanSymbol} → ${cfdSymbol}`);
            return {
                symbol: cfdSymbol,
                alternatives: [cfdSymbol],
                marketType: 'FUTURES'
            };
        }
        
        // Si no se encuentra, usar OANDA por defecto con el símbolo base
        const fallbackSymbol = `OANDA:${baseSymbol || cleanSymbol}USD`;
        console.log(`⚠️ Futuro no mapeado, usando fallback CFD: ${cleanSymbol} → ${fallbackSymbol}`);
        return {
            symbol: fallbackSymbol,
            alternatives: [fallbackSymbol, `CAPITALCOM:${baseSymbol || cleanSymbol}`],
            marketType: 'FUTURES'
        };
    }
    
    if (marketInfo.type === 'CFD') {
        // CFDs de ÍNDICES y COMMODITIES (MT5, cTrader, OANDA, etc.)
        // Mapeo directo usando OANDA (el más confiable)
        const cfdMap = {
            // ÍNDICES - OANDA
            'NAS100': 'OANDA:NAS100USD',
            'US100': 'OANDA:NAS100USD',
            'SPX500': 'OANDA:SPX500USD',
            'US500': 'OANDA:SPX500USD',
            'US30': 'OANDA:US30USD',
            'DJ30': 'OANDA:US30USD',
            'US2000': 'OANDA:US2000USD',
            'RUS2000': 'OANDA:US2000USD',
            'GER40': 'OANDA:DE30EUR',
            'DAX': 'OANDA:DE30EUR',
            'UK100': 'OANDA:UK100GBP',
            'FTSE': 'OANDA:UK100GBP',
            'FRA40': 'OANDA:FR40EUR',
            'CAC': 'OANDA:FR40EUR',
            'JPN225': 'OANDA:JP225USD',
            'NIKKEI': 'OANDA:JP225USD',
            
            // METALES - OANDA
            'XAUUSD': 'OANDA:XAUUSD',
            'GOLD': 'OANDA:XAUUSD',
            'XAGUSD': 'OANDA:XAGUSD',
            'SILVER': 'OANDA:XAGUSD',
            
            // ENERGÍA - OANDA
            'WTIUSD': 'OANDA:WTICOUSD',
            'USOIL': 'OANDA:WTICOUSD',
            'BRENT': 'OANDA:BCOUSD',
            'UKOIL': 'OANDA:BCOUSD',
            'NATGAS': 'OANDA:NATGASUSD'
        };
        
        // Buscar coincidencia en el mapa (normalizar quitando sufijos como P, etc)
        const normalizedSymbol = cleanSymbol.replace(/P$/i, ''); // Quitar P final si existe
        let mappedSymbol = null;
        
        for (const [key, value] of Object.entries(cfdMap)) {
            if (normalizedSymbol.includes(key)) {
                mappedSymbol = value;
                break;
            }
        }
        
        if (mappedSymbol) {
            console.log(`✅ CFD mapeado: ${cleanSymbol} → ${mappedSymbol}`);
            // Alternativas con otros brokers CFD
            const alternatives = [
                mappedSymbol,
                mappedSymbol.replace('OANDA:', 'FX_IDC:'),
                mappedSymbol.replace('OANDA:', 'CAPITALCOM:')
            ];
            return {
                symbol: mappedSymbol,
                alternatives: alternatives,
                marketType: 'CFD'
            };
        }
        
        // Fallback genérico usando OANDA
        console.log(`⚠️ CFD no mapeado, usando genérico: OANDA:${normalizedSymbol}`);
        return {
            symbol: `OANDA:${normalizedSymbol}`,
            alternatives: [`OANDA:${normalizedSymbol}`, `FX_IDC:${normalizedSymbol}`],
            marketType: 'CFD'
        };
    }
    
    if (marketInfo.type === 'FOREX') {
        // FOREX - normalizar par de divisas
        cleanSymbol = cleanSymbol.replace('/', '');
        return {
            symbol: `${marketInfo.preferredExchange}:${cleanSymbol}`,
            alternatives: marketInfo.exchanges.map(ex => `${ex}:${cleanSymbol}`),
            marketType: 'FOREX'
        };
    }
    
    if (marketInfo.type === 'CRYPTO') {
        // CRYPTO - detectar si es perpetuo o spot
        // Para contratos perpetuos, TradingView usa el sufijo .P
        const isPerpetual = cleanSymbol.includes('PERP') || 
                           operation.instrument?.toLowerCase().includes('perpetual') ||
                           operation.instrument?.toLowerCase().includes('perp') ||
                           !cleanSymbol.endsWith('USD'); // La mayoría de perpetuos terminan en USDT, no USD
        
        // Si termina en USDT, muy probablemente es un perpetuo
        const needsPerpSuffix = cleanSymbol.endsWith('USDT') || cleanSymbol.endsWith('BUSD') || isPerpetual;
        
        const symbolSuffix = needsPerpSuffix ? '.P' : '';
        
        console.log(`📊 Crypto ${needsPerpSuffix ? 'PERPETUO' : 'SPOT'}: ${cleanSymbol}${symbolSuffix}`);
        
        return {
            symbol: `${marketInfo.preferredExchange}:${cleanSymbol}${symbolSuffix}`,
            alternatives: marketInfo.exchanges.map(ex => `${ex}:${cleanSymbol}${symbolSuffix}`),
            marketType: 'CRYPTO'
        };
    }
    
    if (marketInfo.type === 'STOCK') {
        // ACCIONES - intentar en NASDAQ primero
        return {
            symbol: `${marketInfo.preferredExchange}:${cleanSymbol}`,
            alternatives: marketInfo.exchanges.map(ex => `${ex}:${cleanSymbol}`),
            marketType: 'STOCK'
        };
    }
    
    // Fallback genérico
    return {
        symbol: cleanSymbol,
        alternatives: [cleanSymbol],
        marketType: 'UNKNOWN'
    };
}

// Función mejorada para crear el widget avanzado de TradingView con marcadores
function createTradingViewWidget(operation, relatedOperations) {
    const widgetContainer = document.getElementById('tradingview-widget');
    if (!widgetContainer) {
        console.error('❌ Contenedor tradingview-widget no encontrado');
        return;
    }
    
    // Limpiar contenedor completamente
    widgetContainer.innerHTML = '';
    
    // Asegurar que el contenedor tenga dimensiones visibles
    widgetContainer.style.width = '100%';
    widgetContainer.style.height = '650px';
    widgetContainer.style.display = 'block';
    widgetContainer.style.visibility = 'visible';
    
    // Usar el nuevo sistema de detección de mercado
    const symbolData = convertToTradingViewSymbolWithExchange(operation);
    window.currentSymbolFallbacks = symbolData;
    
    // SOLO resetear si cambia el símbolo (instrumento), NO el operation.id
    const currentInstrument = operation.instrument;
    if (!window.currentInstrument || window.currentInstrument !== currentInstrument) {
        window.currentAlternativeIndex = 0;
        window.currentInstrument = currentInstrument;
        window.totalRotationCount = 0; // Reset contador de rotaciones
        window.widgetHasError = false; // Reset flag de errores
        console.log(`🆕 Nuevo instrumento detectado: ${currentInstrument}, reseteando rotación`);  
    }
    
    // Si estamos rotando, usar el índice actual
    let symbolToLoad = symbolData.symbol;
    if (window.currentAlternativeIndex > 0 && window.currentAlternativeIndex < symbolData.alternatives.length) {
        symbolToLoad = symbolData.alternatives[window.currentAlternativeIndex];
        console.log(`🔄 Usando exchange alternativo #${window.currentAlternativeIndex}: ${symbolToLoad}`);
    }
    
    console.log(`📊 Símbolo TradingView seleccionado:`);
    console.log(`   Principal: ${symbolData.symbol}`);
    console.log(`   Actual: ${symbolToLoad}`);
    console.log(`   Tipo: ${symbolData.marketType}`);
    console.log(`   Alternativas: ${symbolData.alternatives.join(', ')}`);
    
    // Verificar si TradingView está disponible
    if (typeof TradingView === 'undefined') {
        console.error('❌ TradingView no está disponible');
        // Usar sistema de fallback con APIs gratuitas
        createFreeAPIChart(operation, relatedOperations);
        return;
    }
    
    // Variable global para saber si onChartReady se ejecutó
    window.chartReadyFired = false;
    window.currentSymbolConfirmed = false;

    try {
        console.log(`🎨 Creando widget TradingView:`);
        console.log(`   - Símbolo: ${symbolToLoad}`);
        console.log(`   - Contenedor: tradingview-widget`);
        console.log(`   - Dimensiones: 100% x 650px`);
        console.log(`   - Símbolo: ${symbolToLoad}`);
        console.log(`   - Contenedor: tradingview-widget`);
        console.log(`   - Dimensiones: 100% x 650px`);
        
        // Destruir widget anterior si existe
        if (tradingViewWidget) {
            try {
                tradingViewWidget.remove();
            } catch (e) {
                console.log('⚠️ Error al remover widget anterior (ignorado)');
            }
        }
        
        // Mostrar indicador de carga
        widgetContainer.innerHTML = '<div class="flex items-center justify-center h-full"><div class="text-primary text-lg">⏳ Cargando gráfico...</div></div>';
        
        tradingViewWidget = new TradingView.widget({
            autosize: false,
            width: '100%',
            height: 650,
            symbol: symbolToLoad,
            interval: '5',
            timezone: 'Etc/UTC',
            theme: 'dark',
            style: '1',
            locale: 'es',
            toolbar_bg: '#000000',
            enable_publishing: false,
            hide_side_toolbar: false,
            allow_symbol_change: false,
            container_id: 'tradingview-widget',
            // Configuración mínima para evitar errores internos
            disabled_features: [],
            enabled_features: [],
            overrides: {
                // Fondo negro puro
                "paneProperties.background": "#000000",
                "paneProperties.backgroundType": "solid"
            },
            // Callback cuando el widget está listo
            onChartReady: function() {
                try {
                    console.log(`✅ Widget cargado: ${symbolToLoad}`);
                    window.chartReadyFired = true;
                    window.currentSymbolConfirmed = true;
                    window.totalRotationCount = 0;
                    
                    if (window.currentSymbolCheckInterval) {
                        clearInterval(window.currentSymbolCheckInterval);
                        window.currentSymbolCheckInterval = null;
                    }
                } catch (error) {
                    console.warn('⚠️ Error en callback:', error.message);
                }
            }
        });
        
        console.log('✅ Widget de TradingView creado exitosamente');
        
        // Resetear flag de confirmación
        window.currentSymbolConfirmed = false;
        
        // Función para intentar siguiente exchange
        const tryNextExchange = () => {
            if (!window.currentSymbolFallbacks || !window.currentSymbolFallbacks.alternatives) {
                console.log('⚠️ No hay alternativas disponibles, usando APIs gratuitas');
                createFreeAPIChart(operation, relatedOperations);
                return;
            }
            
            window.currentAlternativeIndex++;
            
            if (window.currentAlternativeIndex >= window.currentSymbolFallbacks.alternatives.length) {
                console.log('⚠️ Todas las alternativas de TradingView agotadas');
                console.log('🔄 Cambiando a APIs gratuitas como último recurso...');
                createFreeAPIChart(operation, relatedOperations);
                return;
            }
            
            const nextSymbol = window.currentSymbolFallbacks.alternatives[window.currentAlternativeIndex];
            const exchangeName = nextSymbol.split(':')[0];
            console.log(`🔄 AUTO-ROTACIÓN ${window.currentAlternativeIndex + 1}/${window.currentSymbolFallbacks.alternatives.length}: ${nextSymbol}`);
            
            // Destruir widget anterior
            if (tradingViewWidget) {
                try { tradingViewWidget.remove(); } catch (e) {}
            }
            
            // Mostrar indicador de rotación
            const previousExchange = window.currentAlternativeIndex > 0 ? 
                window.currentSymbolFallbacks.alternatives[window.currentAlternativeIndex - 1]?.split(':')[0] : null;
            
            widgetContainer.innerHTML = `<div class="flex items-center justify-center h-full bg-black">
                <div class="text-center max-w-md">
                    <div class="text-5xl mb-4">🔄</div>
                    <div class="text-primary text-xl font-semibold mb-2">Buscando en ${exchangeName}</div>
                    <div class="text-gray-400 text-sm mb-4">Exchange ${window.currentAlternativeIndex + 1} de ${window.currentSymbolFallbacks.alternatives.length}</div>
                    ${previousExchange ? `
                        <div class="bg-surface border border-border rounded p-3 text-xs">
                            <div class="text-gray-500">⚡ Símbolo no disponible en <span class="text-red-500">${previousExchange}</span></div>
                        </div>
                    ` : ''}
                    <div class="text-gray-600 text-xs mt-4">
                        <i class="fas fa-robot mr-1"></i> Sistema automático activado
                    </div>
                </div>
            </div>`;
            
            // Reintentar con el siguiente exchange después de un breve delay
            setTimeout(() => {
                const tempOp = {...operation};
                createTradingViewWidget(tempOp, relatedOperations);
            }, 500);
        };
        
        // Hacer la función accesible globalmente
        window.tryNextExchangeFunction = tryNextExchange;
        
        // Limpiar intervalo anterior si existe
        if (window.currentSymbolCheckInterval) {
            clearInterval(window.currentSymbolCheckInterval);
        }
        
        // Sistema SIMPLE: Si no se confirma el widget en 6 segundos, rotar
        let autoCheckCount = 0;
        const maxAutoChecks = 2; // 2 verificaciones × 3 segundos = 6 segundos total
        const maxTotalRotations = 10;
        
        // Resetear variables de estado
        window.chartReadyFired = false;
        window.currentSymbolConfirmed = false;
        
        // Inicializar contador global de rotaciones si no existe
        if (typeof window.totalRotationCount === 'undefined') {
            window.totalRotationCount = 0;
        }

        window.currentSymbolCheckInterval = setInterval(() => {
            autoCheckCount++;
            
            const widgetContainer = document.getElementById('tradingview-widget');
            const hasIframe = widgetContainer && widgetContainer.querySelector('iframe');
            
            console.log(`🔍 [Check ${autoCheckCount}/${maxAutoChecks}]`, {
                hasIframe: !!hasIframe,
                confirmed: window.currentSymbolConfirmed
            });
            
            // Si el widget ya está confirmado, detener
            if (window.currentSymbolConfirmed) {
                console.log(`✅ Símbolo confirmado, deteniendo verificaciones`);
                clearInterval(window.currentSymbolCheckInterval);
                window.totalRotationCount = 0;
                return;
            }

            // Si alcanzamos el máximo de checks
            if (autoCheckCount >= maxAutoChecks) {
                // Si hay iframe, aceptarlo (con .P ya debería funcionar)
                if (hasIframe) {
                    console.log(`✅ GRÁFICO VÁLIDO - Aceptando exchange actual`);
                    window.currentSymbolConfirmed = true;
                    window.totalRotationCount = 0;
                    clearInterval(window.currentSymbolCheckInterval);
                    
                    // Agregar marcadores
                    setTimeout(() => {
                        if (operation && relatedOperations) {
                            addTradeMarkersToChart(operation, relatedOperations);
                        }
                    }, 2000);
                    return;
                }
                
                // NO hay iframe → ROTAR
                console.log(`⏱️ NO HAY IFRAME - Rotando a siguiente exchange`);
                clearInterval(window.currentSymbolCheckInterval);
                window.totalRotationCount = (window.totalRotationCount || 0) + 1;
                
                if (window.totalRotationCount >= maxTotalRotations) {
                    console.error(`❌ Se alcanzó el límite de ${maxTotalRotations} exchanges probados`);
                    const widgetContainer = document.getElementById('tradingview-widget');
                    if (widgetContainer) {
                        widgetContainer.innerHTML = `
                            <div class="flex items-center justify-center h-full bg-black">
                                <div class="text-center max-w-md p-6">
                                    <div class="text-6xl mb-4">⚠️</div>
                                    <div class="text-red-500 text-2xl font-bold mb-4">Símbolo No Disponible</div>
                                    <div class="text-gray-400 mb-4">
                                        El símbolo <span class="text-primary font-mono">${currentInstrument}</span> 
                                        no está disponible en ninguno de los ${maxTotalRotations} exchanges probados.
                                    </div>
                                    <div class="text-xs text-gray-600 space-y-1">
                                        <div>✓ BINANCE</div>
                                        <div>✓ BYBIT</div>
                                        <div>✓ OKX</div>
                                        <div>✓ GATE.IO</div>
                                        <div>✓ MEXC</div>
                                        <div>✓ BITGET</div>
                                        <div>✓ BINGX</div>
                                        <div>✓ COINBASE</div>
                                        <div>✓ KRAKEN</div>
                                        <div>✓ KUCOIN</div>
                                    </div>
                                </div>
                            </div>
                        `;
                    }
                    window.totalRotationCount = 0;
                    return;
                }
                
                tryNextExchange();
                return;
            }
        }, 3000); // Verificar cada 3 segundos (total 6 segundos por exchange)
        
    } catch (error) {
        console.error('❌ Error creando widget de TradingView:', error);
        console.error('   Stack:', error.stack);
        
        // Intentar siguiente exchange si hay disponibles
        if (window.currentSymbolFallbacks && 
            window.currentSymbolFallbacks.alternatives &&
            window.currentAlternativeIndex < window.currentSymbolFallbacks.alternatives.length - 1) {
            console.log('🔄 Error en widget, intentando siguiente exchange...');
            setTimeout(() => {
                if (window.tryNextExchangeFunction) {
                    window.tryNextExchangeFunction();
                }
            }, 1000);
        } else {
            // Usar APIs gratuitas como último fallback
            console.log('🔄 Cambiando a APIs gratuitas...');
            createFreeAPIChart(operation, relatedOperations);
        }
    }
}

// Función para agregar botón de fallback manual a APIs gratuitas
function addFallbackButton(operation, relatedOperations) {
    const detailsSection = document.getElementById('operation-detail-page');
    if (!detailsSection) return;
    
    let existingBtn = document.getElementById('free-api-fallback-btn');
    if (existingBtn) existingBtn.remove();
    
    const button = document.createElement('button');
    button.id = 'free-api-fallback-btn';
    button.innerHTML = '<i class="fas fa-sync-alt mr-2"></i>Usar APIs Gratuitas';
    button.title = 'Si el símbolo no se encuentra en TradingView, haz clic para usar Binance, MEXC o CoinGecko';
    button.style.cssText = `
        position: absolute;
        top: 70px;
        right: 20px;
        background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 12px;
        font-weight: 500;
        box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
        transition: all 0.2s;
        z-index: 100;
    `;
    
    button.addEventListener('mouseenter', () => {
        button.style.transform = 'translateY(-2px)';
        button.style.boxShadow = '0 4px 12px rgba(59, 130, 246, 0.4)';
    });
    
    button.addEventListener('mouseleave', () => {
        button.style.transform = 'translateY(0)';
        button.style.boxShadow = '0 2px 8px rgba(59, 130, 246, 0.3)';
    });
    
    button.onclick = () => {
        console.log('👆 Usuario solicitó usar APIs gratuitas');
        createFreeAPIChart(operation, relatedOperations);
    };
    
    const chartContainer = detailsSection.querySelector('.chart-analysis-container');
    if (chartContainer) {
        chartContainer.style.position = 'relative';
        chartContainer.appendChild(button);
    }
}

// Función para intentar símbolo alternativo cuando falla el principal
function tryAlternativeSymbol() {
    if (!window.currentSymbolFallbacks || 
        !window.currentSymbolFallbacks.alternatives ||
        !Array.isArray(window.currentSymbolFallbacks.alternatives) ||
        !window.currentOperationForChart) {
        console.log('⚠️ No hay fallbacks disponibles o no hay operación activa');
        return false;
    }
    
    const fallbacks = window.currentSymbolFallbacks;
    
    // Asegurar que attemptIndex existe
    if (typeof fallbacks.attemptIndex !== 'number') {
        fallbacks.attemptIndex = 0;
    }
    
    // Si se agotaron las alternativas, volver al principio (crear ciclo infinito de opciones)
    if (fallbacks.attemptIndex >= fallbacks.alternatives.length) {
        console.log('🔄 Se probaron todas las alternativas, volviendo al inicio...');
        fallbacks.attemptIndex = 0; // Resetear para volver a empezar
        
        // Mostrar mensaje informativo
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 80px;
            right: 20px;
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(139, 92, 246, 0.3);
            z-index: 10000;
            max-width: 350px;
            font-family: 'Inter', sans-serif;
        `;
        notification.innerHTML = `
            <div style="display: flex; align-items: center; gap: 10px;">
                <i class="fas fa-sync-alt" style="font-size: 20px;"></i>
                <div>
                    <div style="font-weight: 600; margin-bottom: 5px;">Volviendo al primer exchange</div>
                    <div style="font-size: 13px; opacity: 0.95;">
                        Ciclo completo de exchanges para "${fallbacks.baseSymbol}"
                    </div>
                </div>
            </div>
        `;
        document.body.appendChild(notification);
        setTimeout(() => notification.remove(), 3000);
    }
    
    const nextSymbol = fallbacks.alternatives[fallbacks.attemptIndex];
    console.log(`🔄 Cambiando a exchange alternativo #${fallbacks.attemptIndex + 1}: ${nextSymbol}`);
    
    // Mostrar notificación de cambio
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed; top: 80px; right: 20px;
        background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        color: white; padding: 12px 18px; border-radius: 8px;
        box-shadow: 0 4px 15px rgba(16, 185, 129, 0.3);
        z-index: 10000; font-size: 13px; font-weight: 500;
    `;
    notification.innerHTML = `
        <i class="fas fa-chart-line"></i> 
        Cambiando a exchange alternativo...
    `;
    document.body.appendChild(notification);
    setTimeout(() => notification.remove(), 2000);
    
    // Incrementar índice para el próximo intento
    fallbacks.attemptIndex++;
    
    // Recrear el widget con el nuevo símbolo
    if (tradingViewWidget) {
        try {
            tradingViewWidget.remove();
        } catch (e) {
            console.warn('No se pudo remover el widget anterior:', e);
        }
    }
    
    const widgetContainer = document.getElementById('tradingview-widget');
    if (!widgetContainer) return false;
    
    widgetContainer.innerHTML = '';
    
    console.log(`📊 Creando widget con símbolo alternativo: ${nextSymbol}`);
    
    try {
        tradingViewWidget = new TradingView.widget({
            width: '100%',
            height: 650,
            symbol: nextSymbol,
            interval: '5',
            timezone: 'Etc/UTC',
            theme: 'dark',
            style: '1',
            locale: 'es',
            toolbar_bg: '#0f0f0f',
            enable_publishing: false,
            hide_side_toolbar: false,
            allow_symbol_change: true,
            container_id: 'tradingview-widget',
            autosize: false,
            onChartReady: function() {
                console.log(`✅ Widget cargado con exchange alternativo: ${nextSymbol}`);
                setTimeout(() => {
                    if (window.currentOperationForChart && window.currentOperationForChart.relatedOps) {
                        addTradeMarkersToChart(window.currentOperationForChart.operation, window.currentOperationForChart.relatedOps);
                    }
                }, 2000);
            }
        });
        
        return true;
    } catch (error) {
        console.error('❌ Error con exchange alternativo:', error);
        return false;
    }
}

// Agregar botón de "Probar otro exchange" en la UI
// DESHABILITADO - El sistema ahora es 100% automático
function addAlternativeSymbolButton() {
    // Sistema automático - no se requiere botón manual
    return;
    
    /* CÓDIGO ORIGINAL COMENTADO
    const detailsSection = document.getElementById('operation-detail-page');
    if (!detailsSection) return;
    
    let existingBtn = document.getElementById('try-alternative-symbol-btn');
    if (existingBtn) existingBtn.remove();
    
    if (!window.currentSymbolFallbacks || 
        !window.currentSymbolFallbacks.alternatives ||
        !Array.isArray(window.currentSymbolFallbacks.alternatives) ||
        window.currentSymbolFallbacks.alternatives.length === 0) {
        return; // No hay fallbacks disponibles
    }
    
    const button = document.createElement('button');
    button.id = 'try-alternative-symbol-btn';
    
    // Obtener índice actual y total de alternativas
    const currentIndex = window.currentAlternativeIndex || 0;
    const totalAlternatives = window.currentSymbolFallbacks.alternatives.length;
    const currentSymbol = window.currentSymbolFallbacks.alternatives[currentIndex];
    const currentExchange = currentSymbol ? currentSymbol.split(':')[0] : 'Unknown';
    
    // Texto mostrando el exchange actual y opción de cambiar
    const buttonText = `<i class="fas fa-exchange-alt"></i> ${currentExchange} <span style="font-size: 10px; opacity: 0.8;">(${currentIndex + 1}/${totalAlternatives})</span>`;
    
    button.innerHTML = buttonText;
    button.title = `Exchange actual: ${currentSymbol}. Haz clic para cambiar a otro exchange.`;
    
    button.innerHTML = buttonText;
    button.title = `Exchange actual: ${currentSymbol}. Haz clic para cambiar a otro exchange.`;
    
    // Color consistente
    const bgColor = 'linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%)';
    const shadowColor = 'rgba(139, 92, 246, 0.3)';
    
    button.style.cssText = `
        position: absolute;
        top: 20px;
        right: 20px;
        background: ${bgColor};
        color: white;
        border: none;
        padding: 10px 18px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 13px;
        font-weight: 500;
        box-shadow: 0 2px 8px ${shadowColor};
        transition: all 0.2s;
        z-index: 100;
    `;
    
    button.addEventListener('mouseenter', () => {
        button.style.transform = 'translateY(-2px)';
        button.style.boxShadow = `0 4px 12px ${shadowColor.replace('0.3', '0.4')}`;
    });
    
    button.addEventListener('mouseleave', () => {
        button.style.transform = 'translateY(0)';
        button.style.boxShadow = `0 2px 8px ${shadowColor}`;
    });
    
    button.onclick = () => {
        if (window.tryNextExchangeFunction) {
            window.tryNextExchangeFunction();
        }
    };
    
    const chartContainer = detailsSection.querySelector('.chart-analysis-container');
    if (chartContainer) {
        chartContainer.style.position = 'relative';
        chartContainer.appendChild(button);
    }
    */
}

// Función para agregar marcadores directamente al gráfico
function addTradeMarkersToChart(operation, relatedOperations) {
    if (!tradingViewWidget) {
        console.warn('⚠️ Widget no disponible para agregar marcadores');
        return;
    }
    
    try {
        // Verificar si el widget está completamente cargado
        if (typeof tradingViewWidget.chart !== 'function') {
            console.warn('⚠️ Widget aún no está listo para marcadores');
            return;
        }
        
        const chart = tradingViewWidget.chart();
        
        // Verificar si el chart tiene los métodos necesarios
        if (!chart || typeof chart.createMultipointShape !== 'function') {
            console.warn('⚠️ API de chart no disponible, marcadores desactivados');
            return;
        }
        
        relatedOperations.forEach((op, index) => {
            const precision = getInstrumentPrecision(op.instrument);
            
            // Marcador de entrada
            if (op.entryTime && op.date && op.entry) {
                const entryDateTime = new Date(`${op.date}T${op.entryTime}:00`);
                if (!isNaN(entryDateTime.getTime())) {
                    const entryTimestamp = Math.floor(entryDateTime.getTime() / 1000);
                    
                    try {
                        // Crear marcador de entrada usando API actualizada
                        chart.createMultipointShape(
                            [{time: entryTimestamp, price: op.entry}],
                            {
                                shape: 'icon',
                                icon: 0xf062, // arrow-up
                                text: `ENTRADA ${index > 0 ? 'P' + index : ''}`,
                                overrides: {
                                    color: op.type === 'buy' ? '#10B981' : '#EF4444',
                                    textColor: '#FFFFFF',
                                    fontSize: 12
                                }
                            }
                        );
                        console.log(`✅ Marcador de entrada agregado: ${op.entryTime} @ ${op.entry}`);
                    } catch (shapeError) {
                        console.log(`⚠️ No se pudo crear marcador de entrada: ${shapeError.message}`);
                    }
                }
            }
            
            // Marcador de salida
            if (op.exitTime && op.date && op.exit) {
                const exitDateTime = new Date(`${op.date}T${op.exitTime}:00`);
                if (!isNaN(exitDateTime.getTime())) {
                    const exitTimestamp = Math.floor(exitDateTime.getTime() / 1000);
                    
                    try {
                        // Crear marcador de salida usando API actualizada
                        chart.createMultipointShape(
                            [{time: exitTimestamp, price: op.exit}],
                            {
                                shape: 'icon',
                                icon: 0xf063, // arrow-down
                                text: `SALIDA ${index > 0 ? 'P' + index : ''}\nP&L: ${formatCurrency(op.pl, op.currency, op.currency)}`,
                                overrides: {
                                    color: op.pl >= 0 ? '#10B981' : '#EF4444',
                                    textColor: '#FFFFFF',
                                    fontSize: 12
                                }
                            }
                        );
                        console.log(`✅ Marcador de salida agregado: ${op.exitTime} @ ${op.exit}`);
                    } catch (shapeError) {
                        console.log(`⚠️ No se pudo crear marcador de salida: ${shapeError.message}`);
                    }
                }
            }
        });
        
        // Centrar el gráfico en el rango de la operación
        if (relatedOperations.length > 0) {
            const firstOp = relatedOperations[0];
            if (firstOp.date && firstOp.entryTime) {
                try {
                    const centerTime = new Date(`${firstOp.date}T${firstOp.entryTime}:00`);
                    const centerTimestamp = Math.floor(centerTime.getTime() / 1000);
                    
                    if (typeof chart.setVisibleRange === 'function') {
                        // Establecer rango visible alrededor de la operación
                        chart.setVisibleRange({
                            from: centerTimestamp - (6 * 3600), // 6 horas antes
                            to: centerTimestamp + (6 * 3600)    // 6 horas después
                        });
                    }
                } catch (rangeError) {
                    console.log(`⚠️ No se pudo establecer rango visible: ${rangeError.message}`);
                }
            }
        }
        
    } catch (error) {
        console.warn('⚠️ No se pudieron agregar marcadores al gráfico:', error.message);
        // No lanzar error, solo registrar advertencia
    }
}

// Función para crear gráfico con APIs gratuitas cuando TradingView falla
async function createFreeAPIChart(operation, relatedOperations) {
    const widgetContainer = document.getElementById('tradingview-widget');
    if (!widgetContainer) return;
    
    // Detectar tipo de mercado
    const marketInfo = detectMarketType(operation);
    
    // Mostrar mensaje de carga
    widgetContainer.innerHTML = `
        <div class="flex flex-col items-center justify-center h-full bg-black">
            <div class="text-primary text-lg mb-4">🔄 Buscando datos del gráfico...</div>
            <div class="text-gray-400 text-sm">Tipo: ${marketInfo.type} | Exchange: ${marketInfo.preferredExchange}</div>
        </div>
    `;
    
    console.log('📊 Usando sistema de APIs gratuitas para:', operation.instrument);
    console.log('   Tipo de mercado:', marketInfo.type);
    
    try {
        // Intentar obtener datos de múltiples fuentes
        const chartDataResult = await fetchMultiSourceChartData(operation);
        
        if (!chartDataResult.success) {
            // Mensaje específico para mercados que requieren TradingView
            if (chartDataResult.requiresTradingView) {
                widgetContainer.innerHTML = `
                    <div class="flex flex-col items-center justify-center h-full bg-black p-8 text-center">
                        <div class="text-6xl mb-4">📈</div>
                        <div class="text-yellow-500 text-lg mb-2">⚠️ API Gratuita no disponible</div>
                        <div class="text-gray-300 text-base mb-4">
                            Los instrumentos tipo <strong>${marketInfo.type}</strong> solo están disponibles en TradingView
                        </div>
                        <div class="bg-surface p-4 rounded border border-border text-sm max-w-md">
                            <div class="text-primary font-semibold mb-2">🔄 Sistema de rotación activo:</div>
                            <div class="text-gray-400 space-y-1">
                                El widget está probando automáticamente estos exchanges:<br>
                                <div class="mt-2 text-xs">
                                    ${marketInfo.exchanges.map((ex, i) => `${i + 1}. ${ex}:${operation.instrument}`).join('<br>')}
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                return;
            }
            
            // Si todas las APIs fallan para crypto, mostrar mensaje
            widgetContainer.innerHTML = `
                <div class="flex flex-col items-center justify-center h-full bg-black p-8 text-center">
                    <div class="text-6xl mb-4">📊</div>
                    <div class="text-red-500 text-lg mb-2">❌ No se encontraron datos</div>
                    <div class="text-gray-400 text-sm mb-4">
                        El símbolo "${operation.instrument}" no está disponible en:<br>
                        Binance, MEXC, ni CoinGecko
                    </div>
                    <div class="bg-surface p-4 rounded border border-border text-left text-xs">
                        <div class="font-semibold mb-2 text-primary">📍 Datos de la operación:</div>
                        <div class="space-y-1">
                            <div>Entrada: ${parseFloat(operation.entry).toFixed(2)} (${operation.entryTime})</div>
                            <div>Salida: ${parseFloat(operation.exit).toFixed(2)} (${operation.exitTime})</div>
                            <div class="${operation.pl >= 0 ? 'text-green' : 'text-red'}">
                                P/L: ${formatCurrency(operation.pl, operation.currency, operation.currency)}
                            </div>
                        </div>
                    </div>
                </div>
            `;
            return;
        }
        
        console.log(`✅ Datos obtenidos de ${chartDataResult.source}`);
        
        // Verificar si Lightweight Charts está disponible
        if (typeof LightweightCharts === 'undefined') {
            console.error('❌ Lightweight Charts no está disponible');
            widgetContainer.innerHTML = `
                <div class="flex items-center justify-center h-full bg-black">
                    <div class="text-red-500">❌ Error: Biblioteca de gráficos no disponible</div>
                </div>
            `;
            return;
        }
        
        // Limpiar contenedor
        widgetContainer.innerHTML = '';
        
        // Crear el gráfico con Lightweight Charts v4
        const chart = window.LightweightCharts.createChart(widgetContainer, {
            width: widgetContainer.clientWidth,
            height: 650,
            layout: {
                background: { color: '#0f0f0f' },
                textColor: '#d1d4dc',
            },
            grid: {
                vertLines: { color: '#2B2B43' },
                horzLines: { color: '#2B2B43' },
            },
            crosshair: {
                mode: window.LightweightCharts.CrosshairMode.Normal,
            },
            rightPriceScale: {
                borderColor: '#485c7b',
            },
            timeScale: {
                borderColor: '#485c7b',
                timeVisible: true,
                secondsVisible: false,
            },
        });
        
        lightweightChart = chart;
        
        // Crear serie de velas
        const candlestickSeries = chart.addCandlestickSeries({
            upColor: '#10B981',
            downColor: '#EF4444',
            borderDownColor: '#EF4444',
            borderUpColor: '#10B981',
            wickDownColor: '#EF4444',
            wickUpColor: '#10B981',
        });
        
        // Cargar datos
        candlestickSeries.setData(chartDataResult.data);
        
        // Agregar marcadores de entrada y salida
        const markers = [];
        
        relatedOperations.forEach((op, index) => {
            const precision = getInstrumentPrecision(op.instrument);
            
            // Marcador de entrada
            if (op.entryTime && op.date && op.entry) {
                const entryDateTime = new Date(`${op.date}T${op.entryTime}:00`);
                const entryTimestamp = Math.floor(entryDateTime.getTime() / 1000);
                
                markers.push({
                    time: entryTimestamp,
                    position: 'belowBar',
                    color: op.type === 'buy' ? '#10B981' : '#EF4444',
                    shape: 'arrowUp',
                    text: `📈 ENTRADA ${index > 0 ? 'P' + index : ''}: ${op.entry.toFixed(precision)}`,
                    size: 1
                });
            }
            
            // Marcador de salida
            if (op.exitTime && op.date && op.exit) {
                const exitDateTime = new Date(`${op.date}T${op.exitTime}:00`);
                const exitTimestamp = Math.floor(exitDateTime.getTime() / 1000);
                
                markers.push({
                    time: exitTimestamp,
                    position: 'aboveBar',
                    color: op.pl >= 0 ? '#10B981' : '#EF4444',
                    shape: 'arrowDown',
                    text: `📉 SALIDA ${index > 0 ? 'P' + index : ''}: ${op.exit.toFixed(precision)} | ${formatCurrency(op.pl, op.currency, op.currency)}`,
                    size: 1
                });
            }
        });
        
        candlestickSeries.setMarkers(markers);
        
        // Agregar badge mostrando la fuente de datos
        const sourceBadge = document.createElement('div');
        sourceBadge.className = 'absolute top-4 right-4 bg-primary bg-opacity-20 border border-primary text-primary px-3 py-1.5 rounded text-xs font-medium z-10';
        sourceBadge.innerHTML = `<i class="fas fa-database mr-1"></i> Fuente: ${chartDataResult.source}`;
        widgetContainer.appendChild(sourceBadge);
        
        // Hacer responsivo
        window.addEventListener('resize', () => {
            if (lightweightChart) {
                lightweightChart.applyOptions({
                    width: widgetContainer.clientWidth
                });
            }
        });
        
        console.log('✅ Gráfico creado exitosamente con datos de', chartDataResult.source);
        
    } catch (error) {
        console.error('❌ Error creando gráfico con APIs gratuitas:', error);
        widgetContainer.innerHTML = `
            <div class="flex items-center justify-center h-full bg-black">
                <div class="text-red-500">❌ Error al cargar el gráfico: ${error.message}</div>
            </div>
        `;
    }
}

// Función alternativa mejorada cuando el widget avanzado no está disponible
function showAdvancedChartAlternative(operation, relatedOperations) {
    const widgetContainer = document.getElementById('tradingview-widget');
    if (!widgetContainer) return;
    
    // Crear iframe con parámetros específicos para marcadores
    const tvSymbol = convertToTradingViewSymbol(operation.instrument);
    
    // Construir URL con estudios personalizados
    let studiesParam = '';
    const studies = [];
    
    relatedOperations.forEach((op, index) => {
        if (op.entryTime && op.date && op.entry) {
            const entryDateTime = new Date(`${op.date}T${op.entryTime}:00`);
            const entryTimestamp = Math.floor(entryDateTime.getTime() / 1000);
            studies.push(`PriceNote@tv-basicstudies-${studies.length + 1}=${JSON.stringify({
                time: entryTimestamp,
                price: op.entry,
                text: '📈 ENTRADA'
            })}`);
        }
        
        if (op.exitTime && op.date && op.exit) {
            const exitDateTime = new Date(`${op.date}T${op.exitTime}:00`);
            const exitTimestamp = Math.floor(exitDateTime.getTime() / 1000);
            studies.push(`PriceNote@tv-basicstudies-${studies.length + 1}=${JSON.stringify({
                time: exitTimestamp,
                price: op.exit,
                text: '📉 SALIDA'
            })}`);
        }
    });
    
    if (studies.length > 0) {
        studiesParam = `&studies=${encodeURIComponent(studies.join(','))}`;
    }
    
    const iframeUrl = `https://s.tradingview.com/widgetembed/?frameElementId=tradingview_widget&symbol=${encodeURIComponent(tvSymbol)}&interval=5&hidesidetoolbar=0&symboledit=1&saveimage=1&toolbarbg=0f0f0f&theme=dark&style=1&timezone=Etc%2FUTC&withdateranges=1${studiesParam}&overrides={"mainSeriesProperties.candleStyle.upColor"%3A"%2310B981"%2C"mainSeriesProperties.candleStyle.downColor"%3A"%23EF4444"}&enabled_features=[]&disabled_features=[]&locale=es`;
    
    widgetContainer.innerHTML = `
        <iframe 
            src="${iframeUrl}"
            style="width: 100%; height: 650px; border: none;"
            frameborder="0">
        </iframe>
        <div class="absolute top-4 left-4 bg-black bg-opacity-75 text-white text-xs p-2 rounded">
            ⚠️ Widget avanzado no disponible. Usando modo alternativo.
        </div>
    `;
}

// Función para crear gráfico con Lightweight Charts y marcadores
async function createLightweightChartWithMarkers(operation, relatedOperations) {
    const widgetContainer = document.getElementById('tradingview-widget');
    if (!widgetContainer) return;
    
    // Limpiar contenedor
    widgetContainer.innerHTML = '';
    
    console.log('📊 Creando gráfico con Lightweight Charts...');
    
    try {
        // Crear el gráfico con Lightweight Charts v4
        const chart = window.LightweightCharts.createChart(widgetContainer, {
            width: widgetContainer.clientWidth,
            height: 650,
            layout: {
                background: { color: '#0f0f0f' },
                textColor: '#d1d4dc',
            },
            grid: {
                vertLines: {
                    color: '#2B2B43',
                },
                horzLines: {
                    color: '#2B2B43',
                },
            },
            crosshair: {
                mode: window.LightweightCharts.CrosshairMode.Normal,
            },
            rightPriceScale: {
                borderColor: '#485c7b',
            },
            timeScale: {
                borderColor: '#485c7b',
                timeVisible: true,
                secondsVisible: false,
            },
        });
        
        lightweightChart = chart;
        
        // Crear serie de velas
        const candlestickSeries = chart.addCandlestickSeries({
            upColor: '#10B981',
            downColor: '#EF4444',
            borderDownColor: '#EF4444',
            borderUpColor: '#10B981',
            wickDownColor: '#EF4444',
            wickUpColor: '#10B981',
        });
        
        // Obtener datos históricos (simulados por ahora)
        const tvSymbol = convertToTradingViewSymbol(operation.instrument);
        const chartData = await generateSampleChartData(operation, relatedOperations);
        
        // Establecer datos del gráfico
        candlestickSeries.setData(chartData);
        
        // Agregar marcadores de entrada y salida
        const markers = [];
        
        relatedOperations.forEach((op, index) => {
            const precision = getInstrumentPrecision(op.instrument);
            
            // Marcador de entrada
            if (op.entryTime && op.date && op.entry) {
                const entryDateTime = new Date(`${op.date}T${op.entryTime}:00`);
                const entryTimestamp = Math.floor(entryDateTime.getTime() / 1000);
                
                markers.push({
                    time: entryTimestamp,
                    position: 'belowBar',
                    color: op.type === 'buy' ? '#10B981' : '#EF4444',
                    shape: 'arrowUp',
                    text: `ENTRADA ${index > 0 ? 'P' + index : ''}: ${op.entry.toFixed(precision)}`,
                    size: 1
                });
            }
            
            // Marcador de salida
            if (op.exitTime && op.date && op.exit) {
                const exitDateTime = new Date(`${op.date}T${op.exitTime}:00`);
                const exitTimestamp = Math.floor(exitDateTime.getTime() / 1000);
                
                markers.push({
                    time: exitTimestamp,
                    position: 'aboveBar',
                    color: op.pl >= 0 ? '#10B981' : '#EF4444',
                    shape: 'arrowDown',
                    text: `SALIDA ${index > 0 ? 'P' + index : ''}: ${op.exit.toFixed(precision)}\nP&L: ${formatCurrency(op.pl, op.currency, op.currency)}`,
                    size: 1
                });
            }
        });
        
        // Aplicar marcadores
        candlestickSeries.setMarkers(markers);
        
        // Centrar gráfico en la operación
        if (relatedOperations.length > 0 && relatedOperations[0].entryTime) {
            const firstOp = relatedOperations[0];
            const centerTime = new Date(`${firstOp.date}T${firstOp.entryTime}:00`);
            const centerTimestamp = Math.floor(centerTime.getTime() / 1000);
            
            lightweightChart.timeScale().setVisibleRange({
                from: centerTimestamp - (4 * 3600), // 4 horas antes
                to: centerTimestamp + (4 * 3600)    // 4 horas después
            });
        }
        
        // Ajustar tamaño cuando cambie la ventana
        window.addEventListener('resize', () => {
            if (lightweightChart) {
                lightweightChart.applyOptions({ 
                    width: widgetContainer.clientWidth 
                });
            }
        });
        
        console.log('✅ Gráfico Lightweight creado con marcadores');
        
    } catch (error) {
        console.error('❌ Error creando gráfico Lightweight:', error);
        
        // Fallback al mensaje de error
        widgetContainer.innerHTML = `
            <div class="flex items-center justify-center h-full bg-surface">
                <div class="text-center p-8">
                    <div class="text-red-400 text-lg mb-4">❌ Error cargando gráfico avanzado</div>
                    <div class="text-gray-400 mb-4">Los marcadores están disponibles en el panel lateral</div>
                    <button onclick="toggleChartMode()" class="bg-primary text-black px-4 py-2 rounded">
                        Volver al gráfico simple
                    </button>
                </div>
            </div>
        `;
    }
}

// Función para generar datos de ejemplo del gráfico
async function generateSampleChartData(operation, relatedOperations) {
    // Esta función generaría datos reales en una implementación completa
    // Por ahora, genera datos de ejemplo basados en la operación
    
    const data = [];
    const startTime = new Date(`${operation.date}T00:00:00`);
    const basePrice = operation.entry || 100;
    
    // Generar 24 horas de datos con intervalos de 5 minutos
    for (let i = 0; i < 288; i++) { // 288 intervalos de 5 min = 24h
        const timestamp = Math.floor((startTime.getTime() + (i * 5 * 60 * 1000)) / 1000);
        const randomVariation = (Math.random() - 0.5) * 0.02; // ±1% variación
        const price = basePrice * (1 + randomVariation);
        
        data.push({
            time: timestamp,
            open: price * 0.999,
            high: price * 1.001,
            low: price * 0.998,
            close: price
        });
    }
    
    return data;
}



function convertToTradingViewSymbol(instrument) {
        if (!instrument) return 'BINANCE:BTCUSDT';

        let symbol = instrument.toUpperCase().trim();

        // Limpiar espacios, guiones, barras y underscores
        symbol = symbol.replace(/[\s\/\-_]/g, '');

        // ELIMINAR SUFIJOS DE BROKERS (MT5, Forex, etc.)
        // Sufijos comunes: .pro, .fs, .i, .m, .raw, .cash, .prousdt, .fsusdt, etc.
        symbol = symbol.replace(/\.PRO(USDT)?$/i, ''); // .pro, .prousdt
        symbol = symbol.replace(/\.FS(USDT)?$/i, '');  // .fs, .fsusdt
        symbol = symbol.replace(/\.I$/i, '');          // .i
        symbol = symbol.replace(/\.M$/i, '');          // .m
        symbol = symbol.replace(/\.RAW$/i, '');        // .raw
        symbol = symbol.replace(/\.CASH$/i, '');       // .cash
        symbol = symbol.replace(/\.E$/i, '');          // .e
        symbol = symbol.replace(/\.C$/i, '');          // .c
        symbol = symbol.replace(/[Pp]$/, '');          // Elimina 'p' o 'P' al final
        symbol = symbol.replace(/D[Pp]$/, '');         // Elimina 'Dp' o 'DP' al final
        
        console.log(`🔄 Símbolo original: "${instrument}" → Limpiado: "${symbol}"`);

        // Mapeo para diferentes tipos de instrumentos
        const symbolMap = {
            // ============================================
            // CRIPTOMONEDAS (BINANCE)
            // ============================================
            // Top 10
            'BTC': 'BINANCE:BTCUSDT',
            'BTCUSD': 'BINANCE:BTCUSDT',
            'BTCUSDT': 'BINANCE:BTCUSDT',
            'BITCOIN': 'BINANCE:BTCUSDT',
            
            // Futuros de Bitcoin (CME)
            'BTC1!': 'CME:BTC1!',
            'BTCFUTURE': 'CME:BTC1!',
            'MBT': 'CME:MBT1!', // Micro Bitcoin
            
            'ETH': 'BINANCE:ETHUSDT',
            'ETHUSD': 'BINANCE:ETHUSDT',
            'ETHUSDT': 'BINANCE:ETHUSDT',
            'ETHEREUM': 'BINANCE:ETHUSDT',
            
            // Futuros de Ethereum (CME)
            'ETH1!': 'CME:ETH1!',
            'ETHFUTURE': 'CME:ETH1!',
            'MET': 'CME:MET1!', // Micro Ethereum
            'BNB': 'BINANCE:BNBUSDT',
            'BNBUSDT': 'BINANCE:BNBUSDT',
            'SOL': 'BINANCE:SOLUSDT',
            'SOLUSDT': 'BINANCE:SOLUSDT',
            'SOLANA': 'BINANCE:SOLUSDT',
            'XRP': 'BINANCE:XRPUSDT',
            'XRPUSDT': 'BINANCE:XRPUSDT',
            'RIPPLE': 'BINANCE:XRPUSDT',
            'ADA': 'BINANCE:ADAUSDT',
            'ADAUSDT': 'BINANCE:ADAUSDT',
            'CARDANO': 'BINANCE:ADAUSDT',
            'DOGE': 'BINANCE:DOGEUSDT',
            'DOGEUSDT': 'BINANCE:DOGEUSDT',
            'DOGECOIN': 'BINANCE:DOGEUSDT',
            'DOT': 'BINANCE:DOTUSDT',
            'DOTUSDT': 'BINANCE:DOTUSDT',
            'POLKADOT': 'BINANCE:DOTUSDT',
            'MATIC': 'BINANCE:MATICUSDT',
            'MATICUSDT': 'BINANCE:MATICUSDT',
            'POLYGON': 'BINANCE:MATICUSDT',
            'AVAX': 'BINANCE:AVAXUSDT',
            'AVAXUSDT': 'BINANCE:AVAXUSDT',
            'AVALANCHE': 'BINANCE:AVAXUSDT',
            
            // Altcoins populares
            'LINK': 'BINANCE:LINKUSDT',
            'LINKUSDT': 'BINANCE:LINKUSDT',
            'CHAINLINK': 'BINANCE:LINKUSDT',
            'UNI': 'BINANCE:UNIUSDT',
            'UNIUSDT': 'BINANCE:UNIUSDT',
            'UNISWAP': 'BINANCE:UNIUSDT',
            'LTC': 'BINANCE:LTCUSDT',
            'LTCUSDT': 'BINANCE:LTCUSDT',
            'LITECOIN': 'BINANCE:LTCUSDT',
            'BCH': 'BINANCE:BCHUSDT',
            'BCHUSDT': 'BINANCE:BCHUSDT',
            'ATOM': 'BINANCE:ATOMUSDT',
            'ATOMUSDT': 'BINANCE:ATOMUSDT',
            'ALGO': 'BINANCE:ALGOUSDT',
            'ALGOUSDT': 'BINANCE:ALGOUSDT',
            'FIL': 'BINANCE:FILUSDT',
            'FILUSDT': 'BINANCE:FILUSDT',
            'NEAR': 'BINANCE:NEARUSDT',
            'NEARUSDT': 'BINANCE:NEARUSDT',
            'APT': 'BINANCE:APTUSDT',
            'APTUSDT': 'BINANCE:APTUSDT',
            'ARB': 'BINANCE:ARBUSDT',
            'ARBUSDT': 'BINANCE:ARBUSDT',
            'OP': 'BINANCE:OPUSDT',
            'OPUSDT': 'BINANCE:OPUSDT',
            'SUI': 'BINANCE:SUIUSDT',
            'SUIUSDT': 'BINANCE:SUIUSDT',
            
            // Tokens adicionales
            'RIVER': 'GATEIO:RIVERUSDT',
            'RIVERUSDT': 'GATEIO:RIVERUSDT',
            'VIRTUAL': 'BYBIT:VIRTUALUSDT',
            'VIRTUALUSDT': 'BYBIT:VIRTUALUSDT',
            'PENGU': 'BINANCE:PENGUUSDT',
            'PENGUUSDT': 'BINANCE:PENGUUSDT',

            // ============================================
            // FOREX (FX)
            // ============================================
            // Pares Principales (Majors)
            'EURUSD': 'FX:EURUSD',
            'GBPUSD': 'FX:GBPUSD',
            'USDJPY': 'FX:USDJPY',
            'AUDUSD': 'FX:AUDUSD',
            'USDCAD': 'FX:USDCAD',
            'NZDUSD': 'FX:NZDUSD',
            'USDCHF': 'FX:USDCHF',
            
            // Futuros de Forex (CME)
            '6E': 'CME:6E1!', // Euro Futuro
            '6B': 'CME:6B1!', // Libra Futuro
            '6J': 'CME:6J1!', // Yen Futuro
            '6A': 'CME:6A1!', // Dólar Australiano Futuro
            '6C': 'CME:6C1!', // Dólar Canadiense Futuro
            '6N': 'CME:6N1!', // Dólar Neozelandés Futuro
            '6S': 'CME:6S1!', // Franco Suizo Futuro
            
            // Pares Cruzados (Crosses)
            'EURGBP': 'FX:EURGBP',
            'EURJPY': 'FX:EURJPY',
            'GBPJPY': 'FX:GBPJPY',
            'AUDJPY': 'FX:AUDJPY',
            'EURAUD': 'FX:EURAUD',
            'EURCHF': 'FX:EURCHF',
            'GBPCHF': 'FX:GBPCHF',
            'AUDNZD': 'FX:AUDNZD',
            'AUDCAD': 'FX:AUDCAD',
            'EURAUD': 'FX:EURAUD',
            'EURNZD': 'FX:EURNZD',
            'GBPAUD': 'FX:GBPAUD',
            'GBPNZD': 'FX:GBPNZD',
            'CADJPY': 'FX:CADJPY',
            'NZDJPY': 'FX:NZDJPY',
            'CHFJPY': 'FX:CHFJPY',
            
            // Pares Exóticos
            'USDMXN': 'FX:USDMXN',
            'USDZAR': 'FX:USDZAR',
            'USDTRY': 'FX:USDTRY',
            'USDBRL': 'FX:USDBRL',
            'USDCNH': 'FX:USDCNH',

            // ============================================
            // FUTUROS DE ÍNDICES (CME, NASDAQ)
            // ============================================
            // E-mini S&P 500
            'ES': 'CME_MINI:ES1!',
            'ESP': 'CME_MINI:ES1!',
            'SPX': 'SP:SPX',
            'SP500': 'SP:SPX',
            'SPY': 'AMEX:SPY',
            'USA500': 'CME_MINI:ES1!',
            'SPX500': 'SP:SPX',
            
            // ============================================
            // ÍNDICES - FUTUROS CME/CBOT/EUREX/MEFF
            // ============================================
            // === NASDAQ 100 ===
            'NQ': 'CME_MINI:NQ1!',
            'NQP': 'CME_MINI:NQ1!',
            'NASDAQ': 'CME_MINI:NQ1!',
            'NAS100': 'CME_MINI:NQ1!',
            'US100': 'CME_MINI:NQ1!',
            'USTEC': 'CME_MINI:NQ1!',
            // Micro E-mini Nasdaq (MNQ)
            'MNQ': 'CME_MINI:MNQ1!',
            'MNQP': 'CME_MINI:MNQ1!',
            'MNQMAR': 'CME_MINI:MNQ1!',
            'MNQMAR26': 'CME_MINI:MNQ1!',
            
            // === S&P 500 ===
            'ES': 'CME_MINI:ES1!',
            'ESP': 'CME_MINI:ES1!',
            'SP500': 'CME_MINI:ES1!',
            'USA500': 'CME_MINI:ES1!',
            'SPX500': 'CME_MINI:ES1!',
            // Micro E-mini S&P 500
            'MES': 'CME_MINI:MES1!',
            'MESP': 'CME_MINI:MES1!',
            
            // === DOW JONES ===
            'YM': 'CBOT_MINI:YM1!',
            'YMP': 'CBOT_MINI:YM1!',
            'US30': 'CBOT_MINI:YM1!',
            'DOW': 'CBOT_MINI:YM1!',
            'DJI': 'CBOT_MINI:YM1!',
            // Micro E-mini Dow
            'MYM': 'CBOT_MINI:MYM1!',
            'MYMP': 'CBOT_MINI:MYM1!',
            
            // === RUSSELL 2000 ===
            'RTY': 'CME:RTY1!',
            'RTYP': 'CME:RTY1!',
            'US2000': 'CME:RTY1!',
            // Micro Russell 2000
            'M2K': 'CME_MINI:M2K1!',

            // === DAX 40 (Alemania - EUREX) ===
            'DAX': 'EUREX:FDAX1!',
            'FDAX': 'EUREX:FDAX1!',
            'FDAXP': 'EUREX:FDAX1!',
            'GER40': 'EUREX:FDAX1!',
            'DE40': 'EUREX:FDAX1!',
            
            // === EURO STOXX 50 (Europa - EUREX) ===
            'FESX': 'EUREX:FESX1!',
            'FESXP': 'EUREX:FESX1!',
            'EU50': 'EUREX:FESX1!',
            'ESTX50': 'EUREX:FESX1!',
            'EUROSTOXX': 'EUREX:FESX1!',
            
            // === IBEX 35 (España - MEFF) ===
            'IBX': 'MEFF:IBEX1!',
            'IBXP': 'MEFF:IBEX1!',
            'IBEX': 'MEFF:IBEX1!',
            'ESP35': 'MEFF:IBEX1!',
            'IBEX35': 'MEFF:IBEX1!',
            
            // === FTSE 100 (Reino Unido) ===
            'FTSE': 'ICE:Z1!',
            'UK100': 'ICE:Z1!',
            
            // === CAC 40 (Francia) ===
            'CAC': 'EUREX:FCE1!',
            'FR40': 'EUREX:FCE1!',
            
            // ============================================
            // ÍNDICES ASIA/OCEANÍA
            // ============================================
            'NIKKEI': 'CME:NKD1!',
            'JP225': 'CME:NKD1!',
            'HSI': 'HKEX:HSI1!',
            'HK50': 'HKEX:HSI1!',
            'ASX': 'ASX:XJO',
            'AUS200': 'ASX:XJO',

            // ============================================
            // COMMODITIES - METALES PRECIOSOS
            // ============================================
            // === ORO (COMEX) ===
            'GOLD': 'COMEX:GC1!',
            'XAUUSD': 'COMEX:GC1!',
            'GC': 'COMEX:GC1!',
            'GCP': 'COMEX:GC1!',
            'MGC': 'COMEX:MGC1!', // Micro Gold
            'MGCP': 'COMEX:MGC1!',
            
            // === PLATA (COMEX) ===
            'SILVER': 'COMEX:SI1!',
            'XAGUSD': 'COMEX:SI1!',
            'SI': 'COMEX:SI1!',
            'SIP': 'COMEX:SI1!',
            'SIL': 'COMEX:SIL1!', // Micro Silver
            'SILP': 'COMEX:SIL1!',
            
            // Platino
            'PLATINUM': 'NYMEX:PL1!',
            'PL': 'NYMEX:PL1!',
            'PLP': 'NYMEX:PL1!',
            
            // Paladio
            'PALLADIUM': 'NYMEX:PA1!',
            'PA': 'NYMEX:PA1!',
            'PAP': 'NYMEX:PA1!',
            
            // Cobre
            'COPPER': 'COMEX:HG1!',
            'HG': 'COMEX:HG1!',
            'HGP': 'COMEX:HG1!',

            // ============================================
            // COMMODITIES - ENERGÍA (NYMEX)
            // ============================================
            // === PETRÓLEO WTI (EE.UU.) ===
            'OIL': 'NYMEX:CL1!',
            'CRUDE': 'NYMEX:CL1!',
            'CL': 'NYMEX:CL1!',
            'CLP': 'NYMEX:CL1!',
            'MCL': 'NYMEX:MCL1!', // Micro WTI
            'MCLP': 'NYMEX:MCL1!',
            'WTI': 'NYMEX:CL1!',
            'USOIL': 'NYMEX:CL1!',
            'OILCASH': 'NYMEX:CL1!',
            'QM': 'NYMEX:QM1!', // Micro WTI alternativo
            
            // === PETRÓLEO BRENT (Europa) ===
            'BRENT': 'NYMEX:BZ1!',
            'UKOIL': 'NYMEX:BZ1!',
            'BZ': 'NYMEX:BZ1!',
            'BZP': 'NYMEX:BZ1!',
            'EB': 'NYMEX:EB1!', // E-mini Brent
            'EBP': 'NYMEX:EB1!',
            
            // === GAS NATURAL ===
            'NG': 'NYMEX:NG1!',
            'NGP': 'NYMEX:NG1!',
            'NATURALGAS': 'NYMEX:NG1!',
            'NATGAS': 'NYMEX:NG1!',
            'GAS': 'NYMEX:NG1!',
            
            // Gasolina
            'RB': 'NYMEX:RB1!',
            'RBOB': 'NYMEX:RB1!',
            
            // Heating Oil
            'HO': 'NYMEX:HO1!',

            // ============================================
            // COMMODITIES - AGRICULTURA
            // ============================================
            // Granos
            'CORN': 'CBOT:ZC1!',
            'ZC': 'CBOT:ZC1!',
            'WHEAT': 'CBOT:ZW1!',
            'ZW': 'CBOT:ZW1!',
            'SOYBEANS': 'CBOT:ZS1!',
            'ZS': 'CBOT:ZS1!',
            
            // Softs
            'SUGAR': 'ICEUS:SB1!',
            'SB': 'ICEUS:SB1!',
            'COFFEE': 'ICEUS:KC1!',
            'KC': 'ICEUS:KC1!',
            'COTTON': 'ICEUS:CT1!',
            'CT': 'ICEUS:CT1!',
            'COCOA': 'ICEUS:CC1!',
            'CC': 'ICEUS:CC1!',
            
            // Ganadería
            'CATTLE': 'CME:LE1!',
            'LE': 'CME:LE1!',
            'FEEDER': 'CME:GF1!',
            'GF': 'CME:GF1!',
            'HOGS': 'CME:HE1!',
            'HE': 'CME:HE1!',

            // ============================================
            // BONOS Y TASAS DE INTERÉS
            // ============================================
            // US Treasury
            'ZN': 'CBOT:ZN1!',    // 10-Year Note
            'ZB': 'CBOT:ZB1!',    // 30-Year Bond
            'ZF': 'CBOT:ZF1!',    // 5-Year Note
            'ZT': 'CBOT:ZT1!',    // 2-Year Note
            'TN': 'CBOT:ZN1!',
            'US10Y': 'TVC:US10Y',
            'US30Y': 'TVC:US30Y',
            'US2Y': 'TVC:US02Y',

            // ============================================
            // ACCIONES POPULARES (NASDAQ/NYSE)
            // ============================================
            // Tech Giants
            'AAPL': 'NASDAQ:AAPL',
            'APPLE': 'NASDAQ:AAPL',
            'MSFT': 'NASDAQ:MSFT',
            'MICROSOFT': 'NASDAQ:MSFT',
            'GOOGL': 'NASDAQ:GOOGL',
            'GOOGLE': 'NASDAQ:GOOGL',
            'AMZN': 'NASDAQ:AMZN',
            'AMAZON': 'NASDAQ:AMZN',
            'META': 'NASDAQ:META',
            'FACEBOOK': 'NASDAQ:META',
            'TSLA': 'NASDAQ:TSLA',
            'TESLA': 'NASDAQ:TSLA',
            'NVDA': 'NASDAQ:NVDA',
            'NVIDIA': 'NASDAQ:NVDA',
            'AMD': 'NASDAQ:AMD',
            'NFLX': 'NASDAQ:NFLX',
            'NETFLIX': 'NASDAQ:NFLX',
            
            // Financial
            'JPM': 'NYSE:JPM',
            'BAC': 'NYSE:BAC',
            'WFC': 'NYSE:WFC',
            'GS': 'NYSE:GS',
            'MS': 'NYSE:MS',
            
            // Industrial
            'BA': 'NYSE:BA',
            'BOEING': 'NYSE:BA',
            'CAT': 'NYSE:CAT',
            'GE': 'NYSE:GE',
            
            // Retail
            'WMT': 'NYSE:WMT',
            'WALMART': 'NYSE:WMT',
            'HD': 'NYSE:HD',
            'TGT': 'NYSE:TGT',
            
            // Healthcare
            'JNJ': 'NYSE:JNJ',
            'PFE': 'NYSE:PFE',
            'UNH': 'NYSE:UNH',
            'MRNA': 'NASDAQ:MRNA',
            
            // Energy
            'XOM': 'NYSE:XOM',
            'CVX': 'NYSE:CVX',
            'COP': 'NYSE:COP'
        };

        // ============================================
        // SISTEMA DE FALLBACK: Exchanges alternativos y CFDs
        // ============================================
        // === CONFIGURACIÓN DE FALLBACKS POR SÍMBOLO BASE ===
        // ORDEN: CFD SIEMPRE PRIMERO (sin notificaciones)
        // ============================================
        const exchangeFallbacks = {
            // ========== ÍNDICES DE EE.UU. ==========
            // S&P 500
            'ES': ['CAPITALCOM:US500', 'OANDA:SPX500USD'],
            'MES': ['CAPITALCOM:US500', 'OANDA:SPX500USD'],
            'SPX': ['CAPITALCOM:US500', 'OANDA:SPX500USD'],
            'SP500': ['CAPITALCOM:US500', 'OANDA:SPX500USD'],
            'USA500': ['CAPITALCOM:US500', 'OANDA:SPX500USD'],
            'SPX500': ['CAPITALCOM:US500', 'OANDA:SPX500USD'],
            
            // Nasdaq 100
            'NQ': ['CAPITALCOM:US100', 'OANDA:NAS100USD'],
            'MNQ': ['CAPITALCOM:US100', 'OANDA:NAS100USD'],
            'NAS100': ['CAPITALCOM:US100', 'OANDA:NAS100USD'],
            'USTEC': ['CAPITALCOM:US100', 'OANDA:NAS100USD'],
            'NASDAQ': ['CAPITALCOM:US100', 'OANDA:NAS100USD'],
            'US100': ['CAPITALCOM:US100', 'OANDA:NAS100USD'],
            
            // Dow Jones
            'YM': ['CAPITALCOM:US30', 'OANDA:US30USD'],
            'MYM': ['CAPITALCOM:US30', 'OANDA:US30USD'],
            'US30': ['CAPITALCOM:US30', 'OANDA:US30USD'],
            'DOW': ['CAPITALCOM:US30', 'OANDA:US30USD'],
            'DJI': ['CAPITALCOM:US30', 'OANDA:US30USD'],
            
            // Russell 2000
            'RTY': ['CAPITALCOM:RTY', 'OANDA:US2000USD'],
            'M2K': ['CAPITALCOM:RTY', 'OANDA:US2000USD'],
            
            // ========== ÍNDICES EUROPA ==========
            // DAX 40 (Alemania)
            'FDAX': ['CAPITALCOM:DE40', 'OANDA:DE30EUR'],
            'DAX': ['CAPITALCOM:DE40', 'OANDA:DE30EUR'],
            'GER40': ['CAPITALCOM:DE40', 'OANDA:DE30EUR'],
            'DE40': ['CAPITALCOM:DE40', 'OANDA:DE30EUR'],
            
            // Euro Stoxx 50
            'FESX': ['CAPITALCOM:EU50', 'OANDA:EU50EUR'],
            'EU50': ['CAPITALCOM:EU50', 'OANDA:EU50EUR'],
            'ESTX50': ['CAPITALCOM:EU50', 'OANDA:EU50EUR'],
            'EUROSTOXX': ['CAPITALCOM:EU50', 'OANDA:EU50EUR'],
            
            // IBEX 35 (España)
            'IBX': ['CAPITALCOM:ES35'],
            'IBEX': ['CAPITALCOM:ES35'],
            'ESP35': ['CAPITALCOM:ES35'],
            'IBEX35': ['CAPITALCOM:ES35'],
            
            // ========== METALES PRECIOSOS ==========
            // Oro
            'GC': ['OANDA:XAUUSD', 'CAPITALCOM:GOLD'],
            'MGC': ['OANDA:XAUUSD', 'CAPITALCOM:GOLD'],
            'GOLD': ['OANDA:XAUUSD', 'CAPITALCOM:GOLD'],
            'XAUUSD': ['OANDA:XAUUSD', 'CAPITALCOM:GOLD'],
            
            // Plata
            'SI': ['OANDA:XAGUSD', 'CAPITALCOM:SILVER'],
            'SIL': ['OANDA:XAGUSD', 'CAPITALCOM:SILVER'],
            'SILVER': ['OANDA:XAGUSD', 'CAPITALCOM:SILVER'],
            'XAGUSD': ['OANDA:XAGUSD', 'CAPITALCOM:SILVER'],
            
            // Cobre
            'HG': ['CAPITALCOM:COPPER'],
            'COPPER': ['CAPITALCOM:COPPER'],
            
            // Platino
            'PL': ['CAPITALCOM:PLATINUM'],
            'PLATINUM': ['CAPITALCOM:PLATINUM'],
            
            // Paladio
            'PA': ['CAPITALCOM:PALLADIUM'],
            'PALLADIUM': ['CAPITALCOM:PALLADIUM'],
            
            // ========== ENERGÍA ==========
            // Petróleo WTI (EE.UU.)
            'CL': ['OANDA:WTIUSD', 'CAPITALCOM:OIL'],
            'MCL': ['OANDA:WTIUSD', 'CAPITALCOM:OIL'],
            'WTI': ['OANDA:WTIUSD', 'CAPITALCOM:OIL'],
            'OILCASH': ['OANDA:WTIUSD', 'CAPITALCOM:OIL'],
            'USOIL': ['OANDA:WTIUSD', 'CAPITALCOM:OIL'],
            'OIL': ['OANDA:WTIUSD', 'CAPITALCOM:OIL'],
            
            // Petróleo Brent (Europa)
            'BZ': ['OANDA:BCOUSD', 'CAPITALCOM:BRENT'],
            'EB': ['OANDA:BCOUSD', 'CAPITALCOM:BRENT'],
            'BRENT': ['OANDA:BCOUSD', 'CAPITALCOM:BRENT'],
            'UKOIL': ['OANDA:BCOUSD', 'CAPITALCOM:BRENT'],
            
            // Gas Natural
            'NG': ['OANDA:NATGASUSD', 'CAPITALCOM:GAS'],
            'NATGAS': ['OANDA:NATGASUSD', 'CAPITALCOM:GAS'],
            'NATGAS': ['NYMEX:NG1!', 'OANDA:NATGASUSD', 'CAPITALCOM:GAS', 'TVC:NATURALGAS'],
            'GAS': ['NYMEX:NG1!', 'OANDA:NATGASUSD', 'CAPITALCOM:GAS', 'TVC:NATURALGAS'],
            
            // ========== FOREX FUTUROS (CME) ==========
            // Euro / USD
            '6E': ['CME:6E1!', 'OANDA:EURUSD', 'FX:EURUSD'],
            'EURUSD': ['CME:6E1!', 'OANDA:EURUSD', 'FX:EURUSD'],
            
            // Libra / USD
            '6B': ['CME:6B1!', 'OANDA:GBPUSD', 'FX:GBPUSD'],
            'GBPUSD': ['CME:6B1!', 'OANDA:GBPUSD', 'FX:GBPUSD'],
            
            // USD / Yen
            '6J': ['CME:6J1!', 'OANDA:USDJPY', 'FX:USDJPY'],
            'USDJPY': ['CME:6J1!', 'OANDA:USDJPY', 'FX:USDJPY'],
            
            // AUD / USD
            '6A': ['CME:6A1!', 'OANDA:AUDUSD', 'FX:AUDUSD'],
            'AUDUSD': ['CME:6A1!', 'OANDA:AUDUSD', 'FX:AUDUSD'],
            
            // Dólar Canadiense
            '6C': ['CME:6C1!', 'FX:USDCAD', 'OANDA:USDCAD'],
            'USDCAD': ['FX:USDCAD', 'CME:6C1!', 'OANDA:USDCAD'],
            
            // Dólar Neozelandés
            '6N': ['CME:6N1!', 'FX:NZDUSD', 'OANDA:NZDUSD'],
            'NZDUSD': ['FX:NZDUSD', 'CME:6N1!', 'OANDA:NZDUSD'],
            
            // Franco Suizo
            '6S': ['CME:6S1!', 'FX:USDCHF', 'OANDA:USDCHF'],
            'USDCHF': ['FX:USDCHF', 'CME:6S1!', 'OANDA:USDCHF'],
            
            // ========== CRIPTOMONEDAS ==========
            // Bitcoin
            'BTC': ['BINANCE:BTCUSDT', 'CME:BTC1!', 'COINBASE:BTCUSD'],
            'BTCUSD': ['BINANCE:BTCUSDT', 'CME:BTC1!', 'COINBASE:BTCUSD'],
            'MBT': ['BINANCE:BTCUSDT', 'CME:MBT1!', 'CME:BTC1!'],
            
            // Ethereum
            'ETH': ['BINANCE:ETHUSDT', 'CME:ETH1!', 'COINBASE:ETHUSD'],
            'ETHUSD': ['BINANCE:ETHUSDT', 'CME:ETH1!', 'COINBASE:ETHUSD'],
            'MET': ['BINANCE:ETHUSDT', 'CME:MET1!', 'CME:ETH1!'],
            
            // Altcoins adicionales
            'RIVER': ['GATEIO:RIVERUSDT', 'BYBIT:RIVERUSDT'],
            'RIVERUSDT': ['GATEIO:RIVERUSDT', 'BYBIT:RIVERUSDT'],
            'VIRTUAL': ['BYBIT:VIRTUALUSDT', 'GATEIO:VIRTUALUSDT'],
            'VIRTUALUSDT': ['BYBIT:VIRTUALUSDT', 'GATEIO:VIRTUALUSDT'],
            'PENGU': ['BINANCE:PENGUUSDT', 'BYBIT:PENGUUSDT'],
            'PENGUUSDT': ['BINANCE:PENGUUSDT', 'BYBIT:PENGUUSDT'],
            
            // ========== ÍNDICES ADICIONALES ==========
            'FTSE': ['CAPITALCOM:UK100', 'ICE:Z1!'],
            'UK100': ['CAPITALCOM:UK100'],
            'CAC': ['CAPITALCOM:FR40', 'EUREX:FCE1!'],
            'FR40': ['CAPITALCOM:FR40'],
            'FCE': ['CAPITALCOM:FR40', 'EUREX:FCE1!'],
            
            // ========== ENERGÍA ADICIONAL ==========
            'QM': ['OANDA:WTIUSD', 'CAPITALCOM:OIL', 'NYMEX:QM1!'],
            'RB': ['CAPITALCOM:GASOLINE', 'NYMEX:RB1!'],
            'HO': ['CAPITALCOM:HEATINGOIL', 'NYMEX:HO1!'],
            
            // ========== BONOS (CFDs limitados) ==========
            'ZN': ['TVC:US10Y', 'CBOT:ZN1!'],
            'ZB': ['TVC:US30Y', 'CBOT:ZB1!'],
            'ZF': ['TVC:US05Y', 'CBOT:ZF1!'],
            'ZT': ['TVC:US02Y', 'CBOT:ZT1!']
        };
        
        // Guardar símbolo original para verificación de fallback
        window.currentSymbolFallbacks = null;

        // ============================================
        // PRIORIDAD #1: FORZAR CFD PARA CUALQUIER FUTURO
        // ============================================
        // Verificar PRIMERO si es un futuro y forzar CFD directamente
        const futuresBases = [
            'MNQ','NQ','ES','MES','YM','MYM','RTY','M2K', // Índices US
            'FDAX','DAX','FESX','IBX','FTSE','CAC','FCE', // Índices EU
            'GC','MGC','SI','SIL','PL','PA','HG', // Metales
            'CL','MCL','QM','NG','BZ','EB','RB','HO', // Energía
            '6E','6B','6J','6A','6C','6N','6S', // Forex Futuros
            'BTC','ETH','MBT','MET', // Cripto Futuros
            'ZN','ZB','ZF','ZT', // Bonos
            'ZC','ZW','ZS','SB','KC','CT','CC','LE','GF','HE' // Agricultura
        ];
        
        // Detectar si es un futuro (comienza con algún símbolo base)
        let detectedBaseSymbol = null;
        for (const base of futuresBases) {
            if (symbol.toUpperCase().startsWith(base)) {
                detectedBaseSymbol = base;
                break;
            }
        }
        
        // Si es un futuro Y tiene CFD disponible, FORZAR CFD
        if (detectedBaseSymbol && exchangeFallbacks[detectedBaseSymbol] && exchangeFallbacks[detectedBaseSymbol].length > 0) {
            const cfdSymbol = exchangeFallbacks[detectedBaseSymbol][0]; // SIEMPRE primer elemento = CFD
            console.log(`🎯 [FUTURO→CFD FORZADO] "${symbol}" (base: ${detectedBaseSymbol}) → "${cfdSymbol}"`);
            
            window.currentSymbolFallbacks = {
                current: cfdSymbol,
                alternatives: exchangeFallbacks[detectedBaseSymbol],
                baseSymbol: detectedBaseSymbol,
                attemptIndex: 0,
                originalSymbol: symbol,
                isForcedCFD: true
            };
            
            return cfdSymbol;
        }

        // ============================================
        // FUNCIÓN UNIVERSAL DE DETECCIÓN DE FUTUROS
        // ============================================
        // Detecta si el símbolo es un futuro en CUALQUIER formato
        function isFutureSymbol(sym) {
            // Lista completa de símbolos base de futuros
            const futuresBases = [
                'MNQ','NQ','ES','MES','YM','MYM','RTY','M2K', // Índices US
                'FDAX','DAX','FESX','IBX','FTSE','CAC','FCE', // Índices EU
                'GC','MGC','SI','SIL','PL','PA','HG', // Metales
                'CL','MCL','QM','NG','BZ','EB','RB','HO', // Energía
                '6E','6B','6J','6A','6C','6N','6S', // Forex Futuros
                'BTC','ETH','MBT','MET', // Cripto Futuros
                'ZN','ZB','ZF','ZT', // Bonos
                'ZC','ZW','ZS','SB','KC','CT','CC','LE','GF','HE' // Agricultura
            ];
            
            // Verificar si empieza con algún símbolo base de futuro
            return futuresBases.some(base => {
                const regex = new RegExp(`^${base}`, 'i');
                return regex.test(sym);
            });
        }
        
        // Función para extraer símbolo base de un futuro
        function extractBaseSymbol(sym) {
            const futuresBases = [
                'MNQMAR','MNQ','NQ','ES','MES','YM','MYM','RTY','M2K',
                'FDAX','DAX','FESX','IBX','FTSE','CAC','FCE',
                'GC','MGC','SI','SIL','PL','PA','HG',
                'CL','MCL','QM','NG','BZ','EB','RB','HO',
                '6E','6B','6J','6A','6C','6N','6S',
                'BTC','ETH','MBT','MET',
                'ZN','ZB','ZF','ZT',
                'ZC','ZW','ZS','SB','KC','CT','CC','LE','GF','HE'
            ];
            
            for (const base of futuresBases) {
                if (sym.toUpperCase().startsWith(base)) {
                    return base;
                }
            }
            return sym;
        }
        
        // Buscar en el mapeo exacto
        if (symbolMap[symbol]) {
            let finalSymbol = symbolMap[symbol];
            
            // Extraer símbolo BASE para buscar fallbacks
            const baseSymbol = extractBaseSymbol(symbol);
            
            // ESTRATEGIA: Si hay fallbacks, usar SIEMPRE el primero (que es CFD)
            if (exchangeFallbacks[baseSymbol] && exchangeFallbacks[baseSymbol].length > 0) {
                finalSymbol = exchangeFallbacks[baseSymbol][0]; // Usar SIEMPRE el primero (CFD)
                console.log(`✅ Usando CFD directamente: "${symbol}" (base: "${baseSymbol}") → "${finalSymbol}"`);
                
                window.currentSymbolFallbacks = {
                    current: finalSymbol,
                    alternatives: exchangeFallbacks[baseSymbol].slice(1), // Resto de alternativas
                    baseSymbol: baseSymbol,
                    attemptIndex: 0
                };
                console.log(`🔄 Fallbacks disponibles:`, window.currentSymbolFallbacks.alternatives);
            } else {
                console.log(`✅ Símbolo encontrado en mapeo: "${symbol}" → "${symbolMap[symbol]}"`);
            }
            
            return finalSymbol;
        }

        // ============================================
        // DETECCIÓN INTELIGENTE DE FUTUROS CON FECHAS
        // ============================================
        // Patrones COMPLETOS: MNQMAR26, ESMAR26, NQMAR26, ESH26, FDAXZ26, 6EH26, NQH6, etc.
        // Incluye: Meses completos (MAR,JUN,SEP,DEC), Códigos de mes (H,M,U,Z,F,G,J,K,N,Q,V,X), Años (2 o 4 dígitos)
        const futuresPattern = /^(MNQ|NQ|ES|MES|YM|MYM|RTY|M2K|GC|MGC|SI|SIL|CL|MCL|QM|NG|BZ|EB|RB|HO|PL|PA|HG|FDAX|FESX|IBX|FTSE|CAC|FCE|DAX|6E|6B|6J|6A|6C|6N|6S|BTC|ETH|MBT|MET|ZN|ZB|ZF|ZT|ZC|ZW|ZS|SB|KC|CT|CC|LE|GF|HE)(MAR|JUN|SEP|DEC|H|M|U|Z|F|G|J|K|N|Q|V|X)?(\ )?([0-9]{1,4})?$/i;
        const match = symbol.match(futuresPattern);
        
        if (match) {
            const baseSymbol = match[1].toUpperCase();
            console.log(`🔍 Detectado futuro: base="${baseSymbol}", completo="${symbol}"`);
            
            // Mapeo de símbolos base de futuros a continuo
            const futuresMap = {
                // Índices EE.UU.
                'MNQ': 'CME_MINI:MNQ1!',
                'NQ': 'CME_MINI:NQ1!',
                'ES': 'CME_MINI:ES1!',
                'MES': 'CME_MINI:MES1!',
                'YM': 'CBOT_MINI:YM1!',
                'MYM': 'CBOT_MINI:MYM1!',
                'RTY': 'CME:RTY1!',
                'M2K': 'CME_MINI:M2K1!',
                
                // Índices Europa
                'FDAX': 'EUREX:FDAX1!',
                'DAX': 'EUREX:FDAX1!',
                'FESX': 'EUREX:FESX1!',
                'IBX': 'BME:IBC',
                'FTSE': 'ICE:Z1!',
                'CAC': 'EUREX:FCE1!',
                'FCE': 'EUREX:FCE1!',
                
                // Metales
                'GC': 'COMEX:GC1!',
                'MGC': 'COMEX:MGC1!',
                'SI': 'COMEX:SI1!',
                'SIL': 'COMEX:SI1!',
                'PL': 'NYMEX:PL1!',
                'PA': 'NYMEX:PA1!',
                'HG': 'COMEX:HG1!',
                
                // Energía
                'CL': 'NYMEX:CL1!',
                'MCL': 'NYMEX:MCL1!',
                'QM': 'NYMEX:QM1!',
                'NG': 'NYMEX:NG1!',
                'BZ': 'NYMEX:BZ1!',
                'EB': 'NYMEX:BZ1!',
                'RB': 'NYMEX:RB1!',
                'HO': 'NYMEX:HO1!',
                
                // Forex Futuros
                '6E': 'CME:6E1!',
                '6B': 'CME:6B1!',
                '6J': 'CME:6J1!',
                '6A': 'CME:6A1!',
                '6C': 'CME:6C1!',
                '6N': 'CME:6N1!',
                '6S': 'CME:6S1!',
                
                // Cripto Futuros
                'BTC': 'CME:BTC1!',
                'MBT': 'CME:MBT1!',
                'ETH': 'CME:ETH1!',
                'MET': 'CME:MET1!',
                
                // Bonos y Tasas
                'ZN': 'CBOT:ZN1!',
                'ZB': 'CBOT:ZB1!',
                'ZF': 'CBOT:ZF1!',
                'ZT': 'CBOT:ZT1!',
                
                // Agricultura
                'ZC': 'CBOT:ZC1!',
                'ZW': 'CBOT:ZW1!',
                'ZS': 'CBOT:ZS1!',
                'SB': 'ICEUS:SB1!',
                'KC': 'ICEUS:KC1!',
                'CT': 'ICEUS:CT1!',
                'CC': 'ICEUS:CC1!',
                
                // Ganadería
                'LE': 'CME:LE1!',
                'GF': 'CME:GF1!',
                'HE': 'CME:HE1!'
            };
            
            if (futuresMap[baseSymbol]) {
                // ESTRATEGIA: Devolver CFD directamente SIEMPRE
                if (exchangeFallbacks[baseSymbol] && exchangeFallbacks[baseSymbol].length > 0) {
                    const cfdSymbol = exchangeFallbacks[baseSymbol][0]; // Usar SIEMPRE el primero (CFD)
                    console.log(`✅ Usando CFD directamente: "${symbol}" (futuro detectado) → "${cfdSymbol}"`);
                    
                    window.currentSymbolFallbacks = {
                        current: cfdSymbol,
                        alternatives: exchangeFallbacks[baseSymbol].slice(1),
                        baseSymbol: baseSymbol,
                        attemptIndex: 0
                    };
                    return cfdSymbol;
                }
                
                // Solo si NO hay fallbacks, usar futuro (no debería pasar)
                console.log(`⚠️ Sin CFD disponible, usando futuro: "${symbol}" → "${futuresMap[baseSymbol]}"`);
                return futuresMap[baseSymbol];
                
                return futuresMap[baseSymbol];
            }
        }

        // ============================================
        // AUTO-DETECCIÓN POR PATRONES
        // ============================================
        
        // Criptomonedas: termina en USD o USDT
        if (symbol.endsWith('USD') || symbol.endsWith('USDT')) {
            if (symbol.endsWith('USDT')) {
                console.log(`🪙 Auto-detectado como cripto: "${symbol}" → "BINANCE:${symbol}"`);
                return 'BINANCE:' + symbol;
            } else {
                console.log(`🪙 Auto-detectado como cripto: "${symbol}" → "BINANCE:${symbol}T"`);
                return 'BINANCE:' + symbol + 'T';
            }
        }

        // Forex: 6 caracteres sin USD al final
        if (symbol.length === 6 && !symbol.endsWith('USD') && /^[A-Z]{6}$/.test(symbol)) {
            console.log(`💱 Auto-detectado como forex: "${symbol}" → "FX:${symbol}"`);
            return 'FX:' + symbol;
        }

        // Índices con números: US30, NAS100, etc.
        if (/^[A-Z]+\d+$/.test(symbol) && symbol.length <= 8) {
            console.log(`📊 Auto-detectado como índice: "${symbol}" → "CAPITALCOM:${symbol}"`);
            return 'CAPITALCOM:' + symbol;
        }
        
        // Acciones: 1-5 caracteres alfabéticos
        if (/^[A-Z]{1,5}$/.test(symbol) && symbol.length <= 5) {
            console.log(`📈 Auto-detectado como acción: "${symbol}" → "NASDAQ:${symbol}"`);
            return 'NASDAQ:' + symbol;
        }

        // Default: intentar como cripto en Binance
        console.log(`⚠️ No se detectó tipo, usando default: "${symbol}" → "BINANCE:${symbol}USDT"`);
        return 'BINANCE:' + symbol + 'USDT';
    }

function updateChartInfo(operation) {
    const precision = getInstrumentPrecision(operation.instrument);

    const elements = {
        entryPrice: document.getElementById('chart-entry-price'),
        exitPrice: document.getElementById('chart-exit-price'),
        entryTime: document.getElementById('chart-entry-time'),
        exitTime: document.getElementById('chart-exit-time'),
        pl: document.getElementById('chart-pl-display')
    };

    if (elements.entryPrice) elements.entryPrice.textContent = operation.entry ? operation.entry.toFixed(precision) : '-';
    if (elements.exitPrice) elements.exitPrice.textContent = operation.exit ? operation.exit.toFixed(precision) : '-';
    if (elements.entryTime) elements.entryTime.textContent = operation.entryTime ? `${operation.date} ${operation.entryTime}` : '-';
    if (elements.exitTime) elements.exitTime.textContent = operation.exitTime ? `${operation.date} ${operation.exitTime}` : '-';

    if (elements.pl) {
        elements.pl.textContent = formatCurrency(operation.pl, operation.currency, operation.currency);
        elements.pl.className = `ml-2 font-bold text-lg ${operation.pl >= 0 ? 'text-green-400' : 'text-red-400'}`;
    }
}
    // Crear panel de información simple
    function createInfoPanel(operation) {
        const container = document.getElementById('candlestick-container');
        if (!container) return;

        // Remover panel anterior
        const existing = document.getElementById('chart-info-panel');
        if (existing) existing.remove();

        const panel = document.createElement('div');
        panel.id = 'chart-info-panel';
        panel.style.cssText = `
            position: absolute; top: 60px; right: 10px; background: rgba(17, 24, 39, 0.95);
            color: white; padding: 12px; border-radius: 8px; font-size: 13px;
            z-index: 1000; border: 1px solid #374151; min-width: 200px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        `;

        const precision = getInstrumentPrecision(operation.instrument);
        const pl = operation.pl || 0;
        const plColor = pl >= 0 ? '#10B981' : '#EF4444';

        panel.innerHTML = `
            <div style="font-weight: bold; margin-bottom: 10px; color: #F3F4F6; border-bottom: 1px solid #374151; padding-bottom: 8px;">
                📊 Detalles de la Operación
            </div>
            <div style="margin-bottom: 8px;">
                <div style="display: flex; align-items: center; margin-bottom: 4px;">
                    <div style="width: 10px; height: 10px; background: #10B981; border-radius: 50%; margin-right: 8px;"></div>
                    <span style="color: #10B981; font-weight: 600;">ENTRADA:</span>
                </div>
                <div style="margin-left: 18px; color: #D1D5DB;">
                    ${operation.entry ? operation.entry.toFixed(precision) : '-'}
                    ${operation.entryTime ? `<br><small style="color: #9CA3AF;">${operation.date} ${operation.entryTime}</small>` : ''}
                </div>
            </div>
            <div style="margin-bottom: 8px;">
                <div style="display: flex; align-items: center; margin-bottom: 4px;">
                    <div style="width: 10px; height: 10px; background: #EF4444; border-radius: 50%; margin-right: 8px;"></div>
                    <span style="color: #EF4444; font-weight: 600;">SALIDA:</span>
                </div>
                <div style="margin-left: 18px; color: #D1D5DB;">
                    ${operation.exit ? operation.exit.toFixed(precision) : '-'}
                    ${operation.exitTime ? `<br><small style="color: #9CA3AF;">${operation.date} ${operation.exitTime}</small>` : ''}
                </div>
            </div>
            <div style="border-top: 1px solid #374151; padding-top: 8px; margin-top: 10px;">
                <div style="display: flex; justify-between; align-items: center;">
                    <span style="color: #F3F4F6; font-weight: 600;">P&L:</span>
                    <span style="color: ${plColor}; font-weight: bold; font-size: 14px;">
                        ${formatCurrency(pl, operation.currency, operation.currency)}
                    </span>
                </div>
            </div>
        `;

        container.appendChild(panel);
    }

    function updateChartInfo(operation) {
        const precision = getInstrumentPrecision(operation.instrument);

        const elements = {
            entryPrice: document.getElementById('chart-entry-price'),
            exitPrice: document.getElementById('chart-exit-price'),
            entryTime: document.getElementById('chart-entry-time'),
            exitTime: document.getElementById('chart-exit-time'),
            pl: document.getElementById('chart-pl-display'),
            duration: document.getElementById('chart-duration-display')
        };

        if (elements.entryPrice) elements.entryPrice.textContent = operation.entry ? operation.entry.toFixed(precision) : '-';
        if (elements.exitPrice) elements.exitPrice.textContent = operation.exit ? operation.exit.toFixed(precision) : '-';
        if (elements.entryTime) elements.entryTime.textContent = operation.entryTime ? `${operation.date} ${operation.entryTime}` : '-';
        if (elements.exitTime) elements.exitTime.textContent = operation.exitTime ? `${operation.date} ${operation.exitTime}` : '-';

        if (elements.pl) {
            elements.pl.textContent = formatCurrency(operation.pl, operation.currency, operation.currency);
            elements.pl.className = `ml-2 font-semibold ${operation.pl >= 0 ? 'text-green-400' : 'text-red-400'}`;
        }

        // Calcular duración
        let duration = '-';
        if (operation.entryTime && operation.exitTime) {
            const entry = new Date(`${operation.date}T${operation.entryTime}`);
            const exit = new Date(`${operation.date}T${operation.exitTime}`);
            const diffMinutes = Math.round((exit - entry) / (1000 * 60));
            duration = diffMinutes < 60 ? `${diffMinutes}min` : `${Math.floor(diffMinutes / 60)}h ${diffMinutes % 60}min`;
        }
        if (elements.duration) elements.duration.textContent = duration;
    }

    // Limpiar gráfico (llamado internamente)
    function hideTradingChart() {
        console.log('🔒 Limpiando gráfico');

        // Limpiar widget de TradingView
        if (tradingViewWidget) {
            try {
                tradingViewWidget.remove();
                tradingViewWidget = null;
            } catch (e) {
                console.log('Widget de TradingView limpiado');
            }
        }
    }

    // Mostrar error
    function showError(message) {
        console.error('❌ Error:', message);
        const loading = document.getElementById('tradingview-loading-detail');
        const error = document.getElementById('chart-error-message');

        if (loading) loading.style.display = 'none';
        if (error) {
            const p = error.querySelector('p');
            if (p) p.textContent = message;
            error.style.display = 'block';
        }
    }


console.log('✅ Sistema de gráficos TradingView iframe listo');

// ==================== DETECTOR AUTOMÁTICO DE PROXY (SOLO CONSOLA) ====================
(async function checkProxyOnStartup() {
    // Detectar automáticamente si estamos en producción o desarrollo
    const isProduction = window.location.hostname !== 'localhost' && 
                        window.location.hostname !== '127.0.0.1' &&
                        !window.location.hostname.includes('.local');
    
    // URL del proxy: Vercel en producción, localhost en desarrollo
    const PROXY_URL = isProduction 
        ? `${window.location.origin}/api`  // Vercel
        : (window.PROXY_URL || 'http://127.0.0.1:8003'); // Local
    
    // Guardar globalmente para que las APIs lo usen
    window.PROXY_URL = PROXY_URL;
    
    console.log(`🌍 Modo: ${isProduction ? 'PRODUCCIÓN' : 'DESARROLLO'}`);
    console.log(`🔗 Proxy URL: ${PROXY_URL}`);

    try {
        const response = await fetch(`${PROXY_URL}/health`, {
            method: 'GET',
            cache: 'no-cache',
            signal: AbortSignal.timeout(5000)
        });

        if (response.ok) {
            const data = await response.json();
            console.log('✅ Proxy server activo:', data);
        } else {
            console.warn('⚠️ Proxy no disponible. Las APIs pueden no funcionar.');
        }
    } catch (error) {
        console.warn('⚠️ Proxy no disponible:', error.message);
        console.info('💡 Para usar las APIs, inicia el servidor con: npm start');
    }
})();

// ============================================
// FUNCIONES DE PANTALLA COMPLETA PARA GRÁFICOS
// ============================================
let fullscreenChartInstance = null;
let currentFullscreenChartData = null;

window.openFullscreenChart = function(canvasId, title) {
    console.log('Abriendo gráfico en pantalla completa:', canvasId);
    const sourceCanvas = document.getElementById(canvasId);
    if (!sourceCanvas) {
        console.error('Canvas no encontrado:', canvasId);
        alert('Error: No se encontró el gráfico');
        return;
    }

    // Obtener el Chart.js instance del canvas original
    const sourceChart = Chart.getChart(sourceCanvas);
    if (!sourceChart) {
        console.error('No hay gráfico en el canvas:', canvasId);
        alert('Error: El gráfico no está listo');
        return;
    }

    console.log('Gráfico encontrado, configuración:', sourceChart.config);

    // Mostrar modal
    const modal = document.getElementById('fullscreen-chart-modal');
    const titleEl = document.getElementById('fullscreen-chart-title');
    const fullscreenCanvas = document.getElementById('fullscreen-chart-canvas');
    
    if (!modal || !titleEl || !fullscreenCanvas) {
        console.error('Elementos del modal no encontrados');
        alert('Error: Modal no encontrado');
        return;
    }
    
    modal.style.display = 'block';
    titleEl.textContent = title;
    
    // Destruir gráfico anterior si existe
    if (fullscreenChartInstance) {
        fullscreenChartInstance.destroy();
        fullscreenChartInstance = null;
    }

    // Crear configuración para el nuevo gráfico
    try {
        const newConfig = {
            type: sourceChart.config.type,
            data: JSON.parse(JSON.stringify(sourceChart.data)),
            options: JSON.parse(JSON.stringify(sourceChart.options))
        };
        
        // Optimizar opciones para pantalla completa
        newConfig.options.maintainAspectRatio = false;
        newConfig.options.responsive = true;
        
        // Mejorar legibilidad en pantalla completa
        if (newConfig.options.plugins) {
            if (newConfig.options.plugins.legend) {
                newConfig.options.plugins.legend.labels = {
                    ...newConfig.options.plugins.legend.labels,
                    font: { size: 16, weight: 'bold' },
                    color: '#39FF14',
                    padding: 20
                };
            }
            if (newConfig.options.plugins.tooltip) {
                newConfig.options.plugins.tooltip.titleFont = { size: 16, weight: 'bold' };
                newConfig.options.plugins.tooltip.bodyFont = { size: 14 };
                newConfig.options.plugins.tooltip.padding = 15;
            }
        }
        
        // Aumentar tamaño de fuentes en ejes
        if (newConfig.options.scales) {
            Object.keys(newConfig.options.scales).forEach(axisKey => {
                if (newConfig.options.scales[axisKey].ticks) {
                    newConfig.options.scales[axisKey].ticks.font = { size: 14, weight: 'bold' };
                    newConfig.options.scales[axisKey].ticks.color = '#ffffff';
                }
                if (newConfig.options.scales[axisKey].title) {
                    newConfig.options.scales[axisKey].title.font = { size: 16, weight: 'bold' };
                }
                // Mejorar líneas de grid
                if (newConfig.options.scales[axisKey].grid) {
                    newConfig.options.scales[axisKey].grid.color = 'rgba(57, 255, 20, 0.1)';
                }
            });
        }
        
        console.log('Creando gráfico en pantalla completa...');
        
        // Esperar a que el modal se renderice completamente
        setTimeout(() => {
            const container = fullscreenCanvas.parentElement;
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            
            // Establecer dimensiones exactas del canvas
            fullscreenCanvas.width = containerWidth;
            fullscreenCanvas.height = containerHeight;
            fullscreenCanvas.style.width = containerWidth + 'px';
            fullscreenCanvas.style.height = containerHeight + 'px';
            
            fullscreenChartInstance = new Chart(fullscreenCanvas, newConfig);
            console.log('Gráfico en pantalla completa creado exitosamente');
        }, 200);
        
    } catch (error) {
        console.error('Error al crear el gráfico:', error);
        alert('Error al crear el gráfico: ' + error.message);
        modal.style.display = 'none';
    }
}

window.closeFullscreenChart = function() {
    const modal = document.getElementById('fullscreen-chart-modal');
    modal.style.display = 'none';
    
    if (fullscreenChartInstance) {
        fullscreenChartInstance.destroy();
        fullscreenChartInstance = null;
    }
}

// Cerrar modal con tecla ESC
if (!window.fullscreenChartEscListenerAdded) {
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
            window.closeFullscreenChart();
        }
    });
    window.fullscreenChartEscListenerAdded = true;
}

// ============================================
// === INTEGRACIÓN TRADOVATE API ===
// ============================================

let tradovateAccessToken = null;
let tradovateTokenExpiry = null;

// URL del proxy para Tradovate
const TRADOVATE_PROXY_URL = 'http://127.0.0.1:8003/tradovate';

// Función para autenticar con Tradovate
async function authenticateTradovate(username, password, mode = 'live') {
    try {
        const response = await fetch(`${TRADOVATE_PROXY_URL}/auth/accesstokenrequest?mode=${mode}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json',
                'X-Tradovate-Mode': mode
            },
            body: JSON.stringify({
                name: username,
                password: password,
                appId: 'TradingSurvivor',
                appVersion: '1.0.0',
                deviceId: 'TradingSurvivorApp',
                cid: 1,
                sec: 'TradingSurvivorSecret'
            })
        });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Error de autenticación: ${response.status} - ${errorText}`);
        }

        const data = await response.json();
        
        if (data.accessToken) {
            tradovateAccessToken = data.accessToken;
            tradovateTokenExpiry = Date.now() + (data.expirationTime || 3600) * 1000; // Default 1 hora
            
            console.log('✅ Autenticación Tradovate exitosa');
            return { success: true, token: data.accessToken };
        } else {
            throw new Error('No se recibió token de acceso');
        }
    } catch (error) {
        console.error('❌ Error autenticando con Tradovate:', error);
        return { success: false, error: error.message };
    }
}

// Función para verificar si el token está vigente
function isTradovateTokenValid() {
    if (!tradovateAccessToken || !tradovateTokenExpiry) return false;
    return Date.now() < tradovateTokenExpiry;
}

// Función para obtener fills (trades ejecutados) de Tradovate
async function getTradovateFills(accountId, username, password, mode = 'live', startDate = null) {
    try {
        // Autenticar si no hay token válido
        if (!isTradovateTokenValid()) {
            const authResult = await authenticateTradovate(username, password, mode);
            if (!authResult.success) {
                throw new Error('Error de autenticación: ' + authResult.error);
            }
        }
        
        // Obtener el ID numérico de la cuenta
        const accountResponse = await fetch(`${TRADOVATE_PROXY_URL}/account/list?mode=${mode}`, {
            headers: {
                'Authorization': `Bearer ${tradovateAccessToken}`,
                'Accept': 'application/json',
                'X-Tradovate-Mode': mode
            }
        });

        if (!accountResponse.ok) {
            throw new Error(`Error obteniendo cuentas: ${accountResponse.status}`);
        }

        const accounts = await accountResponse.json();
        const account = accounts.find(acc => acc.name === accountId || acc.id.toString() === accountId);
        
        if (!account) {
            throw new Error(`Cuenta ${accountId} no encontrada`);
        }

        // Obtener fills
        let fillsParams = `mode=${mode}&accountId=${account.id}`;
        
        // Filtrar por fecha si se proporciona
        if (startDate) {
            const startTimestamp = new Date(startDate).toISOString();
            fillsParams += `&startTimestamp=${startTimestamp}`;
        }

        const fillsResponse = await fetch(`${TRADOVATE_PROXY_URL}/fill/list?${fillsParams}`, {
            headers: {
                'Authorization': `Bearer ${tradovateAccessToken}`,
                'Accept': 'application/json',
                'X-Tradovate-Mode': mode
            }
        });

        if (!fillsResponse.ok) {
            throw new Error(`Error obteniendo fills: ${fillsResponse.status}`);
        }

        const fills = await fillsResponse.json();
        console.log(`✅ ${fills.length} fills obtenidos de Tradovate`);
        
        return { success: true, fills: fills };
    } catch (error) {
        console.error('❌ Error obteniendo fills de Tradovate:', error);
        return { success: false, error: error.message };
    }
}

// Función para convertir fill de Tradovate al formato de la aplicación
function convertTradovateFillToAppFormat(fill, contractInfo, accountId) {
    // Determinar dirección (buy/sell)
    const type = fill.action === 'Buy' ? 'buy' : 'sell';
    
    // Calcular P&L (ya viene en el fill)
    const pnl = parseFloat(fill.netPrice || 0);
    const result = pnl > 0 ? 'win' : (pnl < 0 ? 'loss' : 'breakeven');

    // Convertir timestamp a fecha
    const tradeDateObj = new Date(fill.timestamp);
    const tradeDate = getLocalDateString(tradeDateObj);
    const tradeTime = tradeDateObj.toTimeString().split(' ')[0];

    return {
        id: `tradovate_${fill.id}`,
        date: tradeDate,
        accountId: accountId,
        instrument: contractInfo?.name || fill.contractId.toString(),
        type: type,
        entry: parseFloat(fill.price),
        exit: parseFloat(fill.price), // Para fills individuales
        entryTime: tradeTime,
        exitTime: tradeTime,
        volume: fill.qty,
        result: result,
        pl: pnl,
        fees: Math.abs(parseFloat(fill.commission || 0)),
        currency: 'USD', // Tradovate usa USD
        notes: `Importado de Tradovate - Fill ID: ${fill.id} - Order ID: ${fill.orderId}`,
        imageDatas: [],
        manualPL: null,
        session: detectTradingSession(entryTime) || ''
    };
}

// Función para sincronizar trades desde Tradovate
async function syncTradovateTrades(accountId) {
    try {
        // Buscar cuenta de Tradovate
        const tradovateAccount = DB.accounts.find(acc => 
            acc.platform === 'tradovate' && acc.id === accountId
        );

        if (!tradovateAccount) {
            showSyncNotification('❌ Cuenta de Tradovate no encontrada', 'error');
            return;
        }

        // Verificar que tenga credenciales
        if (!tradovateAccount.tradovateUsername || !tradovateAccount.tradovatePassword || !tradovateAccount.tradovateAccountId) {
            showSyncNotification('❌ Credenciales de Tradovate incompletas', 'error');
            return;
        }

        updateTradovateStatus('syncing', 'Sincronizando...', true);

        // Obtener fills de Tradovate
        const fillsResult = await getTradovateFills(
            tradovateAccount.tradovateAccountId,
            tradovateAccount.tradovateUsername,
            tradovateAccount.tradovatePassword,
            'live' // Por defecto usar live, puedes agregar campo para seleccionar
        );

        if (!fillsResult.success) {
            throw new Error(fillsResult.error);
        }

        const fills = fillsResult.fills || [];
        
        if (fills.length === 0) {
            updateTradovateStatus('success', 'Sin trades nuevos', false);
            showSyncNotification('ℹ️ No hay trades nuevos para importar', 'info');
            return;
        }

        // Convertir fills al formato de la aplicación
        let newTrades = 0;
        let skippedTrades = 0;

        for (const fill of fills) {
            const appTrade = convertTradovateFillToAppFormat(fill, null, tradovateAccount.id);

            // Verificar si el trade ya existe
            const existingTrade = DB.operations.find(op => op.id === appTrade.id);

            if (!existingTrade) {
                // Guardar localmente
                DB.operations.push(appTrade);
                await dexieDB.operations.add(appTrade);

                // Sincronizar con Supabase si está conectado
                if (currentUser) {
                    await saveOperationToSupabase(appTrade);
                }

                newTrades++;
            } else {
                skippedTrades++;
            }
        }

        // Actualizar balance de la cuenta
        updateAccountBalances();
        refreshAllViews();

        // Guardar última sincronización
        localStorage.setItem('tradovate-last-sync', new Date().toISOString());
        
        updateTradovateStatus('success', `${newTrades} trades importados`, false);
        showSyncNotification(
            `✅ Tradovate: ${newTrades} trades importados, ${skippedTrades} ya existentes`,
            'success'
        );

        console.log(`✅ Sincronización Tradovate completada: ${newTrades} nuevos, ${skippedTrades} duplicados`);

    } catch (error) {
        console.error('❌ Error sincronizando Tradovate:', error);
        updateTradovateStatus('error', 'Error: ' + error.message, false);
        showSyncNotification('❌ Error sincronizando Tradovate: ' + error.message, 'error');
    }
}

// Función para actualizar el estado visual de Tradovate
function updateTradovateStatus(status, message, isLoading) {
    const statusIndicator = document.getElementById('tradovate-status-indicator');
    const lastSyncEl = document.getElementById('tradovate-last-sync');
    const progressBar = document.getElementById('tradovate-progress-bar');
    // const syncButton = document.getElementById('tradovate-quick-sync'); // Botón eliminado

    if (statusIndicator) {
        if (status === 'success') {
            statusIndicator.className = 'text-green';
            statusIndicator.textContent = 'Conectado';
        } else if (status === 'error') {
            statusIndicator.className = 'text-red';
            statusIndicator.textContent = 'Error';
        } else if (status === 'syncing') {
            statusIndicator.className = 'text-yellow-400';
            statusIndicator.textContent = 'Sincronizando...';
        }
    }

    if (lastSyncEl && message) {
        lastSyncEl.textContent = message;
    }

    if (progressBar) {
        if (isLoading) {
            progressBar.style.width = '100%';
            progressBar.classList.add('animate-pulse');
        } else {
            progressBar.style.width = '0%';
            progressBar.classList.remove('animate-pulse');
        }
    }

    /* Botón eliminado
    if (syncButton) {
        syncButton.disabled = isLoading;
        if (isLoading) {
            syncButton.innerHTML = '<i class="fas fa-spinner fa-spin text-xs"></i><span>Sincronizando...</span>';
        } else {
            syncButton.innerHTML = '<i class="fas fa-sync-alt text-xs"></i><span>Importar Trades</span>';
        }
    }
    */
}

// Event listener para el botón de importar trades de Tradovate - ELIMINADO
/* Botón tradovate-quick-sync eliminado - Solo CSV manual
document.addEventListener('DOMContentLoaded', function() {
    const tradovateQuickSyncBtn = document.getElementById('tradovate-quick-sync');
    
    if (tradovateQuickSyncBtn) {
        tradovateQuickSyncBtn.addEventListener('click', async function() {
            // Buscar la primera cuenta de Tradovate
            const tradovateAccount = DB.accounts.find(acc => acc.platform === 'tradovate');
            
            if (!tradovateAccount) {
                showSyncNotification('❌ Primero crea una cuenta de Tradovate', 'error');
                return;
            }

            await syncTradovateTrades(tradovateAccount.id);
        });
    }
});
*/

// ===== AUDICIÓN PÚBLICA - FUNCIONES =====

// Generar link público de audición
/*
// ===== CÓDIGO VIEJO DE AUDICIÓN COMENTADO (causaba URI_TOO_LONG) =====
// Este código intentaba poner todos los datos en la URL con base64
// Ahora usamos Supabase para guardar los datos y solo enviamos el ID
function generatePublicAudicionLink() {
    const modal = document.getElementById('public-link-modal');
    modal.classList.add('active');
}

// Generar el link con las opciones seleccionadas
document.getElementById('generate-public-link-btn')?.addEventListener('click', function() {
    const shareMetrics = document.getElementById('share-metrics').checked;
    const shareTrades = document.getElementById('share-trades').checked;
    const shareCharts = document.getElementById('share-charts').checked;
    const sharePersonalInfo = document.getElementById('share-personal-info').checked;

    // Exportar datos de audición
    const audicionData = {
        metrics: shareMetrics ? getAudicionMetrics() : null,
        trades: shareTrades ? getAudicionTrades() : null,
        charts: shareCharts ? getAudicionChartsData() : null,
        personalInfo: sharePersonalInfo ? getPersonalInfo() : null,
        timestamp: new Date().toISOString()
    };

    // Codificar datos en base64
    const encodedData = btoa(JSON.stringify(audicionData));
    
    // Generar URL pública
    const baseUrl = window.location.origin + window.location.pathname;
    const publicLink = `${baseUrl}?audicion=public&data=${encodedData}`;
    
    // Mostrar el link generado
    document.getElementById('generated-public-link').value = publicLink;
    document.getElementById('audicion-public-link').value = publicLink;
    
    showNotification('✅ Link público generado correctamente', 'success');
});

// Copiar link público al portapapeles
document.getElementById('copy-public-link-btn')?.addEventListener('click', function() {
    const linkInput = document.getElementById('generated-public-link');
    linkInput.select();
    document.execCommand('copy');
    showNotification('✅ Link copiado al portapapeles', 'success');
});

document.getElementById('copy-audicion-link')?.addEventListener('click', function() {
    const linkInput = document.getElementById('audicion-public-link');
    linkInput.select();
    document.execCommand('copy');
    showNotification('✅ Link copiado al portapapeles', 'success');
});

// Abrir modal de link público
document.getElementById('share-audicion-btn')?.addEventListener('click', function() {
    generatePublicAudicionLink();
});

// Cerrar modal
document.getElementById('close-public-link-modal')?.addEventListener('click', function() {
    document.getElementById('public-link-modal').classList.remove('active');
});

document.getElementById('cancel-public-link')?.addEventListener('click', function() {
    document.getElementById('public-link-modal').classList.remove('active');
});
*/

// ===== FIN DEL CÓDIGO VIEJO =====

// Obtener métricas de audición
function getAudicionMetrics() {
    const operations = DB.operations || [];
    
    const totalPL = operations.reduce((sum, op) => sum + (op.pnl || 0), 0);
    const winners = operations.filter(op => op.pnl > 0).length;
    const losers = operations.filter(op => op.pnl < 0).length;
    const breakeven = operations.filter(op => op.pnl === 0).length;
    const winRate = operations.length > 0 ? (winners / operations.length * 100) : 0;
    
    const totalWinPL = operations.filter(op => op.pnl > 0).reduce((sum, op) => sum + op.pnl, 0);
    const totalLossPL = Math.abs(operations.filter(op => op.pnl < 0).reduce((sum, op) => sum + op.pnl, 0));
    const profitFactor = totalLossPL > 0 ? (totalWinPL / totalLossPL) : 0;
    
    return {
        totalPL,
        winners,
        losers,
        breakeven,
        winRate: winRate.toFixed(2),
        profitFactor: profitFactor.toFixed(2),
        totalTrades: operations.length
    };
}

// Obtener trades de audición
function getAudicionTrades() {
    return (DB.operations || []).map(op => ({
        id: op.id,
        date: op.date,
        symbol: op.symbol,
        type: op.type,
        entryPrice: op.entryPrice,
        exitPrice: op.exitPrice,
        pnl: op.pnl,
        volume: op.volume,
        result: op.pnl > 0 ? 'win' : op.pnl < 0 ? 'loss' : 'breakeven'
    }));
}

// Obtener datos de gráficos
function getAudicionChartsData() {
    return {
        profitCurve: generateProfitCurveData(),
        drawdownCurve: generateDrawdownCurveData()
    };
}

// Obtener información personal
function getPersonalInfo() {
    return {
        email: DB.currentUser?.email || 'usuario@example.com',
        memberSince: 'Dic 2024',
        tradingSince: 'Ene 2023'
    };
}

// Generar datos de curva de profit
function generateProfitCurveData() {
    const operations = DB.operations || [];
    let cumulative = 0;
    return operations.map(op => {
        cumulative += op.pnl || 0;
        return { date: op.date, value: cumulative };
    });
}

// Generar datos de curva de drawdown
function generateDrawdownCurveData() {
    const operations = DB.operations || [];
    let peak = 0;
    let cumulative = 0;
    return operations.map(op => {
        cumulative += op.pnl || 0;
        peak = Math.max(peak, cumulative);
        const drawdown = peak - cumulative;
        return { date: op.date, value: -drawdown };
    });
}

// Detectar y cargar vista pública
window.addEventListener('DOMContentLoaded', async function() {
    if (!window.IS_PUBLIC_AUDICION_VIEW) return;
    
    try {
        console.log('📊 Cargando vista pública de audición...');
        console.log('📊 ID de audición:', window.PUBLIC_AUDICION_ID);
        
        // Cargar audición desde Supabase usando el ID
        const audicionId = window.PUBLIC_AUDICION_ID;
        
        if (!audicionId) {
            console.error('❌ No se encontró ID de audición');
            return;
        }
        
        // Inicializar Supabase si es necesario
        if (!window.supabase) {
            const initialized = await initializeSupabase();
            if (!initialized) {
                console.error('❌ No se pudo inicializar Supabase para cargar audición pública');
                return;
            }
        }
        
        // Cargar datos de la audición desde Supabase
        console.log('📥 Cargando audición desde Supabase...');
        const { data: audicion, error } = await window.supabase
            .from('public_audiciones')
            .select('*')
            .eq('id', audicionId)
            .single();
        
        if (error) {
            console.error('❌ Error cargando audición:', error);
            document.body.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: center; min-height: 100vh; background: #000; color: #fff; font-family: sans-serif;">
                    <div style="text-align: center;">
                        <h1 style="font-size: 2rem; margin-bottom: 1rem;">❌ Error</h1>
                        <p>No se pudo cargar esta audición</p>
                        <p style="color: #888; margin-top: 1rem;">La audición puede haber sido eliminada o el enlace es inválido</p>
                    </div>
                </div>
            `;
            return;
        }
        
        if (!audicion) {
            console.error('❌ Audición no encontrada');
            document.body.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: center; min-height: 100vh; background: #000; color: #fff; font-family: sans-serif;">
                    <div style="text-align: center;">
                        <h1 style="font-size: 2rem; margin-bottom: 1rem;">🔍 No encontrada</h1>
                        <p>Esta audición no existe o ha sido eliminada</p>
                    </div>
                </div>
            `;
            return;
        }
        
        console.log('✅ Audición cargada:', audicion);
        
        // Incrementar contador de vistas
        await window.supabase.rpc('increment_audicion_views', { audicion_id: audicionId });
        
        const decodedData = audicion.data;
        console.log('✅ Datos decodificados:', decodedData);
        
        // Ocultar modal de autenticación si existe
        const authModal = document.getElementById('auth-modal');
        if (authModal) {
            authModal.style.display = 'none';
        }
        
        // Mostrar solo la sección de audición
        setTimeout(() => {
            document.querySelectorAll('.section-container').forEach(section => {
                section.style.display = 'none';
            });
            const audicionSection = document.getElementById('audicion');
            if (audicionSection) {
                audicionSection.style.display = 'block';
                audicionSection.classList.add('active');
            }
            
            // Cargar datos públicos
            if (decodedData.metrics) {
                loadPublicMetrics(decodedData.metrics);
            }
            if (decodedData.trades) {
                loadPublicTrades(decodedData.trades);
            }
            if (decodedData.personalInfo) {
                loadPublicPersonalInfo(decodedData.personalInfo);
            }
            if (decodedData.charts) {
                loadPublicCharts(decodedData.charts);
            }
            
            console.log('✅ Vista pública cargada correctamente');
        }, 100);
        
    } catch (error) {
        console.error('Error cargando vista pública:', error);
        document.body.innerHTML = `
            <div style="display: flex; align-items: center; justify-content: center; min-height: 100vh; background: #000; color: #fff; font-family: sans-serif;">
                <div style="text-align: center;">
                    <h1 style="font-size: 2rem; margin-bottom: 1rem;">⚠️ Error</h1>
                    <p>Ocurrió un error al cargar la audición</p>
                    <p style="color: #888; margin-top: 1rem; font-size: 0.875rem;">${error.message}</p>
                </div>
            </div>
        `;
    }
});

// Cargar métricas públicas
function loadPublicMetrics(metrics) {
    // Métricas principales
    document.getElementById('audicion-pl-total').textContent = `$${(metrics.totalPL || 0).toFixed(2)}`;
    document.getElementById('audicion-total-wins').textContent = metrics.winners || 0;
    document.getElementById('audicion-total-losses').textContent = metrics.losers || 0;
    document.getElementById('audicion-win-rate').textContent = `${metrics.winRate || '0.00'}%`;
    document.getElementById('audicion-winners').textContent = metrics.winners || 0;
    document.getElementById('audicion-losers').textContent = metrics.losers || 0;
    document.getElementById('audicion-breakeven').textContent = metrics.breakeven || 0;
    document.getElementById('audicion-profit-factor').textContent = metrics.profitFactor || '0.00';
    
    // Métricas adicionales si existen
    const dayWinRate = document.getElementById('audicion-day-win-rate');
    if (dayWinRate && metrics.dayWinRate) {
        dayWinRate.textContent = `${metrics.dayWinRate}%`;
    }
    
    const winningDays = document.getElementById('audicion-winning-days');
    if (winningDays && metrics.winningDays !== undefined) {
        winningDays.textContent = metrics.winningDays;
    }
    
    const losingDays = document.getElementById('audicion-losing-days');
    if (losingDays && metrics.losingDays !== undefined) {
        losingDays.textContent = metrics.losingDays;
    }
    
    const pfRatio = document.getElementById('audicion-pf-ratio');
    if (pfRatio && metrics.profitFactor) {
        pfRatio.textContent = `1:${metrics.profitFactor}`;
    }
    
    const bestTrade = document.getElementById('audicion-best-trade');
    if (bestTrade && metrics.bestTrade !== undefined) {
        bestTrade.textContent = `$${metrics.bestTrade.toFixed(2)}`;
    }
    
    const worstTrade = document.getElementById('audicion-worst-trade');
    if (worstTrade && metrics.worstTrade !== undefined) {
        worstTrade.textContent = `$${metrics.worstTrade.toFixed(2)}`;
    }
    
    // Actualizar los gauges circulares si es vista pública
    if (window.IS_PUBLIC_AUDICION_VIEW) {
        initGaugeCanvases();
        updateAudicionCharts(metrics);
    }
    
    const avgTrade = document.getElementById('audicion-avg-trade');
    if (avgTrade && metrics.avgTrade !== undefined) {
        avgTrade.textContent = `$${metrics.avgTrade.toFixed(2)}`;
    }
}

// Cargar trades públicos
function loadPublicTrades(trades) {
    const tbody = document.querySelector('#audicion-latest-trades tbody');
    if (!tbody) return;
    
    tbody.innerHTML = '';
    
    if (!trades || trades.length === 0) {
        tbody.innerHTML = '<tr><td colspan="7" class="text-center py-8 text-text-secondary">No hay trades disponibles</td></tr>';
        return;
    }
    
    trades.slice(0, 10).forEach(trade => {
        const row = document.createElement('tr');
        row.className = 'border-b border-border hover:bg-surface-light transition-colors';
        
        // Determinar resultado basado en el campo result
        const isWin = trade.result === 'win';
        const resultClass = isWin ? 'bg-primary bg-opacity-20 text-primary' : 'bg-red bg-opacity-20 text-red';
        const resultText = isWin ? 'WIN' : (trade.result === 'loss' ? 'LOSS' : 'BE');
        
        row.innerHTML = `
            <td class="py-3 px-2 text-xs">${trade.date || '-'}</td>
            <td class="py-3 px-2 font-medium">${trade.id || '-'}</td>
            <td class="py-3 px-2 text-center">
                <span class="px-2 py-1 rounded text-xs ${trade.type === 'buy' ? 'bg-primary bg-opacity-20 text-primary' : 'bg-red bg-opacity-20 text-red'}">
                    ${trade.type === 'buy' ? 'LONG' : 'SHORT'}
                </span>
            </td>
            <td class="py-3 px-2 text-center text-xs">${trade.volume || '-'}</td>
            <td class="py-3 px-2 text-center">
                <span class="px-2 py-1 rounded text-xs font-medium ${resultClass}">
                    ${resultText}
                </span>
            </td>
            <td class="py-3 px-2 text-right font-bold ${isWin ? 'text-primary' : 'text-red'}">
                ${trade.pnl ? (trade.pnl >= 0 ? '+' : '') + '$' + trade.pnl.toFixed(2) : '$0.00'}
            </td>
            <td class="py-3 px-2 text-right text-xs">-</td>
        `;
        tbody.appendChild(row);
    });
}

// Cargar información personal pública
function loadPublicPersonalInfo(info) {
    if (!info) return;
    
    // Actualizar username
    const usernameEl = document.getElementById('audicion-username');
    if (usernameEl && info.username) {
        usernameEl.textContent = info.username;
    }
    
    // Actualizar foto de perfil
    const avatarEl = document.getElementById('audicion-user-avatar');
    if (avatarEl) {
        if (info.profileImage) {
            avatarEl.style.backgroundImage = `url(${info.profileImage})`;
            avatarEl.style.backgroundSize = 'cover';
            avatarEl.style.backgroundPosition = 'center';
            avatarEl.textContent = '';
        } else if (info.username) {
            avatarEl.textContent = info.username.charAt(0).toUpperCase();
        } else if (info.email) {
            avatarEl.textContent = info.email.charAt(0).toUpperCase();
        }
    }
    
    // Actualizar email
    const emailEl = document.getElementById('audicion-user-email');
    if (emailEl && info.email) {
        emailEl.textContent = info.email;
    }
    
    // Actualizar member since
    const memberSinceEl = document.getElementById('audicion-member-since');
    if (memberSinceEl && info.memberSince) {
        memberSinceEl.textContent = info.memberSince;
    }
    
    // Actualizar trading since
    const tradingSinceEl = document.getElementById('audicion-trading-since');
    if (tradingSinceEl && info.tradingSince) {
        tradingSinceEl.textContent = info.tradingSince;
    }
}

// Cargar gráficos públicos
function loadPublicCharts(charts) {
    if (!charts) return;
    
    // Cargar curva de profit
    if (charts.profitCurve && charts.profitCurve.length > 0) {
        const profitCanvas = document.getElementById('audicion-profit-curve');
        if (profitCanvas) {
            const ctx = profitCanvas.getContext('2d');
            
            // Destruir gráfico anterior si existe
            if (window.audicionProfitChart) {
                window.audicionProfitChart.destroy();
            }
            
            window.audicionProfitChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: charts.profitCurve.map(d => d.date),
                    datasets: [{
                        label: 'Profit Acumulado',
                        data: charts.profitCurve.map(d => d.value),
                        borderColor: '#39ff14',
                        backgroundColor: 'rgba(57, 255, 20, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        y: {
                            ticks: { color: '#a0a0a0' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' }
                        },
                        x: {
                            ticks: { color: '#a0a0a0' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' }
                        }
                    }
                }
            });
        }
    }
    
    // Cargar curva de drawdown
    if (charts.drawdownCurve && charts.drawdownCurve.length > 0) {
        const drawdownCanvas = document.getElementById('audicion-drawdown-curve');
        if (drawdownCanvas) {
            const ctx = drawdownCanvas.getContext('2d');
            
            // Destruir gráfico anterior si existe
            if (window.audicionDrawdownChart) {
                window.audicionDrawdownChart.destroy();
            }
            
            window.audicionDrawdownChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: charts.drawdownCurve.map(d => d.date),
                    datasets: [{
                        label: 'Drawdown',
                        data: charts.drawdownCurve.map(d => d.value),
                        borderColor: '#ff4136',
                        backgroundColor: 'rgba(255, 65, 54, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        y: {
                            ticks: { color: '#a0a0a0' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' }
                        },
                        x: {
                            ticks: { color: '#a0a0a0' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' }
                        }
                    }
                }
            });
        }
    }
}

// ===== FIN AUDICIÓN PÚBLICA =====

</script>

<!-- Panel Lateral de Filtros (estilo Tradervue) -->
<div id="filters-sidebar" class="filters-sidebar">
    <div class="filters-sidebar-header">
        <h3>Filtros personalizados</h3>
        <button id="close-filters-btn" class="close-filters-btn">
            <i class="fas fa-times"></i>
        </button>
    </div>
    
    <div class="filters-sidebar-content">
        <!-- Filtro por Símbolo -->
        <div class="filter-section">
            <label class="filter-label">Símbolo</label>
            <input type="text" id="sidebar-filter-symbol" class="filter-sidebar-input" placeholder="Símbolo">
        </div>

        <!-- Filtro por Etiquetas (Tipo de Operación) -->
        <div class="filter-section">
            <label class="filter-label">Etiquetas</label>
            <select id="sidebar-filter-type" class="filter-sidebar-select">
                <option value="all">Seleccionar</option>
                <option value="buy">Compra (Long)</option>
                <option value="sell">Venta (Short)</option>
            </select>
        </div>

        <!-- Filtro Lateral (Win/Loss) -->
        <div class="filter-section">
            <label class="filter-label">Lateral</label>
            <select id="sidebar-filter-result" class="filter-sidebar-select">
                <option value="all">Todo</option>
                <option value="win">Ganadores</option>
                <option value="loss">Perdedores</option>
                <option value="breakeven">Break Even</option>
            </select>
        </div>

        <!-- Filtro por Duración -->
        <div class="filter-section">
            <label class="filter-label">Duración</label>
            <select id="sidebar-filter-duration" class="filter-sidebar-select">
                <option value="all">Todo</option>
                <option value="scalping">Scalping (< 5 min)</option>
                <option value="intraday">Intraday (5-60 min)</option>
                <option value="swing">Swing (> 60 min)</option>
            </select>
        </div>

        <!-- Days/Time -->
        <div class="filter-section expandable">
            <div class="filter-section-header" onclick="toggleFilterSection('days-time')">
                <span class="filter-label">Days/Time</span>
                <i class="fas fa-chevron-down"></i>
            </div>
            <div id="days-time-content" class="filter-section-content">
                <label class="filter-sublabel">Día de la semana</label>
                <select id="sidebar-filter-day" class="filter-sidebar-select">
                    <option value="all">Todos</option>
                    <option value="1">Lunes</option>
                    <option value="2">Martes</option>
                    <option value="3">Miércoles</option>
                    <option value="4">Jueves</option>
                    <option value="5">Viernes</option>
                    <option value="6">Sábado</option>
                    <option value="0">Domingo</option>
                </select>

                <label class="filter-sublabel mt-3">Sesión de Trading</label>
                <select id="sidebar-filter-session" class="filter-sidebar-select">
                    <option value="all">Todas</option>
                    <option value="asian">Asiática (00:00-08:00)</option>
                    <option value="london">Londres (08:00-16:00)</option>
                    <option value="newyork">Nueva York (13:00-22:00)</option>
                </select>
            </div>
        </div>

        <!-- Price/Volume -->
        <div class="filter-section expandable">
            <div class="filter-section-header" onclick="toggleFilterSection('price-volume')">
                <span class="filter-label">Price/Volume</span>
                <i class="fas fa-chevron-down"></i>
            </div>
            <div id="price-volume-content" class="filter-section-content">
                <label class="filter-sublabel">P/L Mínimo</label>
                <input type="number" id="sidebar-filter-pl-min" class="filter-sidebar-input" placeholder="Ej: -100">
                
                <label class="filter-sublabel mt-3">P/L Máximo</label>
                <input type="number" id="sidebar-filter-pl-max" class="filter-sidebar-input" placeholder="Ej: 500">
            </div>
        </div>

        <!-- Win/Loss Trades -->
        <div class="filter-section expandable">
            <div class="filter-section-header" onclick="toggleFilterSection('winloss-trades')">
                <span class="filter-label">Win/Loss Trades</span>
                <i class="fas fa-chevron-down"></i>
            </div>
            <div id="winloss-trades-content" class="filter-section-content">
                <label class="filter-sublabel">Filtrar por resultado</label>
                <div class="filter-checkbox-group">
                    <label class="filter-checkbox">
                        <input type="checkbox" id="sidebar-show-wins" checked>
                        <span>Mostrar ganadores</span>
                    </label>
                    <label class="filter-checkbox">
                        <input type="checkbox" id="sidebar-show-losses" checked>
                        <span>Mostrar perdedores</span>
                    </label>
                    <label class="filter-checkbox">
                        <input type="checkbox" id="sidebar-show-breakeven" checked>
                        <span>Mostrar break even</span>
                    </label>
                </div>
            </div>
        </div>
    </div>

    <div class="filters-sidebar-footer">
        <button id="sidebar-apply-filters-btn" class="sidebar-apply-btn">
            <i class="fas fa-check"></i> Aplicar
        </button>
        <button id="sidebar-clear-filters-btn" class="sidebar-clear-btn">
            Limpiar
        </button>
    </div>
</div>

<!-- Panel Lateral de Filtros para Daily Journal -->
<div id="daily-journal-filters-sidebar" class="filters-sidebar">
    <div class="filters-sidebar-header">
        <h3>Filtros personalizados</h3>
        <button id="close-daily-journal-filters-btn" class="close-filters-btn">
            <i class="fas fa-times"></i>
        </button>
    </div>
    
    <div class="filters-sidebar-content">
        <!-- Filtro por Símbolo -->
        <div class="filter-section">
            <label class="filter-label">Símbolo</label>
            <input type="text" id="dj-sidebar-filter-symbol" class="filter-sidebar-input" placeholder="Símbolo">
        </div>

        <!-- Filtro por Etiquetas (Tipo de Operación) -->
        <div class="filter-section">
            <label class="filter-label">Etiquetas</label>
            <select id="dj-sidebar-filter-type" class="filter-sidebar-select">
                <option value="all">Seleccionar</option>
                <option value="buy">Compra (Long)</option>
                <option value="sell">Venta (Short)</option>
            </select>
        </div>

        <!-- Filtro Lateral (Win/Loss) -->
        <div class="filter-section">
            <label class="filter-label">Lateral</label>
            <select id="dj-sidebar-filter-result" class="filter-sidebar-select">
                <option value="all">Todo</option>
                <option value="win">Ganadores</option>
                <option value="loss">Perdedores</option>
                <option value="breakeven">Break Even</option>
            </select>
        </div>

        <!-- Filtro por Duración -->
        <div class="filter-section">
            <label class="filter-label">Duración</label>
            <select id="dj-sidebar-filter-duration" class="filter-sidebar-select">
                <option value="all">Todo</option>
                <option value="scalping">Scalping (< 5 min)</option>
                <option value="intraday">Intraday (5-60 min)</option>
                <option value="swing">Swing (> 60 min)</option>
            </select>
        </div>

        <!-- Days/Time -->
        <div class="filter-section expandable">
            <div class="filter-section-header" onclick="toggleFilterSection('dj-days-time')">
                <span class="filter-label">Days/Time</span>
                <i class="fas fa-chevron-down"></i>
            </div>
            <div id="dj-days-time-content" class="filter-section-content">
                <label class="filter-sublabel">Día de la semana</label>
                <select id="dj-sidebar-filter-day" class="filter-sidebar-select">
                    <option value="all">Todos</option>
                    <option value="1">Lunes</option>
                    <option value="2">Martes</option>
                    <option value="3">Miércoles</option>
                    <option value="4">Jueves</option>
                    <option value="5">Viernes</option>
                    <option value="6">Sábado</option>
                    <option value="0">Domingo</option>
                </select>

                <label class="filter-sublabel mt-3">Sesión de Trading</label>
                <select id="dj-sidebar-filter-session" class="filter-sidebar-select">
                    <option value="all">Todas</option>
                    <option value="asian">Asiática (00:00-08:00)</option>
                    <option value="london">Londres (08:00-16:00)</option>
                    <option value="newyork">Nueva York (13:00-22:00)</option>
                </select>
            </div>
        </div>

        <!-- Price/Volume -->
        <div class="filter-section expandable">
            <div class="filter-section-header" onclick="toggleFilterSection('dj-price-volume')">
                <span class="filter-label">Price/Volume</span>
                <i class="fas fa-chevron-down"></i>
            </div>
            <div id="dj-price-volume-content" class="filter-section-content">
                <label class="filter-sublabel">P/L Mínimo</label>
                <input type="number" id="dj-sidebar-filter-pl-min" class="filter-sidebar-input" placeholder="Ej: -100">
                
                <label class="filter-sublabel mt-3">P/L Máximo</label>
                <input type="number" id="dj-sidebar-filter-pl-max" class="filter-sidebar-input" placeholder="Ej: 500">
            </div>
        </div>

        <!-- Win/Loss Trades -->
        <div class="filter-section expandable">
            <div class="filter-section-header" onclick="toggleFilterSection('dj-winloss-trades')">
                <span class="filter-label">Win/Loss Trades</span>
                <i class="fas fa-chevron-down"></i>
            </div>
            <div id="dj-winloss-trades-content" class="filter-section-content">
                <label class="filter-sublabel">Filtrar por resultado</label>
                <div class="filter-checkbox-group">
                    <label class="filter-checkbox">
                        <input type="checkbox" id="dj-sidebar-show-wins" checked>
                        <span>Mostrar ganadores</span>
                    </label>
                    <label class="filter-checkbox">
                        <input type="checkbox" id="dj-sidebar-show-losses" checked>
                        <span>Mostrar perdedores</span>
                    </label>
                    <label class="filter-checkbox">
                        <input type="checkbox" id="dj-sidebar-show-breakeven" checked>
                        <span>Mostrar break even</span>
                    </label>
                </div>
            </div>
        </div>
    </div>

    <div class="filters-sidebar-footer">
        <button id="dj-sidebar-apply-filters-btn" class="sidebar-apply-btn">
            <i class="fas fa-check"></i> Aplicar
        </button>
        <button id="dj-sidebar-clear-filters-btn" class="sidebar-clear-btn">
            Limpiar
        </button>
    </div>
</div>

<!-- Panel Lateral de Filtros para Operations -->
<div id="operations-filters-sidebar" class="filters-sidebar">
    <div class="filters-sidebar-header">
        <h3>Filtros personalizados</h3>
        <button id="close-operations-filters-btn" class="close-filters-btn">
            <i class="fas fa-times"></i>
        </button>
    </div>
    
    <div class="filters-sidebar-content">
        <!-- Filtro por Símbolo -->
        <div class="filter-section">
            <label class="filter-label">Símbolo</label>
            <input type="text" id="ops-sidebar-filter-symbol" class="filter-sidebar-input" placeholder="Símbolo">
        </div>

        <!-- Filtro por Etiquetas (Tipo de Operación) -->
        <div class="filter-section">
            <label class="filter-label">Etiquetas</label>
            <select id="ops-sidebar-filter-type" class="filter-sidebar-select">
                <option value="all">Seleccionar</option>
                <option value="buy">Compra (Long)</option>
                <option value="sell">Venta (Short)</option>
            </select>
        </div>

        <!-- Filtro Lateral (Win/Loss) -->
        <div class="filter-section">
            <label class="filter-label">Lateral</label>
            <select id="ops-sidebar-filter-result" class="filter-sidebar-select">
                <option value="all">Todo</option>
                <option value="win">Ganadores</option>
                <option value="loss">Perdedores</option>
                <option value="breakeven">Break Even</option>
            </select>
        </div>

        <!-- Filtro por Duración -->
        <div class="filter-section">
            <label class="filter-label">Duración</label>
            <select id="ops-sidebar-filter-duration" class="filter-sidebar-select">
                <option value="all">Todo</option>
                <option value="scalping">Scalping (< 5 min)</option>
                <option value="intraday">Intraday (5-60 min)</option>
                <option value="swing">Swing (> 60 min)</option>
            </select>
        </div>

        <!-- Days/Time -->
        <div class="filter-section expandable">
            <div class="filter-section-header" onclick="toggleFilterSection('ops-days-time')">
                <span class="filter-label">Days/Time</span>
                <i class="fas fa-chevron-down"></i>
            </div>
            <div id="ops-days-time-content" class="filter-section-content">
                <label class="filter-sublabel">Día de la semana</label>
                <select id="ops-sidebar-filter-day" class="filter-sidebar-select">
                    <option value="all">Todos</option>
                    <option value="1">Lunes</option>
                    <option value="2">Martes</option>
                    <option value="3">Miércoles</option>
                    <option value="4">Jueves</option>
                    <option value="5">Viernes</option>
                    <option value="6">Sábado</option>
                    <option value="0">Domingo</option>
                </select>

                <label class="filter-sublabel mt-3">Sesión de Trading</label>
                <select id="ops-sidebar-filter-session" class="filter-sidebar-select">
                    <option value="all">Todas</option>
                    <option value="asian">Asiática (00:00-08:00)</option>
                    <option value="london">Londres (08:00-16:00)</option>
                    <option value="newyork">Nueva York (13:00-22:00)</option>
                </select>
            </div>
        </div>

        <!-- Price/Volume -->
        <div class="filter-section expandable">
            <div class="filter-section-header" onclick="toggleFilterSection('ops-price-volume')">
                <span class="filter-label">Price/Volume</span>
                <i class="fas fa-chevron-down"></i>
            </div>
            <div id="ops-price-volume-content" class="filter-section-content">
                <label class="filter-sublabel">P/L Mínimo</label>
                <input type="number" id="ops-sidebar-filter-pl-min" class="filter-sidebar-input" placeholder="Ej: -100">
                
                <label class="filter-sublabel mt-3">P/L Máximo</label>
                <input type="number" id="ops-sidebar-filter-pl-max" class="filter-sidebar-input" placeholder="Ej: 500">
            </div>
        </div>

        <!-- Win/Loss Trades -->
        <div class="filter-section expandable">
            <div class="filter-section-header" onclick="toggleFilterSection('ops-winloss-trades')">
                <span class="filter-label">Win/Loss Trades</span>
                <i class="fas fa-chevron-down"></i>
            </div>
            <div id="ops-winloss-trades-content" class="filter-section-content">
                <label class="filter-sublabel">Filtrar por resultado</label>
                <div class="filter-checkbox-group">
                    <label class="filter-checkbox">
                        <input type="checkbox" id="ops-sidebar-show-wins" checked>
                        <span>Mostrar ganadores</span>
                    </label>
                    <label class="filter-checkbox">
                        <input type="checkbox" id="ops-sidebar-show-losses" checked>
                        <span>Mostrar perdedores</span>
                    </label>
                    <label class="filter-checkbox">
                        <input type="checkbox" id="ops-sidebar-show-breakeven" checked>
                        <span>Mostrar break even</span>
                    </label>
                </div>
            </div>
        </div>
    </div>

    <div class="filters-sidebar-footer">
        <button id="ops-sidebar-apply-filters-btn" class="sidebar-apply-btn">
            <i class="fas fa-check"></i> Aplicar
        </button>
        <button id="ops-sidebar-clear-filters-btn" class="sidebar-clear-btn">
            Limpiar
        </button>
    </div>
</div>

<!-- Panel Lateral de Filtros para Equity Graph -->
<div id="equity-filters-sidebar" class="filters-sidebar">
    <div class="filters-sidebar-header">
        <h3>Filtros de Equity Graph</h3>
        <button id="close-equity-filters-btn" class="close-filters-btn">
            <i class="fas fa-times"></i>
        </button>
    </div>

    <div class="filters-sidebar-body">
        <!-- Período -->
        <div class="filter-section">
            <label class="filter-label">
                <i class="fas fa-calendar mr-2"></i>Período
            </label>
            <select id="equity-sidebar-period" class="filter-sidebar-select">
                <option value="all">Total</option>
                <option value="1w">Última Semana</option>
                <option value="1m">Último Mes</option>
                <option value="3m">Últimos 3 Meses</option>
                <option value="6m">Últimos 6 Meses</option>
                <option value="1y">Último Año</option>
                <option value="custom">Personalizado</option>
            </select>
        </div>

        <!-- Rango Personalizado -->
        <div id="equity-sidebar-custom-range" class="filter-section" style="display: none;">
            <label class="filter-label">Desde - Hasta</label>
            <input type="date" id="equity-sidebar-date-from" class="filter-sidebar-input mb-2">
            <input type="date" id="equity-sidebar-date-to" class="filter-sidebar-input">
        </div>

        <!-- Instrumento -->
        <div class="filter-section">
            <label class="filter-label">
                <i class="fas fa-chart-line mr-2"></i>Instrumento
            </label>
            <select id="equity-sidebar-instrument" class="filter-sidebar-select">
                <option value="all">Todos</option>
            </select>
        </div>

        <!-- Resultado -->
        <div class="filter-section">
            <label class="filter-label">
                <i class="fas fa-trophy mr-2"></i>Resultado
            </label>
            <select id="equity-sidebar-outcome" class="filter-sidebar-select">
                <option value="all">Todos</option>
                <option value="win">Ganadas</option>
                <option value="loss">Perdidas</option>
                <option value="breakeven">Breakeven</option>
            </select>
        </div>

        <!-- Dirección -->
        <div class="filter-section">
            <label class="filter-label">
                <i class="fas fa-exchange-alt mr-2"></i>Dirección
            </label>
            <select id="equity-sidebar-direction" class="filter-sidebar-select">
                <option value="all">Todas</option>
                <option value="long">Long</option>
                <option value="short">Short</option>
            </select>
        </div>

        <!-- Setup -->
        <div class="filter-section">
            <label class="filter-label">
                <i class="fas fa-layer-group mr-2"></i>Setup
            </label>
            <select id="equity-sidebar-setup" class="filter-sidebar-select">
                <option value="all">Todos</option>
            </select>
        </div>

        <!-- RRR Mínimo -->
        <div class="filter-section">
            <label class="filter-label">
                <i class="fas fa-percentage mr-2"></i>RRR Mínimo
            </label>
            <select id="equity-sidebar-rrr" class="filter-sidebar-select">
                <option value="0">Todos</option>
                <option value="1">RRR ≥ 1</option>
                <option value="2">RRR ≥ 2</option>
                <option value="3">RRR ≥ 3</option>
                <option value="5">RRR ≥ 5</option>
            </select>
        </div>

        <!-- Marcadas -->
        <div class="filter-section">
            <label class="filter-label">
                <i class="fas fa-star mr-2"></i>Marcadas
            </label>
            <select id="equity-sidebar-starred" class="filter-sidebar-select">
                <option value="all">Todas</option>
                <option value="starred">Solo Marcadas</option>
                <option value="not-starred">No Marcadas</option>
            </select>
        </div>

        <!-- Visualización -->
        <div class="filter-section">
            <label class="filter-label">
                <i class="fas fa-chart-area mr-2"></i>Visualización
            </label>
            <select id="equity-sidebar-display" class="filter-sidebar-select">
                <option value="return">Return ($)</option>
                <option value="balance">Account Balance ($)</option>
                <option value="return-pct">Return, gain sum (%)</option>
                <option value="roi">Return, ROI (%)</option>
                <option value="r-multiple">R Multiple (R)</option>
            </select>
        </div>

        <!-- Agrupación -->
        <div class="filter-section">
            <label class="filter-label">
                <i class="fas fa-layer-group mr-2"></i>Agrupar por
            </label>
            <select id="equity-sidebar-groupby" class="filter-sidebar-select">
                <option value="trades">Trades Individuales</option>
                <option value="day">Agrupar por Día</option>
                <option value="week">Agrupar por Semana</option>
                <option value="month">Agrupar por Mes</option>
            </select>
        </div>

        <!-- Últimas Operaciones -->
        <div class="filter-section">
            <label class="filter-label">
                <i class="fas fa-list-ol mr-2"></i>Últimas Operaciones
            </label>
            <select id="equity-sidebar-lasttrades" class="filter-sidebar-select">
                <option value="all">Todas</option>
                <option value="10">Últimas 10</option>
                <option value="20">Últimas 20</option>
                <option value="50">Últimas 50</option>
                <option value="100">Últimas 100</option>
            </select>
        </div>
    </div>

    <div class="filters-sidebar-footer">
        <button id="equity-sidebar-apply-btn" class="sidebar-apply-btn">
            <i class="fas fa-check"></i> Aplicar
        </button>
        <button id="equity-sidebar-clear-btn" class="sidebar-clear-btn">
            Limpiar
        </button>
    </div>
</div>

<!-- Overlay para cerrar el sidebar -->
<div id="filters-overlay" class="filters-overlay"></div>

<!-- Modal para ampliar gráficos -->
<div id="chart-modal" class="chart-modal">
    <div class="chart-modal-content">
        <button id="chart-modal-close" class="chart-modal-close">
            <i class="fas fa-times"></i>
        </button>
        <div class="chart-modal-body">
            <canvas id="chart-modal-canvas"></canvas>
        </div>
    </div>
</div>

<style>
    .chart-modal {
        display: none;
        position: fixed;
        z-index: 10000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.9);
        animation: fadeIn 0.2s;
    }

    .chart-modal.active {
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .chart-modal-content {
        position: relative;
        width: 90%;
        height: 90%;
        background-color: #1a1a2e;
        border-radius: 12px;
        padding: 20px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
    }

    .chart-modal-close {
        position: absolute;
        top: 10px;
        right: 10px;
        background: rgba(255, 255, 255, 0.1);
        border: none;
        color: #fff;
        font-size: 24px;
        cursor: pointer;
        padding: 8px 12px;
        border-radius: 50%;
        transition: background-color 0.3s;
        z-index: 1;
    }

    .chart-modal-close:hover {
        background-color: rgba(255, 255, 255, 0.2);
    }

    .chart-modal-body {
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    #chart-modal-canvas {
        max-width: 100%;
        max-height: 100%;
    }

    @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
    }

    /* Cursor pointer para los contenedores de gráficos */
    .chart-container {
        cursor: pointer;
        transition: transform 0.2s;
    }

    .chart-container:hover {
        transform: scale(1.02);
    }
</style>

<script>
    // Sistema de Modal para Gráficos
    (function() {
        const modal = document.getElementById('chart-modal');
        const modalCanvas = document.getElementById('chart-modal-canvas');
        const closeBtn = document.getElementById('chart-modal-close');
        let currentModalChart = null;

        // Función para abrir el modal con un gráfico
        function openChartModal(sourceCanvas) {
            if (!sourceCanvas) return;

            // Buscar la instancia de Chart.js asociada al canvas
            let chartInstance = null;
            
            // Método 1: Buscar en Chart.instances (Chart.js 3.x)
            if (window.Chart && Chart.instances) {
                for (let i = 0; i < Chart.instances.length; i++) {
                    if (Chart.instances[i].canvas === sourceCanvas) {
                        chartInstance = Chart.instances[i];
                        break;
                    }
                }
            }
            
            // Método 2: Buscar en la propiedad chart del canvas (si existe)
            if (!chartInstance && sourceCanvas.chart) {
                chartInstance = sourceCanvas.chart;
            }
            
            // Método 3: Usar Chart.getChart() si está disponible (Chart.js 3.x)
            if (!chartInstance && window.Chart && Chart.getChart) {
                chartInstance = Chart.getChart(sourceCanvas);
            }

            if (!chartInstance) {
                console.warn('No se encontró instancia de gráfico para el canvas');
                return;
            }

            const config = chartInstance.config;

            // Crear una copia profunda del config para el modal
            const modalConfig = {
                type: config.type,
                data: JSON.parse(JSON.stringify(config.data)),
                options: JSON.parse(JSON.stringify(config.options || {}))
            };

            // Ajustar tamaño y responsive
            if (!modalConfig.options) modalConfig.options = {};
            modalConfig.options.maintainAspectRatio = true;
            modalConfig.options.responsive = true;

            // Destruir gráfico anterior si existe
            if (currentModalChart) {
                currentModalChart.destroy();
                currentModalChart = null;
            }

            // Mostrar modal
            modal.classList.add('active');

            // Crear nuevo gráfico en el modal
            setTimeout(() => {
                const ctx = modalCanvas.getContext('2d');
                currentModalChart = new Chart(ctx, modalConfig);
            }, 100);
        }

        // Función para cerrar el modal
        function closeChartModal() {
            modal.classList.remove('active');
            if (currentModalChart) {
                currentModalChart.destroy();
                currentModalChart = null;
            }
        }

        // Event listeners
        closeBtn.addEventListener('click', closeChartModal);
        modal.addEventListener('click', function(e) {
            if (e.target === modal) {
                closeChartModal();
            }
        });

        // Cerrar con tecla ESC
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && modal.classList.contains('active')) {
                closeChartModal();
            }
        });

        // Agregar click listeners a todos los canvas de gráficos
        function initChartClickListeners() {
            // Buscar todos los canvas que contienen gráficos (id termina en 'chart' o contiene 'chart')
            const canvasElements = document.querySelectorAll('canvas[id*="chart"], canvas[id*="-gauge"]');
            
            canvasElements.forEach(canvas => {
                // Evitar duplicados
                if (canvas.hasAttribute('data-chart-modal-ready')) return;
                canvas.setAttribute('data-chart-modal-ready', 'true');
                
                // Buscar el contenedor más apropiado
                let container = canvas.closest('.chart-container');
                if (!container) {
                    container = canvas.closest('.metric-card, .stat-card, .chart-box');
                }
                
                // Si no hay contenedor, usar el canvas directamente
                const clickTarget = container || canvas;
                
                if (!clickTarget.classList.contains('chart-clickable')) {
                    clickTarget.classList.add('chart-clickable');
                    clickTarget.style.cursor = 'pointer';
                    
                    clickTarget.addEventListener('click', function(e) {
                        // Evitar abrir modal si se hace clic en botones dentro del contenedor
                        if (e.target.tagName === 'BUTTON' || e.target.closest('button')) {
                            return;
                        }
                        // Evitar si se hace clic en inputs o selects
                        if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.closest('input, select')) {
                            return;
                        }
                        openChartModal(canvas);
                    });
                }
            });
        }

        // Inicializar cuando el DOM esté listo
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initChartClickListeners);
        } else {
            initChartClickListeners();
        }

        // Reinicializar cuando se cambien vistas o se creen nuevos gráficos
        const observer = new MutationObserver(function(mutations) {
            mutations.forEach(function(mutation) {
                if (mutation.addedNodes.length) {
                    initChartClickListeners();
                }
            });
        });

        observer.observe(document.body, {
            childList: true,
            subtree: true
        });

        // Event listeners para modal de retiros (con verificación de existencia)
        const closeWithdrawalBtn = document.getElementById('close-withdrawal-modal');
        const cancelWithdrawalBtn = document.getElementById('cancel-withdrawal-btn');
        const withdrawalForm = document.getElementById('withdrawal-form');
        const withdrawalModal = document.getElementById('withdrawal-modal');

        if (closeWithdrawalBtn && typeof closeWithdrawalModal !== 'undefined') {
            closeWithdrawalBtn.addEventListener('click', closeWithdrawalModal);
        }
        
        if (cancelWithdrawalBtn && typeof closeWithdrawalModal !== 'undefined') {
            cancelWithdrawalBtn.addEventListener('click', closeWithdrawalModal);
        }
        
        if (withdrawalForm) {
            withdrawalForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                if (typeof saveWithdrawal !== 'undefined') {
                    await saveWithdrawal();
                }
            });
        }

        // Cerrar modal al hacer click fuera
        if (withdrawalModal && typeof closeWithdrawalModal !== 'undefined') {
            withdrawalModal.addEventListener('click', (e) => {
                if (e.target.id === 'withdrawal-modal') {
                    closeWithdrawalModal();
                }
            });
        }


        // Exponer función globalmente por si se necesita llamar manualmente
        window.openChartModal = openChartModal;
    })();

// =============================================
// MARKET SCANNER - NOTICIAS
// =============================================
console.log('📰 Inicializando Market Scanner...');

// API Configuration
const FINNHUB_API_KEY = 'd5qg241r01qhn30ffdq0d5qg241r01qhn30ffdqg';
const NEWSAPI_KEY = '2e4c7b532f6244168c5486e4a4a6857e';
const ALPHAVANTAGE_KEY = 'SU0HM9RG6FUID5Y7';
const FINNHUB_BASE = 'https://finnhub.io/api/v1';
const COINGECKO_BASE = 'https://api.coingecko.com/api/v3';
const EXCHANGERATE_BASE = 'https://api.exchangerate-api.com/v4/latest';
const NEWSAPI_BASE = 'https://newsapi.org/v2';
const ALPHAVANTAGE_BASE = 'https://www.alphavantage.co/query';

// Almacenar tasas de cambio base
let forexRates = {};
let lastForexUpdate = 0;

// Variables globales para filtros de fecha
let dateFilterFrom = null;
let dateFilterTo = null;

// Cache para reducir llamadas a la API
const cache = {
    data: {},
    timestamp: {},
    TTL: 60000, // 1 minuto (default)
    TTL_ALPHAVANTAGE: 300000 // 5 minutos para Alpha Vantage (límite 25/día)
};

// Datos de mercado (se actualizarán con API real)
let marketData = {
    indices: [],
    crypto: [],
    forex: [],
    commodities: []
};

let newsData = { all: [] };
let currentSector = 'indices';

// Función para hacer fetch con cache
async function fetchWithCache(url, cacheKey, useExtendedTTL = false) {
        const now = Date.now();
        const ttl = useExtendedTTL ? cache.TTL_ALPHAVANTAGE : cache.TTL;
        
        if (cache.data[cacheKey] && (now - cache.timestamp[cacheKey]) < ttl) {
            console.log(`📦 Cache hit: ${cacheKey}`);
            return cache.data[cacheKey];
        }

        try {
            const response = await fetch(url);
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            const data = await response.json();
            cache.data[cacheKey] = data;
            cache.timestamp[cacheKey] = now;
            console.log(`✅ API fetch: ${cacheKey}`);
            return data;
        } catch (error) {
            console.error(`❌ Error fetching ${cacheKey}:`, error);
            return cache.data[cacheKey] || null;
        }
    }

    // Cargar datos de Crypto desde CoinGecko (GRATIS, sin API key)
    async function loadCryptoData() {
        try {
            const data = await fetchWithCache(
                `${COINGECKO_BASE}/simple/price?ids=bitcoin,ethereum,solana,ripple,cardano,dogecoin&vs_currencies=usd&include_24hr_change=true`,
                'crypto'
            );

            if (data) {
                marketData.crypto = [
                    { name: 'Bitcoin', symbol: 'BTC', price: data.bitcoin?.usd || 0, change: data.bitcoin?.usd_24h_change || 0 },
                    { name: 'Ethereum', symbol: 'ETH', price: data.ethereum?.usd || 0, change: data.ethereum?.usd_24h_change || 0 },
                    { name: 'Solana', symbol: 'SOL', price: data.solana?.usd || 0, change: data.solana?.usd_24h_change || 0 },
                    { name: 'XRP', symbol: 'XRP', price: data.ripple?.usd || 0, change: data.ripple?.usd_24h_change || 0 },
                    { name: 'Cardano', symbol: 'ADA', price: data.cardano?.usd || 0, change: data.cardano?.usd_24h_change || 0 },
                    { name: 'Dogecoin', symbol: 'DOGE', price: data.dogecoin?.usd || 0, change: data.dogecoin?.usd_24h_change || 0 }
                ];
                console.log('✅ Crypto data loaded:', marketData.crypto);
            }
        } catch (error) {
            console.error('❌ Error loading crypto:', error);
        }
    }

    // Cargar datos de Forex desde ExchangeRate-API (GRATIS)
    async function loadForexData() {
        try {
            // Obtener tasas actuales desde USD base
            const data = await fetchWithCache(
                `${EXCHANGERATE_BASE}/USD`,
                'forex_rates'
            );

            if (data && data.rates) {
                // Guardar las tasas para calcular pares cruzados
                const prevRates = {...forexRates};
                forexRates = data.rates;
                
                // Calcular pares principales
                const pairs = [
                    { name: 'EUR/USD', base: 'EUR', quote: 'USD' },
                    { name: 'GBP/USD', base: 'GBP', quote: 'USD' },
                    { name: 'USD/JPY', base: 'USD', quote: 'JPY' },
                    { name: 'USD/CHF', base: 'USD', quote: 'CHF' },
                    { name: 'AUD/USD', base: 'AUD', quote: 'USD' },
                    { name: 'USD/CAD', base: 'USD', quote: 'CAD' }
                ];

                marketData.forex = pairs.map(pair => {
                    let price;
                    if (pair.base === 'USD') {
                        price = forexRates[pair.quote];
                    } else if (pair.quote === 'USD') {
                        price = 1 / forexRates[pair.base];
                    } else {
                        price = forexRates[pair.quote] / forexRates[pair.base];
                    }

                    // Calcular cambio % comparando con tasas previas
                    let change = 0;
                    if (prevRates[pair.base] && prevRates[pair.quote]) {
                        let prevPrice;
                        if (pair.base === 'USD') {
                            prevPrice = prevRates[pair.quote];
                        } else if (pair.quote === 'USD') {
                            prevPrice = 1 / prevRates[pair.base];
                        } else {
                            prevPrice = prevRates[pair.quote] / prevRates[pair.base];
                        }
                        change = ((price - prevPrice) / prevPrice) * 100;
                    }

                    return {
                        name: pair.name,
                        symbol: pair.base + pair.quote,
                        price: price,
                        change: change || (Math.random() - 0.5) * 0.5 // Simulado si es primera carga
                    };
                });

                console.log('✅ Forex data loaded:', marketData.forex);
            }
        } catch (error) {
            console.error('❌ Error loading forex:', error);
            // Fallback a datos simulados
            marketData.forex = [
                { name: 'EUR/USD', symbol: 'EURUSD', price: 1.0435, change: 0.15 },
                { name: 'GBP/USD', symbol: 'GBPUSD', price: 1.2123, change: -0.22 },
                { name: 'USD/JPY', symbol: 'USDJPY', price: 157.45, change: 0.34 },
                { name: 'USD/CHF', symbol: 'USDCHF', price: 0.9134, change: 0.12 },
                { name: 'AUD/USD', symbol: 'AUDUSD', price: 0.6234, change: -0.18 },
                { name: 'USD/CAD', symbol: 'USDCAD', price: 1.4356, change: 0.08 }
            ];
        }
    }

    // Cargar datos de Índices desde Alpha Vantage (REAL)
    async function loadIndicesData() {
        try {
            // Usar ETFs que representan los índices principales
            const indices = [
                { name: 'S&P 500', symbol: 'SPY', multiplier: 10 },
                { name: 'Nasdaq 100', symbol: 'QQQ', multiplier: 50 },
                { name: 'Dow Jones', symbol: 'DIA', multiplier: 100 },
                { name: 'DAX 40', symbol: 'EWG', multiplier: 250 },
                { name: 'FTSE 100', symbol: 'EWU', multiplier: 250 },
                { name: 'Nikkei 225', symbol: 'EWJ', multiplier: 600 }
            ];

            marketData.indices = [];

            for (const index of indices) {
                try {
                    const data = await fetchWithCache(
                        `${ALPHAVANTAGE_BASE}?function=GLOBAL_QUOTE&symbol=${index.symbol}&apikey=${ALPHAVANTAGE_KEY}`,
                        `index_${index.symbol}`,
                        true // Cache extendido 5 min para Alpha Vantage
                    );

                    if (data && data['Global Quote'] && data['Global Quote']['05. price']) {
                        const quote = data['Global Quote'];
                        const etfPrice = parseFloat(quote['05. price']);
                        const indexPrice = etfPrice * index.multiplier;
                        const change = parseFloat(quote['10. change percent'].replace('%', ''));

                        marketData.indices.push({
                            name: index.name,
                            symbol: index.symbol,
                            price: indexPrice,
                            change: change
                        });
                    }
                } catch (error) {
                    console.error(`Error loading ${index.name}:`, error);
                }
            }

            console.log('✅ Indices data loaded (REAL):', marketData.indices);
        } catch (error) {
            console.error('❌ Error loading indices:', error);
        }
    }

    // Cargar datos de Commodities desde Alpha Vantage (REAL)
    async function loadCommoditiesData() {
        try {
            // Activos principales: Metales preciosos, energía e índices USA
            const assets = [
                { name: 'XAU/USD (Oro)', symbol: 'GLD', multiplier: 18.5, category: 'metal' },
                { name: 'XAG/USD (Plata)', symbol: 'SLV', multiplier: 25, category: 'metal' },
                { name: 'Gas Natural', symbol: 'UNG', multiplier: 3.5, category: 'energy' },
                { name: 'Petróleo WTI', symbol: 'USO', multiplier: 7.5, category: 'energy' },
                { name: 'US100 (Nasdaq)', symbol: 'QQQ', multiplier: 1, category: 'index' },
                { name: 'US500 (S&P 500)', symbol: 'SPY', multiplier: 1, category: 'index' },
                { name: 'US30 (Dow Jones)', symbol: 'DIA', multiplier: 1, category: 'index' },
                { name: 'DAX 40 (Alemania)', symbol: 'DAX', multiplier: 1, category: 'index' }
            ];

            marketData.commodities = [];

            for (const asset of assets) {
                try {
                    const data = await fetchWithCache(
                        `${ALPHAVANTAGE_BASE}?function=GLOBAL_QUOTE&symbol=${asset.symbol}&apikey=${ALPHAVANTAGE_KEY}`,
                        `asset_${asset.symbol}`,
                        true // Cache extendido 5 min para Alpha Vantage
                    );

                    if (data && data['Global Quote'] && data['Global Quote']['05. price']) {
                        const quote = data['Global Quote'];
                        const etfPrice = parseFloat(quote['05. price']);
                        const assetPrice = etfPrice * asset.multiplier;
                        const change = parseFloat(quote['10. change percent'].replace('%', ''));

                        marketData.commodities.push({
                            name: asset.name,
                            symbol: asset.symbol,
                            price: assetPrice,
                            change: change,
                            category: asset.category
                        });
                    }
                } catch (error) {
                    console.error(`Error loading ${asset.name}:`, error);
                }
            }

            console.log('✅ Assets data loaded (Metals, Energy, Indices):', marketData.commodities);
        } catch (error) {
            console.error('❌ Error loading assets:', error);
        }
    }

    // Cargar noticias desde NewsAPI (principal) con fallback a Finnhub
    async function loadNewsData() {
        try {
            // Intentar NewsAPI primero (mejor para noticias financieras)
            const data = await fetchWithCache(
                `${NEWSAPI_BASE}/everything?q=finance OR trading OR stocks OR forex OR crypto&language=es&sortBy=publishedAt&pageSize=20&apiKey=${NEWSAPI_KEY}`,
                'news_newsapi'
            );

            if (data && data.articles && data.articles.length > 0) {
                newsData.all = data.articles.slice(0, 10).map(item => {
                    const timeAgo = getTimeAgoFromISO(item.publishedAt);
                    const sector = categorizNews('', item.title + ' ' + item.description);
                    
                    return {
                        time: timeAgo,
                        title: item.title,
                        sector: sector,
                        source: item.source.name,
                        url: item.url,
                        image: item.urlToImage
                    };
                });
                console.log('✅ News loaded from NewsAPI:', newsData.all.length);
            } else {
                // Fallback a Finnhub si NewsAPI falla
                await loadNewsFromFinnhub();
            }
        } catch (error) {
            console.error('❌ Error loading news from NewsAPI, using Finnhub:', error);
            await loadNewsFromFinnhub();
        }
    }

    // Fallback: Cargar noticias desde Finnhub
    async function loadNewsFromFinnhub() {
        try {
            const data = await fetchWithCache(
                `${FINNHUB_BASE}/news?category=general&token=${FINNHUB_API_KEY}`,
                'news_finnhub'
            );

            if (data && Array.isArray(data)) {
                newsData.all = data.slice(0, 10).map(item => {
                    const timeAgo = getTimeAgo(item.datetime);
                    const sector = categorizNews(item.category, item.headline);
                    
                    return {
                        time: timeAgo,
                        title: item.headline,
                        sector: sector,
                        source: item.source,
                        url: item.url,
                        image: item.image
                    };
                });
                console.log('✅ News loaded from Finnhub:', newsData.all.length);
            }
        } catch (error) {
            console.error('❌ Error loading news from Finnhub:', error);
        }
    }

    // Categorizar noticia según contenido
    function categorizNews(category, headline) {
        const lower = headline.toLowerCase();
        if (lower.includes('bitcoin') || lower.includes('crypto') || lower.includes('ethereum')) return 'crypto';
        if (lower.includes('forex') || lower.includes('usd') || lower.includes('eur')) return 'forex';
        if (lower.includes('s&p') || lower.includes('nasdaq') || lower.includes('dow')) return 'indices';
        if (lower.includes('gold') || lower.includes('oil') || lower.includes('commodity')) return 'commodities';
        return 'indices';
    }

    // Calcular tiempo transcurrido desde timestamp Unix
    function getTimeAgo(timestamp) {
        const now = Math.floor(Date.now() / 1000);
        const diff = now - timestamp;
        
        if (diff < 60) return 'Hace menos de 1 min';
        if (diff < 3600) return `Hace ${Math.floor(diff / 60)} min`;
        if (diff < 86400) return `Hace ${Math.floor(diff / 3600)} hora${Math.floor(diff / 3600) > 1 ? 's' : ''}`;
        return `Hace ${Math.floor(diff / 86400)} día${Math.floor(diff / 86400) > 1 ? 's' : ''}`;
    }

    // Calcular tiempo transcurrido desde ISO string (para NewsAPI)
    function getTimeAgoFromISO(isoString) {
        const timestamp = Math.floor(new Date(isoString).getTime() / 1000);
        return getTimeAgo(timestamp);
    }

// Calendario económico en español con detalles completos (VARIABLE GLOBAL)
// ACTUALIZADO con eventos REALES según calendarios de Investing.com y FXStreet
const economicEvents = [
    // LUNES 26 DE ENERO 2026
    { 
        time: '14:30',
        date: '2026-01-26',
        countryCode: 'USA', 
        event: 'Peticiones de bienes duraderos ex transporte', 
        importance: 'medium', 
        forecast: '0.3%', 
        previous: '0.2%',
        actual: '-',
        description: 'Mide el cambio en el valor total de nuevas órdenes de bienes duraderos excluyendo transporte, que es volátil.',
        impact: [
            { asset: 'USD', direction: 'up', explanation: 'Datos fuertes indican demanda manufacturera sólida' },
            { asset: 'S&P 500', direction: 'up', explanation: 'Señal de fortaleza en sector industrial' }
        ],
        interpretation: 'Indicador clave de la salud del sector manufacturero estadounidense.'
    },
    { 
        time: '14:30',
        date: '2026-01-26',
        countryCode: 'USA', 
        event: 'Peticiones de Bienes Duraderos Excluyendo Defensa', 
        importance: 'medium', 
        forecast: '-', 
        previous: '-1.5%',
        actual: '-',
        description: 'Órdenes de bienes duraderos sin el componente de defensa para ver tendencia subyacente.',
        impact: [
            { asset: 'USD', direction: 'up', explanation: 'Mejora indica fortaleza manufacturera civil' },
            { asset: 'Industriales', direction: 'up', explanation: 'Beneficia a sectores industriales' }
        ],
        interpretation: 'Excluir defensa da una visión más clara de la demanda comercial.'
    },
    { 
        time: '14:30',
        date: '2026-01-26',
        countryCode: 'USA', 
        event: 'Peticiones de Bienes Duraderos Excluyendo Defensa y Aviación', 
        importance: 'medium', 
        forecast: '-', 
        previous: '0.5%',
        actual: '-',
        description: 'Versión más depurada excluyendo los dos componentes más volátiles.',
        impact: [
            { asset: 'USD', direction: 'up', explanation: 'Dato positivo muestra tendencia manufacturera sólida' },
            { asset: 'Dólar Index', direction: 'up', explanation: 'Fortalece perspectiva económica USA' }
        ],
        interpretation: 'Es la medida más limpia de la demanda manufacturera subyacente.'
    },
    { 
        time: '14:30',
        date: '2026-01-26',
        countryCode: 'USA', 
        event: 'Índice de actividad nacional de la Fed de Chicago', 
        importance: 'low', 
        forecast: '-', 
        previous: '-',
        actual: '-',
        description: 'Índice compuesto de 85 indicadores económicos mensuales. Valor de cero = crecimiento tendencial.',
        impact: [
            { asset: 'USD', direction: 'up', explanation: 'Lectura positiva indica economía sobre tendencia' }
        ],
        interpretation: 'Mide presiones inflacionarias y actividad económica general.'
    },
    { 
        time: '16:30',
        date: '2026-01-26',
        countryCode: 'USA', 
        event: 'Índice de negocios manufactureros de la Fed de Dallas', 
        importance: 'low', 
        forecast: '-', 
        previous: '-10.9',
        actual: '-',
        description: 'Encuesta a fabricantes de Texas sobre condiciones empresariales actuales.',
        impact: [
            { asset: 'USD', direction: 'up', explanation: 'Mejora en manufactura regional apoya al dólar' },
            { asset: 'Petróleo', direction: 'up', explanation: 'Texas es hub energético importante' }
        ],
        interpretation: 'Indicador regional pero Texas es economía clave en USA.'
    },
    { 
        time: '17:30',
        date: '2026-01-26',
        countryCode: 'USA', 
        event: 'Emisión de bonos a 3 meses', 
        importance: 'low', 
        forecast: '-', 
        previous: '3.59%',
        actual: '-',
        description: 'Tasa de rendimiento de bonos del Tesoro a 3 meses subastados.',
        impact: [
            { asset: 'USD', direction: 'up', explanation: 'Rendimientos altos atraen capital a dólar' },
            { asset: 'Bonos', direction: 'down', explanation: 'Rendimientos altos = precios bajos' }
        ],
        interpretation: 'Refleja expectativas de política monetaria a corto plazo.'
    },
    { 
        time: '17:30',
        date: '2026-01-26',
        countryCode: 'USA', 
        event: 'Emisión de bonos a 6 meses', 
        importance: 'low', 
        forecast: '-', 
        previous: '3.52%',
        actual: '-',
        description: 'Tasa de rendimiento de bonos del Tesoro a 6 meses subastados.',
        impact: [
            { asset: 'USD', direction: 'up', explanation: 'Tasas atractivas fortalecen dólar' }
        ],
        interpretation: 'Indica apetito por deuda estadounidense de corto plazo.'
    },
    { 
        time: '19:00',
        date: '2026-01-26',
        countryCode: 'USA', 
        event: 'Emisión de Notas del Tesoro a 2 años', 
        importance: 'low', 
        forecast: '-', 
        previous: '3.499%',
        actual: '-',
        description: 'Subasta de notas del Tesoro a 2 años. Demanda indica confianza en economía USA.',
        impact: [
            { asset: 'USD', direction: 'up', explanation: 'Fuerte demanda apoya al dólar' },
            { asset: 'Yields', direction: 'variable', explanation: 'Alta demanda puede bajar yields' }
        ],
        interpretation: 'Refleja expectativas de política de la Fed a mediano plazo.'
    },
    { 
        time: '22:30',
        date: '2026-01-26',
        countryCode: 'USA', 
        event: 'PMI de Chicago', 
        importance: 'medium', 
        forecast: '-', 
        previous: '-4.3%',
        actual: '-',
        description: 'Índice de actividad manufacturera en región de Chicago. >50 = expansión.',
        impact: [
            { asset: 'USD', direction: 'up', explanation: 'Lectura fuerte indica economía saludable' },
            { asset: 'Industriales', direction: 'up', explanation: 'Beneficia sector manufacturero' }
        ],
        interpretation: 'Chicago es hub industrial importante, precursor de ISM nacional.'
    },
    { 
        time: '18:30',
        date: '2026-01-26',
        countryCode: 'USA', 
        event: 'Discurso de Alberto G. Musalem, presidente de la Fed de St. Louis', 
        importance: 'medium', 
        forecast: '-', 
        previous: '-',
        actual: '-',
        description: 'Miembro votante del FOMC comparte perspectiva sobre economía y política monetaria.',
        impact: [
            { asset: 'USD', direction: 'variable', explanation: 'Comentarios hawkish fortalecen dólar' },
            { asset: 'Bonos', direction: 'variable', explanation: 'Afecta expectativas de tasas' }
        ],
        interpretation: 'Los mercados buscan pistas sobre futuras decisiones de política monetaria.'
    },
    { 
        time: '19:00',
        date: '2026-01-26',
        countryCode: 'USA', 
        event: 'Conteo Equipos Perforación Crudo USA Baker Hughes', 
        importance: 'low', 
        forecast: '-', 
        previous: '411',
        actual: '-',
        description: 'Número de plataformas petrolíferas activas en USA. Indicador de producción futura.',
        impact: [
            { asset: 'Petróleo', direction: 'down', explanation: 'Más plataformas = mayor oferta futura' },
            { asset: 'Energy Stocks', direction: 'up', explanation: 'Mayor actividad beneficia sector' }
        ],
        interpretation: 'Seguido de cerca por el mercado energético para anticipar cambios en producción.'
    },
    { 
        time: '21:30',
        date: '2026-01-26',
        countryCode: 'EUR', 
        event: 'Posiciones netas no comerciales COT del EUR', 
        importance: 'low', 
        forecast: '-', 
        previous: '-€111.7K',
        actual: '-',
        description: 'Reporte de posiciones de traders especulativos en futuros de EUR.',
        impact: [
            { asset: 'EUR', direction: 'variable', explanation: 'Posiciones largas extremas pueden indicar reversión' }
        ],
        interpretation: 'Herramienta de sentimiento de mercado para posicionamiento institucional.'
    },
    { 
        time: '21:30',
        date: '2026-01-26',
        countryCode: 'USA', 
        event: 'Posiciones netas no comerciales COT del Oro', 
        importance: 'low', 
        forecast: '-', 
        previous: '-$244.8K',
        actual: '-',
        description: 'Posiciones especulativas en futuros de oro.',
        impact: [
            { asset: 'Oro', direction: 'variable', explanation: 'Cambios grandes pueden anticipar movimientos' }
        ],
        interpretation: 'Indica sentimiento de grandes traders hacia el oro.'
    },
    { 
        time: '21:30',
        date: '2026-01-26',
        countryCode: 'USA', 
        event: 'Posiciones netas no comerciales COT del Petróleo', 
        importance: 'low', 
        forecast: '-', 
        previous: '78.8K',
        actual: '-',
        description: 'Posicionamiento especulativo en petróleo crudo.',
        impact: [
            { asset: 'Petróleo', direction: 'variable', explanation: 'Exceso de posiciones puede señalar reversión' }
        ],
        interpretation: 'Muestra optimismo o pesimismo institucional sobre precios del crudo.'
    },
    { 
        time: '21:30',
        date: '2026-01-26',
        countryCode: 'USA', 
        event: 'Posiciones netas no comerciales COT del S&P500', 
        importance: 'low', 
        forecast: '-', 
        previous: '-$81.8K',
        actual: '-',
        description: 'Posiciones especulativas en futuros del S&P 500.',
        impact: [
            { asset: 'S&P 500', direction: 'variable', explanation: 'Extremos pueden indicar puntos de giro' }
        ],
        interpretation: 'Refleja sentimiento institucional sobre mercado de acciones USA.'
    },
    { 
        time: '23:00',
        date: '2026-01-26',
        countryCode: 'USA', 
        event: 'Discurso de Michelle Bowman, miembro de la Fed', 
        importance: 'medium', 
        forecast: '-', 
        previous: '-',
        actual: '-',
        description: 'Gobernadora de la Fed comparte perspectivas sobre economía y política monetaria.',
        impact: [
            { asset: 'USD', direction: 'variable', explanation: 'Tono hawkish fortalece dólar' },
            { asset: 'Yields', direction: 'variable', explanation: 'Afecta expectativas de tasas' }
        ],
        interpretation: 'Los mercados analizan cada palabra para anticipar movimientos de la Fed.'
    },
    
    // MARTES 27 DE ENERO 2026
    { 
        time: '14:30',
        date: '2026-01-27',
        countryCode: 'USA', 
        event: 'Variación del empleo de ADP - Promedio de 4 semanas', 
        importance: 'medium', 
        forecast: '-', 
        previous: '8K',
        actual: '-',
        description: 'Promedio de 4 semanas del cambio en empleo privado según ADP.',
        impact: [
            { asset: 'USD', direction: 'up', explanation: 'Creación fuerte de empleo apoya dólar' },
            { asset: 'S&P 500', direction: 'up', explanation: 'Mercado laboral sólido = economía fuerte' }
        ],
        interpretation: 'Adelanto del NFP oficial. Dato fuerte es alcista para USD.'
    },
    { 
        time: '14:55',
        date: '2026-01-27',
        countryCode: 'USA', 
        event: 'Índice Redbook', 
        importance: 'low', 
        forecast: '-', 
        previous: '5.5%',
        actual: '-',
        description: 'Ventas minoristas en cadenas de tiendas, medición semanal.',
        impact: [
            { asset: 'USD', direction: 'up', explanation: 'Ventas fuertes indican consumo sólido' },
            { asset: 'Retail Stocks', direction: 'up', explanation: 'Beneficia sector minorista' }
        ],
        interpretation: 'Indicador de alta frecuencia del gasto del consumidor.'
    },
    { 
        time: '15:00',
        date: '2026-01-27',
        countryCode: 'USA', 
        event: 'Índice de Precio de vivienda S&P/Case-Shiller', 
        importance: 'medium', 
        forecast: '1.2%', 
        previous: '1.3%',
        actual: '-',
        description: 'Mide cambio mensual en precios de viviendas en 20 ciudades principales.',
        impact: [
            { asset: 'USD', direction: 'up', explanation: 'Precios al alza indican economía fuerte' },
            { asset: 'Construcción', direction: 'up', explanation: 'Sector inmobiliario saludable' },
            { asset: 'Bancos', direction: 'up', explanation: 'Más actividad hipotecaria' }
        ],
        interpretation: 'Indicador clave de salud del mercado inmobiliario estadounidense.'
    },
    { 
        time: '15:00',
        date: '2026-01-27',
        countryCode: 'USA', 
        event: 'Índice de precios de viviendas (MoM)', 
        importance: 'medium', 
        forecast: '0.3%', 
        previous: '0.4%',
        actual: '-',
        description: 'Variación mensual del índice de precios de viviendas.',
        impact: [
            { asset: 'USD', direction: 'up', explanation: 'Aumento indica fortaleza del sector' },
            { asset: 'REITs', direction: 'up', explanation: 'Beneficia al sector inmobiliario' }
        ],
        interpretation: 'Complemento mensual del índice Case-Shiller.'
    },
    { 
        time: '16:00',
        date: '2026-01-27',
        countryCode: 'USA', 
        event: 'Confianza del consumidor', 
        importance: 'high', 
        forecast: '-', 
        previous: '-',
        actual: '-',
        description: 'Encuesta del Conference Board sobre percepción económica de consumidores.',
        impact: [
            { asset: 'USD', direction: 'up', explanation: 'Alta confianza = mayor gasto futuro' },
            { asset: 'S&P 500', direction: 'up', explanation: 'Consumidores optimistas impulsan mercado' },
            { asset: 'Retail', direction: 'up', explanation: 'Beneficia sector minorista directamente' }
        ],
        interpretation: 'MUY IMPORTANTE. Consumo = ~70% de economía USA. Lectura superior es muy alcista.'
    },
    { 
        time: '16:00',
        date: '2026-01-27',
        countryCode: 'USA', 
        event: 'Índice manufacturero de la Fed de Richmond', 
        importance: 'low', 
        forecast: '-8', 
        previous: '-7',
        actual: '-',
        description: 'Encuesta a fabricantes de la región de Richmond sobre actividad manufacturera.',
        impact: [
            { asset: 'USD', direction: 'up', explanation: 'Mejora indica fortaleza regional' }
        ],
        interpretation: 'Indicador regional. Lectura menos negativa es positiva.'
    },
    { 
        time: '18:00',
        date: '2026-01-27',
        countryCode: 'EUR', 
        event: 'Discurso de Christine Lagarde, presidenta del BCE', 
        importance: 'high', 
        forecast: '-', 
        previous: '-',
        actual: '-',
        description: 'La presidenta del BCE habla sobre política monetaria y perspectivas económicas.',
        impact: [
            { asset: 'EUR', direction: 'variable', explanation: 'Tono hawkish fortalece euro' },
            { asset: 'EUR/USD', direction: 'variable', explanation: 'Comentarios sobre tasas mueven el par' },
            { asset: 'DAX', direction: 'variable', explanation: 'Afecta mercados europeos' }
        ],
        interpretation: 'EVENTO CLAVE. Los mercados buscan pistas sobre futuras subidas/bajadas de tasas.'
    },
    { 
        time: '18:00',
        date: '2026-01-27',
        countryCode: 'EUR', 
        event: 'Discurso de Joachim Nagel, miembro del BCE', 
        importance: 'medium', 
        forecast: '-', 
        previous: '-',
        actual: '-',
        description: 'Presidente del Bundesbank y miembro del Consejo del BCE habla sobre política monetaria.',
        impact: [
            { asset: 'EUR', direction: 'variable', explanation: 'Comentarios hawkish apoyan euro' }
        ],
        interpretation: 'Voz influyente en el BCE, especialmente en temas de inflación.'
    },
    { 
        time: '19:00',
        date: '2026-01-27',
        countryCode: 'USA', 
        event: 'Emisión de Notas del Tesoro a 5 años', 
        importance: 'low', 
        forecast: '-', 
        previous: '3.747%',
        actual: '-',
        description: 'Subasta de notas del Tesoro a 5 años.',
        impact: [
            { asset: 'USD', direction: 'up', explanation: 'Fuerte demanda apoya dólar' },
            { asset: 'Yields', direction: 'down', explanation: 'Alta demanda baja rendimientos' }
        ],
        interpretation: 'Muestra apetito por deuda USA de mediano plazo.'
    },
    { 
        time: '22:30',
        date: '2026-01-27',
        countryCode: 'USA', 
        event: 'Reservas semanales de crudo del API', 
        importance: 'low', 
        forecast: '-', 
        previous: '-0.7M / 3.04M',
        actual: '-',
        description: 'Cambio semanal en reservas de petróleo crudo según American Petroleum Institute.',
        impact: [
            { asset: 'Petróleo', direction: 'down', explanation: 'Aumento de inventarios presiona precios' },
            { asset: 'CAD', direction: 'down', explanation: 'Petróleo débil afecta monedas exportadoras' }
        ],
        interpretation: 'Adelanto del reporte oficial EIA del miércoles.'
    },
    
    // MIÉRCOLES 28 DE ENERO 2026
    { 
        time: '00:00',
        date: '2026-01-28',
        countryCode: 'EUR', 
        event: 'Masa monetaria M3 (Anual)', 
        importance: 'low', 
        forecast: '3%', 
        previous: '3%',
        actual: '-',
        description: 'Mide el cambio anual en la oferta total de dinero en la Eurozona.',
        impact: [
            { asset: 'EUR', direction: 'up', explanation: 'Crecimiento controlado es positivo' },
            { asset: 'Inflación', direction: 'up', explanation: 'Más dinero puede generar presiones inflacionarias' }
        ],
        interpretation: 'El BCE monitorea M3 para evaluar liquidez y riesgos inflacionarios.'
    },
    { 
        time: '00:00',
        date: '2026-01-28',
        countryCode: 'EUR', 
        event: 'Masa monetaria M3 (Mensual)', 
        importance: 'low', 
        forecast: '-', 
        previous: '2.9%',
        actual: '-',
        description: 'Cambio mensual en M3.',
        impact: [
            { asset: 'EUR', direction: 'variable', explanation: 'Crecimiento excesivo puede preocupar al BCE' }
        ],
        interpretation: 'Complemento mensual del dato anual.'
    },
    { 
        time: '00:00',
        date: '2026-01-28',
        countryCode: 'EUR', 
        event: 'Préstamos Privados (Anual)', 
        importance: 'low', 
        forecast: '2.9%', 
        previous: '2.9%',
        actual: '-',
        description: 'Cambio anual en el total de préstamos al sector privado.',
        impact: [
            { asset: 'EUR', direction: 'up', explanation: 'Crecimiento indica actividad económica' },
            { asset: 'Bancos EUR', direction: 'up', explanation: 'Mayor actividad crediticia' }
        ],
        interpretation: 'Indicador de demanda de crédito y actividad económica.'
    },
    { 
        time: '01:00',
        date: '2026-01-28',
        countryCode: 'EUR', 
        event: 'Clima empresarial', 
        importance: 'medium', 
        forecast: '-', 
        previous: '-0.56',
        actual: '-',
        description: 'Encuesta de confianza empresarial en la Eurozona.',
        impact: [
            { asset: 'EUR', direction: 'up', explanation: 'Mejora en confianza fortalece euro' },
            { asset: 'STOXX 50', direction: 'up', explanation: 'Optimismo empresarial impulsa bolsas' }
        ],
        interpretation: 'Lectura superior indica mejores expectativas de negocios.'
    },
    { 
        time: '01:00',
        date: '2026-01-28',
        countryCode: 'EUR', 
        event: 'Confianza del consumidor', 
        importance: 'medium', 
        forecast: '-12.4', 
        previous: '-12.4',
        actual: '-',
        description: 'Encuesta mensual de sentimiento del consumidor en la Eurozona.',
        impact: [
            { asset: 'EUR', direction: 'up', explanation: 'Mejora indica mayor gasto futuro' },
            { asset: 'Retail EUR', direction: 'up', explanation: 'Beneficia sector minorista europeo' }
        ],
        interpretation: 'Lectura menos negativa o positiva es alcista para EUR.'
    },
    { 
        time: '01:00',
        date: '2026-01-28',
        countryCode: 'EUR', 
        event: 'Confianza en el Sector Servicios', 
        importance: 'low', 
        forecast: '-', 
        previous: '5.6',
        actual: '-',
        description: 'Encuesta de confianza en el sector servicios europeo.',
        impact: [
            { asset: 'EUR', direction: 'up', explanation: 'Servicios representan ~70% de economía europea' }
        ],
        interpretation: 'Indicador importante dado el peso de servicios en el PIB.'
    },
    { 
        time: '01:00',
        date: '2026-01-28',
        countryCode: 'EUR', 
        event: 'Confianza Industrial', 
        importance: 'low', 
        forecast: '-', 
        previous: '-8',
        actual: '-',
        description: 'Confianza de fabricantes en la Eurozona.',
        impact: [
            { asset: 'EUR', direction: 'up', explanation: 'Mejora indica fortaleza manufacturera' },
            { asset: 'Materiales EUR', direction: 'up', explanation: 'Beneficia sector industrial' }
        ],
        interpretation: 'Lectura menos negativa es positiva para EUR.'
    },
    { 
        time: '01:00',
        date: '2026-01-28',
        countryCode: 'EUR', 
        event: 'Indicador de Sentimiento Económico (ESI)', 
        importance: 'medium', 
        forecast: '97.1', 
        previous: '96.7',
        actual: '-',
        description: 'Índice compuesto de confianza económica en la Eurozona. 100 = promedio histórico.',
        impact: [
            { asset: 'EUR', direction: 'up', explanation: 'Lectura superior indica economía más fuerte' },
            { asset: 'EUR/USD', direction: 'up', explanation: 'Mejora en sentimiento apoya al euro' }
        ],
        interpretation: 'Indicador adelantado importante. >100 = optimismo, <100 = pesimismo.'
    },
    { 
        time: '03:00',
        date: '2026-01-28',
        countryCode: 'EUR', 
        event: 'Discurso de Frank Elderson del BCE', 
        importance: 'medium', 
        forecast: '-', 
        previous: '-',
        actual: '-',
        description: 'Miembro del Consejo Ejecutivo del BCE habla sobre política monetaria.',
        impact: [
            { asset: 'EUR', direction: 'variable', explanation: 'Comentarios sobre tasas mueven mercado' }
        ],
        interpretation: 'Los mercados buscan pistas sobre futura política del BCE.'
    },
    { 
        time: '05:00',
        date: '2026-01-28',
        countryCode: 'USA', 
        event: 'Solicitudes de hipotecas MBA', 
        importance: 'low', 
        forecast: '-', 
        previous: '14.1%',
        actual: '-',
        description: 'Cambio semanal en número de solicitudes de hipotecas.',
        impact: [
            { asset: 'USD', direction: 'up', explanation: 'Aumento indica sector inmobiliario saludable' },
            { asset: 'Construcción', direction: 'up', explanation: 'Más hipotecas = más ventas de viviendas' }
        ],
        interpretation: 'Indicador adelantado de actividad en el mercado inmobiliario.'
    },
    { 
        time: '16:30',
        date: '2026-01-28',
        countryCode: 'USA', 
        event: 'Cambio en reservas de petróleo EIA', 
        importance: 'medium', 
        forecast: '-', 
        previous: '3.602M',
        actual: '-',
        description: 'Cambio semanal en reservas de petróleo crudo según Energy Information Administration.',
        impact: [
            { asset: 'Petróleo', direction: 'down', explanation: 'Aumento de inventarios = mayor oferta' },
            { asset: 'CAD', direction: 'down', explanation: 'Petróleo débil afecta a Canadá' },
            { asset: 'Energy Stocks', direction: 'down', explanation: 'Presiona acciones energéticas' }
        ],
        interpretation: 'REPORTE CLAVE para mercado petrolero. Gran impacto en precios del crudo.'
    },
    { 
        time: '19:00',
        date: '2026-01-28',
        countryCode: 'EUR', 
        event: 'Discurso de Schnabel del BCE', 
        importance: 'medium', 
        forecast: '-', 
        previous: '-',
        actual: '-',
        description: 'Isabel Schnabel, miembro del Consejo Ejecutivo del BCE, habla sobre política monetaria.',
        impact: [
            { asset: 'EUR', direction: 'variable', explanation: 'Voz influyente en decisiones del BCE' }
        ],
        interpretation: 'Schnabel es considerada hawkish, sus comentarios mueven mercado.'
    },
    { 
        time: '20:00',
        date: '2026-01-28',
        countryCode: 'USA', 
        event: 'Decisión de tipos de interés de la Fed', 
        importance: 'high', 
        forecast: '3.75%', 
        previous: '3.75%',
        actual: '-',
        description: 'La Reserva Federal anuncia su decisión sobre la tasa de interés de fondos federales.',
        impact: [
            { asset: 'USD', direction: 'variable', explanation: 'Subida = USD fuerte, bajada = USD débil' },
            { asset: 'S&P 500', direction: 'variable', explanation: 'Subida presiona acciones' },
            { asset: 'Oro', direction: 'down', explanation: 'Tasas altas reducen atractivo del oro' },
            { asset: 'Bonos', direction: 'variable', explanation: 'Afecta toda la curva de rendimientos' }
        ],
        interpretation: '🔴 EVENTO MÁS IMPORTANTE DEL MES. Mueve todos los mercados globalmente.'
    },
    { 
        time: '20:00',
        date: '2026-01-28',
        countryCode: 'USA', 
        event: 'Declaración de política monetaria de la Fed', 
        importance: 'high', 
        forecast: '-', 
        previous: '-',
        actual: '-',
        description: 'Comunicado oficial de la Fed explicando su decisión y perspectivas.',
        impact: [
            { asset: 'Todos', direction: 'variable', explanation: 'Lenguaje hawkish/dovish mueve mercados' }
        ],
        interpretation: '🔴 Los mercados analizan cada palabra para anticipar futuras decisiones.'
    },
    { 
        time: '20:30',
        date: '2026-01-28',
        countryCode: 'USA', 
        event: 'Conferencia de prensa del FOMC', 
        importance: 'high', 
        forecast: '-', 
        previous: '-',
        actual: '-',
        description: 'Jerome Powell, presidente de la Fed, responde preguntas sobre la decisión.',
        impact: [
            { asset: 'USD', direction: 'variable', explanation: 'Comentarios hawkish fortalecen dólar' },
            { asset: 'S&P 500', direction: 'variable', explanation: 'Afecta apetito por riesgo' },
            { asset: 'Volatilidad', direction: 'up', explanation: 'Puede generar movimientos bruscos' }
        ],
        interpretation: '🔴 EXTREMADAMENTE IMPORTANTE. Genera alta volatilidad en todos los mercados.'
    },
    
    // JUEVES 29 DE ENERO 2026
    { 
        time: '00:00',
        date: '2026-01-29',
        countryCode: 'EUR', 
        event: 'Masa monetaria M3 (Anual)', 
        importance: 'low', 
        forecast: '3%', 
        previous: '3%',
        actual: '-',
        description: 'Dato final revisado de M3 anual.',
        impact: [
            { asset: 'EUR', direction: 'variable', explanation: 'Revisiones pueden afectar expectativas' }
        ],
        interpretation: 'Versión final del dato preliminar.'
    },
    { 
        time: '00:00',
        date: '2026-01-29',
        countryCode: 'EUR', 
        event: 'Masa monetaria M3 (Mensual)', 
        importance: 'low', 
        forecast: '-', 
        previous: '2.9%',
        actual: '-',
        description: 'Dato final M3 mensual.',
        impact: [
            { asset: 'EUR', direction: 'variable', explanation: 'Generalmente poco impacto' }
        ],
        interpretation: 'Dato revisado, menor impacto que preliminar.'
    },
    { 
        time: '00:00',
        date: '2026-01-29',
        countryCode: 'EUR', 
        event: 'Préstamos Privados (Anual)', 
        importance: 'low', 
        forecast: '2.9%', 
        previous: '2.9%',
        actual: '-',
        description: 'Dato final de préstamos al sector privado.',
        impact: [
            { asset: 'EUR', direction: 'variable', explanation: 'Revisiones menores rara vez impactan' }
        ],
        interpretation: 'Confirmación del dato preliminar.'
    },
    { 
        time: '01:00',
        date: '2026-01-29',
        countryCode: 'EUR', 
        event: 'Clima empresarial', 
        importance: 'medium', 
        forecast: '-', 
        previous: '-0.56',
        actual: '-',
        description: 'Dato final de confianza empresarial.',
        impact: [
            { asset: 'EUR', direction: 'variable', explanation: 'Revisiones pueden sorprender' }
        ],
        interpretation: 'Última lectura oficial del mes.'
    },
    { 
        time: '01:00',
        date: '2026-01-29',
        countryCode: 'EUR', 
        event: 'Confianza del consumidor', 
        importance: 'medium', 
        forecast: '-12.4', 
        previous: '-12.4',
        actual: '-',
        description: 'Dato final de confianza del consumidor.',
        impact: [
            { asset: 'EUR', direction: 'variable', explanation: 'Confirmación del preliminar' }
        ],
        interpretation: 'Versión revisada, menos impacto que preliminar.'
    },
    { 
        time: '01:00',
        date: '2026-01-29',
        countryCode: 'EUR', 
        event: 'Confianza en el Sector Servicios', 
        importance: 'low', 
        forecast: '-', 
        previous: '5.6',
        actual: '-',
        description: 'Dato final de confianza en servicios.',
        impact: [
            { asset: 'EUR', direction: 'variable', explanation: 'Generalmente sin impacto' }
        ],
        interpretation: 'Confirmación del dato preliminar.'
    },
    { 
        time: '01:00',
        date: '2026-01-29',
        countryCode: 'EUR', 
        event: 'Confianza Industrial', 
        importance: 'low', 
        forecast: '-', 
        previous: '-8',
        actual: '-',
        description: 'Dato final de confianza industrial.',
        impact: [
            { asset: 'EUR', direction: 'variable', explanation: 'Poco impacto esperado' }
        ],
        interpretation: 'Última lectura oficial del periodo.'
    },
    { 
        time: '01:00',
        date: '2026-01-29',
        countryCode: 'EUR', 
        event: 'Indicador de Sentimiento Económico (ESI)', 
        importance: 'medium', 
        forecast: '97.1', 
        previous: '96.7',
        actual: '-',
        description: 'Dato final del ESI.',
        impact: [
            { asset: 'EUR', direction: 'variable', explanation: 'Revisiones pueden generar movimiento' }
        ],
        interpretation: 'Confirmación del dato preliminar, puede haber sorpresas.'
    },
    { 
        time: '14:30',
        date: '2026-01-29',
        countryCode: 'USA', 
        event: 'Balanza comercial', 
        importance: 'medium', 
        forecast: '-$44.6B', 
        previous: '-$29.4B',
        actual: '-',
        description: 'Diferencia entre exportaciones e importaciones de bienes y servicios.',
        impact: [
            { asset: 'USD', direction: 'up', explanation: 'Déficit menor de lo esperado fortalece USD' },
            { asset: 'Exportadoras', direction: 'up', explanation: 'Exportaciones altas benefician empresas' }
        ],
        interpretation: 'Déficit mayor = más dólares saliendo de USA = USD débil.'
    },
    { 
        time: '14:30',
        date: '2026-01-29',
        countryCode: 'USA', 
        event: 'Balanza Comercial de Bienes', 
        importance: 'low', 
        forecast: '-', 
        previous: '-$59.1B',
        actual: '-',
        description: 'Balanza comercial excluyendo servicios.',
        impact: [
            { asset: 'USD', direction: 'variable', explanation: 'Complementa dato total' }
        ],
        interpretation: 'Desglosa componente de bienes del dato total.'
    },
    { 
        time: '14:30',
        date: '2026-01-29',
        countryCode: 'USA', 
        event: 'Costes Laborales Unitarios (Trimestral) (Q3)', 
        importance: 'medium', 
        forecast: '-1.9%', 
        previous: '-1.9%',
        actual: '-',
        description: 'Mide cambio en el costo del trabajo por unidad de producción.',
        impact: [
            { asset: 'USD', direction: 'down', explanation: 'Aumento indica presiones inflacionarias' },
            { asset: 'Bonos', direction: 'down', explanation: 'Inflación presiona yields al alza' }
        ],
        interpretation: 'La Fed monitorea esto de cerca por presiones salariales.'
    },
    { 
        time: '14:30',
        date: '2026-01-29',
        countryCode: 'USA', 
        event: 'Inventarios mayoristas', 
        importance: 'low', 
        forecast: '0.2%', 
        previous: '-',
        actual: '-',
        description: 'Cambio mensual en el valor total de inventarios mantenidos por mayoristas.',
        impact: [
            { asset: 'USD', direction: 'variable', explanation: 'Aumento puede indicar ventas débiles' }
        ],
        interpretation: 'Inventarios altos pueden frenar producción futura.'
    },
    { 
        time: '14:30',
        date: '2026-01-29',
        countryCode: 'USA', 
        event: 'Peticiones de desempleo continuadas', 
        importance: 'medium', 
        forecast: '-', 
        previous: '1.849M',
        actual: '-',
        description: 'Número de personas que continúan recibiendo beneficios de desempleo.',
        impact: [
            { asset: 'USD', direction: 'down', explanation: 'Aumento indica debilidad en mercado laboral' },
            { asset: 'S&P 500', direction: 'down', explanation: 'Mercado laboral débil preocupa' }
        ],
        interpretation: 'Aumento persistente puede señalar deterioro económico.'
    },
    { 
        time: '14:30',
        date: '2026-01-29',
        countryCode: 'USA', 
        event: 'Peticiones Iniciales de Desempleo - Media de 4 semanas', 
        importance: 'medium', 
        forecast: '-', 
        previous: '-',
        actual: '-',
        description: 'Promedio de 4 semanas de peticiones iniciales de desempleo.',
        impact: [
            { asset: 'USD', direction: 'down', explanation: 'Aumento indica deterioro laboral' }
        ],
        interpretation: 'Suaviza volatilidad semanal para ver tendencia real.'
    },
    { 
        time: '14:30',
        date: '2026-01-29',
        countryCode: 'USA', 
        event: 'Peticiones semanales de subsidio por desempleo', 
        importance: 'high', 
        forecast: '205K', 
        previous: '200K',
        actual: '-',
        description: 'Número de personas que solicitaron beneficios de desempleo por primera vez la semana pasada.',
        impact: [
            { asset: 'USD', direction: 'down', explanation: 'Aumento indica despidos crecientes' },
            { asset: 'S&P 500', direction: 'down', explanation: 'Mercado laboral débil = economía débil' },
            { asset: 'Oro', direction: 'up', explanation: 'Debilidad económica impulsa refugio' }
        ],
        interpretation: 'DATO SEMANAL MUY SEGUIDO. <220K = mercado laboral saludable.'
    },
    { 
        time: '14:30',
        date: '2026-01-29',
        countryCode: 'USA', 
        event: 'Productividad no Agrícola (Trimestral) (Q3)', 
        importance: 'medium', 
        forecast: '4.9%', 
        previous: '4.9%',
        actual: '-',
        description: 'Mide cambio en producción por hora trabajada en sector no agrícola.',
        impact: [
            { asset: 'USD', direction: 'up', explanation: 'Alta productividad = economía más eficiente' },
            { asset: 'S&P 500', direction: 'up', explanation: 'Más producción = más ganancias empresariales' }
        ],
        interpretation: 'Productividad creciente permite crecimiento sin inflación.'
    },
    { 
        time: '16:00',
        date: '2026-01-29',
        countryCode: 'USA', 
        event: 'Pedidos a Fábrica', 
        importance: 'medium', 
        forecast: '0.5%', 
        previous: '-1.3%',
        actual: '-',
        description: 'Cambio mensual en el valor total de nuevas órdenes de fabricación.',
        impact: [
            { asset: 'USD', direction: 'up', explanation: 'Aumento indica demanda manufacturera fuerte' },
            { asset: 'Industriales', direction: 'up', explanation: 'Más órdenes = más producción' }
        ],
        interpretation: 'Combina bienes duraderos y no duraderos. Indicador amplio de demanda.'
    },
    { 
        time: '16:30',
        date: '2026-01-29',
        countryCode: 'USA', 
        event: 'Cambio de Almacenamiento de Gas Natural (EIA)', 
        importance: 'low', 
        forecast: '-', 
        previous: '-120B',
        actual: '-',
        description: 'Cambio semanal en reservas de gas natural según EIA.',
        impact: [
            { asset: 'Gas Natural', direction: 'up', explanation: 'Caída de inventarios = precios al alza' },
            { asset: 'Energy', direction: 'variable', explanation: 'Afecta sector energético' }
        ],
        interpretation: 'Seguido por traders de commodities energéticas.'
    },
    { 
        time: '17:30',
        date: '2026-01-29',
        countryCode: 'USA', 
        event: 'Emisión de bonos a 4 semanas', 
        importance: 'low', 
        forecast: '-', 
        previous: '3.63%',
        actual: '-',
        description: 'Subasta de bonos del Tesoro a 4 semanas.',
        impact: [
            { asset: 'USD', direction: 'variable', explanation: 'Afecta extremo corto de curva' }
        ],
        interpretation: 'Refleja condiciones de liquidez a muy corto plazo.'
    },
    { 
        time: '19:00',
        date: '2026-01-29',
        countryCode: 'USA', 
        event: 'Emisión de Notas del Tesoro a 7 años', 
        importance: 'low', 
        forecast: '-', 
        previous: '3.93%',
        actual: '-',
        description: 'Subasta de notas a 7 años.',
        impact: [
            { asset: 'USD', direction: 'variable', explanation: 'Demanda fuerte apoya dólar' },
            { asset: 'Yields', direction: 'variable', explanation: 'Afecta parte media de curva' }
        ],
        interpretation: 'Completa ciclo de subastas de la semana.'
    },
    { 
        time: '16:30',
        date: '2026-01-29',
        countryCode: 'EUR', 
        event: 'Discurso de Piero Cipollone, miembro del BCE', 
        importance: 'medium', 
        forecast: '-', 
        previous: '-',
        actual: '-',
        description: 'Miembro del Consejo Ejecutivo del BCE habla sobre política monetaria.',
        impact: [
            { asset: 'EUR', direction: 'variable', explanation: 'Comentarios sobre tasas mueven mercado' }
        ],
        interpretation: 'Los mercados buscan pistas sobre próximas decisiones del BCE.'
    },
    
    // VIERNES 30 DE ENERO 2026
    { 
        time: '11:00',
        date: '2026-01-30',
        countryCode: 'EUR', 
        event: 'Producto Interior Bruto s.a. (Anual) (Q4)', 
        importance: 'high', 
        forecast: '1.2%', 
        previous: '1.4%',
        actual: '-',
        description: 'Cambio anual en el PIB de la Eurozona. DATO MÁS IMPORTANTE de salud económica.',
        impact: [
            { asset: 'EUR', direction: 'up', explanation: 'Crecimiento fuerte fortalece euro' },
            { asset: 'STOXX 50', direction: 'up', explanation: 'Economía saludable impulsa bolsas' },
            { asset: 'EUR/USD', direction: 'up', explanation: 'EUR fuerte empuja par al alza' }
        ],
        interpretation: '🔴 EXTREMADAMENTE IMPORTANTE. Crecimiento >pronóstico es muy alcista para EUR.'
    },
    { 
        time: '11:00',
        date: '2026-01-30',
        countryCode: 'EUR', 
        event: 'Producto Interior Bruto s.a. (Trimestral) (Q4)', 
        importance: 'high', 
        forecast: '0.3%', 
        previous: '0.3%',
        actual: '-',
        description: 'Cambio trimestral del PIB de la Eurozona.',
        impact: [
            { asset: 'EUR', direction: 'up', explanation: 'Dato superior = economía acelerando' },
            { asset: 'EUR/USD', direction: 'up', explanation: 'Fortalece caso para mantener tasas' }
        ],
        interpretation: '🔴 MUY IMPORTANTE. Muestra tendencia reciente de crecimiento económico.'
    },
    { 
        time: '11:00',
        date: '2026-01-30',
        countryCode: 'EUR', 
        event: 'Tasa de desempleo', 
        importance: 'medium', 
        forecast: '6.3%', 
        previous: '6.3%',
        actual: '-',
        description: 'Porcentaje de población activa desempleada en la Eurozona.',
        impact: [
            { asset: 'EUR', direction: 'up', explanation: 'Tasa baja = mercado laboral saludable' },
            { asset: 'Consumo EUR', direction: 'up', explanation: 'Más empleos = más gasto' }
        ],
        interpretation: 'Tasa estable o cayendo es positiva para EUR.'
    },
    { 
        time: '14:30',
        date: '2026-01-30',
        countryCode: 'USA', 
        event: 'Índice de Precios de Producción (Anual)', 
        importance: 'high', 
        forecast: '-', 
        previous: '3%',
        actual: '-',
        description: 'Cambio anual en precios que productores cobran por bienes y servicios.',
        impact: [
            { asset: 'USD', direction: 'down', explanation: 'PPI alto indica presiones inflacionarias' },
            { asset: 'Bonos', direction: 'down', explanation: 'Inflación presiona yields' },
            { asset: 'Oro', direction: 'up', explanation: 'Inflación alta impulsa oro' }
        ],
        interpretation: 'Indicador adelantado de IPC. PPI alto anticipa inflación al consumidor.'
    },
    { 
        time: '14:30',
        date: '2026-01-30',
        countryCode: 'USA', 
        event: 'Índice de Precios de Producción (Mensual)', 
        importance: 'high', 
        forecast: '0.2%', 
        previous: '0.2%',
        actual: '-',
        description: 'Cambio mensual del PPI.',
        impact: [
            { asset: 'USD', direction: 'down', explanation: 'Aumento indica inflación' },
            { asset: 'Fed Policy', direction: 'hawkish', explanation: 'Puede forzar a Fed a subir tasas' }
        ],
        interpretation: 'DATO CLAVE. La Fed monitorea de cerca para decisiones de tasas.'
    },
    { 
        time: '14:30',
        date: '2026-01-30',
        countryCode: 'USA', 
        event: 'Índice de Precios de Producción Excluyendo Alimentación y Energía (Anual)', 
        importance: 'high', 
        forecast: '-', 
        previous: '3%',
        actual: '-',
        description: 'PPI Core anual - excluye componentes volátiles.',
        impact: [
            { asset: 'USD', direction: 'variable', explanation: 'Muestra presiones inflacionarias subyacentes' },
            { asset: 'Fed Policy', direction: 'variable', explanation: 'La Fed prefiere este dato al total' }
        ],
        interpretation: 'MÁS IMPORTANTE que el PPI total. Muestra inflación persistente.'
    },
    { 
        time: '14:30',
        date: '2026-01-30',
        countryCode: 'USA', 
        event: 'Índice de Precios de Producción excluyendo alimentación y energía (Mensual)', 
        importance: 'high', 
        forecast: '0.3%', 
        previous: '0%',
        actual: '-',
        description: 'PPI Core mensual.',
        impact: [
            { asset: 'USD', direction: 'down', explanation: 'Aumento presiona a Fed a actuar' },
            { asset: 'Bonos', direction: 'down', explanation: 'Yields suben con inflación' }
        ],
        interpretation: 'CRÍTICO. Lectura >pronóstico es hawkish para política Fed.'
    },
    { 
        time: '22:45',
        date: '2026-01-30',
        countryCode: 'USA', 
        event: 'PMI de Chicago', 
        importance: 'medium', 
        forecast: '-', 
        previous: '-4.3%',
        actual: '-',
        description: 'Índice de gerentes de compras de Chicago. >50 = expansión.',
        impact: [
            { asset: 'USD', direction: 'up', explanation: 'Lectura >50 es positiva' },
            { asset: 'Industriales', direction: 'up', explanation: 'Fortaleza manufacturera' }
        ],
        interpretation: 'Indicador regional importante, precursor de ISM.'
    },
    { 
        time: '14:15',
        date: '2026-01-27',
        countryCode: 'USA', 
        event: 'ADP - Cambio de Empleo Privado', 
        importance: 'high', 
        forecast: '150K', 
        previous: '8K',
        actual: '-',
        description: 'Estimación de ADP del cambio mensual en empleos del sector privado (no incluye gobierno). Anticipa el reporte oficial de NFP.',
        impact: [
            { asset: 'USD', direction: 'up', explanation: 'Fuerte creación de empleo fortalece el dólar' },
            { asset: 'Oro', direction: 'down', explanation: 'Economía fuerte reduce demanda de refugio' },
            { asset: 'S&P 500', direction: 'up', explanation: 'Más empleo = más consumo = mejores ganancias' }
        ],
        interpretation: 'Considerado un anticipo del NFP del viernes. Lectura superior a expectativas es alcista para USD.'
    },
    { 
        time: '14:30',
        date: '2026-01-30',
        countryCode: 'USA', 
        event: 'Nóminas No Agrícolas (NFP)', 
        importance: 'high', 
        forecast: '200K', 
        previous: '200K',
        actual: '-',
        description: 'Cambio mensual en el número de empleados en USA excluyendo el sector agrícola. Es el indicador de empleo más importante del mundo.',
        impact: [
            { asset: 'USD', direction: 'up', explanation: 'Fuerte creación de empleo fortalece significativamente el USD' },
            { asset: 'Oro', direction: 'down', explanation: 'USD fuerte presiona al oro' },
            { asset: 'S&P 500', direction: 'up', explanation: 'Empleo fuerte = economía saludable' },
            { asset: 'Bonos', direction: 'down', explanation: 'Puede llevar a la FED a mantener tasas altas' }
        ],
        interpretation: '🔴 El evento económico MÁS IMPORTANTE del mes. Puede causar movimientos de 100+ pips en pares de USD. Lectura >200K es muy alcista para USD.'
    },
    { 
        time: '14:30',
        date: '2026-01-30',
        countryCode: 'USA', 
        event: 'Tasa de Desempleo', 
        importance: 'high', 
        forecast: '3.7%', 
        previous: '3.7%',
        actual: '-',
        description: 'Porcentaje de la fuerza laboral total que está desempleada y buscando activamente trabajo.',
        impact: [
            { asset: 'USD', direction: 'down', explanation: 'Desempleo más bajo fortalece USD (relación inversa)' },
            { asset: 'S&P 500', direction: 'up', explanation: 'Bajo desempleo indica economía fuerte' }
        ],
        interpretation: 'Se publica junto con NFP. Una caída en desempleo es alcista para USD. Desempleo ~4% se considera pleno empleo.'
    }
];

    // Inicializar
    async function initMarketScanner() {
        console.log('🚀 Cargando datos del Market Scanner...');
        
        // Cargar datos en paralelo
        await Promise.all([
            loadCryptoData(),
            loadForexData(),
            loadIndicesData(),
            loadCommoditiesData(),
            loadNewsData()
        ]);
        
        // Renderizar UI
        renderMarketOverview('indices');
        renderEconomicCalendar();
        renderLatestNews('all');
        updateSentimentAnalysis();
        setupEventListeners();
        
        console.log('✅ Market Scanner inicializado');
    }

    // Función para refrescar datos
    async function refreshMarketData() {
        console.log('🔄 Refrescando datos del mercado...');
        
        // Limpiar cache para forzar nueva carga
        cache.data = {};
        cache.timestamp = {};
        
        // Recargar todos los datos
        await Promise.all([
            loadCryptoData(),
            loadForexData(),
            loadIndicesData(),
            loadCommoditiesData(),
            loadNewsData()
        ]);
        
        // Re-renderizar vista actual
        renderMarketOverview(currentSector);
        renderLatestNews('all');
        updateSentimentAnalysis();
        
        console.log('✅ Datos actualizados');
    }

    // Renderizar visión general del mercado
    function renderMarketOverview(sector) {
        const container = document.getElementById('market-cards');
        if (!container) return;

        const data = marketData[sector] || [];
        
        container.innerHTML = data.map(item => {
            const isPositive = item.change >= 0;
            const changeClass = isPositive ? 'text-green' : 'text-red';
            const cardClass = isPositive ? 'positive' : 'negative';
            const arrow = isPositive ? '↑' : '↓';
            
            return `
                <div class="market-card ${cardClass}">
                    <div class="flex justify-between items-start mb-2">
                        <div>
                            <p class="text-xs text-text-secondary">${item.symbol}</p>
                            <p class="font-semibold text-sm">${item.name}</p>
                        </div>
                    </div>
                    <p class="text-2xl font-bold mb-1">${formatMarketPrice(item.price, sector)}</p>
                    <p class="${changeClass} text-sm font-semibold">
                        ${arrow} ${Math.abs(item.change).toFixed(2)}%
                    </p>
                </div>
            `;
        }).join('');
    }

    // Formatear precios según sector
    function formatMarketPrice(price, sector) {
        if (sector === 'crypto' && price > 1000) {
            return `$${price.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
        } else if (sector === 'crypto') {
            return `$${price.toFixed(4)}`;
        } else if (sector === 'forex') {
            return price.toFixed(4);
        } else {
            return price.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
        }
    }

    // Renderizar calendario económico
// Renderizar calendario económico (FUNCIÓN GLOBAL)
function renderEconomicCalendar() {
    const container = document.getElementById('economic-calendar');
    if (!container) return;

    const countryFlags = {
        'USA': 'us',
        'EUR': 'eu',
        'GBP': 'gb',
        'JPY': 'jp',
        'CAD': 'ca',
        'CHN': 'cn',
        'AUD': 'au',
        'DEU': 'de',
        'CHE': 'ch'
    };

    container.innerHTML = economicEvents.map((event, index) => {
        const importanceClass = `event-importance-${event.importance}`;
        const importanceText = event.importance === 'high' ? 'Alta' : event.importance === 'medium' ? 'Media' : 'Baja';
        const flagCode = countryFlags[event.countryCode] || 'un';
        const flagUrl = `https://flagcdn.com/48x36/${flagCode}.png`;
        
        // Formatear fecha
        const eventDate = new Date(event.date);
        const options = { weekday: 'short', day: 'numeric', month: 'short' };
        const formattedDate = eventDate.toLocaleDateString('es-ES', options);
        
        // Determinar si es hoy
        const today = new Date();
        const isToday = eventDate.toDateString() === today.toDateString();
        const dateLabel = isToday ? 'HOY' : formattedDate;
        
        return `
            <div class="economic-event-card p-4 bg-surface-light rounded-lg border-l-4 ${importanceClass}" 
                 data-country="${event.countryCode}" 
                 data-date="${event.date}"
                 data-importance="${event.importance}"
                 onclick="openEconomicEventModal(${index})">
                <div class="flex justify-between items-start mb-3">
                    <div class="flex items-center gap-3">
                        <img src="${flagUrl}" alt="${event.countryCode}" class="w-12 h-9 object-cover rounded shadow-sm" onerror="this.style.display='none'" />
                        <div>
                            <div class="flex items-center gap-2 mb-1">
                                <span class="text-xs font-bold px-2 py-1 rounded ${isToday ? 'bg-primary text-background' : 'bg-surface text-text-secondary'}">
                                    <i class="fas fa-calendar-day"></i> ${dateLabel}
                                </span>
                                <span class="text-sm font-bold text-primary">${event.time}</span>
                            </div>
                            <span class="text-xs px-2 py-0.5 rounded ${event.importance === 'high' ? 'bg-red text-white' : event.importance === 'medium' ? 'bg-yellow-600 text-white' : 'bg-gray-500 text-white'}">
                                <i class="fas fa-circle text-xs"></i> ${importanceText}
                            </span>
                        </div>
                    </div>
                    <i class="fas fa-chevron-right text-text-secondary text-sm"></i>
                </div>
                <p class="font-semibold text-sm mb-2">${event.event}</p>
                <div class="grid grid-cols-3 gap-2 text-xs">
                    <div>
                        <span class="text-text-secondary">Actual:</span>
                        <span class="ml-1 font-bold ${event.actual !== '-' ? 'text-primary' : ''}">${event.actual || '-'}</span>
                    </div>
                    <div>
                        <span class="text-text-secondary">Pronóstico:</span>
                        <span class="ml-1 font-semibold text-white">${event.forecast}</span>
                    </div>
                    <div>
                        <span class="text-text-secondary">Anterior:</span>
                        <span class="ml-1 text-text-secondary">${event.previous}</span>
                    </div>
                </div>
            </div>
        `;
    }).join('');
}

    // Renderizar noticias con imágenes
    function renderLatestNews(sector) {
        const container = document.getElementById('latest-news-container');
        if (!container) return;

        const news = sector === 'all' 
            ? newsData.all 
            : newsData.all.filter(n => n.sector === sector);

        container.innerHTML = news.map(item => {
            // URL de imagen: usar la de la API o placeholder
            const imageUrl = item.image || 'https://via.placeholder.com/80x80/1a1a1a/39FF14?text=News';
            
            // Hacer la tarjeta clickeable
            const newsUrl = item.url || '#';

            return `
                <a href="${newsUrl}" target="_blank" class="news-card-with-image block">
                    <div class="flex items-start gap-3 p-3 bg-surface-light rounded-lg hover:bg-surface border border-transparent hover:border-primary transition-all">
                        <img src="${imageUrl}" 
                             alt="News thumbnail" 
                             class="news-thumbnail w-20 h-20 object-cover rounded"
                             onerror="this.src='https://via.placeholder.com/80x80/1a1a1a/39FF14?text=News'"
                        />
                        <div class="flex-1 min-w-0">
                            <div class="flex items-center justify-between gap-2 mb-1">
                                <span class="text-xs px-2 py-0.5 rounded bg-primary text-background font-bold">${item.sector.toUpperCase()}</span>
                                <span class="text-xs text-text-secondary">
                                    <i class="fas fa-clock"></i> ${item.time}
                                </span>
                            </div>
                            <p class="font-semibold text-sm mb-2 line-clamp-2">${item.title}</p>
                            <div class="flex justify-between items-center text-xs text-text-secondary">
                                <span class="flex items-center gap-1">
                                    <i class="fas fa-newspaper"></i>
                                    ${item.source}
                                </span>
                            </div>
                        </div>
                        <i class="fas fa-external-link-alt text-text-secondary text-sm self-center"></i>
                    </div>
                </a>
            `;
        }).join('');
    }

    // Actualizar análisis de sentimiento
    function updateSentimentAnalysis() {
        let marketsUp = 0;
        let marketsDown = 0;

        Object.values(marketData).flat().forEach(item => {
            if (item.change > 0) marketsUp++;
            else if (item.change < 0) marketsDown++;
        });

        const total = marketsUp + marketsDown;
        const upPercentage = (marketsUp / total) * 100;

        // Actualizar indicadores
        const marketsUpEl = document.getElementById('markets-up');
        const marketsDownEl = document.getElementById('markets-down');
        if (marketsUpEl) marketsUpEl.textContent = marketsUp;
        if (marketsDownEl) marketsDownEl.textContent = marketsDown;

        // Determinar sentimiento
        const sentimentEl = document.getElementById('sentiment-indicator');
        const sentimentLabel = document.getElementById('sentiment-label');
        
        if (!sentimentEl || !sentimentLabel) return;
        
        if (upPercentage >= 70) {
            sentimentEl.textContent = '😄';
            sentimentLabel.textContent = 'Muy Positivo';
            sentimentLabel.className = 'text-2xl font-bold text-green';
        } else if (upPercentage >= 55) {
            sentimentEl.textContent = '🙂';
            sentimentLabel.textContent = 'Positivo';
            sentimentLabel.className = 'text-2xl font-bold text-green';
        } else if (upPercentage >= 45) {
            sentimentEl.textContent = '😐';
            sentimentLabel.textContent = 'Neutral';
            sentimentLabel.className = 'text-2xl font-bold text-white';
        } else if (upPercentage >= 30) {
            sentimentEl.textContent = '😟';
            sentimentLabel.textContent = 'Negativo';
            sentimentLabel.className = 'text-2xl font-bold text-red';
        } else {
            sentimentEl.textContent = '😨';
            sentimentLabel.textContent = 'Muy Negativo';
            sentimentLabel.className = 'text-2xl font-bold text-red';
        }
    }

    // Event listeners
    function setupEventListeners() {
        // Tabs de sectores
        document.querySelectorAll('.market-tab').forEach(tab => {
            tab.addEventListener('click', function() {
                document.querySelectorAll('.market-tab').forEach(t => t.classList.remove('active'));
                this.classList.add('active');
                const sector = this.dataset.sector;
                currentSector = sector;
                renderMarketOverview(sector);
            });
        });

        // Filtro de sector general
        const sectorFilter = document.getElementById('market-sector-filter');
        if (sectorFilter) {
            sectorFilter.addEventListener('change', function() {
                const sector = this.value;
                if (sector !== 'all') {
                    document.querySelectorAll('.market-tab').forEach(t => t.classList.remove('active'));
                    const targetTab = document.querySelector(`.market-tab[data-sector="${sector}"]`);
                    if (targetTab) {
                        targetTab.classList.add('active');
                        renderMarketOverview(sector);
                    }
                }
            });
        }

        // Filtro de noticias
        const newsFilter = document.getElementById('news-sector-filter');
        if (newsFilter) {
            newsFilter.addEventListener('change', function() {
                renderLatestNews(this.value);
            });
        }

        // Toggle dropdown de países
        const countryFilterBtn = document.getElementById('calendar-country-filter-btn');
        const countryDropdown = document.getElementById('calendar-country-dropdown');
        if (countryFilterBtn && countryDropdown) {
            countryFilterBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                countryDropdown.classList.toggle('hidden');
                // Cerrar dropdown de importancia
                const importanceDropdown = document.getElementById('calendar-importance-dropdown');
                if (importanceDropdown) importanceDropdown.classList.add('hidden');
            });
        }
        
        // Toggle dropdown de importancia
        const importanceFilterBtn = document.getElementById('calendar-importance-filter-btn');
        const importanceDropdown = document.getElementById('calendar-importance-dropdown');
        if (importanceFilterBtn && importanceDropdown) {
            importanceFilterBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                importanceDropdown.classList.toggle('hidden');
                // Cerrar dropdown de países
                if (countryDropdown) countryDropdown.classList.add('hidden');
            });
        }
        
        // Cerrar dropdowns al hacer click fuera
        document.addEventListener('click', function() {
            if (countryDropdown) countryDropdown.classList.add('hidden');
            if (importanceDropdown) importanceDropdown.classList.add('hidden');
        });
        
        // Prevenir cierre al hacer click dentro del dropdown
        if (countryDropdown) {
            countryDropdown.addEventListener('click', function(e) {
                e.stopPropagation();
            });
        }
        if (importanceDropdown) {
            importanceDropdown.addEventListener('click', function(e) {
                e.stopPropagation();
            });
        }
        
        // Manejar checkbox "Todos" de países
        const countryCheckboxes = document.querySelectorAll('.country-filter-checkbox');
        const allCountryCheckbox = document.querySelector('.country-filter-checkbox[value="all"]');
        countryCheckboxes.forEach(checkbox => {
            if (checkbox.value !== 'all') {
                checkbox.addEventListener('change', function() {
                    if (this.checked && allCountryCheckbox) {
                        allCountryCheckbox.checked = false;
                    }
                    updateCountryFilterCount();
                });
            } else {
                checkbox.addEventListener('change', function() {
                    if (this.checked) {
                        countryCheckboxes.forEach(cb => {
                            if (cb.value !== 'all') cb.checked = false;
                        });
                    }
                    updateCountryFilterCount();
                });
            }
        });
        
        // Manejar checkbox "Todas" de importancia
        const importanceCheckboxes = document.querySelectorAll('.importance-filter-checkbox');
        const allImportanceCheckbox = document.querySelector('.importance-filter-checkbox[value="all"]');
        importanceCheckboxes.forEach(checkbox => {
            if (checkbox.value !== 'all') {
                checkbox.addEventListener('change', function() {
                    if (this.checked && allImportanceCheckbox) {
                        allImportanceCheckbox.checked = false;
                    }
                    updateImportanceFilterCount();
                });
            } else {
                checkbox.addEventListener('change', function() {
                    if (this.checked) {
                        importanceCheckboxes.forEach(cb => {
                            if (cb.value !== 'all') cb.checked = false;
                        });
                    }
                    updateImportanceFilterCount();
                });
            }
        });

        // Botón de actualizar
        const refreshBtn = document.getElementById('refresh-market-data');
        if (refreshBtn) {
            refreshBtn.addEventListener('click', async function() {
                const icon = this.querySelector('i');
                icon.classList.add('fa-spin');
                
                try {
                    await refreshMarketData();
                    showNotification('Datos actualizados correctamente', 'success');
                } catch (error) {
                    console.error('Error al actualizar:', error);
                    showNotification('Error al actualizar datos', 'error');
                } finally {
                    icon.classList.remove('fa-spin');
                }
            });
        }
    }

    // Inicializar cuando se carga la página
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initMarketScanner);
    } else {
        initMarketScanner();
    }

    console.log('✅ Market Scanner inicializado');

// FUNCIONES GLOBALES PARA MODALES
// =============================================

// Variables globales para filtros
let selectedCountries = [];
let selectedImportances = [];

// Actualizar contador de países seleccionados
function updateCountryFilterCount() {
    const checkboxes = document.querySelectorAll('.country-filter-checkbox:not([value="all"]):checked');
    const count = checkboxes.length;
    const countElement = document.getElementById('selected-countries-count');
    if (countElement) {
        countElement.textContent = count;
        countElement.style.display = count > 0 ? 'inline-block' : 'none';
    }
}

// Actualizar contador de importancias seleccionadas
function updateImportanceFilterCount() {
    const checkboxes = document.querySelectorAll('.importance-filter-checkbox:not([value="all"]):checked');
    const count = checkboxes.length;
    const countElement = document.getElementById('selected-importance-count');
    if (countElement) {
        countElement.textContent = count;
        countElement.style.display = count > 0 ? 'inline-block' : 'none';
    }
}

// Limpiar filtros de países
function clearCountryFilters() {
    const checkboxes = document.querySelectorAll('.country-filter-checkbox');
    const allCheckbox = document.querySelector('.country-filter-checkbox[value="all"]');
    
    checkboxes.forEach(cb => {
        if (cb.value !== 'all') cb.checked = false;
    });
    
    if (allCheckbox) allCheckbox.checked = true;
    updateCountryFilterCount();
    applyCountryFilters();
}

// Aplicar filtros de países
function applyCountryFilters() {
    const checkboxes = document.querySelectorAll('.country-filter-checkbox:not([value="all"])');
    const allCheckbox = document.querySelector('.country-filter-checkbox[value="all"]');
    
    selectedCountries = [];
    checkboxes.forEach(cb => {
        if (cb.checked) selectedCountries.push(cb.value);
    });
    
    // Aplicar filtro visual
    const events = document.querySelectorAll('#economic-calendar > .economic-event-card');
    events.forEach(event => {
        const eventCountry = event.dataset.country;
        const eventImportance = event.dataset.importance;
        
        // Verificar si pasa filtro de país
        const passesCountry = allCheckbox?.checked || selectedCountries.length === 0 || selectedCountries.includes(eventCountry);
        
        // Verificar si pasa filtro de importancia
        const passesImportance = selectedImportances.length === 0 || selectedImportances.includes(eventImportance);
        
        // Mostrar solo si pasa ambos filtros
        event.style.display = (passesCountry && passesImportance) ? 'block' : 'none';
    });
    
    // Cerrar dropdown
    const dropdown = document.getElementById('calendar-country-dropdown');
    if (dropdown) dropdown.classList.add('hidden');
    
    // Mensaje de confirmación
    const count = selectedCountries.length;
    if (count > 0) {
        showNotification(`Filtrando ${count} país${count > 1 ? 'es' : ''}`, 'success');
    }
}

// Limpiar filtros de importancia
function clearImportanceFilters() {
    const checkboxes = document.querySelectorAll('.importance-filter-checkbox');
    const allCheckbox = document.querySelector('.importance-filter-checkbox[value="all"]');
    
    checkboxes.forEach(cb => {
        if (cb.value !== 'all') cb.checked = false;
    });
    
    if (allCheckbox) allCheckbox.checked = true;
    updateImportanceFilterCount();
    applyImportanceFilters();
}

// Aplicar filtros de importancia
function applyImportanceFilters() {
    const checkboxes = document.querySelectorAll('.importance-filter-checkbox:not([value="all"])');
    const allCheckbox = document.querySelector('.importance-filter-checkbox[value="all"]');
    
    selectedImportances = [];
    checkboxes.forEach(cb => {
        if (cb.checked) selectedImportances.push(cb.value);
    });
    
    // Aplicar filtro visual
    const events = document.querySelectorAll('#economic-calendar > .economic-event-card');
    events.forEach(event => {
        const eventCountry = event.dataset.country;
        const eventImportance = event.dataset.importance;
        
        // Verificar si pasa filtro de país
        const countryCheckboxes = document.querySelectorAll('.country-filter-checkbox:not([value="all"])');
        const allCountryCheckbox = document.querySelector('.country-filter-checkbox[value="all"]');
        const activeCountries = Array.from(countryCheckboxes).filter(cb => cb.checked).map(cb => cb.value);
        const passesCountry = allCountryCheckbox?.checked || activeCountries.length === 0 || activeCountries.includes(eventCountry);
        
        // Verificar si pasa filtro de importancia
        const passesImportance = allCheckbox?.checked || selectedImportances.length === 0 || selectedImportances.includes(eventImportance);
        
        // Mostrar solo si pasa ambos filtros
        event.style.display = (passesCountry && passesImportance) ? 'block' : 'none';
    });
    
    // Cerrar dropdown
    const dropdown = document.getElementById('calendar-importance-dropdown');
    if (dropdown) dropdown.classList.add('hidden');
    
    // Mensaje de confirmación
    const importanceNames = { high: 'Alta', medium: 'Media', low: 'Baja' };
    if (selectedImportances.length > 0) {
        const names = selectedImportances.map(i => importanceNames[i]).join(', ');
        showNotification(`Filtrando: ${names}`, 'success');
    }
}

// Abrir modal de filtro de fechas
function openDateFilterModal() {
    document.getElementById('calendar-date-filter-modal').style.display = 'flex';
    const today = new Date().toISOString().split('T')[0];
    if (!document.getElementById('calendar-date-from').value) {
        document.getElementById('calendar-date-from').value = today;
    }
    if (!document.getElementById('calendar-date-to').value) {
        const nextWeek = new Date();
        nextWeek.setDate(nextWeek.getDate() + 7);
        document.getElementById('calendar-date-to').value = nextWeek.toISOString().split('T')[0];
    }
}

// Cerrar modal de filtro de fechas
function closeDateFilterModal() {
    document.getElementById('calendar-date-filter-modal').style.display = 'none';
}

// Establecer filtro rápido
function setDateFilter(type) {
    const today = new Date();
    let from, to;
    
    if (type === 'today') {
        from = to = today;
    } else if (type === 'week') {
        from = today;
        to = new Date(today);
        to.setDate(to.getDate() + 7);
    } else if (type === 'month') {
        from = today;
        to = new Date(today);
        to.setMonth(to.getMonth() + 1);
    }
    
    document.getElementById('calendar-date-from').value = from.toISOString().split('T')[0];
    document.getElementById('calendar-date-to').value = to.toISOString().split('T')[0];
    
    applyDateFilter();
}

// Aplicar filtro de fechas
function applyDateFilter() {
    const dateFrom = document.getElementById('calendar-date-from').value;
    const dateTo = document.getElementById('calendar-date-to').value;
    
    const events = document.querySelectorAll('#economic-calendar > .economic-event-card');
    events.forEach(event => {
        if (!dateFrom || !dateTo) {
            event.style.display = 'block';
            return;
        }
        
        const eventDate = event.dataset.date;
        if (eventDate >= dateFrom && eventDate <= dateTo) {
            event.style.display = 'block';
        } else {
            event.style.display = 'none';
        }
    });
    
    closeDateFilterModal();
    showNotification('Filtro de fechas aplicado', 'success');
}

// Limpiar filtro de fechas
function clearDateFilter() {
    document.getElementById('calendar-date-from').value = '';
    document.getElementById('calendar-date-to').value = '';
    
    const events = document.querySelectorAll('#economic-calendar > .economic-event-card');
    events.forEach(event => {
        event.style.display = 'block';
    });
    
    closeDateFilterModal();
    showNotification('Filtro de fechas eliminado', 'success');
}

// Cerrar modal de evento económico
function closeEconomicEventModal() {
    document.getElementById('economic-event-modal').style.display = 'none';
}

// Abrir modal de evento económico
function openEconomicEventModal(index) {
    const event = economicEvents[index];
    const modal = document.getElementById('economic-event-modal');
    
    const countryNames = {
        'USA': 'Estados Unidos',
        'EUR': 'Eurozona',
        'GBP': 'Reino Unido',
        'JPY': 'Japón',
        'CAD': 'Canadá',
        'CHN': 'China',
        'AUD': 'Australia',
        'DEU': 'Alemania',
        'CHE': 'Suiza'
    };
    
    document.getElementById('event-modal-title').textContent = event.event;
    document.getElementById('event-modal-country-code').textContent = event.countryCode;
    document.getElementById('event-modal-country').textContent = countryNames[event.countryCode] || event.countryCode;
    document.getElementById('event-modal-time').textContent = event.time;
    document.getElementById('event-modal-date').textContent = event.date || 'Hoy';
    document.getElementById('event-modal-description').textContent = event.description;
    document.getElementById('event-modal-actual').textContent = event.actual || '-';
    document.getElementById('event-modal-forecast').textContent = event.forecast;
    document.getElementById('event-modal-previous').textContent = event.previous;
    document.getElementById('event-modal-interpretation').textContent = event.interpretation;
    
    const badge = document.getElementById('event-modal-importance-badge');
    if (event.importance === 'high') {
        badge.className = 'px-3 py-1 rounded text-sm font-bold bg-red text-white';
        badge.innerHTML = '<i class="fas fa-circle text-xs"></i> Alta Importancia';
    } else if (event.importance === 'medium') {
        badge.className = 'px-3 py-1 rounded text-sm font-bold bg-yellow-600 text-white';
        badge.innerHTML = '<i class="fas fa-circle text-xs"></i> Media Importancia';
    } else {
        badge.className = 'px-3 py-1 rounded text-sm font-bold bg-gray-500 text-white';
        badge.innerHTML = '<i class="fas fa-circle text-xs"></i> Baja Importancia';
    }
    
    const impactContainer = document.getElementById('event-modal-impact');
    impactContainer.innerHTML = event.impact.map(imp => {
        const icon = imp.direction === 'up' ? 'fa-arrow-trend-up' : 'fa-arrow-trend-down';
        const colorClass = imp.direction === 'up' ? 'text-green' : 'text-red';
        const directionText = imp.direction === 'up' ? 'ALCISTA' : 'BAJISTA';
        const bgClass = imp.direction === 'up' ? 'border-green' : 'border-red';
        
        return `
            <div class="flex items-start gap-3 p-3 bg-surface rounded-lg border-l-4 ${bgClass}">
                <div><i class="fas ${icon} text-2xl ${colorClass}"></i></div>
                <div class="flex-1">
                    <div class="flex items-center gap-2 mb-1">
                        <span class="font-bold">${imp.asset}</span>
                        <span class="text-xs px-2 py-0.5 rounded ${colorClass} font-bold">${directionText}</span>
                    </div>
                    <p class="text-sm text-text-secondary">${imp.explanation}</p>
                </div>
            </div>
        `;
    }).join('');
    
    modal.style.display = 'flex';
}

// Event listener para botón de filtro de fechas
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', function() {
        const filterBtn = document.getElementById('calendar-date-filter-btn');
        if (filterBtn) {
            filterBtn.addEventListener('click', openDateFilterModal);
        }
        
        // Dashboard date filter
        const dashboardFilterBtn = document.getElementById('new-dashboard-date-filter-btn');
        if (dashboardFilterBtn) {
            dashboardFilterBtn.addEventListener('click', openDateFilterModal);
        }
        
        // Analytics date filter
        const analyticsFilterBtn = document.getElementById('analytics-date-filter-btn');
        if (analyticsFilterBtn) {
            analyticsFilterBtn.addEventListener('click', openDateFilterModal);
        }
        
        // Renderizar calendario al cargar
        if (typeof renderEconomicCalendar === 'function') {
            renderEconomicCalendar();
        }
    });
} else {
    const filterBtn = document.getElementById('calendar-date-filter-btn');
    if (filterBtn) {
        filterBtn.addEventListener('click', openDateFilterModal);
    }
    
    // Dashboard date filter
    const dashboardFilterBtn = document.getElementById('new-dashboard-date-filter-btn');
    if (dashboardFilterBtn) {
        dashboardFilterBtn.addEventListener('click', openDateFilterModal);
    }
    
    // Analytics date filter
    const analyticsFilterBtn = document.getElementById('analytics-date-filter-btn');
    if (analyticsFilterBtn) {
        analyticsFilterBtn.addEventListener('click', openDateFilterModal);
    }
    
    // Renderizar calendario inmediatamente
    if (typeof renderEconomicCalendar === 'function') {
        renderEconomicCalendar();
    }
}

console.log('✅ Funciones globales del calendario cargadas');

</script>

<!-- NinjaTrader Integration Scripts -->
<script src="frontend/ninjatrader-csv-importer.js"></script>
<script src="frontend/ninjatrader-file-sync.js"></script>
<script src="frontend/ninjatrader-integration.js"></script>

</body>
</html>
